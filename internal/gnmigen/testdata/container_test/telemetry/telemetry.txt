package telemetry

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"fmt"
	"reflect"
	"sort"
	"strconv"
	"testing"
	"time"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
	"github.com/openconfig/ondatra/internal/gnmigen/genutil/genutil"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// WithReplica adds the replica number to the context metadata of the gNMI
// server query.
func (n *RootPath) WithReplica(replica int) *RootPath {
	genutil.PutReplica(n, replica)
	return n
}

// WithSubscriptionMode specifies the subscription mode in the underlying gNMI
// subscribe.
func (n *RootPath) WithSubscriptionMode(mode gpb.SubscriptionMode) *RootPath {
	genutil.PutSubscriptionMode(n, mode)
	return n
}

// WithClient allows the user to provide a gNMI client. This allows for creation
// of tests for multiple gNMI clients to a single DUT.
func (n *RootPath) WithClient(c gpb.GNMIClient) *RootPath {
	genutil.PutClient(n, c)
	return n
}

// NewBatch returns a newly instantiated SetRequestBatch object for batching set requests.
func (d *RootPath) NewBatch() *Batch {
	return NewBatch(d)
}

// QualifiedParent is a *Parent with a corresponding timestamp.
type QualifiedParent struct {
	*genutil.Metadata
	val *Parent // val is the sample value.
	present bool
}

func (q *QualifiedParent) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the *Parent sample, erroring out if not present.
func (q *QualifiedParent) Val(t testing.TB) *Parent {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the *Parent sample.
func (q *QualifiedParent) SetVal(v *Parent) *QualifiedParent {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedParent) IsPresent() bool {
	return q != nil && q.present
}


// CollectionParent is a telemetry Collection whose Await method returns a slice of *Parent samples.
type CollectionParent struct {
	W *ParentWatcher
	Data []*QualifiedParent
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionParent) Await(t testing.TB) []*QualifiedParent {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// ParentWatcher observes a stream of *Parent samples.
type ParentWatcher struct {
	W *genutil.Watcher
	LastVal *QualifiedParent
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *ParentWatcher) Await(t testing.TB) (*QualifiedParent, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// QualifiedParent_Child is a *Parent_Child with a corresponding timestamp.
type QualifiedParent_Child struct {
	*genutil.Metadata
	val *Parent_Child // val is the sample value.
	present bool
}

func (q *QualifiedParent_Child) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the *Parent_Child sample, erroring out if not present.
func (q *QualifiedParent_Child) Val(t testing.TB) *Parent_Child {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the *Parent_Child sample.
func (q *QualifiedParent_Child) SetVal(v *Parent_Child) *QualifiedParent_Child {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedParent_Child) IsPresent() bool {
	return q != nil && q.present
}


// CollectionParent_Child is a telemetry Collection whose Await method returns a slice of *Parent_Child samples.
type CollectionParent_Child struct {
	W *Parent_ChildWatcher
	Data []*QualifiedParent_Child
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionParent_Child) Await(t testing.TB) []*QualifiedParent_Child {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// Parent_ChildWatcher observes a stream of *Parent_Child samples.
type Parent_ChildWatcher struct {
	W *genutil.Watcher
	LastVal *QualifiedParent_Child
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *Parent_ChildWatcher) Await(t testing.TB) (*QualifiedParent_Child, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// QualifiedRemoteContainer is a *RemoteContainer with a corresponding timestamp.
type QualifiedRemoteContainer struct {
	*genutil.Metadata
	val *RemoteContainer // val is the sample value.
	present bool
}

func (q *QualifiedRemoteContainer) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the *RemoteContainer sample, erroring out if not present.
func (q *QualifiedRemoteContainer) Val(t testing.TB) *RemoteContainer {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the *RemoteContainer sample.
func (q *QualifiedRemoteContainer) SetVal(v *RemoteContainer) *QualifiedRemoteContainer {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedRemoteContainer) IsPresent() bool {
	return q != nil && q.present
}


// CollectionRemoteContainer is a telemetry Collection whose Await method returns a slice of *RemoteContainer samples.
type CollectionRemoteContainer struct {
	W *RemoteContainerWatcher
	Data []*QualifiedRemoteContainer
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionRemoteContainer) Await(t testing.TB) []*QualifiedRemoteContainer {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// RemoteContainerWatcher observes a stream of *RemoteContainer samples.
type RemoteContainerWatcher struct {
	W *genutil.Watcher
	LastVal *QualifiedRemoteContainer
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *RemoteContainerWatcher) Await(t testing.TB) (*QualifiedRemoteContainer, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// QualifiedRoot is a *Root with a corresponding timestamp.
type QualifiedRoot struct {
	*genutil.Metadata
	val *Root // val is the sample value.
	present bool
}

func (q *QualifiedRoot) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the *Root sample, erroring out if not present.
func (q *QualifiedRoot) Val(t testing.TB) *Root {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the *Root sample.
func (q *QualifiedRoot) SetVal(v *Root) *QualifiedRoot {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedRoot) IsPresent() bool {
	return q != nil && q.present
}


// CollectionRoot is a telemetry Collection whose Await method returns a slice of *Root samples.
type CollectionRoot struct {
	W *RootWatcher
	Data []*QualifiedRoot
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionRoot) Await(t testing.TB) []*QualifiedRoot {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// RootWatcher observes a stream of *Root samples.
type RootWatcher struct {
	W *genutil.Watcher
	LastVal *QualifiedRoot
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *RootWatcher) Await(t testing.TB) (*QualifiedRoot, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// QualifiedBinary is a Binary with a corresponding timestamp.
type QualifiedBinary struct {
	*genutil.Metadata
	val Binary // val is the sample value.
	present bool
}

func (q *QualifiedBinary) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the Binary sample, erroring out if not present.
func (q *QualifiedBinary) Val(t testing.TB) Binary {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the Binary sample.
func (q *QualifiedBinary) SetVal(v Binary) *QualifiedBinary {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedBinary) IsPresent() bool {
	return q != nil && q.present
}


// CollectionBinary is a telemetry Collection whose Await method returns a slice of Binary samples.
type CollectionBinary struct {
	W *BinaryWatcher
	Data []*QualifiedBinary
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionBinary) Await(t testing.TB) []*QualifiedBinary {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// BinaryWatcher observes a stream of Binary samples.
type BinaryWatcher struct {
	W *genutil.Watcher
	LastVal *QualifiedBinary
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *BinaryWatcher) Await(t testing.TB) (*QualifiedBinary, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// QualifiedE_Child_Three is a E_Child_Three with a corresponding timestamp.
type QualifiedE_Child_Three struct {
	*genutil.Metadata
	val E_Child_Three // val is the sample value.
	present bool
}

func (q *QualifiedE_Child_Three) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the E_Child_Three sample, erroring out if not present.
func (q *QualifiedE_Child_Three) Val(t testing.TB) E_Child_Three {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the E_Child_Three sample.
func (q *QualifiedE_Child_Three) SetVal(v E_Child_Three) *QualifiedE_Child_Three {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedE_Child_Three) IsPresent() bool {
	return q != nil && q.present
}


// CollectionE_Child_Three is a telemetry Collection whose Await method returns a slice of E_Child_Three samples.
type CollectionE_Child_Three struct {
	W *E_Child_ThreeWatcher
	Data []*QualifiedE_Child_Three
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionE_Child_Three) Await(t testing.TB) []*QualifiedE_Child_Three {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// E_Child_ThreeWatcher observes a stream of E_Child_Three samples.
type E_Child_ThreeWatcher struct {
	W *genutil.Watcher
	LastVal *QualifiedE_Child_Three
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *E_Child_ThreeWatcher) Await(t testing.TB) (*QualifiedE_Child_Three, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// QualifiedFloat32 is a float32 with a corresponding timestamp.
type QualifiedFloat32 struct {
	*genutil.Metadata
	val float32 // val is the sample value.
	present bool
}

func (q *QualifiedFloat32) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the float32 sample, erroring out if not present.
func (q *QualifiedFloat32) Val(t testing.TB) float32 {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the float32 sample.
func (q *QualifiedFloat32) SetVal(v float32) *QualifiedFloat32 {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedFloat32) IsPresent() bool {
	return q != nil && q.present
}


// CollectionFloat32 is a telemetry Collection whose Await method returns a slice of float32 samples.
type CollectionFloat32 struct {
	W *Float32Watcher
	Data []*QualifiedFloat32
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionFloat32) Await(t testing.TB) []*QualifiedFloat32 {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// Float32Watcher observes a stream of float32 samples.
type Float32Watcher struct {
	W *genutil.Watcher
	LastVal *QualifiedFloat32
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *Float32Watcher) Await(t testing.TB) (*QualifiedFloat32, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// QualifiedString is a string with a corresponding timestamp.
type QualifiedString struct {
	*genutil.Metadata
	val string // val is the sample value.
	present bool
}

func (q *QualifiedString) String() string {
	return genutil.QualifiedTypeString(q.val, q.Metadata)
}

// Val returns the value of the string sample, erroring out if not present.
func (q *QualifiedString) Val(t testing.TB) string {
	t.Helper()
	if q == nil {
		t.Fatal("No value present")
	}
	if !q.present {
		pathStr, err := ygot.PathToString(q.Path)
		if err != nil {
			pathStr = fmt.Sprintf("%v", q.Path.GetElem())
		}
		t.Fatalf("No value present at path %s", pathStr)
	}
	return q.val
}

// SetVal sets the value of the string sample.
func (q *QualifiedString) SetVal(v string) *QualifiedString {
	q.val = v
	q.present = true
	return q
}

// IsPresent returns true if the qualified struct contains a value.
func (q *QualifiedString) IsPresent() bool {
	return q != nil && q.present
}


// CollectionString is a telemetry Collection whose Await method returns a slice of string samples.
type CollectionString struct {
	W *StringWatcher
	Data []*QualifiedString
}

// Await blocks until the telemetry collection is complete and returns the slice of values collected.
func (c *CollectionString) Await(t testing.TB) []*QualifiedString {
	t.Helper()
	c.W.Await(t)
	return c.Data
}

// StringWatcher observes a stream of string samples.
type StringWatcher struct {
	W *genutil.Watcher
	LastVal *QualifiedString
}

// Await blocks until the Watch predicate is true or the duration elapses.
// It returns the last value received and a boolean indicating whether it satisfies the predicate.
func (w *StringWatcher) Await(t testing.TB) (*QualifiedString, bool) {
	t.Helper()
	return w.LastVal, w.W.Await(t)
}

// Lookup fetches the value at /openconfig-simple/parent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *ParentPath) Lookup(t testing.TB) *QualifiedParent {
	t.Helper()
	goStruct := &Parent{}
	md, ok := Lookup(t, n, "Parent", goStruct, false, false)
	if ok {
		return (&QualifiedParent{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/parent with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *ParentPath) Get(t testing.TB) *Parent {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/parent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *ParentPathAny) Lookup(t testing.TB) []*QualifiedParent {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedParent
	for _, prefix := range sortedPrefixes {
		goStruct := &Parent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "Parent", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&QualifiedParent{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/parent with a ONCE subscription.
func (n *ParentPathAny) Get(t testing.TB) []*Parent {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*Parent
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *ParentPath) Collect(t testing.TB, duration time.Duration) *CollectionParent {
	t.Helper()
	c := &CollectionParent{}
	c.W = n.Watch(t, duration, func(v *QualifiedParent) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&QualifiedParent{
			Metadata: v.Metadata,
		}).SetVal(copy.(*Parent)))
		return false
	})
	return c
}

func watch_ParentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedParent) bool) *ParentWatcher {
	t.Helper()
	w := &ParentWatcher{}
	gs := &Parent{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Parent", gs, queryPath, false, false)
		return (&QualifiedParent{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedParent)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *ParentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedParent) bool) *ParentWatcher {
	t.Helper()
	return watch_ParentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/parent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *ParentPath) Await(t testing.TB, timeout time.Duration, val *Parent) *QualifiedParent {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedParent) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/parent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/parent to the batch object.
func (n *ParentPath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *ParentPathAny) Collect(t testing.TB, duration time.Duration) *CollectionParent {
	t.Helper()
	c := &CollectionParent{}
	c.W = n.Watch(t, duration, func(v *QualifiedParent) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *ParentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedParent) bool) *ParentWatcher {
	t.Helper()
	return watch_ParentPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/parent to the batch object.
func (n *ParentPathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-simple/parent/child with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *Parent_ChildPath) Lookup(t testing.TB) *QualifiedParent_Child {
	t.Helper()
	goStruct := &Parent_Child{}
	md, ok := Lookup(t, n, "Parent_Child", goStruct, false, false)
	if ok {
		return (&QualifiedParent_Child{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/parent/child with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *Parent_ChildPath) Get(t testing.TB) *Parent_Child {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/parent/child with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *Parent_ChildPathAny) Lookup(t testing.TB) []*QualifiedParent_Child {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedParent_Child
	for _, prefix := range sortedPrefixes {
		goStruct := &Parent_Child{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "Parent_Child", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&QualifiedParent_Child{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/parent/child with a ONCE subscription.
func (n *Parent_ChildPathAny) Get(t testing.TB) []*Parent_Child {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*Parent_Child
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_ChildPath) Collect(t testing.TB, duration time.Duration) *CollectionParent_Child {
	t.Helper()
	c := &CollectionParent_Child{}
	c.W = n.Watch(t, duration, func(v *QualifiedParent_Child) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&QualifiedParent_Child{
			Metadata: v.Metadata,
		}).SetVal(copy.(*Parent_Child)))
		return false
	})
	return c
}

func watch_Parent_ChildPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedParent_Child) bool) *Parent_ChildWatcher {
	t.Helper()
	w := &Parent_ChildWatcher{}
	gs := &Parent_Child{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Parent_Child", gs, queryPath, false, false)
		return (&QualifiedParent_Child{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedParent_Child)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_ChildPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedParent_Child) bool) *Parent_ChildWatcher {
	t.Helper()
	return watch_Parent_ChildPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/parent/child with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *Parent_ChildPath) Await(t testing.TB, timeout time.Duration, val *Parent_Child) *QualifiedParent_Child {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedParent_Child) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/parent/child failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/parent/child to the batch object.
func (n *Parent_ChildPath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_ChildPathAny) Collect(t testing.TB, duration time.Duration) *CollectionParent_Child {
	t.Helper()
	c := &CollectionParent_Child{}
	c.W = n.Watch(t, duration, func(v *QualifiedParent_Child) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_ChildPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedParent_Child) bool) *Parent_ChildWatcher {
	t.Helper()
	return watch_Parent_ChildPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/parent/child to the batch object.
func (n *Parent_ChildPathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-simple/parent/child/state/five with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *Parent_Child_FivePath) Lookup(t testing.TB) *QualifiedFloat32 {
	t.Helper()
	goStruct := &Parent_Child{}
	md, ok := Lookup(t, n, "Parent_Child", goStruct, true, false)
	if ok {
		return convertParent_Child_FivePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/parent/child/state/five with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *Parent_Child_FivePath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/parent/child/state/five with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *Parent_Child_FivePathAny) Lookup(t testing.TB) []*QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &Parent_Child{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "Parent_Child", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertParent_Child_FivePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/parent/child/state/five with a ONCE subscription.
func (n *Parent_Child_FivePathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/five with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_FivePath) Collect(t testing.TB, duration time.Duration) *CollectionFloat32 {
	t.Helper()
	c := &CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_Parent_Child_FivePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedFloat32) bool) *Float32Watcher {
	t.Helper()
	w := &Float32Watcher{}
	gs := &Parent_Child{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Parent_Child", gs, queryPath, true, false)
		return convertParent_Child_FivePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/five with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_FivePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedFloat32) bool) *Float32Watcher {
	t.Helper()
	return watch_Parent_Child_FivePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/parent/child/state/five with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *Parent_Child_FivePath) Await(t testing.TB, timeout time.Duration, val float32) *QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/parent/child/state/five failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/parent/child/state/five to the batch object.
func (n *Parent_Child_FivePath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/five with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_FivePathAny) Collect(t testing.TB, duration time.Duration) *CollectionFloat32 {
	t.Helper()
	c := &CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/five with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_FivePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedFloat32) bool) *Float32Watcher {
	t.Helper()
	return watch_Parent_Child_FivePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/parent/child/state/five to the batch object.
func (n *Parent_Child_FivePathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// convertParent_Child_FivePath extracts the value of the leaf Five from its parent Parent_Child
// and combines the update with an existing Metadata to return a *QualifiedFloat32.
func convertParent_Child_FivePath(t testing.TB, md *genutil.Metadata, parent *Parent_Child) *QualifiedFloat32 {
	t.Helper()
	qv := &QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Five
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-simple/parent/child/state/four with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *Parent_Child_FourPath) Lookup(t testing.TB) *QualifiedBinary {
	t.Helper()
	goStruct := &Parent_Child{}
	md, ok := Lookup(t, n, "Parent_Child", goStruct, true, false)
	if ok {
		return convertParent_Child_FourPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/parent/child/state/four with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *Parent_Child_FourPath) Get(t testing.TB) Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/parent/child/state/four with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *Parent_Child_FourPathAny) Lookup(t testing.TB) []*QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &Parent_Child{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "Parent_Child", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertParent_Child_FourPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/parent/child/state/four with a ONCE subscription.
func (n *Parent_Child_FourPathAny) Get(t testing.TB) []Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/four with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_FourPath) Collect(t testing.TB, duration time.Duration) *CollectionBinary {
	t.Helper()
	c := &CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_Parent_Child_FourPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedBinary) bool) *BinaryWatcher {
	t.Helper()
	w := &BinaryWatcher{}
	gs := &Parent_Child{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Parent_Child", gs, queryPath, true, false)
		return convertParent_Child_FourPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/four with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_FourPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedBinary) bool) *BinaryWatcher {
	t.Helper()
	return watch_Parent_Child_FourPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/parent/child/state/four with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *Parent_Child_FourPath) Await(t testing.TB, timeout time.Duration, val Binary) *QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/parent/child/state/four failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/parent/child/state/four to the batch object.
func (n *Parent_Child_FourPath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/four with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_FourPathAny) Collect(t testing.TB, duration time.Duration) *CollectionBinary {
	t.Helper()
	c := &CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/four with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_FourPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedBinary) bool) *BinaryWatcher {
	t.Helper()
	return watch_Parent_Child_FourPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/parent/child/state/four to the batch object.
func (n *Parent_Child_FourPathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// convertParent_Child_FourPath extracts the value of the leaf Four from its parent Parent_Child
// and combines the update with an existing Metadata to return a *QualifiedBinary.
func convertParent_Child_FourPath(t testing.TB, md *genutil.Metadata, parent *Parent_Child) *QualifiedBinary {
	t.Helper()
	qv := &QualifiedBinary{
		Metadata: md,
	}
	val := parent.Four
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-simple/parent/child/state/one with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *Parent_Child_OnePath) Lookup(t testing.TB) *QualifiedString {
	t.Helper()
	goStruct := &Parent_Child{}
	md, ok := Lookup(t, n, "Parent_Child", goStruct, true, false)
	if ok {
		return convertParent_Child_OnePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/parent/child/state/one with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *Parent_Child_OnePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/parent/child/state/one with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *Parent_Child_OnePathAny) Lookup(t testing.TB) []*QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &Parent_Child{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "Parent_Child", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertParent_Child_OnePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/parent/child/state/one with a ONCE subscription.
func (n *Parent_Child_OnePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/one with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_OnePath) Collect(t testing.TB, duration time.Duration) *CollectionString {
	t.Helper()
	c := &CollectionString{}
	c.W = n.Watch(t, duration, func(v *QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_Parent_Child_OnePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	w := &StringWatcher{}
	gs := &Parent_Child{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Parent_Child", gs, queryPath, true, false)
		return convertParent_Child_OnePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/one with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_OnePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	return watch_Parent_Child_OnePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/parent/child/state/one with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *Parent_Child_OnePath) Await(t testing.TB, timeout time.Duration, val string) *QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/parent/child/state/one failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/parent/child/state/one to the batch object.
func (n *Parent_Child_OnePath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/one with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_OnePathAny) Collect(t testing.TB, duration time.Duration) *CollectionString {
	t.Helper()
	c := &CollectionString{}
	c.W = n.Watch(t, duration, func(v *QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/one with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_OnePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	return watch_Parent_Child_OnePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/parent/child/state/one to the batch object.
func (n *Parent_Child_OnePathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// convertParent_Child_OnePath extracts the value of the leaf One from its parent Parent_Child
// and combines the update with an existing Metadata to return a *QualifiedString.
func convertParent_Child_OnePath(t testing.TB, md *genutil.Metadata, parent *Parent_Child) *QualifiedString {
	t.Helper()
	qv := &QualifiedString{
		Metadata: md,
	}
	val := parent.One
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-simple/parent/child/state/three with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *Parent_Child_ThreePath) Lookup(t testing.TB) *QualifiedE_Child_Three {
	t.Helper()
	goStruct := &Parent_Child{}
	md, ok := Lookup(t, n, "Parent_Child", goStruct, true, false)
	if ok {
		return convertParent_Child_ThreePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/parent/child/state/three with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *Parent_Child_ThreePath) Get(t testing.TB) E_Child_Three {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/parent/child/state/three with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *Parent_Child_ThreePathAny) Lookup(t testing.TB) []*QualifiedE_Child_Three {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedE_Child_Three
	for _, prefix := range sortedPrefixes {
		goStruct := &Parent_Child{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "Parent_Child", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertParent_Child_ThreePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/parent/child/state/three with a ONCE subscription.
func (n *Parent_Child_ThreePathAny) Get(t testing.TB) []E_Child_Three {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []E_Child_Three
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/three with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_ThreePath) Collect(t testing.TB, duration time.Duration) *CollectionE_Child_Three {
	t.Helper()
	c := &CollectionE_Child_Three{}
	c.W = n.Watch(t, duration, func(v *QualifiedE_Child_Three) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_Parent_Child_ThreePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedE_Child_Three) bool) *E_Child_ThreeWatcher {
	t.Helper()
	w := &E_Child_ThreeWatcher{}
	gs := &Parent_Child{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Parent_Child", gs, queryPath, true, false)
		return convertParent_Child_ThreePath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedE_Child_Three)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/three with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_ThreePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedE_Child_Three) bool) *E_Child_ThreeWatcher {
	t.Helper()
	return watch_Parent_Child_ThreePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/parent/child/state/three with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *Parent_Child_ThreePath) Await(t testing.TB, timeout time.Duration, val E_Child_Three) *QualifiedE_Child_Three {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedE_Child_Three) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/parent/child/state/three failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/parent/child/state/three to the batch object.
func (n *Parent_Child_ThreePath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/three with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_ThreePathAny) Collect(t testing.TB, duration time.Duration) *CollectionE_Child_Three {
	t.Helper()
	c := &CollectionE_Child_Three{}
	c.W = n.Watch(t, duration, func(v *QualifiedE_Child_Three) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/three with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_ThreePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedE_Child_Three) bool) *E_Child_ThreeWatcher {
	t.Helper()
	return watch_Parent_Child_ThreePath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/parent/child/state/three to the batch object.
func (n *Parent_Child_ThreePathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// convertParent_Child_ThreePath extracts the value of the leaf Three from its parent Parent_Child
// and combines the update with an existing Metadata to return a *QualifiedE_Child_Three.
func convertParent_Child_ThreePath(t testing.TB, md *genutil.Metadata, parent *Parent_Child) *QualifiedE_Child_Three {
	t.Helper()
	qv := &QualifiedE_Child_Three{
		Metadata: md,
	}
	val := parent.Three
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-simple/parent/child/state/two with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *Parent_Child_TwoPath) Lookup(t testing.TB) *QualifiedString {
	t.Helper()
	goStruct := &Parent_Child{}
	md, ok := Lookup(t, n, "Parent_Child", goStruct, true, false)
	if ok {
		return convertParent_Child_TwoPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/parent/child/state/two with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *Parent_Child_TwoPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/parent/child/state/two with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *Parent_Child_TwoPathAny) Lookup(t testing.TB) []*QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &Parent_Child{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "Parent_Child", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertParent_Child_TwoPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/parent/child/state/two with a ONCE subscription.
func (n *Parent_Child_TwoPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/two with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_TwoPath) Collect(t testing.TB, duration time.Duration) *CollectionString {
	t.Helper()
	c := &CollectionString{}
	c.W = n.Watch(t, duration, func(v *QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_Parent_Child_TwoPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	w := &StringWatcher{}
	gs := &Parent_Child{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Parent_Child", gs, queryPath, true, false)
		return convertParent_Child_TwoPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/two with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_TwoPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	return watch_Parent_Child_TwoPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/parent/child/state/two with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *Parent_Child_TwoPath) Await(t testing.TB, timeout time.Duration, val string) *QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/parent/child/state/two failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/parent/child/state/two to the batch object.
func (n *Parent_Child_TwoPath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/parent/child/state/two with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *Parent_Child_TwoPathAny) Collect(t testing.TB, duration time.Duration) *CollectionString {
	t.Helper()
	c := &CollectionString{}
	c.W = n.Watch(t, duration, func(v *QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/parent/child/state/two with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *Parent_Child_TwoPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	return watch_Parent_Child_TwoPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/parent/child/state/two to the batch object.
func (n *Parent_Child_TwoPathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// convertParent_Child_TwoPath extracts the value of the leaf Two from its parent Parent_Child
// and combines the update with an existing Metadata to return a *QualifiedString.
func convertParent_Child_TwoPath(t testing.TB, md *genutil.Metadata, parent *Parent_Child) *QualifiedString {
	t.Helper()
	qv := &QualifiedString{
		Metadata: md,
	}
	val := parent.Two
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-simple/remote-container with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *RemoteContainerPath) Lookup(t testing.TB) *QualifiedRemoteContainer {
	t.Helper()
	goStruct := &RemoteContainer{}
	md, ok := Lookup(t, n, "RemoteContainer", goStruct, false, false)
	if ok {
		return (&QualifiedRemoteContainer{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/remote-container with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *RemoteContainerPath) Get(t testing.TB) *RemoteContainer {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/remote-container with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *RemoteContainerPathAny) Lookup(t testing.TB) []*QualifiedRemoteContainer {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedRemoteContainer
	for _, prefix := range sortedPrefixes {
		goStruct := &RemoteContainer{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "RemoteContainer", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&QualifiedRemoteContainer{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/remote-container with a ONCE subscription.
func (n *RemoteContainerPathAny) Get(t testing.TB) []*RemoteContainer {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*RemoteContainer
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/remote-container with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *RemoteContainerPath) Collect(t testing.TB, duration time.Duration) *CollectionRemoteContainer {
	t.Helper()
	c := &CollectionRemoteContainer{}
	c.W = n.Watch(t, duration, func(v *QualifiedRemoteContainer) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&QualifiedRemoteContainer{
			Metadata: v.Metadata,
		}).SetVal(copy.(*RemoteContainer)))
		return false
	})
	return c
}

func watch_RemoteContainerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedRemoteContainer) bool) *RemoteContainerWatcher {
	t.Helper()
	w := &RemoteContainerWatcher{}
	gs := &RemoteContainer{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "RemoteContainer", gs, queryPath, false, false)
		return (&QualifiedRemoteContainer{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedRemoteContainer)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/remote-container with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *RemoteContainerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedRemoteContainer) bool) *RemoteContainerWatcher {
	t.Helper()
	return watch_RemoteContainerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/remote-container with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *RemoteContainerPath) Await(t testing.TB, timeout time.Duration, val *RemoteContainer) *QualifiedRemoteContainer {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedRemoteContainer) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/remote-container failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/remote-container to the batch object.
func (n *RemoteContainerPath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/remote-container with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *RemoteContainerPathAny) Collect(t testing.TB, duration time.Duration) *CollectionRemoteContainer {
	t.Helper()
	c := &CollectionRemoteContainer{}
	c.W = n.Watch(t, duration, func(v *QualifiedRemoteContainer) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/remote-container with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *RemoteContainerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedRemoteContainer) bool) *RemoteContainerWatcher {
	t.Helper()
	return watch_RemoteContainerPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/remote-container to the batch object.
func (n *RemoteContainerPathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-simple/remote-container/state/a-leaf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *RemoteContainer_ALeafPath) Lookup(t testing.TB) *QualifiedString {
	t.Helper()
	goStruct := &RemoteContainer{}
	md, ok := Lookup(t, n, "RemoteContainer", goStruct, true, false)
	if ok {
		return convertRemoteContainer_ALeafPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-simple/remote-container/state/a-leaf with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *RemoteContainer_ALeafPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-simple/remote-container/state/a-leaf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *RemoteContainer_ALeafPathAny) Lookup(t testing.TB) []*QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &RemoteContainer{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], GetSchema(), "RemoteContainer", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertRemoteContainer_ALeafPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-simple/remote-container/state/a-leaf with a ONCE subscription.
func (n *RemoteContainer_ALeafPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/remote-container/state/a-leaf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *RemoteContainer_ALeafPath) Collect(t testing.TB, duration time.Duration) *CollectionString {
	t.Helper()
	c := &CollectionString{}
	c.W = n.Watch(t, duration, func(v *QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_RemoteContainer_ALeafPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	w := &StringWatcher{}
	gs := &RemoteContainer{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "RemoteContainer", gs, queryPath, true, false)
		return convertRemoteContainer_ALeafPath(t, md, gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/remote-container/state/a-leaf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *RemoteContainer_ALeafPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	return watch_RemoteContainer_ALeafPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-simple/remote-container/state/a-leaf with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *RemoteContainer_ALeafPath) Await(t testing.TB, timeout time.Duration, val string) *QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-simple/remote-container/state/a-leaf failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-simple/remote-container/state/a-leaf to the batch object.
func (n *RemoteContainer_ALeafPath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-simple/remote-container/state/a-leaf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *RemoteContainer_ALeafPathAny) Collect(t testing.TB, duration time.Duration) *CollectionString {
	t.Helper()
	c := &CollectionString{}
	c.W = n.Watch(t, duration, func(v *QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

// Watch starts an asynchronous observation of the values at /openconfig-simple/remote-container/state/a-leaf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *RemoteContainer_ALeafPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedString) bool) *StringWatcher {
	t.Helper()
	return watch_RemoteContainer_ALeafPath(t, n, timeout, predicate)
}

// Batch adds /openconfig-simple/remote-container/state/a-leaf to the batch object.
func (n *RemoteContainer_ALeafPathAny) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}

// convertRemoteContainer_ALeafPath extracts the value of the leaf ALeaf from its parent RemoteContainer
// and combines the update with an existing Metadata to return a *QualifiedString.
func convertRemoteContainer_ALeafPath(t testing.TB, md *genutil.Metadata, parent *RemoteContainer) *QualifiedString {
	t.Helper()
	qv := &QualifiedString{
		Metadata: md,
	}
	val := parent.ALeaf
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at / with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *RootPath) Lookup(t testing.TB) *QualifiedRoot {
	t.Helper()
	goStruct := &Root{}
	md, ok := Lookup(t, n, "Root", goStruct, false, false)
	if ok {
		return (&QualifiedRoot{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at / with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *RootPath) Get(t testing.TB) *Root {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Collect starts an asynchronous collection of the values at / with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *RootPath) Collect(t testing.TB, duration time.Duration) *CollectionRoot {
	t.Helper()
	c := &CollectionRoot{}
	c.W = n.Watch(t, duration, func(v *QualifiedRoot) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&QualifiedRoot{
			Metadata: v.Metadata,
		}).SetVal(copy.(*Root)))
		return false
	})
	return c
}

func watch_RootPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *QualifiedRoot) bool) *RootWatcher {
	t.Helper()
	w := &RootWatcher{}
	gs := &Root{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) (genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, GetSchema(), "Root", gs, queryPath, false, false)
		return (&QualifiedRoot{
			Metadata: md,
		}).SetVal(gs), nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*QualifiedRoot)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at / with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *RootPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *QualifiedRoot) bool) *RootWatcher {
	t.Helper()
	return watch_RootPath(t, n, timeout, predicate)
}

// Await observes values at / with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *RootPath) Await(t testing.TB, timeout time.Duration, val *Root) *QualifiedRoot {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *QualifiedRoot) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at / failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds / to the batch object.
func (n *RootPath) Batch(t testing.TB, b *Batch) {
	t.Helper()
	MustAddToBatch(t, b, n)
}
