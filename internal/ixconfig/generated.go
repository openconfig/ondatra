// Copyright 2021 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOGENERATED. DO NOT EDIT MANUALLY!
// To regenerate run codegen/gen_ixconfig.sh in a CitC client.

package ixconfig

// AvailableHardware: TBD
type AvailableHardware struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsOffChassis: TBD

	IsOffChassis *bool `json:"isOffChassis,omitempty"`
	// OffChassisHwM: TBD

	OffChassisHwM *string                     `json:"offChassisHwM,omitempty"`
	Chassis       []*AvailableHardwareChassis `json:"chassis"`

	VirtualChassis *AvailableHardwareVirtualChassis `json:"virtualChassis,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardware) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardware) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardware) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardware) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Chassis {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "chassis",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.VirtualChassis.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "virtualChassis",
	})
}

// AvailableHardwareAggregation: TBD
type AvailableHardwareAggregation struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Mode: TBD

	Mode *string `json:"mode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareAggregation) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareAggregation) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareAggregation) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareAggregation) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// AvailableHardwareCard: TBD
type AvailableHardwareCard struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AggregationMode: TBD

	AggregationMode *string                         `json:"aggregationMode,omitempty"`
	Aggregation     []*AvailableHardwareAggregation `json:"aggregation"`
	Port            []*AvailableHardwarePort        `json:"port"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareCard) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareCard) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareCard) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareCard) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Aggregation {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "aggregation",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Port {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "port",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// AvailableHardwareChassis: TBD
type AvailableHardwareChassis struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// CableLength: TBD

	CableLength *float32 `json:"cableLength,omitempty"`
	// ChainTopology: TBD

	ChainTopology *string `json:"chainTopology,omitempty"`
	// Hostname: TBD

	Hostname *string `json:"hostname,omitempty"`
	// MasterChassis: TBD

	MasterChassis *string `json:"masterChassis,omitempty"`
	// SequenceId: TBD

	SequenceId *float32                 `json:"sequenceId,omitempty"`
	Card       []*AvailableHardwareCard `json:"card"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareChassis) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareChassis) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareChassis) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareChassis) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Card {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "card",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// AvailableHardwareDiscoveredAppliance: TBD
type AvailableHardwareDiscoveredAppliance struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath               *XPath                                  `json:"xpath,omitempty"`
	DiscoveredInterface []*AvailableHardwareDiscoveredInterface `json:"discoveredInterface"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareDiscoveredAppliance) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareDiscoveredAppliance) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareDiscoveredAppliance) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareDiscoveredAppliance) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.DiscoveredInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "discoveredInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// AvailableHardwareDiscoveredInterface: TBD
type AvailableHardwareDiscoveredInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareDiscoveredInterface) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareDiscoveredInterface) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareDiscoveredInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareDiscoveredInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// AvailableHardwareHypervisor: TBD
type AvailableHardwareHypervisor struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// Password: TBD

	Password *string `json:"password,omitempty"`
	// ServerIp: TBD

	ServerIp *string `json:"serverIp,omitempty"`
	// Type_: TBD

	Type_ *string `json:"type,omitempty"`
	// User: TBD

	User *string `json:"user,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareHypervisor) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareHypervisor) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareHypervisor) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareHypervisor) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// AvailableHardwareIxVmCard: TBD
type AvailableHardwareIxVmCard struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// CardId: TBD

	CardId *string `json:"cardId,omitempty"`
	// CardName: TBD

	CardName *string `json:"cardName,omitempty"`
	// KeepAliveTimeout: TBD

	KeepAliveTimeout *float32 `json:"keepAliveTimeout,omitempty"`
	// ManagementIp: TBD

	ManagementIp *string                      `json:"managementIp,omitempty"`
	IxVmPort     []*AvailableHardwareIxVmPort `json:"ixVmPort"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareIxVmCard) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareIxVmCard) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareIxVmCard) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareIxVmCard) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.IxVmPort {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ixVmPort",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// AvailableHardwareIxVmPort: TBD
type AvailableHardwareIxVmPort struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Interface_: TBD

	Interface_ *string `json:"interface,omitempty"`
	// IpAddress: TBD

	IpAddress *string `json:"ipAddress,omitempty"`
	// MacAddress: TBD

	MacAddress *string `json:"macAddress,omitempty"`
	// Mtu: TBD

	Mtu *float32 `json:"mtu,omitempty"`
	// PortId: TBD

	PortId *string `json:"portId,omitempty"`
	// PortName: TBD

	PortName *string `json:"portName,omitempty"`
	// PromiscMode: TBD

	PromiscMode *bool `json:"promiscMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareIxVmPort) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareIxVmPort) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareIxVmPort) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareIxVmPort) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// AvailableHardwareParameter: TBD
type AvailableHardwareParameter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CurrentValue: Parameter UI Display Value

	CurrentValue *string `json:"currentValue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareParameter) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareParameter) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareParameter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareParameter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// AvailableHardwarePort: TBD
type AvailableHardwarePort struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath       *XPath                          `json:"xpath,omitempty"`
	TapSettings []*AvailableHardwareTapSettings `json:"tapSettings"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwarePort) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwarePort) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwarePort) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwarePort) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.TapSettings {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tapSettings",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// AvailableHardwareTapSettings: TBD
type AvailableHardwareTapSettings struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath     *XPath                        `json:"xpath,omitempty"`
	Parameter []*AvailableHardwareParameter `json:"parameter"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareTapSettings) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareTapSettings) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareTapSettings) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareTapSettings) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Parameter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "parameter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// AvailableHardwareVirtualChassis: TBD
type AvailableHardwareVirtualChassis struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableLicenseCheck: TBD

	EnableLicenseCheck *bool `json:"enableLicenseCheck,omitempty"`
	// LicenseServer: TBD

	LicenseServer *string `json:"licenseServer,omitempty"`
	// NtpServer: TBD

	NtpServer *string `json:"ntpServer,omitempty"`
	// StartTxDelay: TBD

	StartTxDelay        *string                                 `json:"startTxDelay,omitempty"`
	DiscoveredAppliance []*AvailableHardwareDiscoveredAppliance `json:"discoveredAppliance"`
	Hypervisor          []*AvailableHardwareHypervisor          `json:"hypervisor"`
	IxVmCard            []*AvailableHardwareIxVmCard            `json:"ixVmCard"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *AvailableHardwareVirtualChassis) XPath() *XPath {
	return n.Xpath
}

func (n *AvailableHardwareVirtualChassis) setRestID(id string) {
	n.RestID = id
}

func (n *AvailableHardwareVirtualChassis) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *AvailableHardwareVirtualChassis) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.DiscoveredAppliance {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "discoveredAppliance",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Hypervisor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "hypervisor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IxVmCard {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ixVmCard",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// Globals: TBD
type Globals struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`

	Ixnet *GlobalsIxnet `json:"ixnet,omitempty"`

	Licensing *GlobalsLicensing `json:"licensing,omitempty"`

	Preferences *GlobalsPreferences `json:"preferences,omitempty"`

	Testworkflow *GlobalsTestworkflow `json:"testworkflow,omitempty"`

	Topology *GlobalsTopology `json:"topology,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Globals) XPath() *XPath {
	return n.Xpath
}

func (n *Globals) setRestID(id string) {
	n.RestID = id
}

func (n *Globals) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Globals) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Ixnet.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ixnet",
	})
	n.Licensing.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "licensing",
	})
	n.Preferences.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "preferences",
	})
	n.Testworkflow.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "testworkflow",
	})
	n.Topology.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "topology",
	})
}

// GlobalsAction: Action prototype.
type GlobalsAction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name  *string               `json:"name,omitempty"`
	Field []*GlobalsActionField `json:"field"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsAction) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsAction) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsAction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsAction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsActionField: Field prototype.
type GlobalsActionField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// Encoding: Encoding of the field value.

	Encoding *string `json:"encoding,omitempty"`
	// Enum: Internal enumeration type used to restrict possible field values.

	Enum *string `json:"enum,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name *string `json:"name,omitempty"`
	// SingleValue: If true the field can only be configured with a single value pattern.

	SingleValue *bool `json:"singleValue,omitempty"`
	// Size: The size of the field in bytes. Field size must be greater or equal to 0. For automatic detection set size to 0.

	Size *float32 `json:"size,omitempty"`
	// SizeType: The size types/data unit of the field.

	SizeType *string `json:"sizeType,omitempty"`
	// Value: Field value.
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsActionField) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsActionField) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsActionField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsActionField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// GlobalsActionSet: Action prototype.
type GlobalsActionSet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name   *string          `json:"name,omitempty"`
	Action []*GlobalsAction `json:"action"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsActionSet) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsActionSet) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsActionSet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsActionSet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Action {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "action",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsActionTemplate: Action Builder Template.
type GlobalsActionTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SavedInVersion: The cpf version of the session

	SavedInVersion *string          `json:"savedInVersion,omitempty"`
	Action         []*GlobalsAction `json:"action"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsActionTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsActionTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsActionTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsActionTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Action {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "action",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsActionsTemplate: Global data for OpenFlow Action Builder template data extension.
type GlobalsActionsTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath          *XPath                   `json:"xpath,omitempty"`
	ActionTemplate []*GlobalsActionTemplate `json:"actionTemplate"`

	Predefined *GlobalsPredefined `json:"predefined,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsActionsTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsActionsTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsActionsTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsActionsTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.ActionTemplate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "actionTemplate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Predefined.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "predefined",
	})
}

// GlobalsAncp: ANCP per port settings
type GlobalsAncp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	PortDownRate *GlobalsPortDownRate `json:"portDownRate,omitempty"`

	PortUpRate *GlobalsPortUpRate `json:"portUpRate,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate  *GlobalsStopRate    `json:"stopRate,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsAncp) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsAncp) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsAncp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsAncp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.PortDownRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "portDownRate",
	})
	n.PortUpRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "portUpRate",
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsArpRate: Parameters used for controlling the rate of actions
type GlobalsArpRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsArpRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsArpRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsArpRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsArpRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsBfdRouter: Bfd Port Specific Data
type GlobalsBfdRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBfdRouter) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBfdRouter) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBfdRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBfdRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsBgpIpv4Peer: BGP Port level Configuration
type GlobalsBgpIpv4Peer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BIERTunnelType: BIER Tunnel Type
	BIERTunnelType *Multivalue `json:"BIERTunnelType,omitempty"`
	// LLGRCapabilityCode: Long Live Graceful Restart Capability Code
	LLGRCapabilityCode *Multivalue `json:"LLGRCapabilityCode,omitempty"`
	// BgpConfMemType: BGP Confederation Member Type
	BgpConfMemType *Multivalue `json:"bgpConfMemType,omitempty"`
	// BgpRouterId: BGP Router-ID Type
	BgpRouterId *Multivalue `json:"bgpRouterId,omitempty"`
	// BindingType: Binding Sub-TLV Type
	BindingType *Multivalue `json:"bindingType,omitempty"`
	// ColorType: Color Sub-TLV Type
	ColorType *Multivalue `json:"colorType,omitempty"`
	// DisableReceivedUpdateValidation: Disable Received Update Validation (Enabled for High Performance)
	DisableReceivedUpdateValidation *Multivalue `json:"disableReceivedUpdateValidation,omitempty"`
	// ENLPType: Explicit NULL Label Policy Sub-TLV Type
	ENLPType *Multivalue `json:"eNLPType,omitempty"`
	// EVPNSIDType: EVPN SID Type
	EVPNSIDType *Multivalue `json:"eVPNSIDType,omitempty"`
	// EnLenthForPolicyNLRI: Include Length Field in SR TE Policy NLRI
	EnLenthForPolicyNLRI *Multivalue `json:"enLenthForPolicyNLRI,omitempty"`
	// EnableAdVplsPrefixLength: Enable AD VPLS Prefix Length in Bits
	EnableAdVplsPrefixLength *Multivalue `json:"enableAdVplsPrefixLength,omitempty"`
	// IBgpTester4BytesAsNumber: Tester 4 Byte AS# for iBGP
	IBgpTester4BytesAsNumber *Multivalue `json:"iBgpTester4BytesAsNumber,omitempty"`
	// IBgpTesterAsNumber: Tester AS# for iBGP
	IBgpTesterAsNumber *Multivalue `json:"iBgpTesterAsNumber,omitempty"`
	// InitiateEbgpActiveConnection: Initiate eBGP Active Connection
	InitiateEbgpActiveConnection *Multivalue `json:"initiateEbgpActiveConnection,omitempty"`
	// InitiateIbgpActiveConnection: Initiate iBGP Active Connection
	InitiateIbgpActiveConnection *Multivalue `json:"initiateIbgpActiveConnection,omitempty"`
	// Ipv4AddrIndexType: IPv4 Address + Index Type
	Ipv4AddrIndexType *Multivalue `json:"ipv4AddrIndexType,omitempty"`
	// Ipv4LocRemoteAddrType: IPv4 Local and Remote Address
	Ipv4LocRemoteAddrType *Multivalue `json:"ipv4LocRemoteAddrType,omitempty"`
	// Ipv4NodeAddrType: IPv4 Node Address Type
	Ipv4NodeAddrType *Multivalue `json:"ipv4NodeAddrType,omitempty"`
	// Ipv6AddrIndexType: IPv6 Address + Index Type
	Ipv6AddrIndexType *Multivalue `json:"ipv6AddrIndexType,omitempty"`
	// Ipv6LocRemoteAddrType: IPv6 Local and Remote Address
	Ipv6LocRemoteAddrType *Multivalue `json:"ipv6LocRemoteAddrType,omitempty"`
	// Ipv6NodeAddrType: IPv6 Node Address Type
	Ipv6NodeAddrType *Multivalue `json:"ipv6NodeAddrType,omitempty"`
	// Ipv6SIDType: IPv6 SID Type
	Ipv6SIDType *Multivalue `json:"ipv6SIDType,omitempty"`
	// LenthForPolicyNLRI: Length Unit
	LenthForPolicyNLRI *Multivalue `json:"lenthForPolicyNLRI,omitempty"`
	// MldpP2mpFecType: MLDP P2MP FEC Type (Hex)
	MldpP2mpFecType *Multivalue `json:"mldpP2mpFecType,omitempty"`
	// MplsSIDType: MPLS SID Type
	MplsSIDType *Multivalue `json:"mplsSIDType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeerAdjSidType: Peer-Adj-SID Type
	PeerAdjSidType *Multivalue `json:"peerAdjSidType,omitempty"`
	// PeerNodeSidType: Peer-Node-SID Type
	PeerNodeSidType *Multivalue `json:"peerNodeSidType,omitempty"`
	// PeerSetSidType: Peer-Set-SID Type
	PeerSetSidType *Multivalue `json:"peerSetSidType,omitempty"`
	// PolicyNameType: Policy Name Sub-TLV Type
	PolicyNameType *Multivalue `json:"policyNameType,omitempty"`
	// PolicyPriorityType: Policy Priority Sub-TLV Type
	PolicyPriorityType *Multivalue `json:"policyPriorityType,omitempty"`
	// PreferenceType: Preference Sub-TLV Type
	PreferenceType *Multivalue `json:"preferenceType,omitempty"`
	// PrefixSIDAttrType: Prefix SID Attr Type
	PrefixSIDAttrType *Multivalue `json:"prefixSIDAttrType,omitempty"`
	// ProtoclIdType: Protocol-ID Type
	ProtoclIdType *Multivalue `json:"protoclIdType,omitempty"`
	// RemoteEndpointType: Remote Endpoint Sub-TLV Type
	RemoteEndpointType *Multivalue `json:"remoteEndpointType,omitempty"`
	// RequestVpnLabelExchangeOverLsp: Request VPN Label Exchange over LSP
	RequestVpnLabelExchangeOverLsp *Multivalue `json:"requestVpnLabelExchangeOverLsp,omitempty"`
	// SRv6VPNSIDTLVType: SRv6-VPN SID TLV Type
	SRv6VPNSIDTLVType *Multivalue `json:"sRv6VPNSIDTLVType,omitempty"`
	// SegmentListType: Segment List Sub-TLV Type
	SegmentListType *Multivalue `json:"segmentListType,omitempty"`
	// SrtePolicyAttrType: Tunnel Encaps Attribute Type
	SrtePolicyAttrType *Multivalue `json:"srtePolicyAttrType,omitempty"`
	// SrtePolicySAFI: SR TE Policy SAFI
	SrtePolicySAFI *Multivalue `json:"srtePolicySAFI,omitempty"`
	// SrtePolicyType: Tunnel Type for SR Policy
	SrtePolicyType *Multivalue `json:"srtePolicyType,omitempty"`
	// Srv6DraftNum: SRv6 VPN Draft Version Number to be used both for L3VPN and EVPN

	Srv6DraftNum *string `json:"srv6DraftNum,omitempty"`
	// TriggerVplsPwInitiation: Trigger VPLS PW Initiation
	TriggerVplsPwInitiation *Multivalue `json:"triggerVplsPwInitiation,omitempty"`
	// UdpDestinationPort: UDP Destination Port for VXLAN
	UdpDestinationPort *Multivalue `json:"udpDestinationPort,omitempty"`
	// UseUnicastDestMacForBierTraffic: Use Unicast Dst MAC for Traffic
	UseUnicastDestMacForBierTraffic *Multivalue `json:"useUnicastDestMacForBierTraffic,omitempty"`
	// VPNSIDType: L3VPN SID Type
	VPNSIDType *Multivalue `json:"vPNSIDType,omitempty"`
	// VrfRouteImportExtendedCommunitySubType: VRF Route Import Extended Community Sub Type
	VrfRouteImportExtendedCommunitySubType *Multivalue `json:"vrfRouteImportExtendedCommunitySubType,omitempty"`
	// WeightType: Weight Sub-TLV Type
	WeightType *Multivalue `json:"weightType,omitempty"`

	StartRate *GlobalsBgpIpv4PeerStartRate `json:"startRate,omitempty"`

	StopRate  *GlobalsBgpIpv4PeerStopRate `json:"stopRate,omitempty"`
	TlvEditor []*GlobalsTlvEditor         `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBgpIpv4Peer) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBgpIpv4Peer) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBgpIpv4Peer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBgpIpv4Peer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BIERTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERTunnelType",
		isMultivalue: true,
	})
	n.LLGRCapabilityCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "LLGRCapabilityCode",
		isMultivalue: true,
	})
	n.BgpConfMemType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpConfMemType",
		isMultivalue: true,
	})
	n.BgpRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpRouterId",
		isMultivalue: true,
	})
	n.BindingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingType",
		isMultivalue: true,
	})
	n.ColorType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorType",
		isMultivalue: true,
	})
	n.DisableReceivedUpdateValidation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableReceivedUpdateValidation",
		isMultivalue: true,
	})
	n.ENLPType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eNLPType",
		isMultivalue: true,
	})
	n.EVPNSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eVPNSIDType",
		isMultivalue: true,
	})
	n.EnLenthForPolicyNLRI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enLenthForPolicyNLRI",
		isMultivalue: true,
	})
	n.EnableAdVplsPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdVplsPrefixLength",
		isMultivalue: true,
	})
	n.IBgpTester4BytesAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iBgpTester4BytesAsNumber",
		isMultivalue: true,
	})
	n.IBgpTesterAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iBgpTesterAsNumber",
		isMultivalue: true,
	})
	n.InitiateEbgpActiveConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initiateEbgpActiveConnection",
		isMultivalue: true,
	})
	n.InitiateIbgpActiveConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initiateIbgpActiveConnection",
		isMultivalue: true,
	})
	n.Ipv4AddrIndexType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4AddrIndexType",
		isMultivalue: true,
	})
	n.Ipv4LocRemoteAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4LocRemoteAddrType",
		isMultivalue: true,
	})
	n.Ipv4NodeAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NodeAddrType",
		isMultivalue: true,
	})
	n.Ipv6AddrIndexType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6AddrIndexType",
		isMultivalue: true,
	})
	n.Ipv6LocRemoteAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6LocRemoteAddrType",
		isMultivalue: true,
	})
	n.Ipv6NodeAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NodeAddrType",
		isMultivalue: true,
	})
	n.Ipv6SIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6SIDType",
		isMultivalue: true,
	})
	n.LenthForPolicyNLRI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lenthForPolicyNLRI",
		isMultivalue: true,
	})
	n.MldpP2mpFecType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mldpP2mpFecType",
		isMultivalue: true,
	})
	n.MplsSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsSIDType",
		isMultivalue: true,
	})
	n.PeerAdjSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerAdjSidType",
		isMultivalue: true,
	})
	n.PeerNodeSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerNodeSidType",
		isMultivalue: true,
	})
	n.PeerSetSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerSetSidType",
		isMultivalue: true,
	})
	n.PolicyNameType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyNameType",
		isMultivalue: true,
	})
	n.PolicyPriorityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyPriorityType",
		isMultivalue: true,
	})
	n.PreferenceType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "preferenceType",
		isMultivalue: true,
	})
	n.PrefixSIDAttrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixSIDAttrType",
		isMultivalue: true,
	})
	n.ProtoclIdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protoclIdType",
		isMultivalue: true,
	})
	n.RemoteEndpointType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteEndpointType",
		isMultivalue: true,
	})
	n.RequestVpnLabelExchangeOverLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requestVpnLabelExchangeOverLsp",
		isMultivalue: true,
	})
	n.SRv6VPNSIDTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sRv6VPNSIDTLVType",
		isMultivalue: true,
	})
	n.SegmentListType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentListType",
		isMultivalue: true,
	})
	n.SrtePolicyAttrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtePolicyAttrType",
		isMultivalue: true,
	})
	n.SrtePolicySAFI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtePolicySAFI",
		isMultivalue: true,
	})
	n.SrtePolicyType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtePolicyType",
		isMultivalue: true,
	})
	n.TriggerVplsPwInitiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggerVplsPwInitiation",
		isMultivalue: true,
	})
	n.UdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpDestinationPort",
		isMultivalue: true,
	})
	n.UseUnicastDestMacForBierTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUnicastDestMacForBierTraffic",
		isMultivalue: true,
	})
	n.VPNSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vPNSIDType",
		isMultivalue: true,
	})
	n.VrfRouteImportExtendedCommunitySubType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vrfRouteImportExtendedCommunitySubType",
		isMultivalue: true,
	})
	n.WeightType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weightType",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsBgpIpv4PeerStartRate: Parameters used for controlling the rate of actions
type GlobalsBgpIpv4PeerStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBgpIpv4PeerStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBgpIpv4PeerStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBgpIpv4PeerStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBgpIpv4PeerStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsBgpIpv4PeerStopRate: Parameters used for controlling the rate of actions
type GlobalsBgpIpv4PeerStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBgpIpv4PeerStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBgpIpv4PeerStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBgpIpv4PeerStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBgpIpv4PeerStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsBgpIpv6Peer: BGP Port level Configuration
type GlobalsBgpIpv6Peer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BIERTunnelType: BIER Tunnel Type
	BIERTunnelType *Multivalue `json:"BIERTunnelType,omitempty"`
	// LLGRCapabilityCode: Long Live Graceful Restart Capability Code
	LLGRCapabilityCode *Multivalue `json:"LLGRCapabilityCode,omitempty"`
	// BgpConfMemType: BGP Confederation Member Type
	BgpConfMemType *Multivalue `json:"bgpConfMemType,omitempty"`
	// BgpRouterId: BGP Router-ID Type
	BgpRouterId *Multivalue `json:"bgpRouterId,omitempty"`
	// BindingType: Binding Sub-TLV Type
	BindingType *Multivalue `json:"bindingType,omitempty"`
	// ColorType: Color Sub-TLV Type
	ColorType *Multivalue `json:"colorType,omitempty"`
	// DisableReceivedUpdateValidation: Disable Received Update Validation (Enabled for High Performance)
	DisableReceivedUpdateValidation *Multivalue `json:"disableReceivedUpdateValidation,omitempty"`
	// ENLPType: Explicit NULL Label Policy Sub-TLV Type
	ENLPType *Multivalue `json:"eNLPType,omitempty"`
	// EVPNSIDType: EVPN SID Type
	EVPNSIDType *Multivalue `json:"eVPNSIDType,omitempty"`
	// EnLenthForPolicyNLRI: Include Length Field in SR TE Policy NLRI
	EnLenthForPolicyNLRI *Multivalue `json:"enLenthForPolicyNLRI,omitempty"`
	// EnableAdVplsPrefixLength: Enable AD VPLS Prefix Length in Bits
	EnableAdVplsPrefixLength *Multivalue `json:"enableAdVplsPrefixLength,omitempty"`
	// IBgpTester4BytesAsNumber: Tester 4 Byte AS# for iBGP
	IBgpTester4BytesAsNumber *Multivalue `json:"iBgpTester4BytesAsNumber,omitempty"`
	// IBgpTesterAsNumber: Tester AS# for iBGP
	IBgpTesterAsNumber *Multivalue `json:"iBgpTesterAsNumber,omitempty"`
	// InitiateEbgpActiveConnection: Initiate eBGP Active Connection
	InitiateEbgpActiveConnection *Multivalue `json:"initiateEbgpActiveConnection,omitempty"`
	// InitiateIbgpActiveConnection: Initiate iBGP Active Connection
	InitiateIbgpActiveConnection *Multivalue `json:"initiateIbgpActiveConnection,omitempty"`
	// Ipv4AddrIndexType: IPv4 Address + Index Type
	Ipv4AddrIndexType *Multivalue `json:"ipv4AddrIndexType,omitempty"`
	// Ipv4LocRemoteAddrType: IPv4 Local and Remote Address
	Ipv4LocRemoteAddrType *Multivalue `json:"ipv4LocRemoteAddrType,omitempty"`
	// Ipv4NodeAddrType: IPv4 Node Address Type
	Ipv4NodeAddrType *Multivalue `json:"ipv4NodeAddrType,omitempty"`
	// Ipv6AddrIndexType: IPv6 Address + Index Type
	Ipv6AddrIndexType *Multivalue `json:"ipv6AddrIndexType,omitempty"`
	// Ipv6LocRemoteAddrType: IPv6 Local and Remote Address
	Ipv6LocRemoteAddrType *Multivalue `json:"ipv6LocRemoteAddrType,omitempty"`
	// Ipv6NodeAddrType: IPv6 Node Address Type
	Ipv6NodeAddrType *Multivalue `json:"ipv6NodeAddrType,omitempty"`
	// Ipv6SIDType: IPv6 SID Type
	Ipv6SIDType *Multivalue `json:"ipv6SIDType,omitempty"`
	// LenthForPolicyNLRI: Length Unit
	LenthForPolicyNLRI *Multivalue `json:"lenthForPolicyNLRI,omitempty"`
	// MldpP2mpFecType: MLDP P2MP FEC Type (Hex)
	MldpP2mpFecType *Multivalue `json:"mldpP2mpFecType,omitempty"`
	// MplsSIDType: MPLS SID Type
	MplsSIDType *Multivalue `json:"mplsSIDType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeerAdjSidType: Peer-Adj-SID Type
	PeerAdjSidType *Multivalue `json:"peerAdjSidType,omitempty"`
	// PeerNodeSidType: Peer-Node-SID Type
	PeerNodeSidType *Multivalue `json:"peerNodeSidType,omitempty"`
	// PeerSetSidType: Peer-Set-SID Type
	PeerSetSidType *Multivalue `json:"peerSetSidType,omitempty"`
	// PolicyNameType: Policy Name Sub-TLV Type
	PolicyNameType *Multivalue `json:"policyNameType,omitempty"`
	// PolicyPriorityType: Policy Priority Sub-TLV Type
	PolicyPriorityType *Multivalue `json:"policyPriorityType,omitempty"`
	// PreferenceType: Preference Sub-TLV Type
	PreferenceType *Multivalue `json:"preferenceType,omitempty"`
	// PrefixSIDAttrType: Prefix SID Attr Type
	PrefixSIDAttrType *Multivalue `json:"prefixSIDAttrType,omitempty"`
	// ProtoclIdType: Protocol-ID Type
	ProtoclIdType *Multivalue `json:"protoclIdType,omitempty"`
	// RemoteEndpointType: Remote Endpoint Sub-TLV Type
	RemoteEndpointType *Multivalue `json:"remoteEndpointType,omitempty"`
	// RequestVpnLabelExchangeOverLsp: Request VPN Label Exchange over LSP
	RequestVpnLabelExchangeOverLsp *Multivalue `json:"requestVpnLabelExchangeOverLsp,omitempty"`
	// SRv6VPNSIDTLVType: SRv6-VPN SID TLV Type
	SRv6VPNSIDTLVType *Multivalue `json:"sRv6VPNSIDTLVType,omitempty"`
	// SegmentListType: Segment List Sub-TLV Type
	SegmentListType *Multivalue `json:"segmentListType,omitempty"`
	// SrtePolicyAttrType: Tunnel Encaps Attribute Type
	SrtePolicyAttrType *Multivalue `json:"srtePolicyAttrType,omitempty"`
	// SrtePolicySAFI: SR TE Policy SAFI
	SrtePolicySAFI *Multivalue `json:"srtePolicySAFI,omitempty"`
	// SrtePolicyType: Tunnel Type for SR Policy
	SrtePolicyType *Multivalue `json:"srtePolicyType,omitempty"`
	// Srv6DraftNum: SRv6 VPN Draft Version Number to be used both for L3VPN and EVPN

	Srv6DraftNum *string `json:"srv6DraftNum,omitempty"`
	// TriggerVplsPwInitiation: Trigger VPLS PW Initiation
	TriggerVplsPwInitiation *Multivalue `json:"triggerVplsPwInitiation,omitempty"`
	// UdpDestinationPort: UDP Destination Port for VXLAN
	UdpDestinationPort *Multivalue `json:"udpDestinationPort,omitempty"`
	// UseUnicastDestMacForBierTraffic: Use Unicast Dst MAC for Traffic
	UseUnicastDestMacForBierTraffic *Multivalue `json:"useUnicastDestMacForBierTraffic,omitempty"`
	// VPNSIDType: L3VPN SID Type
	VPNSIDType *Multivalue `json:"vPNSIDType,omitempty"`
	// VrfRouteImportExtendedCommunitySubType: VRF Route Import Extended Community Sub Type
	VrfRouteImportExtendedCommunitySubType *Multivalue `json:"vrfRouteImportExtendedCommunitySubType,omitempty"`
	// WeightType: Weight Sub-TLV Type
	WeightType *Multivalue `json:"weightType,omitempty"`

	StartRate *GlobalsBgpIpv6PeerStartRate `json:"startRate,omitempty"`

	StopRate  *GlobalsBgpIpv6PeerStopRate `json:"stopRate,omitempty"`
	TlvEditor []*GlobalsTlvEditor         `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBgpIpv6Peer) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBgpIpv6Peer) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBgpIpv6Peer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBgpIpv6Peer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BIERTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERTunnelType",
		isMultivalue: true,
	})
	n.LLGRCapabilityCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "LLGRCapabilityCode",
		isMultivalue: true,
	})
	n.BgpConfMemType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpConfMemType",
		isMultivalue: true,
	})
	n.BgpRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpRouterId",
		isMultivalue: true,
	})
	n.BindingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingType",
		isMultivalue: true,
	})
	n.ColorType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorType",
		isMultivalue: true,
	})
	n.DisableReceivedUpdateValidation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableReceivedUpdateValidation",
		isMultivalue: true,
	})
	n.ENLPType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eNLPType",
		isMultivalue: true,
	})
	n.EVPNSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eVPNSIDType",
		isMultivalue: true,
	})
	n.EnLenthForPolicyNLRI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enLenthForPolicyNLRI",
		isMultivalue: true,
	})
	n.EnableAdVplsPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdVplsPrefixLength",
		isMultivalue: true,
	})
	n.IBgpTester4BytesAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iBgpTester4BytesAsNumber",
		isMultivalue: true,
	})
	n.IBgpTesterAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iBgpTesterAsNumber",
		isMultivalue: true,
	})
	n.InitiateEbgpActiveConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initiateEbgpActiveConnection",
		isMultivalue: true,
	})
	n.InitiateIbgpActiveConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initiateIbgpActiveConnection",
		isMultivalue: true,
	})
	n.Ipv4AddrIndexType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4AddrIndexType",
		isMultivalue: true,
	})
	n.Ipv4LocRemoteAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4LocRemoteAddrType",
		isMultivalue: true,
	})
	n.Ipv4NodeAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NodeAddrType",
		isMultivalue: true,
	})
	n.Ipv6AddrIndexType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6AddrIndexType",
		isMultivalue: true,
	})
	n.Ipv6LocRemoteAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6LocRemoteAddrType",
		isMultivalue: true,
	})
	n.Ipv6NodeAddrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NodeAddrType",
		isMultivalue: true,
	})
	n.Ipv6SIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6SIDType",
		isMultivalue: true,
	})
	n.LenthForPolicyNLRI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lenthForPolicyNLRI",
		isMultivalue: true,
	})
	n.MldpP2mpFecType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mldpP2mpFecType",
		isMultivalue: true,
	})
	n.MplsSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsSIDType",
		isMultivalue: true,
	})
	n.PeerAdjSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerAdjSidType",
		isMultivalue: true,
	})
	n.PeerNodeSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerNodeSidType",
		isMultivalue: true,
	})
	n.PeerSetSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerSetSidType",
		isMultivalue: true,
	})
	n.PolicyNameType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyNameType",
		isMultivalue: true,
	})
	n.PolicyPriorityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyPriorityType",
		isMultivalue: true,
	})
	n.PreferenceType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "preferenceType",
		isMultivalue: true,
	})
	n.PrefixSIDAttrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixSIDAttrType",
		isMultivalue: true,
	})
	n.ProtoclIdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protoclIdType",
		isMultivalue: true,
	})
	n.RemoteEndpointType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteEndpointType",
		isMultivalue: true,
	})
	n.RequestVpnLabelExchangeOverLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requestVpnLabelExchangeOverLsp",
		isMultivalue: true,
	})
	n.SRv6VPNSIDTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sRv6VPNSIDTLVType",
		isMultivalue: true,
	})
	n.SegmentListType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentListType",
		isMultivalue: true,
	})
	n.SrtePolicyAttrType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtePolicyAttrType",
		isMultivalue: true,
	})
	n.SrtePolicySAFI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtePolicySAFI",
		isMultivalue: true,
	})
	n.SrtePolicyType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtePolicyType",
		isMultivalue: true,
	})
	n.TriggerVplsPwInitiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggerVplsPwInitiation",
		isMultivalue: true,
	})
	n.UdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpDestinationPort",
		isMultivalue: true,
	})
	n.UseUnicastDestMacForBierTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUnicastDestMacForBierTraffic",
		isMultivalue: true,
	})
	n.VPNSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vPNSIDType",
		isMultivalue: true,
	})
	n.VrfRouteImportExtendedCommunitySubType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vrfRouteImportExtendedCommunitySubType",
		isMultivalue: true,
	})
	n.WeightType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weightType",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsBgpIpv6PeerStartRate: Parameters used for controlling the rate of actions
type GlobalsBgpIpv6PeerStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBgpIpv6PeerStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBgpIpv6PeerStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBgpIpv6PeerStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBgpIpv6PeerStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsBgpIpv6PeerStopRate: Parameters used for controlling the rate of actions
type GlobalsBgpIpv6PeerStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBgpIpv6PeerStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBgpIpv6PeerStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBgpIpv6PeerStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBgpIpv6PeerStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsBondedGre: TBD
type GlobalsBondedGre struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// HaapRouter: If enabled then MAC address will be same for all control messages from all tunnels.
	HaapRouter *Multivalue `json:"haapRouter,omitempty"`
	// Key: If enabled then key will be included in the GRE header for control messages.
	Key *Multivalue `json:"key,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RouterMac: MAC address of the emulated HAAP Router
	RouterMac *Multivalue `json:"routerMac,omitempty"`
	// WaitForLTE: If enabled then DSL will wait for LTE to start, otherwise DSL can start anytime.
	WaitForLTE *Multivalue         `json:"waitForLTE,omitempty"`
	TlvEditor  []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsBondedGre) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsBondedGre) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsBondedGre) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsBondedGre) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.HaapRouter.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "haapRouter",
		isMultivalue: true,
	})
	n.Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "key",
		isMultivalue: true,
	})
	n.RouterMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerMac",
		isMultivalue: true,
	})
	n.WaitForLTE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "waitForLTE",
		isMultivalue: true,
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsCfmBridge: CFM Port Specific Data
type GlobalsCfmBridge struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableOptionalTlvValidation: Enable Optional TLV Validation
	EnableOptionalTlvValidation *Multivalue `json:"enableOptionalTlvValidation,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ReceiveCcm: Receive CCM
	ReceiveCcm *Multivalue `json:"receiveCcm,omitempty"`
	// SendCcm: Send CCM
	SendCcm *Multivalue `json:"sendCcm,omitempty"`

	StartRate *GlobalsCfmBridgeStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsCfmBridgeStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsCfmBridge) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsCfmBridge) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsCfmBridge) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsCfmBridge) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableOptionalTlvValidation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOptionalTlvValidation",
		isMultivalue: true,
	})
	n.ReceiveCcm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "receiveCcm",
		isMultivalue: true,
	})
	n.SendCcm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendCcm",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsCfmBridgeStartRate: Parameters used for controlling the rate of actions
type GlobalsCfmBridgeStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsCfmBridgeStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsCfmBridgeStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsCfmBridgeStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsCfmBridgeStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsCfmBridgeStopRate: Parameters used for controlling the rate of actions
type GlobalsCfmBridgeStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsCfmBridgeStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsCfmBridgeStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsCfmBridgeStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsCfmBridgeStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsContainer: Tlv container used to group multiple object containers
type GlobalsContainer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Flag indicating whether this is repeatable or not

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Flag indicating whether this is required or not

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the tlv

	Name   *string          `json:"name,omitempty"`
	Object []*GlobalsObject `json:"object"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsContainer) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsContainer) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsContainer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsContainer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Object {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "object",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDefaults: Default Tlv template container
type GlobalsDefaults struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath    *XPath             `json:"xpath,omitempty"`
	Template []*GlobalsTemplate `json:"template"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDefaults) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDefaults) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDefaults) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDefaults) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Template {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "template",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDhcpv4client: IPv4 global and per-port settings
type GlobalsDhcpv4client struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Dhcp4ArpGw: If enabled, DHCP clients ARP to find their Gateway MAC Addresses.
	Dhcp4ArpGw *Multivalue `json:"dhcp4ArpGw,omitempty"`
	// Dhcp4ClientPort: UDP port that the client listens on for DHCP and BOOTP responses.
	Dhcp4ClientPort *Multivalue `json:"dhcp4ClientPort,omitempty"`
	// Dhcp4MaxDiscoverTimeout: The max value, in seconds, that the discover timeout can reach though Discover Timeout Factor.
	Dhcp4MaxDiscoverTimeout *Multivalue `json:"dhcp4MaxDiscoverTimeout,omitempty"`
	// Dhcp4NumRetry: Number of times that the client will retransmit a request for which it has not received a response. When the maximum number of retransmitions is reached, the port will increment the failure counter (DHCPSetupFail).
	Dhcp4NumRetry *Multivalue `json:"dhcp4NumRetry,omitempty"`
	// Dhcp4ResponseTimeout: The initial time, in seconds, that the subnet waits to receive a response from a DHCP server.
	Dhcp4ResponseTimeout *Multivalue `json:"dhcp4ResponseTimeout,omitempty"`
	// Dhcp4ResponseTimeoutFactor: The factor by which the timeout will be multiplied each time the response timeout has been reached.
	Dhcp4ResponseTimeoutFactor *Multivalue `json:"dhcp4ResponseTimeoutFactor,omitempty"`
	// Dhcp4ServerPort: UDP port that the client addresses server requests to.
	Dhcp4ServerPort *Multivalue `json:"dhcp4ServerPort,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RenewOnLinkUp: Indicate to renew the active DHCP sessions after link status goes down and up.
	RenewOnLinkUp *Multivalue `json:"renewOnLinkUp,omitempty"`
	// SkipReleaseOnStop: If enabled, the client does not send a DHCPRELEASE packet when the Stop command is given.
	SkipReleaseOnStop *Multivalue `json:"skipReleaseOnStop,omitempty"`

	SessionLifetime *GlobalsSessionLifetime `json:"sessionLifetime,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate  *GlobalsStopRate    `json:"stopRate,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDhcpv4client) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDhcpv4client) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDhcpv4client) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDhcpv4client) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Dhcp4ArpGw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4ArpGw",
		isMultivalue: true,
	})
	n.Dhcp4ClientPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4ClientPort",
		isMultivalue: true,
	})
	n.Dhcp4MaxDiscoverTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4MaxDiscoverTimeout",
		isMultivalue: true,
	})
	n.Dhcp4NumRetry.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4NumRetry",
		isMultivalue: true,
	})
	n.Dhcp4ResponseTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4ResponseTimeout",
		isMultivalue: true,
	})
	n.Dhcp4ResponseTimeoutFactor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4ResponseTimeoutFactor",
		isMultivalue: true,
	})
	n.Dhcp4ServerPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4ServerPort",
		isMultivalue: true,
	})
	n.RenewOnLinkUp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "renewOnLinkUp",
		isMultivalue: true,
	})
	n.SkipReleaseOnStop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "skipReleaseOnStop",
		isMultivalue: true,
	})
	n.SessionLifetime.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sessionLifetime",
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDhcpv4relayAgent: IPv4 global and per-port settings
type GlobalsDhcpv4relayAgent struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name      *string             `json:"name,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDhcpv4relayAgent) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDhcpv4relayAgent) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDhcpv4relayAgent) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDhcpv4relayAgent) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDhcpv4server: Dhcp4Server global and per-port settings
type GlobalsDhcpv4server struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ForceRenewFactor: Force Renew timeout factor
	ForceRenewFactor *Multivalue `json:"forceRenewFactor,omitempty"`
	// ForceRenewMaxRc: Force Renew Attempts
	ForceRenewMaxRc *Multivalue `json:"forceRenewMaxRc,omitempty"`
	// InitForceRenewTimeout: Force Renew timeout in seconds
	InitForceRenewTimeout *Multivalue `json:"initForceRenewTimeout,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OfferTimeout: Offer timeout in seconds
	OfferTimeout *Multivalue `json:"offerTimeout,omitempty"`
	// PingCheck: When enabled, the DHCP Server will not assign IP addresses that areresponding to ICMP echo requests (PING) within a certain time period.
	PingCheck *Multivalue `json:"pingCheck,omitempty"`
	// PingTimeout: The number of seconds the DHCP Server will wait for anICMP Echo response before assigning the address.
	PingTimeout *Multivalue `json:"pingTimeout,omitempty"`

	ReconfigureRate *GlobalsReconfigureRate `json:"reconfigureRate,omitempty"`
	TlvEditor       []*GlobalsTlvEditor     `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDhcpv4server) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDhcpv4server) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDhcpv4server) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDhcpv4server) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ForceRenewFactor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forceRenewFactor",
		isMultivalue: true,
	})
	n.ForceRenewMaxRc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forceRenewMaxRc",
		isMultivalue: true,
	})
	n.InitForceRenewTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initForceRenewTimeout",
		isMultivalue: true,
	})
	n.OfferTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offerTimeout",
		isMultivalue: true,
	})
	n.PingCheck.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pingCheck",
		isMultivalue: true,
	})
	n.PingTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pingTimeout",
		isMultivalue: true,
	})
	n.ReconfigureRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "reconfigureRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDhcpv6client: IPv6 global and per-port settings
type GlobalsDhcpv6client struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Dhcp6EchoIAInfo: If set, the DHCPv6 client will request the exact address as advertised by server.
	Dhcp6EchoIAInfo *Multivalue `json:"dhcp6EchoIAInfo,omitempty"`
	// Dhcp6InfoReqMaxRc: RFC 3315 Info Request Attempts
	Dhcp6InfoReqMaxRc *Multivalue `json:"dhcp6InfoReqMaxRc,omitempty"`
	// Dhcp6InfoReqMaxRt: RFC 3315 Max Information-request timeout value in seconds
	Dhcp6InfoReqMaxRt *Multivalue `json:"dhcp6InfoReqMaxRt,omitempty"`
	// Dhcp6InfoReqTimeout: RFC 3315 Initial Information-request timeout value in seconds
	Dhcp6InfoReqTimeout *Multivalue `json:"dhcp6InfoReqTimeout,omitempty"`
	// Dhcp6NsGw: If enabled, DHCP clients NS to find their Gateway MAC Addresses.
	Dhcp6NsGw *Multivalue `json:"dhcp6NsGw,omitempty"`
	// Dhcp6RebMaxRt: RFC 3315 Max Rebind timeout value in seconds
	Dhcp6RebMaxRt *Multivalue `json:"dhcp6RebMaxRt,omitempty"`
	// Dhcp6RebTimeout: RFC 3315 Initial Rebind timeout seconds
	Dhcp6RebTimeout *Multivalue `json:"dhcp6RebTimeout,omitempty"`
	// Dhcp6RelMaxRc: RFC 3315 Release attempts
	Dhcp6RelMaxRc *Multivalue `json:"dhcp6RelMaxRc,omitempty"`
	// Dhcp6RelTimeout: RFC 3315 Initial Release timeout in seconds
	Dhcp6RelTimeout *Multivalue `json:"dhcp6RelTimeout,omitempty"`
	// Dhcp6RenMaxRt: RFC 3315 Max Renew timeout value in seconds
	Dhcp6RenMaxRt *Multivalue `json:"dhcp6RenMaxRt,omitempty"`
	// Dhcp6RenTimeout: RFC 3315 Initial Renew timeout in seconds
	Dhcp6RenTimeout *Multivalue `json:"dhcp6RenTimeout,omitempty"`
	// Dhcp6ReqMaxRc: RFC 3315 Max Request retry attempts
	Dhcp6ReqMaxRc *Multivalue `json:"dhcp6ReqMaxRc,omitempty"`
	// Dhcp6ReqMaxRt: RFC 3315 Max Request timeout value in seconds
	Dhcp6ReqMaxRt *Multivalue `json:"dhcp6ReqMaxRt,omitempty"`
	// Dhcp6ReqTimeout: RFC 3315 Initial Request timeout in seconds
	Dhcp6ReqTimeout *Multivalue `json:"dhcp6ReqTimeout,omitempty"`
	// Dhcp6SolMaxRc: RFC 3315 Max Solicit retry attempts
	Dhcp6SolMaxRc *Multivalue `json:"dhcp6SolMaxRc,omitempty"`
	// Dhcp6SolMaxRt: RFC 3315 Max Solicit timeout value in seconds
	Dhcp6SolMaxRt *Multivalue `json:"dhcp6SolMaxRt,omitempty"`
	// Dhcp6SolTimeout: RFC 3315 Initial Solicit timeout in seconds
	Dhcp6SolTimeout *Multivalue `json:"dhcp6SolTimeout,omitempty"`
	// ImmediateResponse: Enables DHCP client to send Request immediately after receiving Advertise irrespective of Initial Solicit Timeout.
	ImmediateResponse *Multivalue `json:"immediateResponse,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RenewOnLinkUp: Indicate to renew the active DHCP sessions after link status goes down and up.
	RenewOnLinkUp *Multivalue `json:"renewOnLinkUp,omitempty"`
	// SkipReleaseOnStop: If enabled, the client does not send a DHCPRELEASE packet when the Stop command is given.
	SkipReleaseOnStop *Multivalue `json:"skipReleaseOnStop,omitempty"`

	SessionLifetime *GlobalsSessionLifetime `json:"sessionLifetime,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate  *GlobalsStopRate    `json:"stopRate,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDhcpv6client) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDhcpv6client) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDhcpv6client) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDhcpv6client) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Dhcp6EchoIAInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6EchoIAInfo",
		isMultivalue: true,
	})
	n.Dhcp6InfoReqMaxRc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6InfoReqMaxRc",
		isMultivalue: true,
	})
	n.Dhcp6InfoReqMaxRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6InfoReqMaxRt",
		isMultivalue: true,
	})
	n.Dhcp6InfoReqTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6InfoReqTimeout",
		isMultivalue: true,
	})
	n.Dhcp6NsGw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6NsGw",
		isMultivalue: true,
	})
	n.Dhcp6RebMaxRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6RebMaxRt",
		isMultivalue: true,
	})
	n.Dhcp6RebTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6RebTimeout",
		isMultivalue: true,
	})
	n.Dhcp6RelMaxRc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6RelMaxRc",
		isMultivalue: true,
	})
	n.Dhcp6RelTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6RelTimeout",
		isMultivalue: true,
	})
	n.Dhcp6RenMaxRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6RenMaxRt",
		isMultivalue: true,
	})
	n.Dhcp6RenTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6RenTimeout",
		isMultivalue: true,
	})
	n.Dhcp6ReqMaxRc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6ReqMaxRc",
		isMultivalue: true,
	})
	n.Dhcp6ReqMaxRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6ReqMaxRt",
		isMultivalue: true,
	})
	n.Dhcp6ReqTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6ReqTimeout",
		isMultivalue: true,
	})
	n.Dhcp6SolMaxRc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6SolMaxRc",
		isMultivalue: true,
	})
	n.Dhcp6SolMaxRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6SolMaxRt",
		isMultivalue: true,
	})
	n.Dhcp6SolTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6SolTimeout",
		isMultivalue: true,
	})
	n.ImmediateResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "immediateResponse",
		isMultivalue: true,
	})
	n.RenewOnLinkUp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "renewOnLinkUp",
		isMultivalue: true,
	})
	n.SkipReleaseOnStop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "skipReleaseOnStop",
		isMultivalue: true,
	})
	n.SessionLifetime.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sessionLifetime",
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDhcpv6relayAgent: IPv6 global and per-port settings
type GlobalsDhcpv6relayAgent struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name      *string             `json:"name,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDhcpv6relayAgent) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDhcpv6relayAgent) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDhcpv6relayAgent) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDhcpv6relayAgent) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDhcpv6server: Dhcp6Server global and per-port settings
type GlobalsDhcpv6server struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvertiseTimeout: Advertise timeout in seconds
	AdvertiseTimeout *Multivalue `json:"advertiseTimeout,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PingCheck: When enabled, the DHCP Server will not assign IP addresses that areresponding to ICMP echo requests (PING) within a certain time period.
	PingCheck *Multivalue `json:"pingCheck,omitempty"`
	// PingTimeout: The number of seconds the DHCP Server will wait for anICMP Echo response before assigning the address.
	PingTimeout *Multivalue `json:"pingTimeout,omitempty"`
	// ReconfigureMaxRc: RFC 3315 Reconfigure retry attempts
	ReconfigureMaxRc *Multivalue `json:"reconfigureMaxRc,omitempty"`
	// ReconfigureTimeout: RFC 3315 Reconfigure timeout in seconds
	ReconfigureTimeout *Multivalue `json:"reconfigureTimeout,omitempty"`

	ReconfigureRate *GlobalsReconfigureRate `json:"reconfigureRate,omitempty"`
	TlvEditor       []*GlobalsTlvEditor     `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDhcpv6server) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDhcpv6server) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDhcpv6server) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDhcpv6server) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdvertiseTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseTimeout",
		isMultivalue: true,
	})
	n.PingCheck.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pingCheck",
		isMultivalue: true,
	})
	n.PingTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pingTimeout",
		isMultivalue: true,
	})
	n.ReconfigureMaxRc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconfigureMaxRc",
		isMultivalue: true,
	})
	n.ReconfigureTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconfigureTimeout",
		isMultivalue: true,
	})
	n.ReconfigureRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "reconfigureRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsDotOneX: TBD
type GlobalsDotOneX struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AltName: Other Options - Alternative Subject Name
	AltName *Multivalue `json:"altName,omitempty"`
	// AuthOnNoResponse: If the DUT is not responding to EAPoL Start after configured number of retries, declare the session a success
	AuthOnNoResponse *Multivalue `json:"authOnNoResponse,omitempty"`
	// AuthWaitPeriod: The maximum time interval, measured in seconds, that a Supplicant will wait for an Authenticator response.Maximum value is 3600
	AuthWaitPeriod *Multivalue `json:"authWaitPeriod,omitempty"`
	// City: Identification Info - City
	City *Multivalue `json:"city,omitempty"`
	// Company: Identification Info - Company
	Company *Multivalue `json:"company,omitempty"`
	// Country: Identification Info - Country
	Country *Multivalue `json:"country,omitempty"`
	// Department: Identification Info - Department
	Department *Multivalue `json:"department,omitempty"`
	// DisableLogoff: Do not send Logoff message when closing a session.
	DisableLogoff *Multivalue `json:"disableLogoff,omitempty"`
	// DutTestMode: Specify what is the dut port mode
	DutTestMode *Multivalue `json:"dutTestMode,omitempty"`
	// FragmentSize: The maximum size of a fragment that can be sent on the wire for TLS fragments that comprise the phase 1 conversation (tunnel establishment). Max value is 1400
	FragmentSize *Multivalue `json:"fragmentSize,omitempty"`
	// GetCACertOnly: Use this option to get CA Certificate Only. Eg: For PEAPv0/v1 case there is no need to get User Certificate.
	GetCACertOnly *Multivalue `json:"getCACertOnly,omitempty"`
	// KeySize: Key Options - Key Size
	KeySize *Multivalue `json:"keySize,omitempty"`
	// KeyUsage: Select key usage extensions
	KeyUsage *Multivalue `json:"keyUsage,omitempty"`
	// MacAuthPrefix: When using machine authentication, a prefix is needed to differentiate between users and machines.
	MacAuthPrefix *Multivalue `json:"macAuthPrefix,omitempty"`
	// MaxOutstandingRequests: The maximum number of sessions that can be negotiated at one moment. Max value is 1024
	MaxOutstandingRequests *Multivalue `json:"maxOutstandingRequests,omitempty"`
	// MaxSetupRate: The number of interfaces to setup per second. Max rate is 1024
	MaxSetupRate *Multivalue `json:"maxSetupRate,omitempty"`
	// MaxStart: The number of times to send EAPOL Start frames for which no response is received before declaring that the sessions have timed out. Max value is 100
	MaxStart *Multivalue `json:"maxStart,omitempty"`
	// MaxTeardownRate: The number of interfaces to tear down per second. Max value is 1024
	MaxTeardownRate *Multivalue `json:"maxTeardownRate,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OnlyMulticast: Specify if destination MAC address can be multicast.
	OnlyMulticast *Multivalue `json:"onlyMulticast,omitempty"`
	// ServerURL: Certificate Server URL
	ServerURL *Multivalue `json:"serverURL,omitempty"`
	// StartPeriod: The time interval between successive EAPOL Start messages sent by a Supplicant.Maxium value is 3600
	StartPeriod *Multivalue `json:"startPeriod,omitempty"`
	// State: Identification Info - State
	State *Multivalue `json:"state,omitempty"`
	// SuccessiveStart: The number of EAPOL Start messages sent when the supplicant starts the process of authentication. Max value is 100
	SuccessiveStart *Multivalue `json:"successiveStart,omitempty"`
	// UseVlanIdentify: Specify if VLAN is to be used to identify the supplicants
	UseVlanIdentify *Multivalue `json:"useVlanIdentify,omitempty"`
	// WaitBeforeRun: The number of secs to wait before running the protocol.Maximum wait is 500
	WaitBeforeRun *Multivalue `json:"waitBeforeRun,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsDotOneX) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsDotOneX) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsDotOneX) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsDotOneX) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AltName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "altName",
		isMultivalue: true,
	})
	n.AuthOnNoResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authOnNoResponse",
		isMultivalue: true,
	})
	n.AuthWaitPeriod.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authWaitPeriod",
		isMultivalue: true,
	})
	n.City.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "city",
		isMultivalue: true,
	})
	n.Company.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "company",
		isMultivalue: true,
	})
	n.Country.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "country",
		isMultivalue: true,
	})
	n.Department.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "department",
		isMultivalue: true,
	})
	n.DisableLogoff.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableLogoff",
		isMultivalue: true,
	})
	n.DutTestMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutTestMode",
		isMultivalue: true,
	})
	n.FragmentSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fragmentSize",
		isMultivalue: true,
	})
	n.GetCACertOnly.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "getCACertOnly",
		isMultivalue: true,
	})
	n.KeySize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keySize",
		isMultivalue: true,
	})
	n.KeyUsage.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keyUsage",
		isMultivalue: true,
	})
	n.MacAuthPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "macAuthPrefix",
		isMultivalue: true,
	})
	n.MaxOutstandingRequests.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstandingRequests",
		isMultivalue: true,
	})
	n.MaxSetupRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSetupRate",
		isMultivalue: true,
	})
	n.MaxStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxStart",
		isMultivalue: true,
	})
	n.MaxTeardownRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTeardownRate",
		isMultivalue: true,
	})
	n.OnlyMulticast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "onlyMulticast",
		isMultivalue: true,
	})
	n.ServerURL.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverURL",
		isMultivalue: true,
	})
	n.StartPeriod.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startPeriod",
		isMultivalue: true,
	})
	n.State.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "state",
		isMultivalue: true,
	})
	n.SuccessiveStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "successiveStart",
		isMultivalue: true,
	})
	n.UseVlanIdentify.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useVlanIdentify",
		isMultivalue: true,
	})
	n.WaitBeforeRun.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "waitBeforeRun",
		isMultivalue: true,
	})
}

// GlobalsECpriRe: eCRPI Port Specific Data
type GlobalsECpriRe struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ECpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	ECpriProtocolRevision *Multivalue `json:"eCpriProtocolRevision,omitempty"`
	// ECpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	ECpriUdpDestinationPort *Multivalue `json:"eCpriUdpDestinationPort,omitempty"`
	// EcpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	EcpriProtocolRevision *Multivalue `json:"ecpriProtocolRevision,omitempty"`
	// EcpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	EcpriUdpDestinationPort *Multivalue `json:"ecpriUdpDestinationPort,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsECpriRe) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsECpriRe) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsECpriRe) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsECpriRe) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ECpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriProtocolRevision",
		isMultivalue: true,
	})
	n.ECpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriUdpDestinationPort",
		isMultivalue: true,
	})
	n.EcpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriProtocolRevision",
		isMultivalue: true,
	})
	n.EcpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriUdpDestinationPort",
		isMultivalue: true,
	})
}

// GlobalsECpriRec: eCRPI Port Specific Data
type GlobalsECpriRec struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ECpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	ECpriProtocolRevision *Multivalue `json:"eCpriProtocolRevision,omitempty"`
	// ECpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	ECpriUdpDestinationPort *Multivalue `json:"eCpriUdpDestinationPort,omitempty"`
	// EcpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	EcpriProtocolRevision *Multivalue `json:"ecpriProtocolRevision,omitempty"`
	// EcpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	EcpriUdpDestinationPort *Multivalue `json:"ecpriUdpDestinationPort,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsECpriRec) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsECpriRec) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsECpriRec) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsECpriRec) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ECpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriProtocolRevision",
		isMultivalue: true,
	})
	n.ECpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriUdpDestinationPort",
		isMultivalue: true,
	})
	n.EcpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriProtocolRevision",
		isMultivalue: true,
	})
	n.EcpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriUdpDestinationPort",
		isMultivalue: true,
	})
}

// GlobalsEcpriRec: eCRPI Port Specific Data
type GlobalsEcpriRec struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ECpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	ECpriProtocolRevision *Multivalue `json:"eCpriProtocolRevision,omitempty"`
	// ECpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	ECpriUdpDestinationPort *Multivalue `json:"eCpriUdpDestinationPort,omitempty"`
	// EcpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	EcpriProtocolRevision *Multivalue `json:"ecpriProtocolRevision,omitempty"`
	// EcpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	EcpriUdpDestinationPort *Multivalue `json:"ecpriUdpDestinationPort,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsEcpriRec) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsEcpriRec) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsEcpriRec) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsEcpriRec) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ECpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriProtocolRevision",
		isMultivalue: true,
	})
	n.ECpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriUdpDestinationPort",
		isMultivalue: true,
	})
	n.EcpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriProtocolRevision",
		isMultivalue: true,
	})
	n.EcpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriUdpDestinationPort",
		isMultivalue: true,
	})
}

// GlobalsEre: eCRPI Port Specific Data
type GlobalsEre struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ECpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	ECpriProtocolRevision *Multivalue `json:"eCpriProtocolRevision,omitempty"`
	// ECpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	ECpriUdpDestinationPort *Multivalue `json:"eCpriUdpDestinationPort,omitempty"`
	// EcpriProtocolRevision: eCPRI protocol revision to be used by all eCPRI messages.
	EcpriProtocolRevision *Multivalue `json:"ecpriProtocolRevision,omitempty"`
	// EcpriUdpDestinationPort: UDP Destination port to be used by all eCPRI messages in this port.
	EcpriUdpDestinationPort *Multivalue `json:"ecpriUdpDestinationPort,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsEre) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsEre) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsEre) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsEre) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ECpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriProtocolRevision",
		isMultivalue: true,
	})
	n.ECpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eCpriUdpDestinationPort",
		isMultivalue: true,
	})
	n.EcpriProtocolRevision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriProtocolRevision",
		isMultivalue: true,
	})
	n.EcpriUdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ecpriUdpDestinationPort",
		isMultivalue: true,
	})
}

// GlobalsEsmc: ESMC global and per-port settings
type GlobalsEsmc struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRateAndFlowControl *GlobalsStartRateAndFlowControl `json:"startRateAndFlowControl,omitempty"`

	StopRateAndFlowControl *GlobalsStopRateAndFlowControl `json:"stopRateAndFlowControl,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsEsmc) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsEsmc) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsEsmc) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsEsmc) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRateAndFlowControl.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRateAndFlowControl",
	})
	n.StopRateAndFlowControl.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRateAndFlowControl",
	})
}

// GlobalsEthernet: Ethernet global and per-port settings
type GlobalsEthernet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsEthernetStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsEthernetStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsEthernet) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsEthernet) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsEthernet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsEthernet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsEthernetStartRate: Parameters used for controlling the rate of actions
type GlobalsEthernetStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsEthernetStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsEthernetStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsEthernetStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsEthernetStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsEthernetStopRate: Parameters used for controlling the rate of actions
type GlobalsEthernetStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsEthernetStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsEthernetStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsEthernetStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsEthernetStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsField: Tlv field
type GlobalsField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// Encoding: Encoding of the tlv value, any change will result in the value being reset

	Encoding *string `json:"encoding,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Flag indicating whether this is repeatable or not

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Flag indicating whether this is required or not

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`
	// Size: Size of the tlv value in bits/bytes based on sizeType, any change will result in the value being reset

	Size *float32 `json:"size,omitempty"`
	// SizeType: Size type of the tlv value, any change will result in the value being reset

	SizeType *string `json:"sizeType,omitempty"`
	// Value: Value represented as a multivalue object
	Value       *Multivalue           `json:"value,omitempty"`
	Restriction []*GlobalsRestriction `json:"restriction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsField) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsField) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
	for i, o := range n.Restriction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "restriction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsFlowAggrMatchTemplate: Global data for OFAggrMatch template data extension.
type GlobalsFlowAggrMatchTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath         *XPath                  `json:"xpath,omitempty"`
	MatchTemplate []*GlobalsMatchTemplate `json:"matchTemplate"`

	Predefined *GlobalsPredefined `json:"predefined,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsFlowAggrMatchTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsFlowAggrMatchTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsFlowAggrMatchTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsFlowAggrMatchTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.MatchTemplate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchTemplate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Predefined.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "predefined",
	})
}

// GlobalsFlowSetTemplate: Global data for OpenFlow flow range template data extension.
type GlobalsFlowSetTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath        *XPath                 `json:"xpath,omitempty"`
	FlowTemplate []*GlobalsFlowTemplate `json:"flowTemplate"`

	Predefined *GlobalsPredefined `json:"predefined,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsFlowSetTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsFlowSetTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsFlowSetTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsFlowSetTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.FlowTemplate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "flowTemplate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Predefined.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "predefined",
	})
}

// GlobalsFlowStatMatchTemplate: Global data for OFMatch template data extension.
type GlobalsFlowStatMatchTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath         *XPath                  `json:"xpath,omitempty"`
	MatchTemplate []*GlobalsMatchTemplate `json:"matchTemplate"`

	Predefined *GlobalsPredefined `json:"predefined,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsFlowStatMatchTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsFlowStatMatchTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsFlowStatMatchTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsFlowStatMatchTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.MatchTemplate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchTemplate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Predefined.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "predefined",
	})
}

// GlobalsFlowTemplate: Flow Range Template.
type GlobalsFlowTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SavedInVersion: The cpf version of the session

	SavedInVersion *string               `json:"savedInVersion,omitempty"`
	MatchAction    []*GlobalsMatchAction `json:"matchAction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsFlowTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsFlowTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsFlowTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsFlowTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.MatchAction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchAction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsGeneve: Geneve global and per-port settings
type GlobalsGeneve struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate  *GlobalsStopRate    `json:"stopRate,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsGeneve) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsGeneve) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsGeneve) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsGeneve) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsGreoipv4: GRE global and per-port settings
type GlobalsGreoipv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsGreoipv4) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsGreoipv4) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsGreoipv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsGreoipv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsGreoipv6: GRE global and per-port settings
type GlobalsGreoipv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsGreoipv6) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsGreoipv6) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsGreoipv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsGreoipv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIgmpHost: IGMP global and per-port settings
type GlobalsIgmpHost struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// IPDSCP: Specifies the ToS/DSCP value in the IPv4 Header
	IPDSCP *Multivalue `json:"iPDSCP,omitempty"`
	// InterStbStartDelay: Time in milliseconds between Join messages from clients within the same range.
	InterStbStartDelay *Multivalue `json:"interStbStartDelay,omitempty"`
	// IntervalInMs: Time interval used to calculate the rate for triggering an action (rate = count/interval)
	IntervalInMs *Multivalue `json:"intervalInMs,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RatePerInterval: No. of Reports triggered per time interval
	RatePerInterval *Multivalue `json:"ratePerInterval,omitempty"`
	// UnicastMode: Unicast Mode
	UnicastMode *Multivalue `json:"unicastMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIgmpHost) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIgmpHost) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIgmpHost) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIgmpHost) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.IPDSCP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iPDSCP",
		isMultivalue: true,
	})
	n.InterStbStartDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interStbStartDelay",
		isMultivalue: true,
	})
	n.IntervalInMs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "intervalInMs",
		isMultivalue: true,
	})
	n.RatePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ratePerInterval",
		isMultivalue: true,
	})
	n.UnicastMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unicastMode",
		isMultivalue: true,
	})
}

// GlobalsIgmpQuerier: IGMP Querier Port Specific Data
type GlobalsIgmpQuerier struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enable/Disable Rate Control
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfQueriesPerUnitTime: No. of Queries (per Time Period)
	NoOfQueriesPerUnitTime *Multivalue `json:"noOfQueriesPerUnitTime,omitempty"`
	// TimePeriod: Time Period
	TimePeriod *Multivalue `json:"timePeriod,omitempty"`
	// UnicastMode: Unicast Mode
	UnicastMode *Multivalue `json:"unicastMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIgmpQuerier) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIgmpQuerier) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIgmpQuerier) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIgmpQuerier) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.NoOfQueriesPerUnitTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfQueriesPerUnitTime",
		isMultivalue: true,
	})
	n.TimePeriod.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timePeriod",
		isMultivalue: true,
	})
	n.UnicastMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unicastMode",
		isMultivalue: true,
	})
}

// GlobalsInstruction: Instruction prototype.
type GlobalsInstruction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name      *string                    `json:"name,omitempty"`
	ActionSet []*GlobalsActionSet        `json:"actionSet"`
	Field     []*GlobalsInstructionField `json:"field"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsInstruction) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsInstruction) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsInstruction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsInstruction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.ActionSet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "actionSet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsInstructionField: Field prototype.
type GlobalsInstructionField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// Encoding: Encoding of the field value.

	Encoding *string `json:"encoding,omitempty"`
	// Enum: Internal enumeration type used to restrict possible field values.

	Enum *string `json:"enum,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name *string `json:"name,omitempty"`
	// SingleValue: If true the field can only be configured with a single value pattern.

	SingleValue *bool `json:"singleValue,omitempty"`
	// Size: The size of the field in bytes. Field size must be greater or equal to 0. For automatic detection set size to 0.

	Size *float32 `json:"size,omitempty"`
	// SizeType: The size types/data unit of the field.

	SizeType *string `json:"sizeType,omitempty"`
	// Value: Field value.
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsInstructionField) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsInstructionField) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsInstructionField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsInstructionField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// GlobalsInstructions: Instruction set prototype.
type GlobalsInstructions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name        *string               `json:"name,omitempty"`
	Instruction []*GlobalsInstruction `json:"instruction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsInstructions) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsInstructions) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsInstructions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsInstructions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Instruction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "instruction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsIpv4: IPv4 global and per-port settings
type GlobalsIpv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// GratarpTransmitCount: Number of times GRATARP packet is sent per source IPv4 address.
	GratarpTransmitCount *Multivalue `json:"gratarpTransmitCount,omitempty"`
	// GratarpTransmitInterval: Time interval to calculate next GRATARP packet transmission for each source IPv4 address.
	GratarpTransmitInterval *Multivalue `json:"gratarpTransmitInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PermanentMacForGateway: When enabled, adds permanent entries for Gateways with manual MAC.
	PermanentMacForGateway *Multivalue `json:"permanentMacForGateway,omitempty"`
	// RarpTransmitCount: Number of times RARP packet is sent per source IPv4 address.
	RarpTransmitCount *Multivalue `json:"rarpTransmitCount,omitempty"`
	// RarpTransmitInterval: Time interval to calculate next RARP packet transmission for each source IPv4 address.
	RarpTransmitInterval *Multivalue `json:"rarpTransmitInterval,omitempty"`
	// ReSendArpOnLinkUp: Resends ARP after link up.
	ReSendArpOnLinkUp *Multivalue `json:"reSendArpOnLinkUp,omitempty"`
	// SuppressArpForDuplicateGateway: Optimizes the gateway MAC discovery by sending a single ARP request for each unique destination.
	SuppressArpForDuplicateGateway *Multivalue `json:"suppressArpForDuplicateGateway,omitempty"`

	ArpRate *GlobalsArpRate `json:"arpRate,omitempty"`

	StartRate *GlobalsIpv4StartRate `json:"startRate,omitempty"`

	StopRate *GlobalsIpv4StopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIpv4) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIpv4) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIpv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIpv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.GratarpTransmitCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gratarpTransmitCount",
		isMultivalue: true,
	})
	n.GratarpTransmitInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gratarpTransmitInterval",
		isMultivalue: true,
	})
	n.PermanentMacForGateway.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "permanentMacForGateway",
		isMultivalue: true,
	})
	n.RarpTransmitCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rarpTransmitCount",
		isMultivalue: true,
	})
	n.RarpTransmitInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rarpTransmitInterval",
		isMultivalue: true,
	})
	n.ReSendArpOnLinkUp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reSendArpOnLinkUp",
		isMultivalue: true,
	})
	n.SuppressArpForDuplicateGateway.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "suppressArpForDuplicateGateway",
		isMultivalue: true,
	})
	n.ArpRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "arpRate",
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIpv4StartRate: Parameters used for controlling the rate of actions
type GlobalsIpv4StartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIpv4StartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIpv4StartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIpv4StartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIpv4StartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIpv4StopRate: Parameters used for controlling the rate of actions
type GlobalsIpv4StopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIpv4StopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIpv4StopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIpv4StopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIpv4StopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIpv6: IPv6 global and per-port settings
type GlobalsIpv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableNaRouterBit: When enabled, Router bit will be set in NA.
	EnableNaRouterBit *Multivalue `json:"enableNaRouterBit,omitempty"`
	// InitialRaCount: Initial RA sent count.
	InitialRaCount *Multivalue `json:"initialRaCount,omitempty"`
	// MaxInitialRaInterval: Maximum Initial RA interval.
	MaxInitialRaInterval *Multivalue `json:"maxInitialRaInterval,omitempty"`
	// MaxRaInterval: Maximum Periodic RA interval.
	MaxRaInterval *Multivalue `json:"maxRaInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PermanentMacForGateway: When enabled, adds permanent entries for Gateways with manual MAC.
	PermanentMacForGateway *Multivalue `json:"permanentMacForGateway,omitempty"`
	// RaRtrLifetime: Router lifetime in RA.
	RaRtrLifetime *Multivalue `json:"raRtrLifetime,omitempty"`
	// ReSendNsOnLinkUp: Resends neighbor solicitation after link up.
	ReSendNsOnLinkUp *Multivalue `json:"reSendNsOnLinkUp,omitempty"`
	// SuppressNsForDuplicateGateway: Optimizes the gateway MAC discovery by sending a single NS request for each unique destination.
	SuppressNsForDuplicateGateway *Multivalue `json:"suppressNsForDuplicateGateway,omitempty"`

	NsRate *GlobalsNsRate `json:"nsRate,omitempty"`

	StartRate *GlobalsIpv6StartRate `json:"startRate,omitempty"`

	StopRate *GlobalsIpv6StopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIpv6) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIpv6) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIpv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIpv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableNaRouterBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNaRouterBit",
		isMultivalue: true,
	})
	n.InitialRaCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initialRaCount",
		isMultivalue: true,
	})
	n.MaxInitialRaInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxInitialRaInterval",
		isMultivalue: true,
	})
	n.MaxRaInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRaInterval",
		isMultivalue: true,
	})
	n.PermanentMacForGateway.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "permanentMacForGateway",
		isMultivalue: true,
	})
	n.RaRtrLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "raRtrLifetime",
		isMultivalue: true,
	})
	n.ReSendNsOnLinkUp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reSendNsOnLinkUp",
		isMultivalue: true,
	})
	n.SuppressNsForDuplicateGateway.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "suppressNsForDuplicateGateway",
		isMultivalue: true,
	})
	n.NsRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "nsRate",
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIpv6Autoconfiguration: IPv6 global and per-port settings
type GlobalsIpv6Autoconfiguration struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	NsRate *GlobalsNsRate `json:"nsRate,omitempty"`

	RsRate *GlobalsRsRate `json:"rsRate,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIpv6Autoconfiguration) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIpv6Autoconfiguration) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIpv6Autoconfiguration) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIpv6Autoconfiguration) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.NsRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "nsRate",
	})
	n.RsRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsRate",
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIpv6StartRate: Parameters used for controlling the rate of actions
type GlobalsIpv6StartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIpv6StartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIpv6StartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIpv6StartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIpv6StartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIpv6StopRate: Parameters used for controlling the rate of actions
type GlobalsIpv6StopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIpv6StopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIpv6StopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIpv6StopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIpv6StopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisFabricPathRouter: Fabric-Path Port Configuration
type GlobalsIsisFabricPathRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AllL1RBridgesMAC: Fabric-Path All L1 RBridges MAC
	AllL1RBridgesMAC *Multivalue `json:"allL1RBridgesMAC,omitempty"`
	// HelloMulticastMAC: Fabric-Path Hello Multicast MAC
	HelloMulticastMAC *Multivalue `json:"helloMulticastMAC,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NlpId: Fabric-Path NLP ID
	NlpId *Multivalue `json:"nlpId,omitempty"`
	// NoOfLSPsOrMgroupPDUsPerInterval: LSPs/MGROUP-PDUs per Interval
	NoOfLSPsOrMgroupPDUsPerInterval *Multivalue `json:"noOfLSPsOrMgroupPDUsPerInterval,omitempty"`
	// RateControlInterval: Rate Control Interval (ms)
	RateControlInterval *Multivalue `json:"rateControlInterval,omitempty"`
	// SendP2PHellosToUnicastMAC: TRILL/Fabric-Path Send P2P Hellos To Unicast MAC
	SendP2PHellosToUnicastMAC *Multivalue `json:"sendP2PHellosToUnicastMAC,omitempty"`

	StartRate *GlobalsIsisFabricPathRouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsIsisFabricPathRouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisFabricPathRouter) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisFabricPathRouter) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisFabricPathRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisFabricPathRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AllL1RBridgesMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allL1RBridgesMAC",
		isMultivalue: true,
	})
	n.HelloMulticastMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloMulticastMAC",
		isMultivalue: true,
	})
	n.NlpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nlpId",
		isMultivalue: true,
	})
	n.NoOfLSPsOrMgroupPDUsPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfLSPsOrMgroupPDUsPerInterval",
		isMultivalue: true,
	})
	n.RateControlInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rateControlInterval",
		isMultivalue: true,
	})
	n.SendP2PHellosToUnicastMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendP2PHellosToUnicastMAC",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIsisFabricPathRouterStartRate: Parameters used for controlling the rate of actions
type GlobalsIsisFabricPathRouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisFabricPathRouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisFabricPathRouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisFabricPathRouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisFabricPathRouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisFabricPathRouterStopRate: Parameters used for controlling the rate of actions
type GlobalsIsisFabricPathRouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisFabricPathRouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisFabricPathRouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisFabricPathRouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisFabricPathRouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisL3Router: ISIS-L3 Port Configuration
type GlobalsIsisL3Router struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BIERInfoSubTLVType: BIER Info Sub-TLV Type
	BIERInfoSubTLVType *Multivalue `json:"bIERInfoSubTLVType,omitempty"`
	// FaAppSpecfLinkAttrSubTlvType: App Specific Link Attr Sub-TLV Type
	FaAppSpecfLinkAttrSubTlvType *Multivalue `json:"faAppSpecfLinkAttrSubTlvType,omitempty"`
	// FaEagSubTlvType: FAEAG Sub-TLV Type
	FaEagSubTlvType *Multivalue `json:"faEagSubTlvType,omitempty"`
	// FadSubTlvType: FAD Sub-TLV Type
	FadSubTlvType *Multivalue `json:"fadSubTlvType,omitempty"`
	// FadfSubTlvType: FADF Sub-TLV Type
	FadfSubTlvType *Multivalue `json:"fadfSubTlvType,omitempty"`
	// FaiAllAgSubTlvType: FAIAllAG Sub-TLV Type
	FaiAllAgSubTlvType *Multivalue `json:"faiAllAgSubTlvType,omitempty"`
	// FaiAnyAgSubTlvType: FAIAnyAG Sub-TLV Type
	FaiAnyAgSubTlvType *Multivalue `json:"faiAnyAgSubTlvType,omitempty"`
	// LinkMsdSubTlvType: This specifies the type of Link MSD sub-TLV
	LinkMsdSubTlvType *Multivalue `json:"linkMsdSubTlvType,omitempty"`
	// MaxEndDMsdType: This specifies the type of Max End D MSD
	MaxEndDMsdType *Multivalue `json:"maxEndDMsdType,omitempty"`
	// MaxEndPopMsdType: This specifies the type of Max End Pop MSD
	MaxEndPopMsdType *Multivalue `json:"maxEndPopMsdType,omitempty"`
	// MaxSegmentsLeftMsdType: This specifies the type of Max Segments Left MSD
	MaxSegmentsLeftMsdType *Multivalue `json:"maxSegmentsLeftMsdType,omitempty"`
	// MaxTEncapMsdType: This specifies the type of Max T Encap MSD
	MaxTEncapMsdType *Multivalue `json:"maxTEncapMsdType,omitempty"`
	// MaxTInsertMsdType: This specifies the type of Max T Insert MSD
	MaxTInsertMsdType *Multivalue `json:"maxTInsertMsdType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfLSPsOrMgroupPDUsPerInterval: LSPs/MGROUP-PDUs per Interval
	NoOfLSPsOrMgroupPDUsPerInterval *Multivalue `json:"noOfLSPsOrMgroupPDUsPerInterval,omitempty"`
	// NodeMsdSubTlvType: This specifies the type of Node MSD sub-TLV
	NodeMsdSubTlvType *Multivalue `json:"nodeMsdSubTlvType,omitempty"`
	// RateControlInterval: Rate Control Interval (ms)
	RateControlInterval *Multivalue `json:"rateControlInterval,omitempty"`
	// SendP2PHellosToUnicastMAC: Send P2P Hellos To Unicast MAC
	SendP2PHellosToUnicastMAC *Multivalue `json:"sendP2PHellosToUnicastMAC,omitempty"`
	// SrDraftExtension: This refers to the TLV structure of SRGB as per the Segment Routing draft version
	SrDraftExtension *Multivalue `json:"srDraftExtension,omitempty"`
	// SrlbSubTlvType: This specifies the type of Segment Routing Local Block sub tlv, suggested value is 22.
	SrlbSubTlvType *Multivalue `json:"srlbSubTlvType,omitempty"`
	// SrmsPreferenceSubTlvType: This specifies the type of SRMS Preference sub tlv, suggested value is 23.
	SrmsPreferenceSubTlvType *Multivalue `json:"srmsPreferenceSubTlvType,omitempty"`
	// Srv6AdjSIDSubTlvType: This specifies the type of SRv6 Adjacency-SID sub-TLV
	Srv6AdjSIDSubTlvType *Multivalue `json:"srv6AdjSIDSubTlvType,omitempty"`
	// Srv6CapabilitiesSubTlvType: This specifies the type of SRv6 Capabilities sub-TLV
	Srv6CapabilitiesSubTlvType *Multivalue `json:"srv6CapabilitiesSubTlvType,omitempty"`
	// Srv6EndSidSubTlvType: This specifies the type of SRv6 End SID sub-TLV
	Srv6EndSidSubTlvType *Multivalue `json:"srv6EndSidSubTlvType,omitempty"`
	// Srv6EndXSidSubTlvType: This specifies the type of SRv6 End.X SID sub-TLV
	Srv6EndXSidSubTlvType *Multivalue `json:"srv6EndXSidSubTlvType,omitempty"`
	// Srv6LANAdjSIDSubTlvType: This specifies the type of SRv6 LAN Adjacency-SID sub-TLV
	Srv6LANAdjSIDSubTlvType *Multivalue `json:"srv6LANAdjSIDSubTlvType,omitempty"`
	// Srv6LanEndXSidSubTlvType: This specifies the type of SRv6 LAN End.X SID sub-TLV
	Srv6LanEndXSidSubTlvType *Multivalue `json:"srv6LanEndXSidSubTlvType,omitempty"`
	// Srv6NodeSIDTlvType: This specifies the type of SRv6 Node SID TLV
	Srv6NodeSIDTlvType *Multivalue `json:"srv6NodeSIDTlvType,omitempty"`
	// Srv6SidLocatorTlvType: SRv6 SID Locator Tlv Type
	Srv6SidLocatorTlvType *Multivalue `json:"srv6SidLocatorTlvType,omitempty"`

	StartRate *GlobalsIsisL3RouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsIsisL3RouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisL3Router) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisL3Router) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisL3Router) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisL3Router) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BIERInfoSubTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bIERInfoSubTLVType",
		isMultivalue: true,
	})
	n.FaAppSpecfLinkAttrSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "faAppSpecfLinkAttrSubTlvType",
		isMultivalue: true,
	})
	n.FaEagSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "faEagSubTlvType",
		isMultivalue: true,
	})
	n.FadSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fadSubTlvType",
		isMultivalue: true,
	})
	n.FadfSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fadfSubTlvType",
		isMultivalue: true,
	})
	n.FaiAllAgSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "faiAllAgSubTlvType",
		isMultivalue: true,
	})
	n.FaiAnyAgSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "faiAnyAgSubTlvType",
		isMultivalue: true,
	})
	n.LinkMsdSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMsdSubTlvType",
		isMultivalue: true,
	})
	n.MaxEndDMsdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndDMsdType",
		isMultivalue: true,
	})
	n.MaxEndPopMsdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndPopMsdType",
		isMultivalue: true,
	})
	n.MaxSegmentsLeftMsdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSegmentsLeftMsdType",
		isMultivalue: true,
	})
	n.MaxTEncapMsdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTEncapMsdType",
		isMultivalue: true,
	})
	n.MaxTInsertMsdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTInsertMsdType",
		isMultivalue: true,
	})
	n.NoOfLSPsOrMgroupPDUsPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfLSPsOrMgroupPDUsPerInterval",
		isMultivalue: true,
	})
	n.NodeMsdSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeMsdSubTlvType",
		isMultivalue: true,
	})
	n.RateControlInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rateControlInterval",
		isMultivalue: true,
	})
	n.SendP2PHellosToUnicastMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendP2PHellosToUnicastMAC",
		isMultivalue: true,
	})
	n.SrDraftExtension.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srDraftExtension",
		isMultivalue: true,
	})
	n.SrlbSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlbSubTlvType",
		isMultivalue: true,
	})
	n.SrmsPreferenceSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srmsPreferenceSubTlvType",
		isMultivalue: true,
	})
	n.Srv6AdjSIDSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6AdjSIDSubTlvType",
		isMultivalue: true,
	})
	n.Srv6CapabilitiesSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6CapabilitiesSubTlvType",
		isMultivalue: true,
	})
	n.Srv6EndSidSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndSidSubTlvType",
		isMultivalue: true,
	})
	n.Srv6EndXSidSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndXSidSubTlvType",
		isMultivalue: true,
	})
	n.Srv6LANAdjSIDSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6LANAdjSIDSubTlvType",
		isMultivalue: true,
	})
	n.Srv6LanEndXSidSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6LanEndXSidSubTlvType",
		isMultivalue: true,
	})
	n.Srv6NodeSIDTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6NodeSIDTlvType",
		isMultivalue: true,
	})
	n.Srv6SidLocatorTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocatorTlvType",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIsisL3RouterStartRate: Parameters used for controlling the rate of actions
type GlobalsIsisL3RouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisL3RouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisL3RouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisL3RouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisL3RouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisL3RouterStopRate: Parameters used for controlling the rate of actions
type GlobalsIsisL3RouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisL3RouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisL3RouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisL3RouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisL3RouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisSpbRouter: ISIS-SPB Port Configuration
type GlobalsIsisSpbRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AllL1BridgesMAC: SPB All L1 Bridges MAC
	AllL1BridgesMAC *Multivalue `json:"allL1BridgesMAC,omitempty"`
	// HelloMulticastMAC: SPB Hello Multicast MAC
	HelloMulticastMAC *Multivalue `json:"helloMulticastMAC,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NlpId: SPB NLP ID
	NlpId *Multivalue `json:"nlpId,omitempty"`
	// NoOfLSPsOrMgroupPDUsPerInterval: LSPs/MGROUP-PDUs per Interval
	NoOfLSPsOrMgroupPDUsPerInterval *Multivalue `json:"noOfLSPsOrMgroupPDUsPerInterval,omitempty"`
	// RateControlInterval: Rate Control Interval (ms)
	RateControlInterval *Multivalue `json:"rateControlInterval,omitempty"`
	// SendP2PHellosToUnicastMAC: Send P2P Hellos To Unicast MAC
	SendP2PHellosToUnicastMAC *Multivalue `json:"sendP2PHellosToUnicastMAC,omitempty"`

	StartRate *GlobalsIsisSpbRouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsIsisSpbRouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisSpbRouter) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisSpbRouter) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisSpbRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisSpbRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AllL1BridgesMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allL1BridgesMAC",
		isMultivalue: true,
	})
	n.HelloMulticastMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloMulticastMAC",
		isMultivalue: true,
	})
	n.NlpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nlpId",
		isMultivalue: true,
	})
	n.NoOfLSPsOrMgroupPDUsPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfLSPsOrMgroupPDUsPerInterval",
		isMultivalue: true,
	})
	n.RateControlInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rateControlInterval",
		isMultivalue: true,
	})
	n.SendP2PHellosToUnicastMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendP2PHellosToUnicastMAC",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIsisSpbRouterStartRate: Parameters used for controlling the rate of actions
type GlobalsIsisSpbRouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisSpbRouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisSpbRouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisSpbRouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisSpbRouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisSpbRouterStopRate: Parameters used for controlling the rate of actions
type GlobalsIsisSpbRouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisSpbRouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisSpbRouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisSpbRouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisSpbRouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisTrillRouter: TRILL Port Configuration
type GlobalsIsisTrillRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AllL1RBridgesMAC: TRILL All L1 RBridges MAC
	AllL1RBridgesMAC *Multivalue `json:"allL1RBridgesMAC,omitempty"`
	// HelloMulticastMAC: TRILL Hello Multicast MAC
	HelloMulticastMAC *Multivalue `json:"helloMulticastMAC,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NlpId: TRILL NLP ID
	NlpId *Multivalue `json:"nlpId,omitempty"`
	// NoOfLSPsOrMgroupPDUsPerInterval: LSPs/MGROUP-PDUs per Interval
	NoOfLSPsOrMgroupPDUsPerInterval *Multivalue `json:"noOfLSPsOrMgroupPDUsPerInterval,omitempty"`
	// RateControlInterval: Rate Control Interval (ms)
	RateControlInterval *Multivalue `json:"rateControlInterval,omitempty"`
	// SendP2PHellosToUnicastMAC: TRILL/Fabric-Path Send P2P Hellos To Unicast MAC
	SendP2PHellosToUnicastMAC *Multivalue `json:"sendP2PHellosToUnicastMAC,omitempty"`

	StartRate *GlobalsIsisTrillRouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsIsisTrillRouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisTrillRouter) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisTrillRouter) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisTrillRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisTrillRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AllL1RBridgesMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allL1RBridgesMAC",
		isMultivalue: true,
	})
	n.HelloMulticastMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloMulticastMAC",
		isMultivalue: true,
	})
	n.NlpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nlpId",
		isMultivalue: true,
	})
	n.NoOfLSPsOrMgroupPDUsPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfLSPsOrMgroupPDUsPerInterval",
		isMultivalue: true,
	})
	n.RateControlInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rateControlInterval",
		isMultivalue: true,
	})
	n.SendP2PHellosToUnicastMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendP2PHellosToUnicastMAC",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsIsisTrillRouterStartRate: Parameters used for controlling the rate of actions
type GlobalsIsisTrillRouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisTrillRouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisTrillRouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisTrillRouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisTrillRouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIsisTrillRouterStopRate: Parameters used for controlling the rate of actions
type GlobalsIsisTrillRouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIsisTrillRouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIsisTrillRouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIsisTrillRouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIsisTrillRouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsIxnet: Tracks remote clients connected using the ixNet API Service over websockets.
type GlobalsIxnet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsIxnet) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsIxnet) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsIxnet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsIxnet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsLac: L2TP Access Concentrator global and per-port settings
type GlobalsLac struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableAggregatedCSUN: Enables Aggregated CSUN
	EnableAggregatedCSUN *Multivalue `json:"enableAggregatedCSUN,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLac) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLac) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLac) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLac) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableAggregatedCSUN.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatedCSUN",
		isMultivalue: true,
	})
}

// GlobalsLacp: Lacp Port Specific Data
type GlobalsLacp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLacp) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLacp) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLacp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLacp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsLagportlacp: Lacp Port Specific Data
type GlobalsLagportlacp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLagportlacp) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLagportlacp) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLagportlacp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLagportlacp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsLagportstaticlag: Lacp Port Specific Data
type GlobalsLagportstaticlag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLagportstaticlag) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLagportstaticlag) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLagportstaticlag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLagportstaticlag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsLdpBasicRouter: Ldp Port Specific Data
type GlobalsLdpBasicRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DiscardSelfOriginatedFECs: Discard SelfOriginated FECs
	DiscardSelfOriginatedFECs *Multivalue `json:"discardSelfOriginatedFECs,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TransportLabels: Use Transport Labels for MPLSOAM
	TransportLabels *Multivalue `json:"transportLabels,omitempty"`
	// VpnLabel: Enable VPN Label Exchange over LSP
	VpnLabel *Multivalue `json:"vpnLabel,omitempty"`

	StartRate *GlobalsLdpBasicRouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsLdpBasicRouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpBasicRouter) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpBasicRouter) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpBasicRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpBasicRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DiscardSelfOriginatedFECs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardSelfOriginatedFECs",
		isMultivalue: true,
	})
	n.TransportLabels.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transportLabels",
		isMultivalue: true,
	})
	n.VpnLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vpnLabel",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsLdpBasicRouterStartRate: Parameters used for controlling the rate of actions
type GlobalsLdpBasicRouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpBasicRouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpBasicRouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpBasicRouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpBasicRouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLdpBasicRouterStopRate: Parameters used for controlling the rate of actions
type GlobalsLdpBasicRouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpBasicRouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpBasicRouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpBasicRouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpBasicRouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLdpBasicRouterV6: Ldp Port Specific Data
type GlobalsLdpBasicRouterV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DiscardSelfOriginatedFECs: Discard SelfOriginated FECs
	DiscardSelfOriginatedFECs *Multivalue `json:"discardSelfOriginatedFECs,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TransportLabels: Use Transport Labels for MPLSOAM
	TransportLabels *Multivalue `json:"transportLabels,omitempty"`
	// VpnLabel: Enable VPN Label Exchange over LSP
	VpnLabel *Multivalue `json:"vpnLabel,omitempty"`

	StartRate *GlobalsLdpBasicRouterV6StartRate `json:"startRate,omitempty"`

	StopRate *GlobalsLdpBasicRouterV6StopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpBasicRouterV6) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpBasicRouterV6) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpBasicRouterV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpBasicRouterV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DiscardSelfOriginatedFECs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardSelfOriginatedFECs",
		isMultivalue: true,
	})
	n.TransportLabels.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transportLabels",
		isMultivalue: true,
	})
	n.VpnLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vpnLabel",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsLdpBasicRouterV6StartRate: Parameters used for controlling the rate of actions
type GlobalsLdpBasicRouterV6StartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpBasicRouterV6StartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpBasicRouterV6StartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpBasicRouterV6StartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpBasicRouterV6StartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLdpBasicRouterV6StopRate: Parameters used for controlling the rate of actions
type GlobalsLdpBasicRouterV6StopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpBasicRouterV6StopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpBasicRouterV6StopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpBasicRouterV6StopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpBasicRouterV6StopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLdpTargetedRouter: Ldp Port Specific Data
type GlobalsLdpTargetedRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DiscardSelfOriginatedFECs: Discard SelfOriginated FECs
	DiscardSelfOriginatedFECs *Multivalue `json:"discardSelfOriginatedFECs,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TransportLabels: Use Transport Labels for MPLSOAM
	TransportLabels *Multivalue `json:"transportLabels,omitempty"`
	// VpnLabel: Enable VPN Label Exchange over LSP
	VpnLabel *Multivalue `json:"vpnLabel,omitempty"`

	StartRate *GlobalsLdpTargetedRouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsLdpTargetedRouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpTargetedRouter) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpTargetedRouter) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpTargetedRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpTargetedRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DiscardSelfOriginatedFECs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardSelfOriginatedFECs",
		isMultivalue: true,
	})
	n.TransportLabels.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transportLabels",
		isMultivalue: true,
	})
	n.VpnLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vpnLabel",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsLdpTargetedRouterStartRate: Parameters used for controlling the rate of actions
type GlobalsLdpTargetedRouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpTargetedRouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpTargetedRouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpTargetedRouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpTargetedRouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLdpTargetedRouterStopRate: Parameters used for controlling the rate of actions
type GlobalsLdpTargetedRouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpTargetedRouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpTargetedRouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpTargetedRouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpTargetedRouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLdpTargetedRouterV6: Ldp Port Specific Data
type GlobalsLdpTargetedRouterV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DiscardSelfOriginatedFECs: Discard SelfOriginated FECs
	DiscardSelfOriginatedFECs *Multivalue `json:"discardSelfOriginatedFECs,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TransportLabels: Use Transport Labels for MPLSOAM
	TransportLabels *Multivalue `json:"transportLabels,omitempty"`
	// VpnLabel: Enable VPN Label Exchange over LSP
	VpnLabel *Multivalue `json:"vpnLabel,omitempty"`

	StartRate *GlobalsLdpTargetedRouterV6StartRate `json:"startRate,omitempty"`

	StopRate *GlobalsLdpTargetedRouterV6StopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpTargetedRouterV6) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpTargetedRouterV6) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpTargetedRouterV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpTargetedRouterV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DiscardSelfOriginatedFECs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardSelfOriginatedFECs",
		isMultivalue: true,
	})
	n.TransportLabels.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transportLabels",
		isMultivalue: true,
	})
	n.VpnLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vpnLabel",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsLdpTargetedRouterV6StartRate: Parameters used for controlling the rate of actions
type GlobalsLdpTargetedRouterV6StartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpTargetedRouterV6StartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpTargetedRouterV6StartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpTargetedRouterV6StartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpTargetedRouterV6StartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLdpTargetedRouterV6StopRate: Parameters used for controlling the rate of actions
type GlobalsLdpTargetedRouterV6StopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLdpTargetedRouterV6StopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLdpTargetedRouterV6StopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLdpTargetedRouterV6StopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLdpTargetedRouterV6StopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsLength: Tlv length container
type GlobalsLength struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// Encoding: Encoding of the tlv value, any change will result in the value being reset

	Encoding *string `json:"encoding,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRequired: Flag indicating whether this is required or not

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`
	// Size: Size of the tlv value in bits/bytes based on sizeType, any change will result in the value being reset

	Size *float32 `json:"size,omitempty"`
	// SizeType: Size type of the tlv value, any change will result in the value being reset

	SizeType *string `json:"sizeType,omitempty"`
	// Value: Value represented as a multivalue object
	Value       *Multivalue           `json:"value,omitempty"`
	Restriction []*GlobalsRestriction `json:"restriction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLength) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLength) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLength) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLength) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
	for i, o := range n.Restriction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "restriction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsLicensing: TBD
type GlobalsLicensing struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// LicensingServers: List of license servers to use
	LicensingServers []string `json:"licensingServers"`
	// Mode: Set license mode to either of perpetual,subscription,mixed or aggregation

	Mode *string `json:"mode,omitempty"`
	// Tier: Set or get the tier level, using the tier ID. Available IDs are: for mode = 'subscription'/'mixed': 'tier0','tier1','tier2','tier3','tier3-10g','tier-IxVerify-Cadence','tier-IxVerify-Mentor','tier-IxVerify-Synopsys', and for mode = 'perpetual': 'tier3-2014','tier3-10g-2017'.

	Tier *string `json:"tier,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLicensing) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLicensing) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLicensing) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLicensing) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsLightweightDhcpv6relayAgent: IPv6 global and per-port settings
type GlobalsLightweightDhcpv6relayAgent struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name      *string             `json:"name,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLightweightDhcpv6relayAgent) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLightweightDhcpv6relayAgent) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLightweightDhcpv6relayAgent) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLightweightDhcpv6relayAgent) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsLns: L2TP Network Server global and per-port settings
type GlobalsLns struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableAggregatedCSURQ: Enables Aggregated CSURQ
	EnableAggregatedCSURQ *Multivalue `json:"enableAggregatedCSURQ,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsLns) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsLns) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsLns) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsLns) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableAggregatedCSURQ.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatedCSURQ",
		isMultivalue: true,
	})
}

// GlobalsMacsec: MACsec Port Specific Data
type GlobalsMacsec struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// KeyGenerationMode: Whether the encryption keys will be informed by MKA or configured statically in MACsec.

	KeyGenerationMode *string `json:"keyGenerationMode,omitempty"`
	// MacsecValidation: Rx Validation behavior set at the port. Can be either Disabled, Check or Strict.
	MacsecValidation *Multivalue `json:"macsecValidation,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ReplayProtection: Replay protection behavior of the port. Based on this out of window packets will either be discarded or passed to the upper layer control plane plugins and corresponding stats will be incremented.
	ReplayProtection *Multivalue `json:"replayProtection,omitempty"`
	// RxSecTagOffset: This denotes the position of the SecTAG in macsec packets received from the DUT. The default offset is 12, but it may not be always 12 depending on different tunneling scenario.
	RxSecTagOffset *Multivalue `json:"rxSecTagOffset,omitempty"`
	// SecTagOffsetUnknown: If the position of the SecTAG in MACsec packets received from the DUT is not known. By default it should be known, and only in some cases DUT may insert some outer headers due to which position of SecTAG will be moved.
	SecTagOffsetUnknown *Multivalue `json:"secTagOffsetUnknown,omitempty"`

	StartRate *GlobalsMacsecStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsMacsecStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMacsec) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMacsec) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMacsec) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMacsec) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.MacsecValidation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "macsecValidation",
		isMultivalue: true,
	})
	n.ReplayProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "replayProtection",
		isMultivalue: true,
	})
	n.RxSecTagOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxSecTagOffset",
		isMultivalue: true,
	})
	n.SecTagOffsetUnknown.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "secTagOffsetUnknown",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsMacsecStartRate: Parameters used for controlling the rate of actions
type GlobalsMacsecStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMacsecStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMacsecStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMacsecStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMacsecStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsMacsecStopRate: Parameters used for controlling the rate of actions
type GlobalsMacsecStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMacsecStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMacsecStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMacsecStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMacsecStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsMatchAction: Match Criteria and Instruction-Action prototype.
type GlobalsMatchAction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name *string `json:"name,omitempty"`

	Instructions  *GlobalsInstructions    `json:"instructions,omitempty"`
	MatchCriteria []*GlobalsMatchCriteria `json:"matchCriteria"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMatchAction) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMatchAction) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMatchAction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMatchAction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Instructions.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "instructions",
	})
	for i, o := range n.MatchCriteria {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchCriteria",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsMatchCriteria: Match Criteria prototype.
type GlobalsMatchCriteria struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name          *string                      `json:"name,omitempty"`
	Field         []*GlobalsMatchCriteriaField `json:"field"`
	MatchCriteria []*GlobalsMatchCriteria      `json:"matchCriteria"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMatchCriteria) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMatchCriteria) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMatchCriteria) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMatchCriteria) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MatchCriteria {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchCriteria",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsMatchCriteriaField: Field prototype.
type GlobalsMatchCriteriaField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the TLV prototype.

	Description *string `json:"description,omitempty"`
	// Encoding: Encoding of the field value.

	Encoding *string `json:"encoding,omitempty"`
	// Enum: Internal enumeration type used to restrict possible field values.

	Enum *string `json:"enum,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Information if the field can be multiplied in the tlv definition.

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the TLV field.

	Name *string `json:"name,omitempty"`
	// SingleValue: If true the field can only be configured with a single value pattern.

	SingleValue *bool `json:"singleValue,omitempty"`
	// Size: The size of the field in bytes. Field size must be greater or equal to 0. For automatic detection set size to 0.

	Size *float32 `json:"size,omitempty"`
	// SizeType: The size types/data unit of the field.

	SizeType *string `json:"sizeType,omitempty"`
	// Value: Field value.
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMatchCriteriaField) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMatchCriteriaField) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMatchCriteriaField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMatchCriteriaField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// GlobalsMatchTemplate: Flow Match Template.
type GlobalsMatchTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SavedInVersion: The cpf version of the session

	SavedInVersion *string                 `json:"savedInVersion,omitempty"`
	MatchCriteria  []*GlobalsMatchCriteria `json:"matchCriteria"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMatchTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMatchTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMatchTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMatchTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.MatchCriteria {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchCriteria",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsMka: IGMP Querier Port Specific Data
type GlobalsMka struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BroadcastMKPDUs: Checkbox to control if MKPDUs need to be broadcast unlike the usual behavior of multicast
	BroadcastMKPDUs *Multivalue `json:"broadcastMKPDUs,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMka) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMka) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMka) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMka) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BroadcastMKPDUs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "broadcastMKPDUs",
		isMultivalue: true,
	})
}

// GlobalsMldHost: IGMP global and per-port settings
type GlobalsMldHost struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// InterStbStartDelay: Time in milliseconds between Join messages from clients within the same range.
	InterStbStartDelay *Multivalue `json:"interStbStartDelay,omitempty"`
	// IntervalInMs: Time interval used to calculate the rate for triggering an action (rate = count/interval)
	IntervalInMs *Multivalue `json:"intervalInMs,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RatePerInterval: No. of Reports triggered per time interval
	RatePerInterval *Multivalue `json:"ratePerInterval,omitempty"`
	// TrafficClass: Specifies the Traffic Class value in the IPv6 Header
	TrafficClass *Multivalue `json:"trafficClass,omitempty"`
	// UnicastMode: Unicast Mode
	UnicastMode *Multivalue `json:"unicastMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMldHost) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMldHost) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMldHost) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMldHost) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.InterStbStartDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interStbStartDelay",
		isMultivalue: true,
	})
	n.IntervalInMs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "intervalInMs",
		isMultivalue: true,
	})
	n.RatePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ratePerInterval",
		isMultivalue: true,
	})
	n.TrafficClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficClass",
		isMultivalue: true,
	})
	n.UnicastMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unicastMode",
		isMultivalue: true,
	})
}

// GlobalsMldQuerier: MLD Querier Port Specific Data
type GlobalsMldQuerier struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enable/Disable Rate Control
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfQueriesPerUnitTime: No. of Queries (per Time Period)
	NoOfQueriesPerUnitTime *Multivalue `json:"noOfQueriesPerUnitTime,omitempty"`
	// TimePeriod: Time Period
	TimePeriod *Multivalue `json:"timePeriod,omitempty"`
	// UnicastMode: Unicast Mode
	UnicastMode *Multivalue `json:"unicastMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMldQuerier) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMldQuerier) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMldQuerier) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMldQuerier) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.NoOfQueriesPerUnitTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfQueriesPerUnitTime",
		isMultivalue: true,
	})
	n.TimePeriod.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timePeriod",
		isMultivalue: true,
	})
	n.UnicastMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unicastMode",
		isMultivalue: true,
	})
}

// GlobalsMsrpListener: MSRP Port Specific Data
type GlobalsMsrpListener struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsMsrpListenerStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsMsrpListenerStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMsrpListener) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMsrpListener) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMsrpListener) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMsrpListener) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsMsrpListenerStartRate: Parameters used for controlling the rate of actions
type GlobalsMsrpListenerStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMsrpListenerStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMsrpListenerStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMsrpListenerStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMsrpListenerStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsMsrpListenerStopRate: Parameters used for controlling the rate of actions
type GlobalsMsrpListenerStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMsrpListenerStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMsrpListenerStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMsrpListenerStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMsrpListenerStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsMsrpTalker: MSRP Port Specific Data
type GlobalsMsrpTalker struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsMsrpTalkerStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsMsrpTalkerStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMsrpTalker) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMsrpTalker) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMsrpTalker) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMsrpTalker) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsMsrpTalkerStartRate: Parameters used for controlling the rate of actions
type GlobalsMsrpTalkerStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMsrpTalkerStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMsrpTalkerStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMsrpTalkerStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMsrpTalkerStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsMsrpTalkerStopRate: Parameters used for controlling the rate of actions
type GlobalsMsrpTalkerStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsMsrpTalkerStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsMsrpTalkerStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsMsrpTalkerStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsMsrpTalkerStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsNetconfClient: Per Port Netconf Client configuration
type GlobalsNetconfClient struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsNetconfClientStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsNetconfClientStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNetconfClient) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNetconfClient) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNetconfClient) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNetconfClient) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsNetconfClientStartRate: Parameters used for controlling the rate of actions
type GlobalsNetconfClientStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNetconfClientStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNetconfClientStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNetconfClientStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNetconfClientStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsNetconfClientStopRate: Parameters used for controlling the rate of actions
type GlobalsNetconfClientStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNetconfClientStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNetconfClientStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNetconfClientStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNetconfClientStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsNetconfServer: Per Port Netconf Server configuration
type GlobalsNetconfServer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsNetconfServerStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsNetconfServerStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNetconfServer) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNetconfServer) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNetconfServer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNetconfServer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsNetconfServerStartRate: Parameters used for controlling the rate of actions
type GlobalsNetconfServerStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNetconfServerStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNetconfServerStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNetconfServerStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNetconfServerStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsNetconfServerStopRate: Parameters used for controlling the rate of actions
type GlobalsNetconfServerStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNetconfServerStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNetconfServerStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNetconfServerStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNetconfServerStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsNsRate: Parameters used for controlling the rate of actions
type GlobalsNsRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNsRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNsRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNsRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNsRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsNtpclock: Ntp Port Specific Data
type GlobalsNtpclock struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsNtpclockStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsNtpclockStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNtpclock) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNtpclock) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNtpclock) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNtpclock) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsNtpclockStartRate: Parameters used for controlling the rate of actions
type GlobalsNtpclockStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNtpclockStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNtpclockStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNtpclockStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNtpclockStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsNtpclockStopRate: Parameters used for controlling the rate of actions
type GlobalsNtpclockStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsNtpclockStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsNtpclockStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsNtpclockStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsNtpclockStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsObject: Tlv object container which can contain one of a field, sub tlv or container
type GlobalsObject struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: The name of the object

	Name *string `json:"name,omitempty"`

	Container *GlobalsContainer `json:"container,omitempty"`

	Field *GlobalsField `json:"field,omitempty"`

	SubTlv *GlobalsSubTlv `json:"subTlv,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsObject) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsObject) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsObject) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsObject) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Container.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "container",
	})
	n.Field.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "field",
	})
	n.SubTlv.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "subTlv",
	})
}

// GlobalsOpenFlowChannel: OpenFlow Controller global and per-port settings
type GlobalsOpenFlowChannel struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	FlowAggrMatchTemplate *GlobalsFlowAggrMatchTemplate `json:"flowAggrMatchTemplate,omitempty"`

	FlowStatMatchTemplate *GlobalsFlowStatMatchTemplate `json:"flowStatMatchTemplate,omitempty"`

	PacketOutActionTemplate *GlobalsPacketOutActionTemplate `json:"packetOutActionTemplate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOpenFlowChannel) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOpenFlowChannel) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOpenFlowChannel) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOpenFlowChannel) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FlowAggrMatchTemplate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "flowAggrMatchTemplate",
	})
	n.FlowStatMatchTemplate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "flowStatMatchTemplate",
	})
	n.PacketOutActionTemplate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "packetOutActionTemplate",
	})
}

// GlobalsOpenFlowController: OpenFlow Controller global and per-port settings
type GlobalsOpenFlowController struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	ActionsTemplate *GlobalsActionsTemplate `json:"actionsTemplate,omitempty"`

	FlowSetTemplate *GlobalsFlowSetTemplate `json:"flowSetTemplate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOpenFlowController) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOpenFlowController) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOpenFlowController) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOpenFlowController) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActionsTemplate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "actionsTemplate",
	})
	n.FlowSetTemplate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "flowSetTemplate",
	})
}

// GlobalsOspfv2Router: Ospf Port Specific Data
type GlobalsOspfv2Router struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BierMplsEncapSubTlvType: BIER MPLS Encapsulation Sub-TLV
	BierMplsEncapSubTlvType *Multivalue `json:"bierMplsEncapSubTlvType,omitempty"`
	// BierSubTlvType: BIER Sub-TLV Type
	BierSubTlvType *Multivalue `json:"bierSubTlvType,omitempty"`
	// EnableDrBdr: Enable DR/BDR
	EnableDrBdr *Multivalue `json:"enableDrBdr,omitempty"`
	// FloodLsUpdatesPerInterval: Flood Link State Updates per Interval
	FloodLsUpdatesPerInterval *Multivalue `json:"floodLsUpdatesPerInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RateControlInterval: Rate Control Interval (ms)
	RateControlInterval *Multivalue `json:"rateControlInterval,omitempty"`

	StartRate *GlobalsOspfv2RouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsOspfv2RouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOspfv2Router) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOspfv2Router) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOspfv2Router) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOspfv2Router) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BierMplsEncapSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierMplsEncapSubTlvType",
		isMultivalue: true,
	})
	n.BierSubTlvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierSubTlvType",
		isMultivalue: true,
	})
	n.EnableDrBdr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDrBdr",
		isMultivalue: true,
	})
	n.FloodLsUpdatesPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "floodLsUpdatesPerInterval",
		isMultivalue: true,
	})
	n.RateControlInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rateControlInterval",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsOspfv2RouterStartRate: Parameters used for controlling the rate of actions
type GlobalsOspfv2RouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOspfv2RouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOspfv2RouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOspfv2RouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOspfv2RouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsOspfv2RouterStopRate: Parameters used for controlling the rate of actions
type GlobalsOspfv2RouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOspfv2RouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOspfv2RouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOspfv2RouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOspfv2RouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsOspfv3Router: Ospfv3 Port Specific Data
type GlobalsOspfv3Router struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableDrBdr: Enable DR/BDR
	EnableDrBdr *Multivalue `json:"enableDrBdr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsOspfv3RouterStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsOspfv3RouterStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOspfv3Router) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOspfv3Router) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOspfv3Router) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOspfv3Router) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableDrBdr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDrBdr",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsOspfv3RouterStartRate: Parameters used for controlling the rate of actions
type GlobalsOspfv3RouterStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOspfv3RouterStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOspfv3RouterStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOspfv3RouterStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOspfv3RouterStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsOspfv3RouterStopRate: Parameters used for controlling the rate of actions
type GlobalsOspfv3RouterStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOspfv3RouterStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOspfv3RouterStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOspfv3RouterStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOspfv3RouterStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsOvsdbcontroller: TBD
type GlobalsOvsdbcontroller struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOvsdbcontroller) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOvsdbcontroller) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOvsdbcontroller) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOvsdbcontroller) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsOvsdbserver: TBD
type GlobalsOvsdbserver struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsOvsdbserver) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsOvsdbserver) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsOvsdbserver) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsOvsdbserver) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsPacketOutActionTemplate: Global data for OpenFlow Action Builder template data extension.
type GlobalsPacketOutActionTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath          *XPath                   `json:"xpath,omitempty"`
	ActionTemplate []*GlobalsActionTemplate `json:"actionTemplate"`

	Predefined *GlobalsPredefined `json:"predefined,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPacketOutActionTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPacketOutActionTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPacketOutActionTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPacketOutActionTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.ActionTemplate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "actionTemplate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Predefined.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "predefined",
	})
}

// GlobalsPcc: PCC Port Specific Data
type GlobalsPcc struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BackupPCEOperationMode: Backup PCE Operation Mode
	BackupPCEOperationMode *Multivalue `json:"backupPCEOperationMode,omitempty"`
	// BindingSIDDraftVersion: Depending on this field backward compatibility will be given. All draft versions before IETF draft will follow existing implementation. New IETF draft will be using new implementation and TLV structure.
	BindingSIDDraftVersion *Multivalue `json:"bindingSIDDraftVersion,omitempty"`
	// LspDelegationDelay: Time in seconds before PCC distributes LSP delegation at startup.
	LspDelegationDelay *Multivalue `json:"lspDelegationDelay,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PcePathComputationMode: PCE Path Computation Mode
	PcePathComputationMode *Multivalue `json:"pcePathComputationMode,omitempty"`

	StartRate *GlobalsPccStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsPccStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPcc) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPcc) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPcc) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPcc) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BackupPCEOperationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupPCEOperationMode",
		isMultivalue: true,
	})
	n.BindingSIDDraftVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingSIDDraftVersion",
		isMultivalue: true,
	})
	n.LspDelegationDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspDelegationDelay",
		isMultivalue: true,
	})
	n.PcePathComputationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pcePathComputationMode",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsPccStartRate: Parameters used for controlling the rate of actions
type GlobalsPccStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPccStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPccStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPccStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPccStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsPccStopRate: Parameters used for controlling the rate of actions
type GlobalsPccStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPccStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPccStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPccStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPccStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsPce: PCE Port Specific Data
type GlobalsPce struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BindingSIDDraftVersion: Depending on this field backward compatibility will be given. All draft versions before IETF draft will follow existing implementation. New IETF draft will be using new implementation and TLV structure.
	BindingSIDDraftVersion *Multivalue `json:"bindingSIDDraftVersion,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsPceStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsPceStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPce) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPce) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPce) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPce) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BindingSIDDraftVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingSIDDraftVersion",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsPceStartRate: Parameters used for controlling the rate of actions
type GlobalsPceStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPceStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPceStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPceStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPceStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsPceStopRate: Parameters used for controlling the rate of actions
type GlobalsPceStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPceStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPceStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPceStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPceStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsPimRouter: Pim Port Specific Data
type GlobalsPimRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BootstrapMessagePerInterval: Bootstrap Messages Per Interval
	BootstrapMessagePerInterval *Multivalue `json:"bootstrapMessagePerInterval,omitempty"`
	// CRpAdvertiseMessagePerInterval: C-RP Advertise Messages per Interval
	CRpAdvertiseMessagePerInterval *Multivalue `json:"cRpAdvertiseMessagePerInterval,omitempty"`
	// DiscardJoinPruneProcessing: Discard join/Prune Processing
	DiscardJoinPruneProcessing *Multivalue `json:"discardJoinPruneProcessing,omitempty"`
	// EnableRateControl: Enable Rate Control
	EnableRateControl *Multivalue `json:"enableRateControl,omitempty"`
	// HelloMessagePerInterval: Hello Messages per Interval
	HelloMessagePerInterval *Multivalue `json:"helloMessagePerInterval,omitempty"`
	// Interval: Interval
	Interval *Multivalue `json:"interval,omitempty"`
	// JoinPruneMessagePerInterval: Join/Prune Messages per Interval
	JoinPruneMessagePerInterval *Multivalue `json:"joinPruneMessagePerInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RegisterMessagePerInterval: Register Messages Per Interval
	RegisterMessagePerInterval *Multivalue `json:"registerMessagePerInterval,omitempty"`
	// RegisterStopMessagePerInterval: Register Stop Messages Per Interval
	RegisterStopMessagePerInterval *Multivalue `json:"registerStopMessagePerInterval,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPimRouter) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPimRouter) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPimRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPimRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BootstrapMessagePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapMessagePerInterval",
		isMultivalue: true,
	})
	n.CRpAdvertiseMessagePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cRpAdvertiseMessagePerInterval",
		isMultivalue: true,
	})
	n.DiscardJoinPruneProcessing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardJoinPruneProcessing",
		isMultivalue: true,
	})
	n.EnableRateControl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRateControl",
		isMultivalue: true,
	})
	n.HelloMessagePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloMessagePerInterval",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.JoinPruneMessagePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "joinPruneMessagePerInterval",
		isMultivalue: true,
	})
	n.RegisterMessagePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "registerMessagePerInterval",
		isMultivalue: true,
	})
	n.RegisterStopMessagePerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "registerStopMessagePerInterval",
		isMultivalue: true,
	})
}

// GlobalsPortDownRate: Parameters used for controlling the rate of actions
type GlobalsPortDownRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPortDownRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPortDownRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPortDownRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPortDownRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsPortUpRate: Parameters used for controlling the rate of actions
type GlobalsPortUpRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPortUpRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPortUpRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPortUpRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPortUpRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsPppoxclient: PPPoX Client global and per-port settings
type GlobalsPppoxclient struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CreateInterfaces: Enable echo request/reply. This command applies only for PPPv4 clients.
	CreateInterfaces *Multivalue `json:"createInterfaces,omitempty"`
	// Ipv6GlobalAddressMode: When PPP/L2TP is stacked under DHCP, this option selects the protocol used to set the IPv6 global address on the PPP/L2TP-IPv6CP interfaces.
	Ipv6GlobalAddressMode *Multivalue `json:"ipv6GlobalAddressMode,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RaTimeout: Time to wait (in seconds) for Router Advertisment before NCP up.
	RaTimeout *Multivalue `json:"raTimeout,omitempty"`

	SessionLifetime *GlobalsSessionLifetime `json:"sessionLifetime,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate  *GlobalsStopRate    `json:"stopRate,omitempty"`
	TlvEditor []*GlobalsTlvEditor `json:"tlvEditor"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPppoxclient) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPppoxclient) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPppoxclient) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPppoxclient) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.CreateInterfaces.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "createInterfaces",
		isMultivalue: true,
	})
	n.Ipv6GlobalAddressMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6GlobalAddressMode",
		isMultivalue: true,
	})
	n.RaTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "raTimeout",
		isMultivalue: true,
	})
	n.SessionLifetime.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sessionLifetime",
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
	for i, o := range n.TlvEditor {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvEditor",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsPppoxserver: PPPoX Server global and per-port settings
type GlobalsPppoxserver struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPppoxserver) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPppoxserver) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPppoxserver) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPppoxserver) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsPredefined: Default template and profile for Flow Match.
type GlobalsPredefined struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath         *XPath                  `json:"xpath,omitempty"`
	MatchTemplate []*GlobalsMatchTemplate `json:"matchTemplate"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPredefined) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPredefined) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPredefined) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPredefined) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.MatchTemplate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchTemplate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsPreferences: TBD
type GlobalsPreferences struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AllowProtocolSessionStateLog: Enables logging each protocol session state change. This option is very heavy for performance.

	AllowProtocolSessionStateLog *bool `json:"allowProtocolSessionStateLog,omitempty"`
	// AutoSaveIntervalMin: Set the interval time in minutes in which the configuration will be saved automatically

	AutoSaveIntervalMin *float32 `json:"autoSaveIntervalMin,omitempty"`
	// AutoSaveLocation: Set the location where the configuration will be saved automatically

	AutoSaveLocation *string `json:"autoSaveLocation,omitempty"`
	// ClientTraceLevel: Set the IxNetwork Client side Log/Trace level

	ClientTraceLevel *string `json:"clientTraceLevel,omitempty"`
	// ConfigurationAtIxNetworkStartup: Controls which configuration to load when IxNetwork starts

	ConfigurationAtIxNetworkStartup *string `json:"configurationAtIxNetworkStartup,omitempty"`
	// ConnectPortsOnLoadConfig: TBD

	ConnectPortsOnLoadConfig *bool `json:"connectPortsOnLoadConfig,omitempty"`
	// DeleteDumpFilesOlderThan: Dump Files older than the days set are deleted automatically. Need to restart IxNetwork for this option to take effect.

	DeleteDumpFilesOlderThan *float32 `json:"deleteDumpFilesOlderThan,omitempty"`
	// EnableAutoSave: If true,saves the configuration automatically. IxNetwork wont prompt to open the auto backup file when running in TCL Server mode. For performance reasons users additionally have to add a decimal registry key ForceAutoSave in Computer/HKEY_CURRENT_USER/Software/Ixia Communications/IxNetwork/Debug to do the auto save. Doesnt work yet on Linux

	EnableAutoSave *bool `json:"enableAutoSave,omitempty"`
	// EnableCloudTools: Controls whether Cloud Tool options will be enabled or not. This is related to learning MAC / IP address for a topology running on VM ports, deployed in AWS

	EnableCloudTools *bool `json:"enableCloudTools,omitempty"`
	// IncludeTroubleshootingComments: Includes troubleshooting comments in the script

	IncludeTroubleshootingComments *bool `json:"includeTroubleshootingComments,omitempty"`
	// LatestConfigInDiagEnabled: TBD

	LatestConfigInDiagEnabled *bool `json:"latestConfigInDiagEnabled,omitempty"`
	// PhyMode: Set the media in Default Port Settings

	PhyMode *string `json:"phyMode,omitempty"`
	// PingChassisOnConnect: Controls whether to ping the chassis before connecting the ports. Must run IxNetwork in administrator mode

	PingChassisOnConnect *bool `json:"pingChassisOnConnect,omitempty"`
	// RebootPortsOnConnect: TBD

	RebootPortsOnConnect *bool `json:"rebootPortsOnConnect,omitempty"`
	// ReceiveMode: Set the receive mode in Default Port settings

	ReceiveMode *string `json:"receiveMode,omitempty"`
	// RecentChassisList: List of recently used chassis
	RecentChassisList []string `json:"recentChassisList"`
	// ResourceManagerLocation: Set the Resource Manager resources location

	ResourceManagerLocation *string `json:"resourceManagerLocation,omitempty"`
	// ScriptgenTextEditorPath: Set the text editor path for Scriptgen

	ScriptgenTextEditorPath *string `json:"scriptgenTextEditorPath,omitempty"`
	// StreamLogsToSyslogServer: Enables streaming Logs To Syslog Server

	StreamLogsToSyslogServer *bool `json:"streamLogsToSyslogServer,omitempty"`
	// SyslogHost: syslog host

	SyslogHost *string `json:"syslogHost,omitempty"`
	// SyslogPort: syslog Port

	SyslogPort *float32 `json:"syslogPort,omitempty"`
	// TransmitMode: Set the transmit mode in Default Port settings

	TransmitMode *string `json:"transmitMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPreferences) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPreferences) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPreferences) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPreferences) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsPtp: PTP global and per-port settings
type GlobalsPtp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// HopLimit: Hop Limit set for PTP packets over IPv6
	HopLimit *Multivalue `json:"hopLimit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Timestamps: Use PTP UTC timestamps, PTC Local Clock timestamps or Traffic engine timestamps
	Timestamps *Multivalue `json:"timestamps,omitempty"`
	// Tos: TOS/DSCP set for PTP packets over IPv4
	Tos *Multivalue `json:"tos,omitempty"`
	// TrafficClass: Traffic Class set for PTP packets over IPv6
	TrafficClass *Multivalue `json:"trafficClass,omitempty"`
	// Ttl: TTL set for PTP packets over IPv4
	Ttl *Multivalue `json:"ttl,omitempty"`

	StartRate *GlobalsPtpStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsPtpStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPtp) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPtp) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPtp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPtp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.HopLimit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hopLimit",
		isMultivalue: true,
	})
	n.Timestamps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timestamps",
		isMultivalue: true,
	})
	n.Tos.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tos",
		isMultivalue: true,
	})
	n.TrafficClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficClass",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsPtpStartRate: Parameters used for controlling the rate of actions
type GlobalsPtpStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPtpStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPtpStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPtpStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPtpStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsPtpStopRate: Parameters used for controlling the rate of actions
type GlobalsPtpStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsPtpStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsPtpStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsPtpStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsPtpStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsReconfigureRate: Parameters used for controlling the rate of actions
type GlobalsReconfigureRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsReconfigureRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsReconfigureRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsReconfigureRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsReconfigureRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsRestriction: Choices for field value
type GlobalsRestriction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Enum: Internal enumeration type to be used as value options

	Enum *string `json:"enum,omitempty"`
	// SingleValue: Restricts the field to single value pattern without overlays

	SingleValue *bool `json:"singleValue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsRestriction) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsRestriction) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsRestriction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsRestriction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsRsRate: Parameters used for controlling the rate of actions
type GlobalsRsRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsRsRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsRsRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsRsRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsRsRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsRsvpteIf: Rsvp Port Specific Data
type GlobalsRsvpteIf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsRsvpteIf) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsRsvpteIf) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsRsvpteIf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsRsvpteIf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsRsvpteLsps: Rsvp LSPs Port Specific Data
type GlobalsRsvpteLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DisableRSVPSignal: Disable RSVP Signaling For PCEP
	DisableRSVPSignal *Multivalue `json:"disableRSVPSignal,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsRsvpteLspsStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsRsvpteLspsStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsRsvpteLsps) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsRsvpteLsps) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsRsvpteLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsRsvpteLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DisableRSVPSignal.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableRSVPSignal",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsRsvpteLspsStartRate: Parameters used for controlling the rate of actions
type GlobalsRsvpteLspsStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsRsvpteLspsStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsRsvpteLspsStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsRsvpteLspsStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsRsvpteLspsStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsRsvpteLspsStopRate: Parameters used for controlling the rate of actions
type GlobalsRsvpteLspsStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsRsvpteLspsStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsRsvpteLspsStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsRsvpteLspsStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsRsvpteLspsStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsSessionLifetime: Parameters used for controlling the lifetime and restart capabilities of sessions
type GlobalsSessionLifetime struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableLifetime: Enables session for lifetime.
	EnableLifetime *Multivalue `json:"enableLifetime,omitempty"`
	// EnableRestart: Enables automatic session restart after the stop at lifetime expiry.
	EnableRestart *Multivalue `json:"enableRestart,omitempty"`
	// MaxLifetime: Maximum session lifetime (in seconds).
	MaxLifetime *Multivalue `json:"maxLifetime,omitempty"`
	// MaxRestarts: Maximum number of times each session is automatically restarted.
	MaxRestarts *Multivalue `json:"maxRestarts,omitempty"`
	// MinLifetime: Minimum session lifetime (in seconds).
	MinLifetime *Multivalue `json:"minLifetime,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// UnlimitedRestarts: Allows each session to always be automatically restarted.
	UnlimitedRestarts *Multivalue `json:"unlimitedRestarts,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsSessionLifetime) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsSessionLifetime) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsSessionLifetime) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsSessionLifetime) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLifetime",
		isMultivalue: true,
	})
	n.EnableRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRestart",
		isMultivalue: true,
	})
	n.MaxLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLifetime",
		isMultivalue: true,
	})
	n.MaxRestarts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRestarts",
		isMultivalue: true,
	})
	n.MinLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minLifetime",
		isMultivalue: true,
	})
	n.UnlimitedRestarts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unlimitedRestarts",
		isMultivalue: true,
	})
}

// GlobalsStartRate: Parameters used for controlling the rate of actions
type GlobalsStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsStartRateAndFlowControl: Parameters used for controlling the rate of actions
type GlobalsStartRateAndFlowControl struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStartRateAndFlowControl) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStartRateAndFlowControl) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStartRateAndFlowControl) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStartRateAndFlowControl) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsStaticLag: Lacp Port Specific Data
type GlobalsStaticLag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStaticLag) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStaticLag) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStaticLag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStaticLag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsStaticMacsec: Static MACsec Port Specific Data
type GlobalsStaticMacsec struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	StartRate *GlobalsStaticMacsecStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsStaticMacsecStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStaticMacsec) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStaticMacsec) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStaticMacsec) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStaticMacsec) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsStaticMacsecStartRate: Parameters used for controlling the rate of actions
type GlobalsStaticMacsecStartRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStaticMacsecStartRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStaticMacsecStartRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStaticMacsecStartRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStaticMacsecStartRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsStaticMacsecStopRate: Parameters used for controlling the rate of actions
type GlobalsStaticMacsecStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated(rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStaticMacsecStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStaticMacsecStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStaticMacsecStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStaticMacsecStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsStopRate: Parameters used for controlling the rate of actions
type GlobalsStopRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStopRate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStopRate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStopRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStopRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsStopRateAndFlowControl: Parameters used for controlling the rate of actions
type GlobalsStopRateAndFlowControl struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enabled
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Interval: The time interval in milliseconds during which the rate is calculated (rate = count/interval)
	Interval *Multivalue `json:"interval,omitempty"`
	// MaxOutstanding: The number of triggered instances of an action that are still awaiting a response or completion
	MaxOutstanding *Multivalue `json:"maxOutstanding,omitempty"`
	// Rate: Number of times an action is triggered per time interval
	Rate *Multivalue `json:"rate,omitempty"`
	// ScaleMode: Indicates whether the control is specified per port or per device group.

	ScaleMode *string `json:"scaleMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsStopRateAndFlowControl) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsStopRateAndFlowControl) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsStopRateAndFlowControl) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsStopRateAndFlowControl) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	n.Interval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interval",
		isMultivalue: true,
	})
	n.MaxOutstanding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxOutstanding",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// GlobalsSubTlv: Sub Tlv container
type GlobalsSubTlv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Indicates whether this can be multiplied in the TLV definition

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Flag indicating whether this is required or not

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`

	Length *GlobalsLength `json:"length,omitempty"`

	Type_ *GlobalsType `json:"type,omitempty"`

	Value *GlobalsValue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsSubTlv) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsSubTlv) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsSubTlv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsSubTlv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Length.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "length",
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "type",
	})
	n.Value.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "value",
	})
}

// GlobalsTemplate: Tlv template container
type GlobalsTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: The name of the template

	Name *string       `json:"name,omitempty"`
	Tlv  []*GlobalsTlv `json:"tlv"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tlv {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlv",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsTestworkflow: TBD
type GlobalsTestworkflow struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsTestworkflow) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsTestworkflow) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsTestworkflow) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsTestworkflow) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// GlobalsTlv: Tlv container
type GlobalsTlv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// IncludeInMessages: Include the TLV in these protocol messages
	IncludeInMessages []string `json:"includeInMessages"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRepeatable: Indicates whether this can be multiplied in the TLV definition

	IsRepeatable *bool `json:"isRepeatable,omitempty"`
	// IsRequired: Flag indicating whether this is required or not

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`

	Length *GlobalsLength `json:"length,omitempty"`

	Type_ *GlobalsType `json:"type,omitempty"`

	Value *GlobalsValue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsTlv) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsTlv) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsTlv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsTlv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Length.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "length",
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "type",
	})
	n.Value.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "value",
	})
}

// GlobalsTlvEditor: Tlv template functionality is contained under this node
type GlobalsTlvEditor struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath    *XPath             `json:"xpath,omitempty"`
	Defaults []*GlobalsDefaults `json:"defaults"`
	Template []*GlobalsTemplate `json:"template"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsTlvEditor) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsTlvEditor) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsTlvEditor) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsTlvEditor) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Defaults {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "defaults",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Template {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "template",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsTopology: Topology port level configuration
type GlobalsTopology struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// NgpfProtocolRateMode: Decides whether protocol's sessions will started in normal or smooth mode

	NgpfProtocolRateMode *string `json:"ngpfProtocolRateMode,omitempty"`
	// ProtocolStackingMode: Decides whether protocol's sessions will started sequentially or parallelly across the layers

	ProtocolStackingMode *string `json:"protocolStackingMode,omitempty"`

	Ancp *GlobalsAncp `json:"ancp,omitempty"`

	BfdRouter *GlobalsBfdRouter `json:"bfdRouter,omitempty"`

	BgpIpv4Peer *GlobalsBgpIpv4Peer `json:"bgpIpv4Peer,omitempty"`

	BgpIpv6Peer *GlobalsBgpIpv6Peer `json:"bgpIpv6Peer,omitempty"`

	BondedGRE *GlobalsBondedGre `json:"bondedGRE,omitempty"`

	CfmBridge *GlobalsCfmBridge `json:"cfmBridge,omitempty"`

	Dhcpv4client *GlobalsDhcpv4client `json:"dhcpv4client,omitempty"`

	Dhcpv4relayAgent *GlobalsDhcpv4relayAgent `json:"dhcpv4relayAgent,omitempty"`

	Dhcpv4server *GlobalsDhcpv4server `json:"dhcpv4server,omitempty"`

	Dhcpv6client *GlobalsDhcpv6client `json:"dhcpv6client,omitempty"`

	Dhcpv6relayAgent *GlobalsDhcpv6relayAgent `json:"dhcpv6relayAgent,omitempty"`

	Dhcpv6server *GlobalsDhcpv6server `json:"dhcpv6server,omitempty"`

	DotOneX *GlobalsDotOneX `json:"dotOneX,omitempty"`

	ECpriRe *GlobalsECpriRe `json:"eCpriRe,omitempty"`

	ECpriRec *GlobalsECpriRec `json:"eCpriRec,omitempty"`

	EcpriRec *GlobalsEcpriRec `json:"ecpriRec,omitempty"`

	Ere *GlobalsEre `json:"ere,omitempty"`

	Esmc *GlobalsEsmc `json:"esmc,omitempty"`

	Ethernet *GlobalsEthernet `json:"ethernet,omitempty"`

	Geneve *GlobalsGeneve `json:"geneve,omitempty"`

	Greoipv4 *GlobalsGreoipv4 `json:"greoipv4,omitempty"`

	Greoipv6 *GlobalsGreoipv6 `json:"greoipv6,omitempty"`

	IgmpHost *GlobalsIgmpHost `json:"igmpHost,omitempty"`

	IgmpQuerier *GlobalsIgmpQuerier `json:"igmpQuerier,omitempty"`

	Ipv4 *GlobalsIpv4 `json:"ipv4,omitempty"`

	Ipv6 *GlobalsIpv6 `json:"ipv6,omitempty"`

	Ipv6Autoconfiguration *GlobalsIpv6Autoconfiguration  `json:"ipv6Autoconfiguration,omitempty"`
	IsisFabricPathRouter  []*GlobalsIsisFabricPathRouter `json:"isisFabricPathRouter"`
	IsisL3Router          []*GlobalsIsisL3Router         `json:"isisL3Router"`

	IsisSpbRouter   *GlobalsIsisSpbRouter     `json:"isisSpbRouter,omitempty"`
	IsisTrillRouter []*GlobalsIsisTrillRouter `json:"isisTrillRouter"`

	Lac *GlobalsLac `json:"lac,omitempty"`

	Lacp *GlobalsLacp `json:"lacp,omitempty"`

	Lagportlacp *GlobalsLagportlacp `json:"lagportlacp,omitempty"`

	Lagportstaticlag *GlobalsLagportstaticlag `json:"lagportstaticlag,omitempty"`

	LdpBasicRouter *GlobalsLdpBasicRouter `json:"ldpBasicRouter,omitempty"`

	LdpBasicRouterV6 *GlobalsLdpBasicRouterV6 `json:"ldpBasicRouterV6,omitempty"`

	LdpTargetedRouter *GlobalsLdpTargetedRouter `json:"ldpTargetedRouter,omitempty"`

	LdpTargetedRouterV6 *GlobalsLdpTargetedRouterV6 `json:"ldpTargetedRouterV6,omitempty"`

	LightweightDhcpv6relayAgent *GlobalsLightweightDhcpv6relayAgent `json:"lightweightDhcpv6relayAgent,omitempty"`

	Lns *GlobalsLns `json:"lns,omitempty"`

	Macsec *GlobalsMacsec `json:"macsec,omitempty"`

	Mka *GlobalsMka `json:"mka,omitempty"`

	MldHost *GlobalsMldHost `json:"mldHost,omitempty"`

	MldQuerier *GlobalsMldQuerier `json:"mldQuerier,omitempty"`

	MsrpListener *GlobalsMsrpListener `json:"msrpListener,omitempty"`

	MsrpTalker *GlobalsMsrpTalker `json:"msrpTalker,omitempty"`

	NetconfClient *GlobalsNetconfClient `json:"netconfClient,omitempty"`

	NetconfServer *GlobalsNetconfServer `json:"netconfServer,omitempty"`

	Ntpclock *GlobalsNtpclock `json:"ntpclock,omitempty"`

	OpenFlowChannel *GlobalsOpenFlowChannel `json:"openFlowChannel,omitempty"`

	OpenFlowController *GlobalsOpenFlowController `json:"openFlowController,omitempty"`
	Ospfv2Router       []*GlobalsOspfv2Router     `json:"ospfv2Router"`

	Ospfv3Router *GlobalsOspfv3Router `json:"ospfv3Router,omitempty"`

	Ovsdbcontroller *GlobalsOvsdbcontroller `json:"ovsdbcontroller,omitempty"`

	Ovsdbserver *GlobalsOvsdbserver `json:"ovsdbserver,omitempty"`

	Pcc *GlobalsPcc `json:"pcc,omitempty"`

	Pce *GlobalsPce `json:"pce,omitempty"`

	PimRouter *GlobalsPimRouter `json:"pimRouter,omitempty"`

	Pppoxclient *GlobalsPppoxclient `json:"pppoxclient,omitempty"`

	Pppoxserver *GlobalsPppoxserver `json:"pppoxserver,omitempty"`

	Ptp *GlobalsPtp `json:"ptp,omitempty"`

	RsvpteIf *GlobalsRsvpteIf `json:"rsvpteIf,omitempty"`

	RsvpteLsps *GlobalsRsvpteLsps `json:"rsvpteLsps,omitempty"`

	StaticLag *GlobalsStaticLag `json:"staticLag,omitempty"`

	StaticMacsec *GlobalsStaticMacsec `json:"staticMacsec,omitempty"`

	Vxlan *GlobalsVxlan `json:"vxlan,omitempty"`

	Vxlanv6 *GlobalsVxlanv6 `json:"vxlanv6,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsTopology) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsTopology) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsTopology) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsTopology) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Ancp.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ancp",
	})
	n.BfdRouter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bfdRouter",
	})
	n.BgpIpv4Peer.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpIpv4Peer",
	})
	n.BgpIpv6Peer.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpIpv6Peer",
	})
	n.BondedGRE.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bondedGRE",
	})
	n.CfmBridge.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "cfmBridge",
	})
	n.Dhcpv4client.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcpv4client",
	})
	n.Dhcpv4relayAgent.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcpv4relayAgent",
	})
	n.Dhcpv4server.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcpv4server",
	})
	n.Dhcpv6client.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcpv6client",
	})
	n.Dhcpv6relayAgent.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcpv6relayAgent",
	})
	n.Dhcpv6server.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcpv6server",
	})
	n.DotOneX.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dotOneX",
	})
	n.ECpriRe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "eCpriRe",
	})
	n.ECpriRec.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "eCpriRec",
	})
	n.EcpriRec.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ecpriRec",
	})
	n.Ere.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ere",
	})
	n.Esmc.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "esmc",
	})
	n.Ethernet.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ethernet",
	})
	n.Geneve.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "geneve",
	})
	n.Greoipv4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "greoipv4",
	})
	n.Greoipv6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "greoipv6",
	})
	n.IgmpHost.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "igmpHost",
	})
	n.IgmpQuerier.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "igmpQuerier",
	})
	n.Ipv4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ipv4",
	})
	n.Ipv6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ipv6",
	})
	n.Ipv6Autoconfiguration.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ipv6Autoconfiguration",
	})
	for i, o := range n.IsisFabricPathRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisFabricPathRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3Router {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3Router",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.IsisSpbRouter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisSpbRouter",
	})
	for i, o := range n.IsisTrillRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Lac.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lac",
	})
	n.Lacp.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lacp",
	})
	n.Lagportlacp.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lagportlacp",
	})
	n.Lagportstaticlag.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lagportstaticlag",
	})
	n.LdpBasicRouter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpBasicRouter",
	})
	n.LdpBasicRouterV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpBasicRouterV6",
	})
	n.LdpTargetedRouter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpTargetedRouter",
	})
	n.LdpTargetedRouterV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpTargetedRouterV6",
	})
	n.LightweightDhcpv6relayAgent.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lightweightDhcpv6relayAgent",
	})
	n.Lns.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lns",
	})
	n.Macsec.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "macsec",
	})
	n.Mka.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "mka",
	})
	n.MldHost.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "mldHost",
	})
	n.MldQuerier.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "mldQuerier",
	})
	n.MsrpListener.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "msrpListener",
	})
	n.MsrpTalker.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "msrpTalker",
	})
	n.NetconfClient.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netconfClient",
	})
	n.NetconfServer.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netconfServer",
	})
	n.Ntpclock.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ntpclock",
	})
	n.OpenFlowChannel.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "openFlowChannel",
	})
	n.OpenFlowController.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "openFlowController",
	})
	for i, o := range n.Ospfv2Router {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv2Router",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Ospfv3Router.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ospfv3Router",
	})
	n.Ovsdbcontroller.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ovsdbcontroller",
	})
	n.Ovsdbserver.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ovsdbserver",
	})
	n.Pcc.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pcc",
	})
	n.Pce.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pce",
	})
	n.PimRouter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pimRouter",
	})
	n.Pppoxclient.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pppoxclient",
	})
	n.Pppoxserver.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pppoxserver",
	})
	n.Ptp.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ptp",
	})
	n.RsvpteIf.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpteIf",
	})
	n.RsvpteLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpteLsps",
	})
	n.StaticLag.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "staticLag",
	})
	n.StaticMacsec.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "staticMacsec",
	})
	n.Vxlan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "vxlan",
	})
	n.Vxlanv6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "vxlanv6",
	})
}

// GlobalsType: Tlv type container
type GlobalsType struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRequired: Indicates whether this is required or not

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the node

	Name   *string          `json:"name,omitempty"`
	Object []*GlobalsObject `json:"object"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsType) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsType) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsType) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsType) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Object {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "object",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsValue: Tlv value container
type GlobalsValue struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: The name of the object

	Name   *string          `json:"name,omitempty"`
	Object []*GlobalsObject `json:"object"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsValue) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsValue) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsValue) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsValue) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Object {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "object",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// GlobalsVxlan: VXLAN global and per-port settings
type GlobalsVxlan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IgmpMode: Indicates the IGMP version used by VXLAN interfaces
	IgmpMode *Multivalue `json:"igmpMode,omitempty"`
	// InnerFrameMinimumSize: Pad inner frame with 0 in order to have inner frame of minumum specified size.
	InnerFrameMinimumSize *Multivalue `json:"innerFrameMinimumSize,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OuterIpDestMode: Indicates what is the outer destination IP in the generated fpga traffic
	OuterIpDestMode *Multivalue `json:"outerIpDestMode,omitempty"`
	// UdpDest: UDP Destination Port.
	UdpDest *Multivalue `json:"udp_dest,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsVxlan) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsVxlan) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsVxlan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsVxlan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.IgmpMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "igmpMode",
		isMultivalue: true,
	})
	n.InnerFrameMinimumSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "innerFrameMinimumSize",
		isMultivalue: true,
	})
	n.OuterIpDestMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outerIpDestMode",
		isMultivalue: true,
	})
	n.UdpDest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udp_dest",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// GlobalsVxlanv6: VXLAN global and per-port settings
type GlobalsVxlanv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// InnerFrameMinimumSize: Pad inner frame with 0 in order to have inner frame of minumum specified size.
	InnerFrameMinimumSize *Multivalue `json:"innerFrameMinimumSize,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OuterIpDestMode: Indicates what is the outer destination IP in the generated fpga traffic
	OuterIpDestMode *Multivalue `json:"outerIpDestMode,omitempty"`
	// UdpDest: UDP Destination Port.
	UdpDest *Multivalue `json:"udp_dest,omitempty"`

	StartRate *GlobalsStartRate `json:"startRate,omitempty"`

	StopRate *GlobalsStopRate `json:"stopRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *GlobalsVxlanv6) XPath() *XPath {
	return n.Xpath
}

func (n *GlobalsVxlanv6) setRestID(id string) {
	n.RestID = id
}

func (n *GlobalsVxlanv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *GlobalsVxlanv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.InnerFrameMinimumSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "innerFrameMinimumSize",
		isMultivalue: true,
	})
	n.OuterIpDestMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outerIpDestMode",
		isMultivalue: true,
	})
	n.UdpDest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udp_dest",
		isMultivalue: true,
	})
	n.StartRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "startRate",
	})
	n.StopRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stopRate",
	})
}

// Ixnetwork: TBD
type Ixnetwork struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`

	AvailableHardware *AvailableHardware `json:"availableHardware,omitempty"`

	Globals    *Globals      `json:"globals,omitempty"`
	Lag        []*Lag        `json:"lag"`
	Locations  []*Locations  `json:"locations"`
	Multivalue []*Multivalue `json:"multivalue"`

	Statistics *Statistics `json:"statistics,omitempty"`
	Topology   []*Topology `json:"topology"`

	Traffic *Traffic `json:"traffic,omitempty"`
	Vport   []*Vport `json:"vport"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Ixnetwork) XPath() *XPath {
	return n.Xpath
}

func (n *Ixnetwork) setRestID(id string) {
	n.RestID = id
}

func (n *Ixnetwork) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Ixnetwork) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AvailableHardware.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "availableHardware",
	})
	n.Globals.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "globals",
	})
	for i, o := range n.Lag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Locations {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "locations",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Multivalue {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "multivalue",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Statistics.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "statistics",
	})
	for i, o := range n.Topology {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "topology",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Traffic.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "traffic",
	})
	for i, o := range n.Vport {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vport",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// Lag: Represents a Ixia port in CPF framework
type Lag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Vports: Virtual port information.
	Vports []string `json:"vports"`
	// VportsRefs: Track refs for Vports.
	VportsRefs []Href `json:"-"`

	LagMode *LagLagMode `json:"lagMode,omitempty"`

	ProtocolStack *LagProtocolStack `json:"protocolStack,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Lag) XPath() *XPath {
	return n.Xpath
}

func (n *Lag) setRestID(id string) {
	n.RestID = id
}

func (n *Lag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Lag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LagMode.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lagMode",
	})
	n.ProtocolStack.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "protocolStack",
	})
}

// LagConnector: Connects scenario elements
type LagConnector struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedTo: Scenario element this connector is connecting to

	ConnectedTo *string `json:"connectedTo,omitempty"`
	// ConnectedToRefs: Track refs for ConnectedTo.
	ConnectedToRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagConnector) XPath() *XPath {
	return n.Xpath
}

func (n *LagConnector) setRestID(id string) {
	n.RestID = id
}

func (n *LagConnector) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagConnector) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// LagEthernet: Ethernet
type LagEthernet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableVlans: Enables VLANs for the sessions.
	EnableVlans *Multivalue `json:"enableVlans,omitempty"`
	// Mac: MAC addresses of the devices
	Mac *Multivalue `json:"mac,omitempty"`
	// Mtu: Maximum transmission unit, min=68, max=16000
	Mtu *Multivalue `json:"mtu,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NotifyMACMove: Flag to determine if MAC move notification to be sent

	NotifyMACMove *bool `json:"notifyMACMove,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UseVlans: Flag to determine whether VLANs are enabled

	UseVlans *bool `json:"useVlans,omitempty"`
	// VlanCount: Number of active VLANs

	VlanCount *float32 `json:"vlanCount,omitempty"`

	Connector        *LagConnector          `json:"connector,omitempty"`
	Lagportlacp      []*LagLagportlacp      `json:"lagportlacp"`
	Lagportstaticlag []*LagLagportstaticlag `json:"lagportstaticlag"`

	PbbEVpnParameter *LagPbbEVpnParameter `json:"pbbEVpnParameter,omitempty"`
	Tag              []*LagTag            `json:"tag"`
	Vlan             []*LagVlan           `json:"vlan"`

	VpnParameter *LagVpnParameter `json:"vpnParameter,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagEthernet) XPath() *XPath {
	return n.Xpath
}

func (n *LagEthernet) setRestID(id string) {
	n.RestID = id
}

func (n *LagEthernet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagEthernet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableVlans.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlans",
		isMultivalue: true,
	})
	n.Mac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mac",
		isMultivalue: true,
	})
	n.Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtu",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Lagportlacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportlacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportstaticlag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportstaticlag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.PbbEVpnParameter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pbbEVpnParameter",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.VpnParameter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "vpnParameter",
	})
}

// LagLagMode: Represents the underlying LAG Protocols
type LagLagMode struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// LagProtocol: LAG Protocol
	LagProtocol *Multivalue `json:"lagProtocol,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagLagMode) XPath() *XPath {
	return n.Xpath
}

func (n *LagLagMode) setRestID(id string) {
	n.RestID = id
}

func (n *LagLagMode) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagLagMode) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LagProtocol.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lagProtocol",
		isMultivalue: true,
	})
}

// LagLagportlacp: TBD
type LagLagportlacp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ActorKey: Actor Key
	ActorKey *Multivalue `json:"actorKey,omitempty"`
	// ActorPortNumber: Actor Port Number
	ActorPortNumber *Multivalue `json:"actorPortNumber,omitempty"`
	// ActorPortPriority: Actor Port Priority
	ActorPortPriority *Multivalue `json:"actorPortPriority,omitempty"`
	// ActorSystemId: Actor System Id
	ActorSystemId *Multivalue `json:"actorSystemId,omitempty"`
	// ActorSystemPriority: Actor System Priority
	ActorSystemPriority *Multivalue `json:"actorSystemPriority,omitempty"`
	// AdministrativeKey: Administrative Key
	AdministrativeKey *Multivalue `json:"administrativeKey,omitempty"`
	// AggregationFlagState: Aggregation Flag State
	AggregationFlagState *Multivalue `json:"aggregationFlagState,omitempty"`
	// CollectingFlag: Collecting Flag
	CollectingFlag *Multivalue `json:"collectingFlag,omitempty"`
	// CollectorsMaxdelay: Collectors Maximum Delay
	CollectorsMaxdelay *Multivalue `json:"collectorsMaxdelay,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DistributingFlag: Distributing Flag
	DistributingFlag *Multivalue `json:"distributingFlag,omitempty"`
	// InterMarkerPDUDelay: Inter Marker PDU Delay (sec)
	InterMarkerPDUDelay *Multivalue `json:"interMarkerPDUDelay,omitempty"`
	// InterMarkerPDUDelayRandomMax: Inter Marker PDU Delay Random Max (sec)
	InterMarkerPDUDelayRandomMax *Multivalue `json:"interMarkerPDUDelayRandomMax,omitempty"`
	// InterMarkerPDUDelayRandomMin: Inter Marker PDU Delay Random Min (sec)
	InterMarkerPDUDelayRandomMin *Multivalue `json:"interMarkerPDUDelayRandomMin,omitempty"`
	// LacpActivity: LACP Actvity
	LacpActivity *Multivalue `json:"lacpActivity,omitempty"`
	// LacpduPeriodicTimeInterval: Lacp PDU Periodic Time Interval
	LacpduPeriodicTimeInterval *Multivalue `json:"lacpduPeriodicTimeInterval,omitempty"`
	// LacpduTimeout: Lacp PDU Timeout
	LacpduTimeout *Multivalue `json:"lacpduTimeout,omitempty"`
	// MarkerRequestMode: Marker Request Mode
	MarkerRequestMode *Multivalue `json:"markerRequestMode,omitempty"`
	// MarkerResponseWaitTime: Marker Response Wait Time (sec)
	MarkerResponseWaitTime *Multivalue `json:"markerResponseWaitTime,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeriodicSendingOfMarkerRequest: Periodic Sending Of Marker Request
	PeriodicSendingOfMarkerRequest *Multivalue `json:"periodicSendingOfMarkerRequest,omitempty"`
	// SendMarkerRequestOnLagChange: Send Marker Request On Lag Change
	SendMarkerRequestOnLagChange *Multivalue `json:"sendMarkerRequestOnLagChange,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SupportRespondingToMarker: Support Responding To Marker
	SupportRespondingToMarker *Multivalue `json:"supportRespondingToMarker,omitempty"`
	// SynchronizationFlag: Synchronization Flag
	SynchronizationFlag *Multivalue `json:"synchronizationFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagLagportlacp) XPath() *XPath {
	return n.Xpath
}

func (n *LagLagportlacp) setRestID(id string) {
	n.RestID = id
}

func (n *LagLagportlacp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagLagportlacp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActorKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorKey",
		isMultivalue: true,
	})
	n.ActorPortNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorPortNumber",
		isMultivalue: true,
	})
	n.ActorPortPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorPortPriority",
		isMultivalue: true,
	})
	n.ActorSystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorSystemId",
		isMultivalue: true,
	})
	n.ActorSystemPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorSystemPriority",
		isMultivalue: true,
	})
	n.AdministrativeKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administrativeKey",
		isMultivalue: true,
	})
	n.AggregationFlagState.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregationFlagState",
		isMultivalue: true,
	})
	n.CollectingFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "collectingFlag",
		isMultivalue: true,
	})
	n.CollectorsMaxdelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "collectorsMaxdelay",
		isMultivalue: true,
	})
	n.DistributingFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distributingFlag",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelay",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelayRandomMax.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelayRandomMax",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelayRandomMin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelayRandomMin",
		isMultivalue: true,
	})
	n.LacpActivity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpActivity",
		isMultivalue: true,
	})
	n.LacpduPeriodicTimeInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpduPeriodicTimeInterval",
		isMultivalue: true,
	})
	n.LacpduTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpduTimeout",
		isMultivalue: true,
	})
	n.MarkerRequestMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "markerRequestMode",
		isMultivalue: true,
	})
	n.MarkerResponseWaitTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "markerResponseWaitTime",
		isMultivalue: true,
	})
	n.PeriodicSendingOfMarkerRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicSendingOfMarkerRequest",
		isMultivalue: true,
	})
	n.SendMarkerRequestOnLagChange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendMarkerRequestOnLagChange",
		isMultivalue: true,
	})
	n.SupportRespondingToMarker.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportRespondingToMarker",
		isMultivalue: true,
	})
	n.SynchronizationFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "synchronizationFlag",
		isMultivalue: true,
	})
}

// LagLagportstaticlag: TBD
type LagLagportstaticlag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// LagId: LAG ID
	LagId *Multivalue `json:"lagId,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagLagportstaticlag) XPath() *XPath {
	return n.Xpath
}

func (n *LagLagportstaticlag) setRestID(id string) {
	n.RestID = id
}

func (n *LagLagportstaticlag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagLagportstaticlag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lagId",
		isMultivalue: true,
	})
}

// LagPbbEVpnParameter: PBB-EVPN
type LagPbbEVpnParameter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// BMac: Broadcast MAC addresses of the devices
	BMac *Multivalue `json:"bMac,omitempty"`
	// UsePbbEVpnParameters: Flag to determine whether optional PBB EVPN parameters are provided.

	UsePbbEVpnParameters *bool `json:"usePbbEVpnParameters,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagPbbEVpnParameter) XPath() *XPath {
	return n.Xpath
}

func (n *LagPbbEVpnParameter) setRestID(id string) {
	n.RestID = id
}

func (n *LagPbbEVpnParameter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagPbbEVpnParameter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMac",
		isMultivalue: true,
	})
}

// LagProtocolStack: Describes a set of network devices with similar configuration and the same multiplicity for devices behind.
type LagProtocolStack struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enables/disables device.
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Multiplier: Number of device instances per parent device instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name     *string        `json:"name,omitempty"`
	Ethernet []*LagEthernet `json:"ethernet"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagProtocolStack) XPath() *XPath {
	return n.Xpath
}

func (n *LagProtocolStack) setRestID(id string) {
	n.RestID = id
}

func (n *LagProtocolStack) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagProtocolStack) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// LagTag: Tag configuration
type LagTag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Id_: the tag ids that this entity will use/publish
	Id_ *Multivalue `json:"__id__,omitempty"`
	// Enabled: Enables/disables tags

	Enabled *bool `json:"enabled,omitempty"`
	// Name: specifies the name of the tag the entity will be part of

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagTag) XPath() *XPath {
	return n.Xpath
}

func (n *LagTag) setRestID(id string) {
	n.RestID = id
}

func (n *LagTag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagTag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Id_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "__id__",
		isMultivalue: true,
	})
}

// LagVlan: VLAN
type LagVlan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Priority: 3-bit user priority field in the VLAN tag.
	Priority *Multivalue `json:"priority,omitempty"`
	// Tpid: 16-bit Tag Protocol Identifier (TPID) or EtherType in the VLAN tag.
	Tpid *Multivalue `json:"tpid,omitempty"`
	// VlanId: 12-bit VLAN ID in the VLAN tag.
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagVlan) XPath() *XPath {
	return n.Xpath
}

func (n *LagVlan) setRestID(id string) {
	n.RestID = id
}

func (n *LagVlan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagVlan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.Tpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tpid",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// LagVpnParameter: VPN
type LagVpnParameter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// SiteId: VPN Site Identifier
	SiteId *Multivalue `json:"siteId,omitempty"`
	// UseVpnParameters: Flag to determine whether optional VPN parameters are provided.

	UseVpnParameters *bool `json:"useVpnParameters,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LagVpnParameter) XPath() *XPath {
	return n.Xpath
}

func (n *LagVpnParameter) setRestID(id string) {
	n.RestID = id
}

func (n *LagVpnParameter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LagVpnParameter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SiteId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "siteId",
		isMultivalue: true,
	})
}

// Locations: TBD
type Locations struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// CableLength: TBD

	CableLength *float32 `json:"cableLength,omitempty"`
	// ChainTopology: TBD

	ChainTopology *string `json:"chainTopology,omitempty"`
	// Hostname: TBD

	Hostname *string `json:"hostname,omitempty"`
	// MasterDevice: TBD

	MasterDevice *string `json:"masterDevice,omitempty"`
	// SequenceId: TBD

	SequenceId               *float32                             `json:"sequenceId,omitempty"`
	FrontPanelResourceGroups []*LocationsFrontPanelResourceGroups `json:"frontPanelResourceGroups"`
	Ports                    []*LocationsPorts                    `json:"ports"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Locations) XPath() *XPath {
	return n.Xpath
}

func (n *Locations) setRestID(id string) {
	n.RestID = id
}

func (n *Locations) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Locations) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.FrontPanelResourceGroups {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "frontPanelResourceGroups",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ports {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ports",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// LocationsFrontPanelResourceGroups: TBD
type LocationsFrontPanelResourceGroups struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LocationsFrontPanelResourceGroups) XPath() *XPath {
	return n.Xpath
}

func (n *LocationsFrontPanelResourceGroups) setRestID(id string) {
	n.RestID = id
}

func (n *LocationsFrontPanelResourceGroups) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LocationsFrontPanelResourceGroups) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// LocationsPorts: TBD
type LocationsPorts struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *LocationsPorts) XPath() *XPath {
	return n.Xpath
}

func (n *LocationsPorts) setRestID(id string) {
	n.RestID = id
}

func (n *LocationsPorts) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *LocationsPorts) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// Multivalue: The multivalue node encapsulates all the options of an attribute that has a type of kMultiValue
type Multivalue struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ClearOverlays: Setting clearOverlays to true will clear all overlays anytime this attribute or any other attribute is set

	ClearOverlays *bool `json:"clearOverlays,omitempty"`
	// Pattern: Used to set the pattern. Setting this attribute and committing the change will use default values for the new pattern. The recommended way is to switch the pattern by adding one of the optional nodes below the multivalue.

	Pattern *string `json:"pattern,omitempty"`

	Alternate *MultivalueAlternate `json:"alternate,omitempty"`

	Counter *MultivalueCounter `json:"counter,omitempty"`

	Custom *MultivalueCustom `json:"custom,omitempty"`

	CustomDistributed *MultivalueCustomDistributed `json:"customDistributed,omitempty"`

	Distributed *MultivalueDistributed `json:"distributed,omitempty"`
	Nest        []*MultivalueNest      `json:"nest"`
	Overlay     []*MultivalueOverlay   `json:"overlay"`

	Random *MultivalueRandom `json:"random,omitempty"`

	RepeatableRandom *MultivalueRepeatableRandom `json:"repeatableRandom,omitempty"`

	RepeatableRandomRange *MultivalueRepeatableRandomRange `json:"repeatableRandomRange,omitempty"`

	Shared *MultivalueShared `json:"shared,omitempty"`

	SingleValue *MultivalueSingleValue `json:"singleValue,omitempty"`

	String *MultivalueString `json:"string,omitempty"`

	Subset *MultivalueSubset `json:"subset,omitempty"`

	ValueList *MultivalueValueList `json:"valueList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Multivalue) XPath() *XPath {
	return n.Xpath
}

func (n *Multivalue) setRestID(id string) {
	n.RestID = id
}

func (n *Multivalue) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Multivalue) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Alternate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "alternate",
	})
	n.Counter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "counter",
	})
	n.Custom.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "custom",
	})
	n.CustomDistributed.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "customDistributed",
	})
	n.Distributed.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "distributed",
	})
	for i, o := range n.Nest {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "nest",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Overlay {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "overlay",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Random.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "random",
	})
	n.RepeatableRandom.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "repeatableRandom",
	})
	n.RepeatableRandomRange.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "repeatableRandomRange",
	})
	n.Shared.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "shared",
	})
	n.SingleValue.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "singleValue",
	})
	n.String.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "string",
	})
	n.Subset.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "subset",
	})
	n.ValueList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "valueList",
	})
}

// MultivalueAlternate: The alternate node is an optional node used to create an alternating pattern
type MultivalueAlternate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: The starting value used for the alternating pattern

	Value *string `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueAlternate) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueAlternate) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueAlternate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueAlternate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueCounter: The counter node is an optional node that used to create an incrementing or decrementing pattern
type MultivalueCounter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Direction: The direction in which the start value is stepped in the counter pattern

	Direction *string `json:"direction,omitempty"`
	// Start: The starting value used in the counter pattern

	Start *string `json:"start,omitempty"`
	// Step: The step value used in the counter pattern

	Step *string `json:"step,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueCounter) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueCounter) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueCounter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueCounter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueCustom: The custom node is an optional node that creates a custom pattern
type MultivalueCustom struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Start: The starting value of the custom pattern

	Start *string `json:"start,omitempty"`
	// Step: The step value of the custom pattern

	Step      *string                `json:"step,omitempty"`
	Increment []*MultivalueIncrement `json:"increment"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueCustom) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueCustom) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueCustom) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueCustom) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Increment {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "increment",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// MultivalueCustomDistributed: The customDistributed node is an optional node that creates a custom distribution pattern
type MultivalueCustomDistributed struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Algorithm: The type of algorithm to apply to the values

	Algorithm *string `json:"algorithm,omitempty"`
	// Mode: The distribution is applied across one of these modes

	Mode *string `json:"mode,omitempty"`
	// Values: An array of structures where each structure is a value and a weight. The type of weight is determined by the algorithm
	Values []map[string]interface{} `json:"values,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueCustomDistributed) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueCustomDistributed) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueCustomDistributed) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueCustomDistributed) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueDistributed: The distributed node is an optional node used to create a distributed pattern
type MultivalueDistributed struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: The starting value used for the distributed pattern

	Value *string `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueDistributed) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueDistributed) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueDistributed) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueDistributed) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueIncrement: The increment node is a user managed node that allows for custom increments within the custom pattern
type MultivalueIncrement struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Count: The count of this custom increment. The value must be between 1 and 4294967295.

	Count *float32 `json:"count,omitempty"`
	// Value: The value of this custom increment

	Value     *string                `json:"value,omitempty"`
	Increment []*MultivalueIncrement `json:"increment"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueIncrement) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueIncrement) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueIncrement) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueIncrement) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Increment {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "increment",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// MultivalueNest: The nest node is a managed node that offers options to customize the selected pattern
type MultivalueNest struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: If true then these options are enabled and applied to the current pattern

	Enabled *bool `json:"enabled,omitempty"`
	// Step: The value that will be used when stepping across the owner

	Step *string `json:"step,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueNest) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueNest) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueNest) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueNest) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueOverlay: The overlay node is a user managed node that allows for individual values of a pattern sequence to be set outside of the selected pattern
type MultivalueOverlay struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Count: The number of values in this overlay

	Count *float32 `json:"count,omitempty"`
	// Index: The index of the overlay

	Index *float32 `json:"index,omitempty"`
	// IndexStep: The step at which the index increments

	IndexStep *float32 `json:"indexStep,omitempty"`
	// Value: The starting value of the overlay

	Value *string `json:"value,omitempty"`
	// ValueStep: The step value of the overlay

	ValueStep *string `json:"valueStep,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueOverlay) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueOverlay) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueOverlay) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueOverlay) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueRandom: The random node is an optional node that creates a non-repeatable random pattern
type MultivalueRandom struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueRandom) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueRandom) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueRandom) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueRandom) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueRepeatableRandom: The repeatableRandom node is an optional node that creates random values having a predefined maximum Hamming distance. Generated sequences will be the same when the same set of parameters are used
type MultivalueRepeatableRandom struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Count: The count value

	Count *float32 `json:"count,omitempty"`
	// Fixed: The fixed starting value

	Fixed *string `json:"fixed,omitempty"`
	// Mask: The mask value

	Mask *string `json:"mask,omitempty"`
	// Seed: The seed value

	Seed *float32 `json:"seed,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueRepeatableRandom) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueRepeatableRandom) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueRepeatableRandom) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueRepeatableRandom) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueRepeatableRandomRange: The repeatableRandomRange node is an optional node that creates unique random values having a predefined maximum Hamming distance. Generated sequences will not be the same when the same set of parameters are used
type MultivalueRepeatableRandomRange struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Max: The maximum value

	Max *string `json:"max,omitempty"`
	// Min: The minimum value

	Min *string `json:"min,omitempty"`
	// Seed: The seed value

	Seed *float32 `json:"seed,omitempty"`
	// Step: The step value

	Step *string `json:"step,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueRepeatableRandomRange) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueRepeatableRandomRange) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueRepeatableRandomRange) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueRepeatableRandomRange) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueShared: The shared node is an optional node used to create a shared pattern which indicates that this is sharing the pattern of the source attribute.
type MultivalueShared struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Source: The source object reference that this shared value is based on.
	Source *Multivalue `json:"source,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueShared) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueShared) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueShared) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueShared) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Source.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "source",
		isMultivalue: true,
	})
}

// MultivalueSingleValue: The singleValue node is an optional node used to create a single value pattern
type MultivalueSingleValue struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: The value used for the single value pattern

	Value *string `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueSingleValue) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueSingleValue) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueSingleValue) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueSingleValue) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueString: The string node is an optional node that creates a string pattern
type MultivalueString struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Pattern: A custom string pattern

	Pattern *string `json:"pattern,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueString) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueString) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueString) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueString) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// MultivalueSubset: The subset node is an optional node used to create a subset pattern which is a subset of a source pattern occurring somewhere else in the hierarchy
type MultivalueSubset struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoScale: If true then the subset is auto scaled

	AutoScale *bool `json:"autoScale,omitempty"`
	// Count: The number of values to use from the source

	Count *float32 `json:"count,omitempty"`
	// Offset: The offset into the source

	Offset *float32 `json:"offset,omitempty"`
	// RoundRobin: The roundrobin type

	RoundRobin *string `json:"roundRobin,omitempty"`
	// Shift: The shift into the source

	Shift *float32 `json:"shift,omitempty"`
	// Source: The source object reference that this subset is based on. If the source object is in the /topology/. hierarchy then the source object will be an attribute with the same name. If the source object is in the /multivaluehierarchy then the source object is the attribute represented by the multivalue.
	Source *Multivalue `json:"source,omitempty"`
	// Step: The step into the source

	Step *float32 `json:"step,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueSubset) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueSubset) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueSubset) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueSubset) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Source.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "source",
		isMultivalue: true,
	})
}

// MultivalueValueList: The valueList node is an optional node used to create a list of values. This is not a pattern but rather a way to create a user defined list of values.
type MultivalueValueList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Values: A list of values representing the value list pattern
	Values []string `json:"values"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *MultivalueValueList) XPath() *XPath {
	return n.Xpath
}

func (n *MultivalueValueList) setRestID(id string) {
	n.RestID = id
}

func (n *MultivalueValueList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *MultivalueValueList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// Statistics: TBD
type Statistics struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdditionalFcoeStat1: TBD

	AdditionalFcoeStat1 *string `json:"additionalFcoeStat1,omitempty"`
	// AdditionalFcoeStat2: TBD

	AdditionalFcoeStat2 *string `json:"additionalFcoeStat2,omitempty"`
	// CsvFilePath: TBD

	CsvFilePath *string `json:"csvFilePath,omitempty"`
	// CsvLogPollIntervalMultiplier: TBD

	CsvLogPollIntervalMultiplier *float32 `json:"csvLogPollIntervalMultiplier,omitempty"`
	// DataStorePollingIntervalMultiplier: TBD

	DataStorePollingIntervalMultiplier *float32 `json:"dataStorePollingIntervalMultiplier,omitempty"`
	// EnableAutoDataStore: TBD

	EnableAutoDataStore *bool `json:"enableAutoDataStore,omitempty"`
	// EnableCsvLogging: TBD

	EnableCsvLogging *bool `json:"enableCsvLogging,omitempty"`
	// EnableDataCenterSharedStats: TBD

	EnableDataCenterSharedStats *bool `json:"enableDataCenterSharedStats,omitempty"`
	// GuardrailEnabled: TBD

	GuardrailEnabled *bool `json:"guardrailEnabled,omitempty"`
	// MaxNumberOfStatsPerCustomGraph: TBD

	MaxNumberOfStatsPerCustomGraph *float32 `json:"maxNumberOfStatsPerCustomGraph,omitempty"`
	// PollInterval: TBD

	PollInterval *float32 `json:"pollInterval,omitempty"`
	// TimeSynchronization: TBD

	TimeSynchronization *string `json:"timeSynchronization,omitempty"`
	// TimestampPrecision: TBD

	TimestampPrecision *float32 `json:"timestampPrecision,omitempty"`

	AutoRefresh *StatisticsAutoRefresh `json:"autoRefresh,omitempty"`
	View        []*StatisticsView      `json:"view"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Statistics) XPath() *XPath {
	return n.Xpath
}

func (n *Statistics) setRestID(id string) {
	n.RestID = id
}

func (n *Statistics) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Statistics) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AutoRefresh.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "autoRefresh",
	})
	for i, o := range n.View {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "view",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsAdvancedCvFilters: TBD
type StatisticsAdvancedCvFilters struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Caption: TBD

	Caption *string `json:"caption,omitempty"`
	// Expression: TBD

	Expression *string `json:"expression,omitempty"`
	// Grouping: TBD

	Grouping *string `json:"grouping,omitempty"`
	// Protocol: TBD

	Protocol *string `json:"protocol,omitempty"`
	// SortingStats: TBD

	SortingStats *string `json:"sortingStats,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAdvancedCvFilters) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAdvancedCvFilters) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAdvancedCvFilters) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAdvancedCvFilters) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAdvancedFilter: TBD
type StatisticsAdvancedFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Expression: TBD

	Expression *string `json:"expression,omitempty"`
	// Name: TBD

	Name *string `json:"name,omitempty"`
	// SortingStats: TBD

	SortingStats *string `json:"sortingStats,omitempty"`
	// TrackingFilterId: TBD

	TrackingFilterId *string `json:"trackingFilterId,omitempty"`
	// TrackingFilterIdRefs: Track refs for TrackingFilterId.
	TrackingFilterIdRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAdvancedFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAdvancedFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAdvancedFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAdvancedFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAllFlowsFilter: TBD
type StatisticsAllFlowsFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// NumberOfResults: TBD

	NumberOfResults *float32 `json:"numberOfResults,omitempty"`
	// SortByStatisticId: TBD

	SortByStatisticId *string `json:"sortByStatisticId,omitempty"`
	// SortByStatisticIdRefs: Track refs for SortByStatisticId.
	SortByStatisticIdRefs []Href `json:"-"`
	// SortingCondition: TBD

	SortingCondition *string `json:"sortingCondition,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAllFlowsFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAllFlowsFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAllFlowsFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAllFlowsFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAutoRefresh: TBD
type StatisticsAutoRefresh struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// MinRefreshInterval: TBD

	MinRefreshInterval *float32 `json:"minRefreshInterval,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAutoRefresh) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAutoRefresh) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAutoRefresh) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAutoRefresh) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableAdvancedFilterOptions: TBD
type StatisticsAvailableAdvancedFilterOptions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableAdvancedFilterOptions) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableAdvancedFilterOptions) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableAdvancedFilterOptions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableAdvancedFilterOptions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableAdvancedFilters: TBD
type StatisticsAvailableAdvancedFilters struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableAdvancedFilters) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableAdvancedFilters) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableAdvancedFilters) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableAdvancedFilters) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailablePortFilter: TBD
type StatisticsAvailablePortFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailablePortFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailablePortFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailablePortFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailablePortFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableProtocolFilter: TBD
type StatisticsAvailableProtocolFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableProtocolFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableProtocolFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableProtocolFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableProtocolFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableProtocolStackFilter: TBD
type StatisticsAvailableProtocolStackFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableProtocolStackFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableProtocolStackFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableProtocolStackFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableProtocolStackFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableStatisticFilter: TBD
type StatisticsAvailableStatisticFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableStatisticFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableStatisticFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableStatisticFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableStatisticFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableTargetRowFilters: TBD
type StatisticsAvailableTargetRowFilters struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableTargetRowFilters) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableTargetRowFilters) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableTargetRowFilters) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableTargetRowFilters) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableTrackingFilter: TBD
type StatisticsAvailableTrackingFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableTrackingFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableTrackingFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableTrackingFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableTrackingFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsAvailableTrafficItemFilter: TBD
type StatisticsAvailableTrafficItemFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsAvailableTrafficItemFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsAvailableTrafficItemFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsAvailableTrafficItemFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsAvailableTrafficItemFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsData: TBD
type StatisticsData struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CurrentPage: TBD

	CurrentPage *float32 `json:"currentPage,omitempty"`
	// EgressMode: TBD

	EgressMode *string `json:"egressMode,omitempty"`
	// EgressPageSize: TBD

	EgressPageSize *float32 `json:"egressPageSize,omitempty"`
	// PageSize: TBD

	PageSize *float32            `json:"pageSize,omitempty"`
	Egress   []*StatisticsEgress `json:"egress"`

	EgressRxCondition *StatisticsEgressRxCondition `json:"egressRxCondition,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsData) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsData) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsData) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsData) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Egress {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "egress",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.EgressRxCondition.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "egressRxCondition",
	})
}

// StatisticsDeadFlowsFilter: TBD
type StatisticsDeadFlowsFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// NumberOfResults: TBD

	NumberOfResults *float32 `json:"numberOfResults,omitempty"`
	// SortingCondition: TBD

	SortingCondition *string `json:"sortingCondition,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsDeadFlowsFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsDeadFlowsFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsDeadFlowsFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsDeadFlowsFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsDrillDown: TBD
type StatisticsDrillDown struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// TargetDrillDownOption: TBD

	TargetDrillDownOption *string `json:"targetDrillDownOption,omitempty"`
	// TargetRowFilter: TBD

	TargetRowFilter *string `json:"targetRowFilter,omitempty"`
	// TargetRowFilterRefs: Track refs for TargetRowFilter.
	TargetRowFilterRefs []Href `json:"-"`
	// TargetRowIndex: TBD

	TargetRowIndex            *float32                               `json:"targetRowIndex,omitempty"`
	AvailableTargetRowFilters []*StatisticsAvailableTargetRowFilters `json:"availableTargetRowFilters"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsDrillDown) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsDrillDown) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsDrillDown) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsDrillDown) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.AvailableTargetRowFilters {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableTargetRowFilters",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsEgress: TBD
type StatisticsEgress struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CommitEgressPage: TBD

	CommitEgressPage *bool `json:"commitEgressPage,omitempty"`
	// CurrentPage: TBD

	CurrentPage   *float32                   `json:"currentPage,omitempty"`
	FlowCondition []*StatisticsFlowCondition `json:"flowCondition"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsEgress) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsEgress) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsEgress) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsEgress) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.FlowCondition {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "flowCondition",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsEgressRxCondition: TBD
type StatisticsEgressRxCondition struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Operator: TBD

	Operator *string `json:"operator,omitempty"`
	// Values: TBD
	Values []float32 `json:"values"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsEgressRxCondition) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsEgressRxCondition) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsEgressRxCondition) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsEgressRxCondition) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsEnumerationFilter: TBD
type StatisticsEnumerationFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// SortDirection: TBD

	SortDirection *string `json:"sortDirection,omitempty"`
	// TrackingFilterId: TBD

	TrackingFilterId *string `json:"trackingFilterId,omitempty"`
	// TrackingFilterIdRefs: Track refs for TrackingFilterId.
	TrackingFilterIdRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsEnumerationFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsEnumerationFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsEnumerationFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsEnumerationFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsFlowCondition: TBD
type StatisticsFlowCondition struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Operator: TBD

	Operator *string `json:"operator,omitempty"`
	// ShowFirstMatchingSet: TBD

	ShowFirstMatchingSet *bool `json:"showFirstMatchingSet,omitempty"`
	// TrackingFilterId: TBD

	TrackingFilterId *string `json:"trackingFilterId,omitempty"`
	// TrackingFilterIdRefs: Track refs for TrackingFilterId.
	TrackingFilterIdRefs []Href `json:"-"`
	// Values: TBD
	Values []float32 `json:"values"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsFlowCondition) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsFlowCondition) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsFlowCondition) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsFlowCondition) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsFormulaCatalog: TBD
type StatisticsFormulaCatalog struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath         *XPath                     `json:"xpath,omitempty"`
	FormulaColumn []*StatisticsFormulaColumn `json:"formulaColumn"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsFormulaCatalog) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsFormulaCatalog) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsFormulaCatalog) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsFormulaCatalog) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.FormulaColumn {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "formulaColumn",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsFormulaColumn: TBD
type StatisticsFormulaColumn struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Caption: TBD

	Caption *string `json:"caption,omitempty"`
	// Formula: TBD

	Formula *string `json:"formula,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsFormulaColumn) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsFormulaColumn) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsFormulaColumn) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsFormulaColumn) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsInnerGlobalStats: TBD
type StatisticsInnerGlobalStats struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsInnerGlobalStats) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsInnerGlobalStats) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsInnerGlobalStats) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsInnerGlobalStats) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsLayer23NextGenProtocolFilter: TBD
type StatisticsLayer23NextGenProtocolFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvancedCVFilter: TBD

	AdvancedCVFilter *string `json:"advancedCVFilter,omitempty"`
	// AdvancedCVFilterRefs: Track refs for AdvancedCVFilter.
	AdvancedCVFilterRefs []Href `json:"-"`
	// AdvancedFilterName: TBD

	AdvancedFilterName *string `json:"advancedFilterName,omitempty"`
	// AggregationType: TBD

	AggregationType *string `json:"aggregationType,omitempty"`
	// PortFilterIds: TBD
	PortFilterIds []string `json:"portFilterIds"`
	// PortFilterIdsRefs: Track refs for PortFilterIds.
	PortFilterIdsRefs []Href `json:"-"`
	// ProtocolFilterIds: TBD
	ProtocolFilterIds []string `json:"protocolFilterIds"`
	// ProtocolFilterIdsRefs: Track refs for ProtocolFilterIds.
	ProtocolFilterIdsRefs          []Href                                      `json:"-"`
	AdvancedFilter                 []*StatisticsAdvancedFilter                 `json:"advancedFilter"`
	AvailableAdvancedFilterOptions []*StatisticsAvailableAdvancedFilterOptions `json:"availableAdvancedFilterOptions"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23NextGenProtocolFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23NextGenProtocolFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23NextGenProtocolFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23NextGenProtocolFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.AdvancedFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "advancedFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailableAdvancedFilterOptions {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableAdvancedFilterOptions",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsLayer23ProtocolAuthAccessFilter: TBD
type StatisticsLayer23ProtocolAuthAccessFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// PortFilterIds: TBD
	PortFilterIds []string `json:"portFilterIds"`
	// PortFilterIdsRefs: Track refs for PortFilterIds.
	PortFilterIdsRefs []Href `json:"-"`
	// ProtocolFilterIds: TBD
	ProtocolFilterIds []string `json:"protocolFilterIds"`
	// ProtocolFilterIdsRefs: Track refs for ProtocolFilterIds.
	ProtocolFilterIdsRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23ProtocolAuthAccessFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23ProtocolAuthAccessFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23ProtocolAuthAccessFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23ProtocolAuthAccessFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsLayer23ProtocolPortFilter: TBD
type StatisticsLayer23ProtocolPortFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// PortFilterIds: TBD
	PortFilterIds []string `json:"portFilterIds"`
	// PortFilterIdsRefs: Track refs for PortFilterIds.
	PortFilterIdsRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23ProtocolPortFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23ProtocolPortFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23ProtocolPortFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23ProtocolPortFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsLayer23ProtocolRoutingFilter: TBD
type StatisticsLayer23ProtocolRoutingFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// PortFilterIds: TBD
	PortFilterIds []string `json:"portFilterIds"`
	// PortFilterIdsRefs: Track refs for PortFilterIds.
	PortFilterIdsRefs []Href `json:"-"`
	// ProtocolFilterIds: TBD
	ProtocolFilterIds []string `json:"protocolFilterIds"`
	// ProtocolFilterIdsRefs: Track refs for ProtocolFilterIds.
	ProtocolFilterIdsRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23ProtocolRoutingFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23ProtocolRoutingFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23ProtocolRoutingFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23ProtocolRoutingFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsLayer23ProtocolStackFilter: TBD
type StatisticsLayer23ProtocolStackFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// DrilldownType: TBD

	DrilldownType *string `json:"drilldownType,omitempty"`
	// NumberOfResults: TBD

	NumberOfResults *float32 `json:"numberOfResults,omitempty"`
	// ProtocolStackFilterId: TBD
	ProtocolStackFilterId []string `json:"protocolStackFilterId"`
	// ProtocolStackFilterIdRefs: Track refs for ProtocolStackFilterId.
	ProtocolStackFilterIdRefs []Href `json:"-"`
	// SortAscending: TBD

	SortAscending *bool `json:"sortAscending,omitempty"`
	// SortingStatistic: TBD

	SortingStatistic *string `json:"sortingStatistic,omitempty"`
	// SortingStatisticRefs: Track refs for SortingStatistic.
	SortingStatisticRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23ProtocolStackFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23ProtocolStackFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23ProtocolStackFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23ProtocolStackFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsLayer23TrafficFlowDetectiveFilter: TBD
type StatisticsLayer23TrafficFlowDetectiveFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// DeadFlowsThreshold: TBD

	DeadFlowsThreshold *float32 `json:"deadFlowsThreshold,omitempty"`
	// FlowFilterType: TBD

	FlowFilterType *string `json:"flowFilterType,omitempty"`
	// PortFilterIds: TBD
	PortFilterIds []string `json:"portFilterIds"`
	// PortFilterIdsRefs: Track refs for PortFilterIds.
	PortFilterIdsRefs []Href `json:"-"`
	// ShowEgressFlows: TBD

	ShowEgressFlows *bool `json:"showEgressFlows,omitempty"`
	// TrafficItemFilterId: TBD

	TrafficItemFilterId *string `json:"trafficItemFilterId,omitempty"`
	// TrafficItemFilterIdRefs: Track refs for TrafficItemFilterId.
	TrafficItemFilterIdRefs []Href `json:"-"`
	// TrafficItemFilterIds: TBD
	TrafficItemFilterIds []string `json:"trafficItemFilterIds"`
	// TrafficItemFilterIdsRefs: Track refs for TrafficItemFilterIds.
	TrafficItemFilterIdsRefs []Href `json:"-"`

	AllFlowsFilter *StatisticsAllFlowsFilter `json:"allFlowsFilter,omitempty"`

	DeadFlowsFilter *StatisticsDeadFlowsFilter `json:"deadFlowsFilter,omitempty"`

	LiveFlowsFilter *StatisticsLiveFlowsFilter   `json:"liveFlowsFilter,omitempty"`
	StatisticFilter []*StatisticsStatisticFilter `json:"statisticFilter"`
	TrackingFilter  []*StatisticsTrackingFilter  `json:"trackingFilter"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23TrafficFlowDetectiveFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23TrafficFlowDetectiveFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23TrafficFlowDetectiveFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23TrafficFlowDetectiveFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AllFlowsFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "allFlowsFilter",
	})
	n.DeadFlowsFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "deadFlowsFilter",
	})
	n.LiveFlowsFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "liveFlowsFilter",
	})
	for i, o := range n.StatisticFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "statisticFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TrackingFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "trackingFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsLayer23TrafficFlowFilter: TBD
type StatisticsLayer23TrafficFlowFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AggregatedAcrossPorts: TBD

	AggregatedAcrossPorts *bool `json:"aggregatedAcrossPorts,omitempty"`
	// EgressLatencyBinDisplayOption: TBD

	EgressLatencyBinDisplayOption *string `json:"egressLatencyBinDisplayOption,omitempty"`
	// PortFilterIds: TBD
	PortFilterIds []string `json:"portFilterIds"`
	// PortFilterIdsRefs: Track refs for PortFilterIds.
	PortFilterIdsRefs []Href `json:"-"`
	// TrafficItemFilterId: TBD

	TrafficItemFilterId *string `json:"trafficItemFilterId,omitempty"`
	// TrafficItemFilterIdRefs: Track refs for TrafficItemFilterId.
	TrafficItemFilterIdRefs []Href `json:"-"`
	// TrafficItemFilterIds: TBD
	TrafficItemFilterIds []string `json:"trafficItemFilterIds"`
	// TrafficItemFilterIdsRefs: Track refs for TrafficItemFilterIds.
	TrafficItemFilterIdsRefs []Href                         `json:"-"`
	EnumerationFilter        []*StatisticsEnumerationFilter `json:"enumerationFilter"`
	TrackingFilter           []*StatisticsTrackingFilter    `json:"trackingFilter"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23TrafficFlowFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23TrafficFlowFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23TrafficFlowFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23TrafficFlowFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.EnumerationFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "enumerationFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TrackingFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "trackingFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsLayer23TrafficItemFilter: TBD
type StatisticsLayer23TrafficItemFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// TrafficItemFilterIds: TBD
	TrafficItemFilterIds []string `json:"trafficItemFilterIds"`
	// TrafficItemFilterIdsRefs: Track refs for TrafficItemFilterIds.
	TrafficItemFilterIdsRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23TrafficItemFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23TrafficItemFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23TrafficItemFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23TrafficItemFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsLayer23TrafficPortFilter: TBD
type StatisticsLayer23TrafficPortFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// PortFilterIds: TBD
	PortFilterIds []string `json:"portFilterIds"`
	// PortFilterIdsRefs: Track refs for PortFilterIds.
	PortFilterIdsRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer23TrafficPortFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer23TrafficPortFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer23TrafficPortFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer23TrafficPortFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsLayer47AppLibraryTrafficFilter: TBD
type StatisticsLayer47AppLibraryTrafficFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvancedFilterName: TBD

	AdvancedFilterName *string `json:"advancedFilterName,omitempty"`
	// TopxEnabled: TBD

	TopxEnabled *bool `json:"topxEnabled,omitempty"`
	// TopxValue: TBD

	TopxValue      *float32                    `json:"topxValue,omitempty"`
	AdvancedFilter []*StatisticsAdvancedFilter `json:"advancedFilter"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLayer47AppLibraryTrafficFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLayer47AppLibraryTrafficFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLayer47AppLibraryTrafficFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLayer47AppLibraryTrafficFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.AdvancedFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "advancedFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// StatisticsLiveFlowsFilter: TBD
type StatisticsLiveFlowsFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// NumberOfResults: TBD

	NumberOfResults *float32 `json:"numberOfResults,omitempty"`
	// SortByStatisticId: TBD

	SortByStatisticId *string `json:"sortByStatisticId,omitempty"`
	// SortByStatisticIdRefs: Track refs for SortByStatisticId.
	SortByStatisticIdRefs []Href `json:"-"`
	// SortingCondition: TBD

	SortingCondition *string `json:"sortingCondition,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsLiveFlowsFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsLiveFlowsFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsLiveFlowsFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsLiveFlowsFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsPage: TBD
type StatisticsPage struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CurrentPage: TBD

	CurrentPage *float32 `json:"currentPage,omitempty"`
	// EgressMode: TBD

	EgressMode *string `json:"egressMode,omitempty"`
	// EgressPageSize: TBD

	EgressPageSize *float32 `json:"egressPageSize,omitempty"`
	// IsReadyTimeout: TBD

	IsReadyTimeout *float32 `json:"isReadyTimeout,omitempty"`
	// PageSize: TBD

	PageSize *float32            `json:"pageSize,omitempty"`
	Egress   []*StatisticsEgress `json:"egress"`

	EgressRxCondition *StatisticsEgressRxCondition `json:"egressRxCondition,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsPage) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsPage) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsPage) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsPage) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Egress {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "egress",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.EgressRxCondition.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "egressRxCondition",
	})
}

// StatisticsStatistic: TBD
type StatisticsStatistic struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AggregationType: TBD

	AggregationType *string `json:"aggregationType,omitempty"`
	// Caption: TBD

	Caption *string `json:"caption,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// ScaleFactor: TBD

	ScaleFactor *float32 `json:"scaleFactor,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsStatistic) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsStatistic) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsStatistic) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsStatistic) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsStatisticFilter: TBD
type StatisticsStatisticFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Operator: TBD

	Operator *string `json:"operator,omitempty"`
	// StatisticFilterId: TBD

	StatisticFilterId *string `json:"statisticFilterId,omitempty"`
	// StatisticFilterIdRefs: Track refs for StatisticFilterId.
	StatisticFilterIdRefs []Href `json:"-"`
	// Value: TBD

	Value *string `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsStatisticFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsStatisticFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsStatisticFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsStatisticFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsTrackingFilter: TBD
type StatisticsTrackingFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Operator: TBD

	Operator *string `json:"operator,omitempty"`
	// TrackingFilterId: TBD

	TrackingFilterId *string `json:"trackingFilterId,omitempty"`
	// TrackingFilterIdRefs: Track refs for TrackingFilterId.
	TrackingFilterIdRefs []Href `json:"-"`
	// Value: TBD
	Value []string `json:"value"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsTrackingFilter) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsTrackingFilter) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsTrackingFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsTrackingFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// StatisticsView: TBD
type StatisticsView struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoRefresh: TBD

	AutoRefresh *bool `json:"autoRefresh,omitempty"`
	// AutoUpdate: TBD

	AutoUpdate *bool `json:"autoUpdate,omitempty"`
	// Caption: TBD

	Caption *string `json:"caption,omitempty"`
	// CsvFileName: TBD

	CsvFileName *string `json:"csvFileName,omitempty"`
	// EnableCsvLogging: TBD

	EnableCsvLogging *bool `json:"enableCsvLogging,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// EnabledStatsSelectorColumns: Columns added from Stat Selector Manager
	EnabledStatsSelectorColumns []string `json:"enabledStatsSelectorColumns"`
	// PageTimeout: TBD

	PageTimeout *float32 `json:"pageTimeout,omitempty"`
	// TimeSeries: TBD

	TimeSeries *bool `json:"timeSeries,omitempty"`
	// TreeViewNodeName: TBD

	TreeViewNodeName *string `json:"treeViewNodeName,omitempty"`
	// Type_: TBD

	Type_ *string `json:"type,omitempty"`
	// Visible: TBD

	Visible                      *bool                                     `json:"visible,omitempty"`
	AdvancedCVFilters            []*StatisticsAdvancedCvFilters            `json:"advancedCVFilters"`
	AvailableAdvancedFilters     []*StatisticsAvailableAdvancedFilters     `json:"availableAdvancedFilters"`
	AvailablePortFilter          []*StatisticsAvailablePortFilter          `json:"availablePortFilter"`
	AvailableProtocolFilter      []*StatisticsAvailableProtocolFilter      `json:"availableProtocolFilter"`
	AvailableProtocolStackFilter []*StatisticsAvailableProtocolStackFilter `json:"availableProtocolStackFilter"`
	AvailableStatisticFilter     []*StatisticsAvailableStatisticFilter     `json:"availableStatisticFilter"`
	AvailableTrackingFilter      []*StatisticsAvailableTrackingFilter      `json:"availableTrackingFilter"`
	AvailableTrafficItemFilter   []*StatisticsAvailableTrafficItemFilter   `json:"availableTrafficItemFilter"`

	Data *StatisticsData `json:"data,omitempty"`

	DrillDown *StatisticsDrillDown `json:"drillDown,omitempty"`

	FormulaCatalog *StatisticsFormulaCatalog `json:"formulaCatalog,omitempty"`

	InnerGlobalStats *StatisticsInnerGlobalStats `json:"innerGlobalStats,omitempty"`

	Layer23NextGenProtocolFilter *StatisticsLayer23NextGenProtocolFilter `json:"layer23NextGenProtocolFilter,omitempty"`

	Layer23ProtocolAuthAccessFilter *StatisticsLayer23ProtocolAuthAccessFilter `json:"layer23ProtocolAuthAccessFilter,omitempty"`

	Layer23ProtocolPortFilter *StatisticsLayer23ProtocolPortFilter `json:"layer23ProtocolPortFilter,omitempty"`

	Layer23ProtocolRoutingFilter *StatisticsLayer23ProtocolRoutingFilter `json:"layer23ProtocolRoutingFilter,omitempty"`

	Layer23ProtocolStackFilter *StatisticsLayer23ProtocolStackFilter `json:"layer23ProtocolStackFilter,omitempty"`

	Layer23TrafficFlowDetectiveFilter *StatisticsLayer23TrafficFlowDetectiveFilter `json:"layer23TrafficFlowDetectiveFilter,omitempty"`

	Layer23TrafficFlowFilter *StatisticsLayer23TrafficFlowFilter `json:"layer23TrafficFlowFilter,omitempty"`

	Layer23TrafficItemFilter *StatisticsLayer23TrafficItemFilter `json:"layer23TrafficItemFilter,omitempty"`

	Layer23TrafficPortFilter *StatisticsLayer23TrafficPortFilter `json:"layer23TrafficPortFilter,omitempty"`

	Layer47AppLibraryTrafficFilter *StatisticsLayer47AppLibraryTrafficFilter `json:"layer47AppLibraryTrafficFilter,omitempty"`

	Page      *StatisticsPage        `json:"page,omitempty"`
	Statistic []*StatisticsStatistic `json:"statistic"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *StatisticsView) XPath() *XPath {
	return n.Xpath
}

func (n *StatisticsView) setRestID(id string) {
	n.RestID = id
}

func (n *StatisticsView) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *StatisticsView) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.AdvancedCVFilters {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "advancedCVFilters",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailableAdvancedFilters {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableAdvancedFilters",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailablePortFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availablePortFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailableProtocolFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableProtocolFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailableProtocolStackFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableProtocolStackFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailableStatisticFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableStatisticFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailableTrackingFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableTrackingFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.AvailableTrafficItemFilter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "availableTrafficItemFilter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Data.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "data",
	})
	n.DrillDown.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "drillDown",
	})
	n.FormulaCatalog.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "formulaCatalog",
	})
	n.InnerGlobalStats.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "innerGlobalStats",
	})
	n.Layer23NextGenProtocolFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23NextGenProtocolFilter",
	})
	n.Layer23ProtocolAuthAccessFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23ProtocolAuthAccessFilter",
	})
	n.Layer23ProtocolPortFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23ProtocolPortFilter",
	})
	n.Layer23ProtocolRoutingFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23ProtocolRoutingFilter",
	})
	n.Layer23ProtocolStackFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23ProtocolStackFilter",
	})
	n.Layer23TrafficFlowDetectiveFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23TrafficFlowDetectiveFilter",
	})
	n.Layer23TrafficFlowFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23TrafficFlowFilter",
	})
	n.Layer23TrafficItemFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23TrafficItemFilter",
	})
	n.Layer23TrafficPortFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer23TrafficPortFilter",
	})
	n.Layer47AppLibraryTrafficFilter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "layer47AppLibraryTrafficFilter",
	})
	n.Page.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "page",
	})
	for i, o := range n.Statistic {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "statistic",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// Topology: Topology represents the concept of network devices which are to be configured on a group of ports.
type Topology struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Note: Any Note about the Topology

	Note *string `json:"note,omitempty"`
	// Ports: Logical port information.
	Ports []string `json:"ports"`
	// PortsRefs: Track refs for Ports.
	PortsRefs []Href `json:"-"`
	// Vports: Virtual port information.
	Vports []string `json:"vports"`
	// VportsRefs: Track refs for Vports.
	VportsRefs  []Href                 `json:"-"`
	DeviceGroup []*TopologyDeviceGroup `json:"deviceGroup"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Topology) XPath() *XPath {
	return n.Xpath
}

func (n *Topology) setRestID(id string) {
	n.RestID = id
}

func (n *Topology) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Topology) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.DeviceGroup {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "deviceGroup",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyAction: Action
type TopologyAction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name  *string                `json:"name,omitempty"`
	Field []*TopologyActionField `json:"field"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyAction) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyAction) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyAction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyAction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyActionField: Fixed size field.
type TopologyActionField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// Encoding: The encoding of the field in bytes.

	Encoding *string `json:"encoding,omitempty"`
	// Enum: Internal enumeration type used to restrict possible field values.

	Enum *string `json:"enum,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name *string `json:"name,omitempty"`
	// SingleValue: If true the field can only be configured with a single value pattern.

	SingleValue *bool `json:"singleValue,omitempty"`
	// Size: The size of the field in bytes.

	Size *float32 `json:"size,omitempty"`
	// SizeType: The size types/data unit of the field.

	SizeType *string `json:"sizeType,omitempty"`
	// Value: The string value of the field.
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyActionField) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyActionField) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyActionField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyActionField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyActions: Action
type TopologyActions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name   *string           `json:"name,omitempty"`
	Action []*TopologyAction `json:"action"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyActions) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyActions) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyActions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyActions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Action {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "action",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyActionsProfile: Action Builder Profile
type TopologyActionsProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name   *string           `json:"name,omitempty"`
	Action []*TopologyAction `json:"action"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyActionsProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyActionsProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyActionsProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyActionsProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Action {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "action",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyAdvancedLearnedInfoOptions: CFM Learned Info Filters
type TopologyAdvancedLearnedInfoOptions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AllCVlanCCM: Include All C-VLAN
	AllCVlanCCM *Multivalue `json:"allCVlanCCM,omitempty"`
	// AllDstMEPDM: Use All Configured MEPs as Destination
	AllDstMEPDM *Multivalue `json:"allDstMEPDM,omitempty"`
	// AllDstMEPLM: Use All Configured MEPs as Destination
	AllDstMEPLM *Multivalue `json:"allDstMEPLM,omitempty"`
	// AllDstMEPLT: Use All Configured MEPs as Destination
	AllDstMEPLT *Multivalue `json:"allDstMEPLT,omitempty"`
	// AllDstMepLB: Use All Configured MEPs as Destination
	AllDstMepLB *Multivalue `json:"allDstMepLB,omitempty"`
	// AllSVlanCCM: Include All S-VLAN
	AllSVlanCCM *Multivalue `json:"allSVlanCCM,omitempty"`
	// AllSrcMEPDM: Use All Configured MEPs as Source
	AllSrcMEPDM *Multivalue `json:"allSrcMEPDM,omitempty"`
	// AllSrcMEPLM: Use All Configured MEPs as Source
	AllSrcMEPLM *Multivalue `json:"allSrcMEPLM,omitempty"`
	// AllSrcMEPLT: Use All Configured MEPs as Source
	AllSrcMEPLT *Multivalue `json:"allSrcMEPLT,omitempty"`
	// AllSrcMepLB: Use All Configured MEPs as Source
	AllSrcMepLB *Multivalue `json:"allSrcMepLB,omitempty"`
	// AllVlanCCM: Include All VLAN
	AllVlanCCM *Multivalue `json:"allVlanCCM,omitempty"`
	// CVlanIdFilterCCM: C-VLAN ID
	CVlanIdFilterCCM *Multivalue `json:"cVlanIdFilterCCM,omitempty"`
	// CVlanIdFilterDM: C-VLAN ID
	CVlanIdFilterDM *Multivalue `json:"cVlanIdFilterDM,omitempty"`
	// CVlanIdFilterLB: C-VLAN ID
	CVlanIdFilterLB *Multivalue `json:"cVlanIdFilterLB,omitempty"`
	// CVlanIdFilterLM: C-VLAN ID
	CVlanIdFilterLM *Multivalue `json:"cVlanIdFilterLM,omitempty"`
	// CVlanIdFilterLT: C-VLAN ID
	CVlanIdFilterLT *Multivalue `json:"cVlanIdFilterLT,omitempty"`
	// CVlanPriorityFilterCCM: C-VLAN Priority
	CVlanPriorityFilterCCM *Multivalue `json:"cVlanPriorityFilterCCM,omitempty"`
	// CVlanPriorityFilterDM: C-VLAN Priority
	CVlanPriorityFilterDM *Multivalue `json:"cVlanPriorityFilterDM,omitempty"`
	// CVlanPriorityFilterLB: C-VLAN Priority
	CVlanPriorityFilterLB *Multivalue `json:"cVlanPriorityFilterLB,omitempty"`
	// CVlanPriorityFilterLM: C-VLAN Priority
	CVlanPriorityFilterLM *Multivalue `json:"cVlanPriorityFilterLM,omitempty"`
	// CVlanPriorityFilterLT: C-VLAN Priority
	CVlanPriorityFilterLT *Multivalue `json:"cVlanPriorityFilterLT,omitempty"`
	// CVlanTpidFilterCCM: C-VLAN TPID
	CVlanTpidFilterCCM *Multivalue `json:"cVlanTpidFilterCCM,omitempty"`
	// CVlanTpidFilterDM: C-VLAN TPID
	CVlanTpidFilterDM *Multivalue `json:"cVlanTpidFilterDM,omitempty"`
	// CVlanTpidFilterLB: C-VLAN TPID
	CVlanTpidFilterLB *Multivalue `json:"cVlanTpidFilterLB,omitempty"`
	// CVlanTpidFilterLM: C-VLAN TPID
	CVlanTpidFilterLM *Multivalue `json:"cVlanTpidFilterLM,omitempty"`
	// CVlanTpidFilterLT: C-VLAN TPID
	CVlanTpidFilterLT *Multivalue `json:"cVlanTpidFilterLT,omitempty"`
	// ConfiguredVlanDM: Use/Don't use VLAN in DM from configured source MEP
	ConfiguredVlanDM *Multivalue `json:"configuredVlanDM,omitempty"`
	// ConfiguredVlanLB: Use/Don't use VLAN in LB from configured source MEP
	ConfiguredVlanLB *Multivalue `json:"configuredVlanLB,omitempty"`
	// ConfiguredVlanLM: Use/Don't use VLAN in LM from configured source MEP
	ConfiguredVlanLM *Multivalue `json:"configuredVlanLM,omitempty"`
	// ConfiguredVlanLT: Use/Don't use VLAN in LT from configured source MEP
	ConfiguredVlanLT *Multivalue `json:"configuredVlanLT,omitempty"`
	// DestinationMpMacDM: Destination MP MAC Filters Use All Destination MAC to fetch all Or use any other value
	DestinationMpMacDM *Multivalue `json:"destinationMpMacDM,omitempty"`
	// DestinationMpMacLB: Destination MP MAC Filters Use All Destination MAC to fetch all Or use any other value
	DestinationMpMacLB *Multivalue `json:"destinationMpMacLB,omitempty"`
	// DestinationMpMacLM: Destination MP MAC Filters Use All Destination MAC to fetch all Or use any other value
	DestinationMpMacLM *Multivalue `json:"destinationMpMacLM,omitempty"`
	// DestinationMpMacLT: Destination MP MAC Filters Use All Destination MEP to fetch all Or use any other value
	DestinationMpMacLT *Multivalue `json:"destinationMpMacLT,omitempty"`
	// EnableVlanFilterCCM: Enable VLAN Filter
	EnableVlanFilterCCM *Multivalue `json:"enableVlanFilterCCM,omitempty"`
	// MdLevelLB: MD/MEG Level Filters Use All MD Levels to fetch all Or use any other value
	MdLevelLB *Multivalue `json:"mdLevelLB,omitempty"`
	// MdLevelLT: MD/MEG Level Filters Use All MD Levels to fetch all Or use any other value
	MdLevelLT *Multivalue `json:"mdLevelLT,omitempty"`
	// MdOrMegLevelCCM: MD/MEG Level Filters Use All MD Levels to fetch all Or use any other value
	MdOrMegLevelCCM *Multivalue `json:"mdOrMegLevelCCM,omitempty"`
	// MdOrMegLevelDM: MD/MEG Level Filters Use All MD Levels to fetch all Or use any other value
	MdOrMegLevelDM *Multivalue `json:"mdOrMegLevelDM,omitempty"`
	// MdOrMegLevelLM: MD/MEG Level Filters Use All MD Levels to fetch all Or use any other value
	MdOrMegLevelLM *Multivalue `json:"mdOrMegLevelLM,omitempty"`
	// MethodDM: Choose a Delay Measurement Method
	MethodDM *Multivalue `json:"methodDM,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SVlanIdFilterCCM: S-VLAN ID
	SVlanIdFilterCCM *Multivalue `json:"sVlanIdFilterCCM,omitempty"`
	// SVlanIdFilterDM: S-VLAN ID
	SVlanIdFilterDM *Multivalue `json:"sVlanIdFilterDM,omitempty"`
	// SVlanIdFilterLB: S-VLAN ID
	SVlanIdFilterLB *Multivalue `json:"sVlanIdFilterLB,omitempty"`
	// SVlanIdFilterLM: S-VLAN ID
	SVlanIdFilterLM *Multivalue `json:"sVlanIdFilterLM,omitempty"`
	// SVlanIdFilterLT: S-VLAN ID
	SVlanIdFilterLT *Multivalue `json:"sVlanIdFilterLT,omitempty"`
	// SVlanPriorityFilterCCM: S-VLAN Priority
	SVlanPriorityFilterCCM *Multivalue `json:"sVlanPriorityFilterCCM,omitempty"`
	// SVlanPriorityFilterDM: S-VLAN Priority
	SVlanPriorityFilterDM *Multivalue `json:"sVlanPriorityFilterDM,omitempty"`
	// SVlanPriorityFilterLB: S-VLAN Priority
	SVlanPriorityFilterLB *Multivalue `json:"sVlanPriorityFilterLB,omitempty"`
	// SVlanPriorityFilterLM: S-VLAN Priority
	SVlanPriorityFilterLM *Multivalue `json:"sVlanPriorityFilterLM,omitempty"`
	// SVlanPriorityFilterLT: S-VLAN Priority
	SVlanPriorityFilterLT *Multivalue `json:"sVlanPriorityFilterLT,omitempty"`
	// SVlanTpidFilterCCM: S-VLAN TPID
	SVlanTpidFilterCCM *Multivalue `json:"sVlanTpidFilterCCM,omitempty"`
	// SVlanTpidFilterDM: S-VLAN TPID
	SVlanTpidFilterDM *Multivalue `json:"sVlanTpidFilterDM,omitempty"`
	// SVlanTpidFilterLB: S-VLAN TPID
	SVlanTpidFilterLB *Multivalue `json:"sVlanTpidFilterLB,omitempty"`
	// SVlanTpidFilterLM: S-VLAN TPID
	SVlanTpidFilterLM *Multivalue `json:"sVlanTpidFilterLM,omitempty"`
	// SVlanTpidFilterLT: S-VLAN TPID
	SVlanTpidFilterLT *Multivalue `json:"sVlanTpidFilterLT,omitempty"`
	// SourceMpMacDM: Source MP MAC Filters Use All Source MAC to fetch all Or use any other value
	SourceMpMacDM *Multivalue `json:"sourceMpMacDM,omitempty"`
	// SourceMpMacLB: Source MP MAC Filters Use All Source MAC to fetch all Or use any other value
	SourceMpMacLB *Multivalue `json:"sourceMpMacLB,omitempty"`
	// SourceMpMacLM: Source MP MAC Filters Use All Source MAC to fetch all Or use any other value
	SourceMpMacLM *Multivalue `json:"sourceMpMacLM,omitempty"`
	// SourceMpMacLT: Source MP MAC Filters Use All Source MEP to fetch all Or use any other value
	SourceMpMacLT *Multivalue `json:"sourceMpMacLT,omitempty"`
	// TimeoutDM: Timeout (ms)
	TimeoutDM *Multivalue `json:"timeoutDM,omitempty"`
	// TimeoutLB: Timeout (ms)
	TimeoutLB *Multivalue `json:"timeoutLB,omitempty"`
	// TimeoutLM: Timeout (ms)
	TimeoutLM *Multivalue `json:"timeoutLM,omitempty"`
	// TimeoutLT: Timeout
	TimeoutLT *Multivalue `json:"timeoutLT,omitempty"`
	// TransactionIdLB: Transaction ID (Unconfigured MEP)
	TransactionIdLB *Multivalue `json:"transactionIdLB,omitempty"`
	// TransactionIdLT: Transaction ID for Unconfigured Source MEP
	TransactionIdLT *Multivalue `json:"transactionIdLT,omitempty"`
	// TtlLT: TTL
	TtlLT *Multivalue `json:"ttlLT,omitempty"`
	// TypeDM: Type (DM/DVM)
	TypeDM *Multivalue `json:"typeDM,omitempty"`
	// VlanIdFilterCCM: VLAN ID
	VlanIdFilterCCM *Multivalue `json:"vlanIdFilterCCM,omitempty"`
	// VlanIdFilterDM: VLAN ID
	VlanIdFilterDM *Multivalue `json:"vlanIdFilterDM,omitempty"`
	// VlanIdFilterLB: VLAN ID
	VlanIdFilterLB *Multivalue `json:"vlanIdFilterLB,omitempty"`
	// VlanIdFilterLM: VLAN ID
	VlanIdFilterLM *Multivalue `json:"vlanIdFilterLM,omitempty"`
	// VlanIdFilterLT: VLAN ID
	VlanIdFilterLT *Multivalue `json:"vlanIdFilterLT,omitempty"`
	// VlanPriorityFilterCCM: VLAN Priority
	VlanPriorityFilterCCM *Multivalue `json:"vlanPriorityFilterCCM,omitempty"`
	// VlanPriorityFilterDM: VLAN Priority
	VlanPriorityFilterDM *Multivalue `json:"vlanPriorityFilterDM,omitempty"`
	// VlanPriorityFilterLB: VLAN Priority
	VlanPriorityFilterLB *Multivalue `json:"vlanPriorityFilterLB,omitempty"`
	// VlanPriorityFilterLM: VLAN Priority
	VlanPriorityFilterLM *Multivalue `json:"vlanPriorityFilterLM,omitempty"`
	// VlanPriorityFilterLT: VLAN Priority
	VlanPriorityFilterLT *Multivalue `json:"vlanPriorityFilterLT,omitempty"`
	// VlanStackingCCM: VLAN Stacking
	VlanStackingCCM *Multivalue `json:"vlanStackingCCM,omitempty"`
	// VlanStackingDM: VLAN Stacking
	VlanStackingDM *Multivalue `json:"vlanStackingDM,omitempty"`
	// VlanStackingLB: VLAN Stacking
	VlanStackingLB *Multivalue `json:"vlanStackingLB,omitempty"`
	// VlanStackingLM: VLAN Stacking
	VlanStackingLM *Multivalue `json:"vlanStackingLM,omitempty"`
	// VlanStackingLT: VLAN Stacking
	VlanStackingLT *Multivalue `json:"vlanStackingLT,omitempty"`
	// VlanTpidFilterCCM: VLAN TPID
	VlanTpidFilterCCM *Multivalue `json:"vlanTpidFilterCCM,omitempty"`
	// VlanTpidFilterDM: VLAN TPID
	VlanTpidFilterDM *Multivalue `json:"vlanTpidFilterDM,omitempty"`
	// VlanTpidFilterLB: VLAN TPID
	VlanTpidFilterLB *Multivalue `json:"vlanTpidFilterLB,omitempty"`
	// VlanTpidFilterLM: VLAN TPID
	VlanTpidFilterLM *Multivalue `json:"vlanTpidFilterLM,omitempty"`
	// VlanTpidFilterLT: VLAN TPID
	VlanTpidFilterLT *Multivalue `json:"vlanTpidFilterLT,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyAdvancedLearnedInfoOptions) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyAdvancedLearnedInfoOptions) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyAdvancedLearnedInfoOptions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyAdvancedLearnedInfoOptions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AllCVlanCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allCVlanCCM",
		isMultivalue: true,
	})
	n.AllDstMEPDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allDstMEPDM",
		isMultivalue: true,
	})
	n.AllDstMEPLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allDstMEPLM",
		isMultivalue: true,
	})
	n.AllDstMEPLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allDstMEPLT",
		isMultivalue: true,
	})
	n.AllDstMepLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allDstMepLB",
		isMultivalue: true,
	})
	n.AllSVlanCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allSVlanCCM",
		isMultivalue: true,
	})
	n.AllSrcMEPDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allSrcMEPDM",
		isMultivalue: true,
	})
	n.AllSrcMEPLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allSrcMEPLM",
		isMultivalue: true,
	})
	n.AllSrcMEPLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allSrcMEPLT",
		isMultivalue: true,
	})
	n.AllSrcMepLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allSrcMepLB",
		isMultivalue: true,
	})
	n.AllVlanCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allVlanCCM",
		isMultivalue: true,
	})
	n.CVlanIdFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanIdFilterCCM",
		isMultivalue: true,
	})
	n.CVlanIdFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanIdFilterDM",
		isMultivalue: true,
	})
	n.CVlanIdFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanIdFilterLB",
		isMultivalue: true,
	})
	n.CVlanIdFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanIdFilterLM",
		isMultivalue: true,
	})
	n.CVlanIdFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanIdFilterLT",
		isMultivalue: true,
	})
	n.CVlanPriorityFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanPriorityFilterCCM",
		isMultivalue: true,
	})
	n.CVlanPriorityFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanPriorityFilterDM",
		isMultivalue: true,
	})
	n.CVlanPriorityFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanPriorityFilterLB",
		isMultivalue: true,
	})
	n.CVlanPriorityFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanPriorityFilterLM",
		isMultivalue: true,
	})
	n.CVlanPriorityFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanPriorityFilterLT",
		isMultivalue: true,
	})
	n.CVlanTpidFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanTpidFilterCCM",
		isMultivalue: true,
	})
	n.CVlanTpidFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanTpidFilterDM",
		isMultivalue: true,
	})
	n.CVlanTpidFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanTpidFilterLB",
		isMultivalue: true,
	})
	n.CVlanTpidFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanTpidFilterLM",
		isMultivalue: true,
	})
	n.CVlanTpidFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanTpidFilterLT",
		isMultivalue: true,
	})
	n.ConfiguredVlanDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredVlanDM",
		isMultivalue: true,
	})
	n.ConfiguredVlanLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredVlanLB",
		isMultivalue: true,
	})
	n.ConfiguredVlanLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredVlanLM",
		isMultivalue: true,
	})
	n.ConfiguredVlanLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredVlanLT",
		isMultivalue: true,
	})
	n.DestinationMpMacDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationMpMacDM",
		isMultivalue: true,
	})
	n.DestinationMpMacLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationMpMacLB",
		isMultivalue: true,
	})
	n.DestinationMpMacLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationMpMacLM",
		isMultivalue: true,
	})
	n.DestinationMpMacLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationMpMacLT",
		isMultivalue: true,
	})
	n.EnableVlanFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanFilterCCM",
		isMultivalue: true,
	})
	n.MdLevelLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdLevelLB",
		isMultivalue: true,
	})
	n.MdLevelLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdLevelLT",
		isMultivalue: true,
	})
	n.MdOrMegLevelCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdOrMegLevelCCM",
		isMultivalue: true,
	})
	n.MdOrMegLevelDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdOrMegLevelDM",
		isMultivalue: true,
	})
	n.MdOrMegLevelLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdOrMegLevelLM",
		isMultivalue: true,
	})
	n.MethodDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "methodDM",
		isMultivalue: true,
	})
	n.SVlanIdFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanIdFilterCCM",
		isMultivalue: true,
	})
	n.SVlanIdFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanIdFilterDM",
		isMultivalue: true,
	})
	n.SVlanIdFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanIdFilterLB",
		isMultivalue: true,
	})
	n.SVlanIdFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanIdFilterLM",
		isMultivalue: true,
	})
	n.SVlanIdFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanIdFilterLT",
		isMultivalue: true,
	})
	n.SVlanPriorityFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanPriorityFilterCCM",
		isMultivalue: true,
	})
	n.SVlanPriorityFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanPriorityFilterDM",
		isMultivalue: true,
	})
	n.SVlanPriorityFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanPriorityFilterLB",
		isMultivalue: true,
	})
	n.SVlanPriorityFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanPriorityFilterLM",
		isMultivalue: true,
	})
	n.SVlanPriorityFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanPriorityFilterLT",
		isMultivalue: true,
	})
	n.SVlanTpidFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanTpidFilterCCM",
		isMultivalue: true,
	})
	n.SVlanTpidFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanTpidFilterDM",
		isMultivalue: true,
	})
	n.SVlanTpidFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanTpidFilterLB",
		isMultivalue: true,
	})
	n.SVlanTpidFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanTpidFilterLM",
		isMultivalue: true,
	})
	n.SVlanTpidFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanTpidFilterLT",
		isMultivalue: true,
	})
	n.SourceMpMacDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMpMacDM",
		isMultivalue: true,
	})
	n.SourceMpMacLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMpMacLB",
		isMultivalue: true,
	})
	n.SourceMpMacLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMpMacLM",
		isMultivalue: true,
	})
	n.SourceMpMacLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMpMacLT",
		isMultivalue: true,
	})
	n.TimeoutDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutDM",
		isMultivalue: true,
	})
	n.TimeoutLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutLB",
		isMultivalue: true,
	})
	n.TimeoutLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutLM",
		isMultivalue: true,
	})
	n.TimeoutLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutLT",
		isMultivalue: true,
	})
	n.TransactionIdLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transactionIdLB",
		isMultivalue: true,
	})
	n.TransactionIdLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transactionIdLT",
		isMultivalue: true,
	})
	n.TtlLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttlLT",
		isMultivalue: true,
	})
	n.TypeDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeDM",
		isMultivalue: true,
	})
	n.VlanIdFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdFilterCCM",
		isMultivalue: true,
	})
	n.VlanIdFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdFilterDM",
		isMultivalue: true,
	})
	n.VlanIdFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdFilterLB",
		isMultivalue: true,
	})
	n.VlanIdFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdFilterLM",
		isMultivalue: true,
	})
	n.VlanIdFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdFilterLT",
		isMultivalue: true,
	})
	n.VlanPriorityFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanPriorityFilterCCM",
		isMultivalue: true,
	})
	n.VlanPriorityFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanPriorityFilterDM",
		isMultivalue: true,
	})
	n.VlanPriorityFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanPriorityFilterLB",
		isMultivalue: true,
	})
	n.VlanPriorityFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanPriorityFilterLM",
		isMultivalue: true,
	})
	n.VlanPriorityFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanPriorityFilterLT",
		isMultivalue: true,
	})
	n.VlanStackingCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanStackingCCM",
		isMultivalue: true,
	})
	n.VlanStackingDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanStackingDM",
		isMultivalue: true,
	})
	n.VlanStackingLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanStackingLB",
		isMultivalue: true,
	})
	n.VlanStackingLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanStackingLM",
		isMultivalue: true,
	})
	n.VlanStackingLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanStackingLT",
		isMultivalue: true,
	})
	n.VlanTpidFilterCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanTpidFilterCCM",
		isMultivalue: true,
	})
	n.VlanTpidFilterDM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanTpidFilterDM",
		isMultivalue: true,
	})
	n.VlanTpidFilterLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanTpidFilterLB",
		isMultivalue: true,
	})
	n.VlanTpidFilterLM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanTpidFilterLM",
		isMultivalue: true,
	})
	n.VlanTpidFilterLT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanTpidFilterLT",
		isMultivalue: true,
	})
}

// TopologyAncp: ANCP plugin
type TopologyAncp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DynamicTopologyDiscovery: Enable/Disable Dynamic Topology Discovery capability
	DynamicTopologyDiscovery *Multivalue `json:"dynamicTopologyDiscovery,omitempty"`
	// KeepAliveRetries: Number of times ANCP adjacency mechanism send ANCP keep-alive packets before closing the TCP connections
	KeepAliveRetries *Multivalue `json:"keepAliveRetries,omitempty"`
	// KeepAliveTimeout: Timer value in units of 100ms used in the adjacency protocol with the peer
	KeepAliveTimeout *Multivalue `json:"keepAliveTimeout,omitempty"`
	// LineConfiguration: Enable/Disable DSL Line Configuration capability
	LineConfiguration *Multivalue `json:"lineConfiguration,omitempty"`
	// MaxRedialAttempts: Number of attempts to establish ANCP adjacency in case connection is lost
	MaxRedialAttempts *Multivalue `json:"maxRedialAttempts,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NasIp: Ip address of BRAS listening for ANCP connections
	NasIp *Multivalue `json:"nasIp,omitempty"`
	// NasServicePort: BRAS TCP port number used to listen for ANCP connections
	NasServicePort *Multivalue `json:"nasServicePort,omitempty"`
	// PartitionId: Partition ID to be used in adjacency negotiation
	PartitionId *Multivalue `json:"partitionId,omitempty"`
	// RemoteLoopback: Enable/Disable DSL Remote Line Conectivity Testing Capability
	RemoteLoopback *Multivalue `json:"remoteLoopback,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// Standard: Define ANCP Standard to be used.
	Standard *Multivalue `json:"standard,omitempty"`
	// TransactionalMulticast: Enable/Disable advertise Transactional Multicast capability
	TransactionalMulticast *Multivalue `json:"transactionalMulticast,omitempty"`
	// TriggerAccessLoopEvents: Enable sending Port Up/ Port Down events when AN is Started / Stopped. Does not apply if flapping is enabled on the Access Loop
	TriggerAccessLoopEvents *Multivalue `json:"triggerAccessLoopEvents,omitempty"`
	// UnlimitedRedial: Limit the Number of attempts to establish ANCP adjacency in case connection is lost
	UnlimitedRedial *Multivalue `json:"unlimitedRedial,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyAncp) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyAncp) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyAncp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyAncp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DynamicTopologyDiscovery.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dynamicTopologyDiscovery",
		isMultivalue: true,
	})
	n.KeepAliveRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveRetries",
		isMultivalue: true,
	})
	n.KeepAliveTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveTimeout",
		isMultivalue: true,
	})
	n.LineConfiguration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lineConfiguration",
		isMultivalue: true,
	})
	n.MaxRedialAttempts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRedialAttempts",
		isMultivalue: true,
	})
	n.NasIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nasIp",
		isMultivalue: true,
	})
	n.NasServicePort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nasServicePort",
		isMultivalue: true,
	})
	n.PartitionId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partitionId",
		isMultivalue: true,
	})
	n.RemoteLoopback.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteLoopback",
		isMultivalue: true,
	})
	n.Standard.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "standard",
		isMultivalue: true,
	})
	n.TransactionalMulticast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transactionalMulticast",
		isMultivalue: true,
	})
	n.TriggerAccessLoopEvents.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggerAccessLoopEvents",
		isMultivalue: true,
	})
	n.UnlimitedRedial.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unlimitedRedial",
		isMultivalue: true,
	})
}

// TopologyAtoiTlvList: PTP IEEE ATOI TLV related configuration
type TopologyAtoiTlvList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CurrentOffset: 'Current Offset' shall be the current offset of the local time, in seconds.
	CurrentOffset *Multivalue `json:"currentOffset,omitempty"`
	// DisplayName: 'Display Name' shall be the text name of the alternate timescale.
	DisplayName *Multivalue `json:"displayName,omitempty"`
	// JumpSeconds: 'Jump Seconds' shall be 0 when the local time does not use Daylight Saving Time (DST), else shall be Nx900 with N, an integer greater or less than 0.
	JumpSeconds *Multivalue `json:"jumpSeconds,omitempty"`
	// KeyField: keyField shall be >0 when the offset is valid, else 0.
	KeyField *Multivalue `json:"keyField,omitempty"`
	// MvActive: Activate/Deactivate Configuration.
	MvActive *Multivalue `json:"mvActive,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TimeOfNextJump: When not zero, 'Time Of Next Jump' shall be the second portion of the PTP time at the next DST event, OR the next leap second.
	TimeOfNextJump *Multivalue `json:"timeOfNextJump,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyAtoiTlvList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyAtoiTlvList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyAtoiTlvList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyAtoiTlvList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.CurrentOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "currentOffset",
		isMultivalue: true,
	})
	n.DisplayName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "displayName",
		isMultivalue: true,
	})
	n.JumpSeconds.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "jumpSeconds",
		isMultivalue: true,
	})
	n.KeyField.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keyField",
		isMultivalue: true,
	})
	n.MvActive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvActive",
		isMultivalue: true,
	})
	n.TimeOfNextJump.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeOfNextJump",
		isMultivalue: true,
	})
}

// TopologyAuxiliaryConnectionList: Openflow Switch Auxiliary Connections level Configuration
type TopologyAuxiliaryConnectionList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuxId: Specify the Auxiliary Id, {0 - 255}
	AuxId *Multivalue `json:"auxId,omitempty"`
	// ConnectionType: The type of connection used for the Interface. Options include: 1) TCP 2) TLS 3) UDP
	ConnectionType *Multivalue `json:"connectionType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// UDPSrcPortNum: UDP Source Port Number
	UDPSrcPortNum *Multivalue `json:"uDPSrcPortNum,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyAuxiliaryConnectionList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyAuxiliaryConnectionList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyAuxiliaryConnectionList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyAuxiliaryConnectionList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuxId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxId",
		isMultivalue: true,
	})
	n.ConnectionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "connectionType",
		isMultivalue: true,
	})
	n.UDPSrcPortNum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uDPSrcPortNum",
		isMultivalue: true,
	})
}

// TopologyBackupLspEroSubObjectsList: Rsvp ERO Sub-Objects
type TopologyBackupLspEroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AsNumber: AS
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// LooseFlag: Loose Flag
	LooseFlag *Multivalue `json:"looseFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBackupLspEroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBackupLspEroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBackupLspEroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBackupLspEroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.LooseFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "looseFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyBands: Openflow Controller Bands Configuration
type TopologyBands struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BandDescription: The description of the Meter. It is a read-only field.
	BandDescription *Multivalue `json:"bandDescription,omitempty"`
	// BandType: Select the band type from the list. Options are as follows: 1) Drop 2) DSCP Remark 3) Experimenter
	BandType *Multivalue `json:"bandType,omitempty"`
	// BurstSize: This indicates the length of the packet or byte burst to consider for applying the meter. The default value is 1.
	BurstSize *Multivalue `json:"burstSize,omitempty"`
	// Experimenter: Indicats the experimenter ID. The default value is 1.
	Experimenter *Multivalue `json:"experimenter,omitempty"`
	// Multiplier: Number of instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PrecedenceLevel: This indicates the amount by which the drop precedence of the packet should be increased if the band is exceeded. The default value is 0.
	PrecedenceLevel *Multivalue `json:"precedenceLevel,omitempty"`
	// Rate: This indicates the rate value above which the corresponding band may apply to packets. The default value is 1.
	Rate *Multivalue `json:"rate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBands) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBands) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBands) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBands) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BandDescription.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandDescription",
		isMultivalue: true,
	})
	n.BandType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandType",
		isMultivalue: true,
	})
	n.BurstSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "burstSize",
		isMultivalue: true,
	})
	n.Experimenter.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "experimenter",
		isMultivalue: true,
	})
	n.PrecedenceLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "precedenceLevel",
		isMultivalue: true,
	})
	n.Rate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rate",
		isMultivalue: true,
	})
}

// TopologyBaseVidList: ISIS SPB BaseVID Configuration
type TopologyBaseVidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BaseVid: Base VID
	BaseVid *Multivalue `json:"baseVid,omitempty"`
	// BaseVlanPriority: B-VLAN Priority
	BaseVlanPriority *Multivalue `json:"baseVlanPriority,omitempty"`
	// Bmac: B-MAC Address
	Bmac *Multivalue `json:"bmac,omitempty"`
	// BmacSameAsSystemId: BMAC Same As System Id
	BmacSameAsSystemId *Multivalue `json:"bmacSameAsSystemId,omitempty"`
	// BvlanTpid: B-VLAN TPID
	BvlanTpid *Multivalue `json:"bvlanTpid,omitempty"`
	// EctAlgorithm: ECT AlgorithmType
	EctAlgorithm *Multivalue `json:"ectAlgorithm,omitempty"`
	// IsidCount: ISID Count(multiplier)

	IsidCount *float32 `json:"isidCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UseFlagBit: Use Flag Bit
	UseFlagBit *Multivalue `json:"useFlagBit,omitempty"`

	IsidList *TopologyIsidList `json:"isidList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBaseVidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBaseVidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBaseVidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBaseVidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BaseVid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseVid",
		isMultivalue: true,
	})
	n.BaseVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseVlanPriority",
		isMultivalue: true,
	})
	n.Bmac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bmac",
		isMultivalue: true,
	})
	n.BmacSameAsSystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bmacSameAsSystemId",
		isMultivalue: true,
	})
	n.BvlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bvlanTpid",
		isMultivalue: true,
	})
	n.EctAlgorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ectAlgorithm",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UseFlagBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useFlagBit",
		isMultivalue: true,
	})
	n.IsidList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isidList",
	})
}

// TopologyBfdRouter: BFD Device level Configuration
type TopologyBfdRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBfdRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBfdRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBfdRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBfdRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyBfdv4Interface: BFDv4 Interface (Device) level Configuration
type TopologyBfdv4Interface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AggregateBfdSession: If enabled, all interfaces except on VNI 0 will be disabled and grayed-out.

	AggregateBfdSession *bool `json:"aggregateBfdSession,omitempty"`
	// ConfigureEchoSourceIp: Selecting this check box enables the ability to configure the source address IP of echo message
	ConfigureEchoSourceIp *Multivalue `json:"configureEchoSourceIp,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EchoRxInterval: The minimum interval, in milliseconds, between received BFD Echo packets that this interface is capable of supporting. If this value is zero, the transmitting system does not support the receipt of BFD Echo packets
	EchoRxInterval *Multivalue `json:"echoRxInterval,omitempty"`
	// EchoTimeOut: The interval, in milliseconds, that the interface waits for a response to the last Echo packet sent out
	EchoTimeOut *Multivalue `json:"echoTimeOut,omitempty"`
	// EchoTxInterval: The minimum interval, in milliseconds, that the interface would like to use when transmitting BFD Echo packets
	EchoTxInterval *Multivalue `json:"echoTxInterval,omitempty"`
	// EnableControlPlaneIndependent: This check box enables Control Plane Independent Mode. If set, the interface's BFD is implemented in the forwarding plane and can continue to function through disruptions in the control plane
	EnableControlPlaneIndependent *Multivalue `json:"enableControlPlaneIndependent,omitempty"`
	// EnableDemandMode: This check box enables Demand Mode. In this mode, it is assumed the interface has an independent way of verifying it has connectivity to the other system. Once a BFD session is established, the systems stop sending BFD Control packets, except when either system feels the need to verify connectivity explicitly. In this case, a short sequence of BFD Control packets is sent
	EnableDemandMode *Multivalue `json:"enableDemandMode,omitempty"`
	// FlapTxIntervals: The number of Tx packets sent from device after which session flaps for BFD. A value of zero means no flapping
	FlapTxIntervals *Multivalue `json:"flapTxIntervals,omitempty"`
	// IpDiffServ: IP DiffServ/TOSByte (Dec)
	IpDiffServ *Multivalue `json:"ipDiffServ,omitempty"`
	// MinRxInterval: The minimum interval, in milliseconds, between received BFD Control packets that this interface is capable of supporting
	MinRxInterval *Multivalue `json:"minRxInterval,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfSessions: The number of configured BFD sessions

	NoOfSessions *float32 `json:"noOfSessions,omitempty"`
	// PollInterval: The interval, in milliseconds, between exchanges of Control Messages in Demand Mode
	PollInterval *Multivalue `json:"pollInterval,omitempty"`
	// SourceIp4: If Configure Echo Source-IP is selected, the IPv4 source address of the Echo Message
	SourceIp4 *Multivalue `json:"sourceIp4,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TimeoutMultiplier: The negotiated transmit interval, multiplied by this value, provides the detection time for the interface
	TimeoutMultiplier *Multivalue `json:"timeoutMultiplier,omitempty"`
	// TxInterval: The minimum interval, in milliseconds, that the interface would like to use when transmitting BFD Control packets
	TxInterval *Multivalue `json:"txInterval,omitempty"`

	Bfdv4Session *TopologyBfdv4Session  `json:"bfdv4Session,omitempty"`
	LearnedInfo  []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBfdv4Interface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBfdv4Interface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBfdv4Interface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBfdv4Interface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ConfigureEchoSourceIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureEchoSourceIp",
		isMultivalue: true,
	})
	n.EchoRxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoRxInterval",
		isMultivalue: true,
	})
	n.EchoTimeOut.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoTimeOut",
		isMultivalue: true,
	})
	n.EchoTxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoTxInterval",
		isMultivalue: true,
	})
	n.EnableControlPlaneIndependent.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableControlPlaneIndependent",
		isMultivalue: true,
	})
	n.EnableDemandMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDemandMode",
		isMultivalue: true,
	})
	n.FlapTxIntervals.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapTxIntervals",
		isMultivalue: true,
	})
	n.IpDiffServ.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipDiffServ",
		isMultivalue: true,
	})
	n.MinRxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minRxInterval",
		isMultivalue: true,
	})
	n.PollInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pollInterval",
		isMultivalue: true,
	})
	n.SourceIp4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIp4",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	n.TxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txInterval",
		isMultivalue: true,
	})
	n.Bfdv4Session.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bfdv4Session",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBfdv4Session: BFDv4 Session (Device) level Configuration
type TopologyBfdv4Session struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// EnableAutoChooseSourceIp: Selecting this check box enables the ability to configure the source IP address IP of BFD Session
	EnableAutoChooseSourceIp *Multivalue `json:"enableAutoChooseSourceIp,omitempty"`
	// EnableOVSDBCommunication: Selecting this check box enables the ability to communicate the remote IP and MAC address of BFD Session
	EnableOVSDBCommunication *Multivalue `json:"enableOVSDBCommunication,omitempty"`
	// EnableRemoteDiscriminatorLearned: Selecting this check box enables the ability to configure the remote discriminator for BFD Session
	EnableRemoteDiscriminatorLearned *Multivalue `json:"enableRemoteDiscriminatorLearned,omitempty"`
	// IpTTL: TTL value of inner ip of BFDoVXLAN packet
	IpTTL *Multivalue `json:"ipTTL,omitempty"`
	// MyDiscriminator: The discriminator used locally for the BFD session
	MyDiscriminator *Multivalue `json:"myDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RemoteDiscriminator: The remote discriminator used by the peer BFD for session
	RemoteDiscriminator *Multivalue `json:"remoteDiscriminator,omitempty"`
	// RemoteIp4: The remote IP address used in BFD session
	RemoteIp4 *Multivalue `json:"remoteIp4,omitempty"`
	// RemoteMac: Remote MAC Address of Peer
	RemoteMac *Multivalue `json:"remoteMac,omitempty"`
	// SessionType: Session Type used in BFD session. One of: Single Hop, Multi Hops
	SessionType *Multivalue `json:"sessionType,omitempty"`
	// SourceIp4: The source IP address used in BFD session
	SourceIp4 *Multivalue `json:"sourceIp4,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBfdv4Session) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBfdv4Session) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBfdv4Session) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBfdv4Session) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableAutoChooseSourceIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoChooseSourceIp",
		isMultivalue: true,
	})
	n.EnableOVSDBCommunication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOVSDBCommunication",
		isMultivalue: true,
	})
	n.EnableRemoteDiscriminatorLearned.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRemoteDiscriminatorLearned",
		isMultivalue: true,
	})
	n.IpTTL.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipTTL",
		isMultivalue: true,
	})
	n.MyDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "myDiscriminator",
		isMultivalue: true,
	})
	n.RemoteDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteDiscriminator",
		isMultivalue: true,
	})
	n.RemoteIp4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIp4",
		isMultivalue: true,
	})
	n.RemoteMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteMac",
		isMultivalue: true,
	})
	n.SessionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionType",
		isMultivalue: true,
	})
	n.SourceIp4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIp4",
		isMultivalue: true,
	})
}

// TopologyBfdv6Interface: BFDv6 Interface level Configuration
type TopologyBfdv6Interface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AggregateBfdSession: If enabled, all interfaces except on VNI 0 will be disabled and grayed-out.

	AggregateBfdSession *bool `json:"aggregateBfdSession,omitempty"`
	// ConfigureEchoSourceIp: Selecting this check box enables the ability to configure the source address IP of echo message
	ConfigureEchoSourceIp *Multivalue `json:"configureEchoSourceIp,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EchoRxInterval: The minimum interval, in milliseconds, between received BFD Echo packets that this interface is capable of supporting. If this value is zero, the transmitting system does not support the receipt of BFD Echo packets
	EchoRxInterval *Multivalue `json:"echoRxInterval,omitempty"`
	// EchoTimeOut: The interval, in milliseconds, that the interface waits for a response to the last Echo packet sent out
	EchoTimeOut *Multivalue `json:"echoTimeOut,omitempty"`
	// EchoTxInterval: The minimum interval, in milliseconds, that the interface would like to use when transmitting BFD Echo packets
	EchoTxInterval *Multivalue `json:"echoTxInterval,omitempty"`
	// EnableControlPlaneIndependent: This check box enables Control Plane Independent Mode. If set, the interface's BFD is implemented in the forwarding plane and can continue to function through disruptions in the control plane
	EnableControlPlaneIndependent *Multivalue `json:"enableControlPlaneIndependent,omitempty"`
	// EnableDemandMode: This check box enables Demand Mode. In this mode, it is assumed the interface has an independent way of verifying it has connectivity to the other system. Once a BFD session is established, the systems stop sending BFD Control packets, except when either system feels the need to verify connectivity explicitly. In this case, a short sequence of BFD Control packets is sent
	EnableDemandMode *Multivalue `json:"enableDemandMode,omitempty"`
	// FlapTxIntervals: The number of Tx packets sent from device after which session flaps for BFD. A value of zero means no flapping
	FlapTxIntervals *Multivalue `json:"flapTxIntervals,omitempty"`
	// IpDiffServ: IP DiffServ/TOSByte (Dec)
	IpDiffServ *Multivalue `json:"ipDiffServ,omitempty"`
	// MinRxInterval: The minimum interval, in milliseconds, between received BFD Control packets that this interface is capable of supporting
	MinRxInterval *Multivalue `json:"minRxInterval,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfSessions: The number of configured BFD sessions

	NoOfSessions *float32 `json:"noOfSessions,omitempty"`
	// PollInterval: The interval, in milliseconds, between exchanges of Control Messages in Demand Mode
	PollInterval *Multivalue `json:"pollInterval,omitempty"`
	// SourceIp6: If Configure Echo Source-IP is selected, the IPv6 source address of the Echo Message
	SourceIp6 *Multivalue `json:"sourceIp6,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TimeoutMultiplier: The negotiated transmit interval, multiplied by this value, provides the detection time for the interface
	TimeoutMultiplier *Multivalue `json:"timeoutMultiplier,omitempty"`
	// TxInterval: The minimum interval, in milliseconds, that the interface would like to use when transmitting BFD Control packets
	TxInterval *Multivalue `json:"txInterval,omitempty"`

	Bfdv6Session *TopologyBfdv6Session  `json:"bfdv6Session,omitempty"`
	LearnedInfo  []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBfdv6Interface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBfdv6Interface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBfdv6Interface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBfdv6Interface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ConfigureEchoSourceIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureEchoSourceIp",
		isMultivalue: true,
	})
	n.EchoRxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoRxInterval",
		isMultivalue: true,
	})
	n.EchoTimeOut.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoTimeOut",
		isMultivalue: true,
	})
	n.EchoTxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoTxInterval",
		isMultivalue: true,
	})
	n.EnableControlPlaneIndependent.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableControlPlaneIndependent",
		isMultivalue: true,
	})
	n.EnableDemandMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDemandMode",
		isMultivalue: true,
	})
	n.FlapTxIntervals.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapTxIntervals",
		isMultivalue: true,
	})
	n.IpDiffServ.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipDiffServ",
		isMultivalue: true,
	})
	n.MinRxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minRxInterval",
		isMultivalue: true,
	})
	n.PollInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pollInterval",
		isMultivalue: true,
	})
	n.SourceIp6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIp6",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	n.TxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txInterval",
		isMultivalue: true,
	})
	n.Bfdv6Session.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bfdv6Session",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBfdv6Session: BFDv6 Session (Device) level Configuration
type TopologyBfdv6Session struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// EnableAutoChooseSourceIp: Selecting this check box enables the ability to configure the source IP address IP of BFD Session
	EnableAutoChooseSourceIp *Multivalue `json:"enableAutoChooseSourceIp,omitempty"`
	// EnableOVSDBCommunication: Selecting this check box enables the ability to communicate the remote IP and MAC address of BFD Session
	EnableOVSDBCommunication *Multivalue `json:"enableOVSDBCommunication,omitempty"`
	// EnableRemoteDiscriminatorLearned: Selecting this check box enables the ability to configure the remote discriminator for BFD Session
	EnableRemoteDiscriminatorLearned *Multivalue `json:"enableRemoteDiscriminatorLearned,omitempty"`
	// MyDiscriminator: The discriminator used locally for the BFD session
	MyDiscriminator *Multivalue `json:"myDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RemoteDiscriminator: The remote discriminator used by the peer BFD for session
	RemoteDiscriminator *Multivalue `json:"remoteDiscriminator,omitempty"`
	// RemoteIp6: The remote IP address used in BFD session
	RemoteIp6 *Multivalue `json:"remoteIp6,omitempty"`
	// RemoteMac: Remote MAC Address of Peer
	RemoteMac *Multivalue `json:"remoteMac,omitempty"`
	// SessionType: Session Type used in BFD session. One of: Single Hop, Multi Hops
	SessionType *Multivalue `json:"sessionType,omitempty"`
	// SourceIp6: The source IP address used in BFD session
	SourceIp6 *Multivalue `json:"sourceIp6,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBfdv6Session) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBfdv6Session) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBfdv6Session) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBfdv6Session) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableAutoChooseSourceIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoChooseSourceIp",
		isMultivalue: true,
	})
	n.EnableOVSDBCommunication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOVSDBCommunication",
		isMultivalue: true,
	})
	n.EnableRemoteDiscriminatorLearned.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRemoteDiscriminatorLearned",
		isMultivalue: true,
	})
	n.MyDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "myDiscriminator",
		isMultivalue: true,
	})
	n.RemoteDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteDiscriminator",
		isMultivalue: true,
	})
	n.RemoteIp6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIp6",
		isMultivalue: true,
	})
	n.RemoteMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteMac",
		isMultivalue: true,
	})
	n.SessionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionType",
		isMultivalue: true,
	})
	n.SourceIp6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIp6",
		isMultivalue: true,
	})
}

// TopologyBgp8277SrSegmentIdList: Rfc 8277 Segment Id Stack
type TopologyBgp8277SrSegmentIdList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IncrementMode: Either Fixed or Increment
	IncrementMode *Multivalue `json:"incrementMode,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SegmentId: SID or Segment ID, converts to label value by adding offset into SRGB Start Label Value.
	SegmentId *Multivalue `json:"segmentId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgp8277SrSegmentIdList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgp8277SrSegmentIdList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgp8277SrSegmentIdList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgp8277SrSegmentIdList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.IncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "incrementMode",
		isMultivalue: true,
	})
	n.SegmentId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentId",
		isMultivalue: true,
	})
}

// TopologyBgpAigpList: Bgp AIGP
type TopologyBgpAigpList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// Value: Value
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpAigpList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpAigpList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpAigpList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpAigpList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyBgpAsNumberList: Bgp Non VPN RR ASNumber
type TopologyBgpAsNumberList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AsNumber: AS#
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// EnableASNumber: Enable AS Number
	EnableASNumber *Multivalue `json:"enableASNumber,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpAsNumberList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpAsNumberList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpAsNumberList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpAsNumberList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.EnableASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableASNumber",
		isMultivalue: true,
	})
}

// TopologyBgpAsPathSegmentList: Bgp Non VPN RR AS Path segments
type TopologyBgpAsPathSegmentList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableASPathSegment: Enable AS Path Segment
	EnableASPathSegment *Multivalue `json:"enableASPathSegment,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfAsNumberInSegment: Number of AS Number In Segment

	NumberOfAsNumberInSegment *float32 `json:"numberOfAsNumberInSegment,omitempty"`
	// SegmentType: SegmentType
	SegmentType     *Multivalue                `json:"segmentType,omitempty"`
	BgpAsNumberList []*TopologyBgpAsNumberList `json:"bgpAsNumberList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpAsPathSegmentList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpAsPathSegmentList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpAsPathSegmentList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpAsPathSegmentList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableASPathSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableASPathSegment",
		isMultivalue: true,
	})
	n.SegmentType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentType",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsNumberList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsNumberList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpClusterIdList: Bgp Non VPN RR Cluster ID
type TopologyBgpClusterIdList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ClusterId: Cluster ID
	ClusterId *Multivalue `json:"clusterId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpClusterIdList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpClusterIdList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpClusterIdList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpClusterIdList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ClusterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clusterId",
		isMultivalue: true,
	})
}

// TopologyBgpCommunitiesList: Bgp Non VPN RR Communities
type TopologyBgpCommunitiesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AsNumber: AS #
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// LastTwoOctets: Last Two Octets
	LastTwoOctets *Multivalue `json:"lastTwoOctets,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpCommunitiesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpCommunitiesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpCommunitiesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpCommunitiesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.LastTwoOctets.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lastTwoOctets",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyBgpCustomAfiSafiv4: TBD
type TopologyBgpCustomAfiSafiv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AfiValue: User Defined AFI value
	AfiValue *Multivalue `json:"afiValue,omitempty"`
	// DataValue: Hex Dump to be used in NLRI field of MP_REACH_NLRI of update packet
	DataValue *Multivalue `json:"dataValue,omitempty"`
	// LengthOfData: Length (in Bytes) of NLRI corresponding to AFI,SAFI configured
	LengthOfData *Multivalue `json:"lengthOfData,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SafiValue: User Defined SAFI value
	SafiValue *Multivalue `json:"safiValue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpCustomAfiSafiv4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpCustomAfiSafiv4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpCustomAfiSafiv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpCustomAfiSafiv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AfiValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "afiValue",
		isMultivalue: true,
	})
	n.DataValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataValue",
		isMultivalue: true,
	})
	n.LengthOfData.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lengthOfData",
		isMultivalue: true,
	})
	n.SafiValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "safiValue",
		isMultivalue: true,
	})
}

// TopologyBgpCustomAfiSafiv6: TBD
type TopologyBgpCustomAfiSafiv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AfiValue: User Defined AFI value
	AfiValue *Multivalue `json:"afiValue,omitempty"`
	// DataValue: Hex Dump to be used in NLRI field of MP_REACH_NLRI of update packet
	DataValue *Multivalue `json:"dataValue,omitempty"`
	// LengthOfData: Length (in Bytes) of NLRI corresponding to AFI,SAFI configured
	LengthOfData *Multivalue `json:"lengthOfData,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SafiValue: User Defined SAFI value
	SafiValue *Multivalue `json:"safiValue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpCustomAfiSafiv6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpCustomAfiSafiv6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpCustomAfiSafiv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpCustomAfiSafiv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AfiValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "afiValue",
		isMultivalue: true,
	})
	n.DataValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataValue",
		isMultivalue: true,
	})
	n.LengthOfData.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lengthOfData",
		isMultivalue: true,
	})
	n.SafiValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "safiValue",
		isMultivalue: true,
	})
}

// TopologyBgpEpePeerLinkList: EPE Peer Links
type TopologyBgpEpePeerLinkList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// BBit: B-Flag:Backup Flag.If set, the SID refers to a path that is eligible for protection.
	BBit *Multivalue `json:"bBit,omitempty"`
	// EnableLinkAddress: Enable Link Addresses
	EnableLinkAddress *Multivalue `json:"enableLinkAddress,omitempty"`
	// EnableLinkIdentifier: Enable Link Identifier
	EnableLinkIdentifier *Multivalue `json:"enableLinkIdentifier,omitempty"`
	// EnablePeerAdjSid: Enable Peer-Adj-SID
	EnablePeerAdjSid *Multivalue `json:"enablePeerAdjSid,omitempty"`
	// LBit: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance.
	LBit *Multivalue `json:"lBit,omitempty"`
	// LinkAddressType: Link Address Type
	LinkAddressType *Multivalue `json:"linkAddressType,omitempty"`
	// LinkLocalIdentifier: Link Local Identifier
	LinkLocalIdentifier *Multivalue `json:"linkLocalIdentifier,omitempty"`
	// LinkNumber: EPE Link Number For Reference
	LinkNumber *Multivalue `json:"linkNumber,omitempty"`
	// LinkRemoteIdentifier: Link Remote Identifier
	LinkRemoteIdentifier *Multivalue `json:"linkRemoteIdentifier,omitempty"`
	// LocalIpv4LinkAddress: Local IPv4 Link Address
	LocalIpv4LinkAddress *Multivalue `json:"localIpv4LinkAddress,omitempty"`
	// LocalIpv6LinkAddress: Local IPv6 Link Address
	LocalIpv6LinkAddress *Multivalue `json:"localIpv6LinkAddress,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PBit: P-Flag: Persistent Flag: If set, the SID is persistently allocated, i.e. the SID value remains consistent across router restart and session/interface flap
	PBit *Multivalue `json:"pBit,omitempty"`
	// RemoteIpv4LinkAddress: Remote IPv4 Link Address
	RemoteIpv4LinkAddress *Multivalue `json:"remoteIpv4LinkAddress,omitempty"`
	// RemoteIpv6LinkAddress: Remote IPv6 Link Address
	RemoteIpv6LinkAddress *Multivalue `json:"remoteIpv6LinkAddress,omitempty"`
	// Reserved: Reserved
	Reserved *Multivalue `json:"reserved,omitempty"`
	// RsvdBits: Reserved for future use and MUST be zero when originated and ignored when received
	RsvdBits *Multivalue `json:"rsvdBits,omitempty"`
	// SidIndex: Local Label for Peer-Adj
	SidIndex *Multivalue `json:"sidIndex,omitempty"`
	// SidIndexValue: If Local Label type is SID, max value is 16777215 and for Index max value is 4294967295
	SidIndexValue *Multivalue `json:"sidIndexValue,omitempty"`
	// VBit: V-Flag: Value flag. If set, then the SID carries a label value.
	VBit *Multivalue `json:"vBit,omitempty"`
	// Weight: Weight of the SID for the purpose of load balancing
	Weight     *Multivalue           `json:"weight,omitempty"`
	TlvProfile []*TopologyTlvProfile `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpEpePeerLinkList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpEpePeerLinkList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpEpePeerLinkList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpEpePeerLinkList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bBit",
		isMultivalue: true,
	})
	n.EnableLinkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLinkAddress",
		isMultivalue: true,
	})
	n.EnableLinkIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLinkIdentifier",
		isMultivalue: true,
	})
	n.EnablePeerAdjSid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePeerAdjSid",
		isMultivalue: true,
	})
	n.LBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lBit",
		isMultivalue: true,
	})
	n.LinkAddressType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkAddressType",
		isMultivalue: true,
	})
	n.LinkLocalIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkLocalIdentifier",
		isMultivalue: true,
	})
	n.LinkNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkNumber",
		isMultivalue: true,
	})
	n.LinkRemoteIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkRemoteIdentifier",
		isMultivalue: true,
	})
	n.LocalIpv4LinkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localIpv4LinkAddress",
		isMultivalue: true,
	})
	n.LocalIpv6LinkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localIpv6LinkAddress",
		isMultivalue: true,
	})
	n.PBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pBit",
		isMultivalue: true,
	})
	n.RemoteIpv4LinkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIpv4LinkAddress",
		isMultivalue: true,
	})
	n.RemoteIpv6LinkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIpv6LinkAddress",
		isMultivalue: true,
	})
	n.Reserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved",
		isMultivalue: true,
	})
	n.RsvdBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvdBits",
		isMultivalue: true,
	})
	n.SidIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndex",
		isMultivalue: true,
	})
	n.SidIndexValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexValue",
		isMultivalue: true,
	})
	n.VBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vBit",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpEpePeerList: EPE Peers
type TopologyBgpEpePeerList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// BBit: B-Flag:Backup Flag.If set, the SID refers to a path that is eligible for protection.
	BBit *Multivalue `json:"bBit,omitempty"`
	// BgpLocalRouterId: BGP Router ID for Local Node Descriptor
	BgpLocalRouterId *Multivalue `json:"bgpLocalRouterId,omitempty"`
	// BgpRemoteRouterId: BGP Router ID for Remote Node Descriptor
	BgpRemoteRouterId *Multivalue `json:"bgpRemoteRouterId,omitempty"`
	// EnablePeerNodeSid: Enable Peer-Node-SID
	EnablePeerNodeSid *Multivalue `json:"enablePeerNodeSid,omitempty"`
	// LBit: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance.
	LBit *Multivalue `json:"lBit,omitempty"`
	// LocalAsn: AS# of Egress node
	LocalAsn *Multivalue `json:"localAsn,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfPeerSet: Number of EPE Peer Set

	NoOfPeerSet *float32 `json:"noOfPeerSet,omitempty"`
	// NoOflinks: Number of Links

	NoOflinks *float32 `json:"noOflinks,omitempty"`
	// PBit: P-Flag: Persistent Flag: If set, the SID is persistently allocated, i.e. the SID value remains consistent across router restart and session/interface flap
	PBit *Multivalue `json:"pBit,omitempty"`
	// PeerName: Peer Name For Reference
	PeerName *Multivalue `json:"peerName,omitempty"`
	// PeerSetGroup: Peer Set Group
	PeerSetGroup *Multivalue `json:"peerSetGroup,omitempty"`
	// RemoteAsn: AS# of Peer Node
	RemoteAsn *Multivalue `json:"remoteAsn,omitempty"`
	// Reserved: Reserved
	Reserved *Multivalue `json:"reserved,omitempty"`
	// RsvdBits: Reserved for future use and MUST be zero when originated and ignored when received
	RsvdBits *Multivalue `json:"rsvdBits,omitempty"`
	// SidIndex: Local Label for Peer-Node
	SidIndex *Multivalue `json:"sidIndex,omitempty"`
	// SidIndexValue: If Local Label type is SID, max value is 16777215 and for Index max value is 4294967295
	SidIndexValue *Multivalue `json:"sidIndexValue,omitempty"`
	// UseLocalConfedId: Use Local Confederation identifier
	UseLocalConfedId *Multivalue `json:"useLocalConfedId,omitempty"`
	// UseRemoteConfedId: Use Remote Confederation identifier
	UseRemoteConfedId *Multivalue `json:"useRemoteConfedId,omitempty"`
	// VBit: V-Flag: Value flag. If set, then the SID carries a label value.
	VBit *Multivalue `json:"vBit,omitempty"`
	// Weight: Weight of SID for Load Balancing
	Weight *Multivalue `json:"weight,omitempty"`

	BgpEpePeerLinkList *TopologyBgpEpePeerLinkList  `json:"bgpEpePeerLinkList,omitempty"`
	BgpEpePeerSetList  []*TopologyBgpEpePeerSetList `json:"bgpEpePeerSetList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpEpePeerList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpEpePeerList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpEpePeerList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpEpePeerList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bBit",
		isMultivalue: true,
	})
	n.BgpLocalRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLocalRouterId",
		isMultivalue: true,
	})
	n.BgpRemoteRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpRemoteRouterId",
		isMultivalue: true,
	})
	n.EnablePeerNodeSid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePeerNodeSid",
		isMultivalue: true,
	})
	n.LBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lBit",
		isMultivalue: true,
	})
	n.LocalAsn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localAsn",
		isMultivalue: true,
	})
	n.PBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pBit",
		isMultivalue: true,
	})
	n.PeerName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerName",
		isMultivalue: true,
	})
	n.PeerSetGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerSetGroup",
		isMultivalue: true,
	})
	n.RemoteAsn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteAsn",
		isMultivalue: true,
	})
	n.Reserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved",
		isMultivalue: true,
	})
	n.RsvdBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvdBits",
		isMultivalue: true,
	})
	n.SidIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndex",
		isMultivalue: true,
	})
	n.SidIndexValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexValue",
		isMultivalue: true,
	})
	n.UseLocalConfedId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useLocalConfedId",
		isMultivalue: true,
	})
	n.UseRemoteConfedId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useRemoteConfedId",
		isMultivalue: true,
	})
	n.VBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vBit",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.BgpEpePeerLinkList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpEpePeerLinkList",
	})
	for i, o := range n.BgpEpePeerSetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpEpePeerSetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpEpePeerSetList: EPE Peer Set
type TopologyBgpEpePeerSetList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BBit: B-Flag:Backup Flag.If set, the SID refers to a path that is eligible for protection.

	BBit *bool `json:"bBit,omitempty"`
	// LBit: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance.

	LBit *bool `json:"lBit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PBit: P-Flag: Persistent Flag: If set, the SID is persistently allocated, i.e. the SID value remains consistent across router restart and session/interface flap

	PBit *bool `json:"pBit,omitempty"`
	// Reserved: Reserved

	Reserved *float32 `json:"reserved,omitempty"`
	// RsvdBits: Reserved for future use and MUST be zero when originated and ignored when received
	RsvdBits *Multivalue `json:"rsvdBits,omitempty"`
	// SidIndex: Local Label for Peer-Set

	SidIndex *string `json:"sidIndex,omitempty"`
	// SidIndexValue: If Local Label type is SID, max value is 16777215 and for Index max value is 4294967295

	SidIndexValue *float32 `json:"sidIndexValue,omitempty"`
	// VBit: V-Flag: Value flag. If set, then the SID carries a label value.

	VBit *bool `json:"vBit,omitempty"`
	// Weight: Weight of SID for the purpose of load balancing

	Weight *float32 `json:"weight,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpEpePeerSetList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpEpePeerSetList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpEpePeerSetList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpEpePeerSetList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.RsvdBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvdBits",
		isMultivalue: true,
	})
}

// TopologyBgpEthernetSegmentV4: BGP V4 Ethernet Segment Configuration
type TopologyBgpEthernetSegmentV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvertiseAliasingBeforeAdPerEsRoute: Advertise Aliasing Before A-D/ES Route
	AdvertiseAliasingBeforeAdPerEsRoute *Multivalue `json:"AdvertiseAliasingBeforeAdPerEsRoute,omitempty"`
	// AdvertiseInclusiveMulticastRoute: Support Inclusive Multicast Ethernet Tag Route (RT Type 3)
	AdvertiseInclusiveMulticastRoute *Multivalue `json:"AdvertiseInclusiveMulticastRoute,omitempty"`
	// AliasingRouteGranularity: Aliasing Route Granularity
	AliasingRouteGranularity *Multivalue `json:"AliasingRouteGranularity,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseAliasingAutomatically: Advertise Aliasing Automatically
	AdvertiseAliasingAutomatically *Multivalue `json:"advertiseAliasingAutomatically,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigureEsImport: Auto Configure ES-Import
	AutoConfigureEsImport *Multivalue `json:"autoConfigureEsImport,omitempty"`
	// BMacPrefix: B-MAC Prefix
	BMacPrefix *Multivalue `json:"bMacPrefix,omitempty"`
	// BMacPrefixLength: B-MAC Prefix Length
	BMacPrefixLength *Multivalue `json:"bMacPrefixLength,omitempty"`
	// DfElectionTimer: DF Election Timer(s)
	DfElectionTimer *Multivalue `json:"dfElectionTimer,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableSingleActive: Enable Single-Active
	EnableSingleActive *Multivalue `json:"enableSingleActive,omitempty"`
	// EnableStickyStaticFlag: Enable B-MAC Sticky/Static Flag
	EnableStickyStaticFlag *Multivalue `json:"enableStickyStaticFlag,omitempty"`
	// EsImport: ES Import
	EsImport *Multivalue `json:"esImport,omitempty"`
	// EsiLabel: ESI Label
	EsiLabel *Multivalue `json:"esiLabel,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// EsiValue: ESI Value
	EsiValue *Multivalue `json:"esiValue,omitempty"`
	// EvisCount: Number of EVIs

	EvisCount *float32 `json:"evisCount,omitempty"`
	// IncludeMacMobilityExtendedCommunity: Include MAC Mobility Extended Community
	IncludeMacMobilityExtendedCommunity *Multivalue `json:"includeMacMobilityExtendedCommunity,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// IrbIPv4Address: IRB IP Address
	IrbIPv4Address *Multivalue `json:"irbIPv4Address,omitempty"`
	// IrbInterfaceLabel: Label to be used for Route Type 2 carrying IRB MAC and/or IRB IP in Route Type 2
	IrbInterfaceLabel *Multivalue `json:"irbInterfaceLabel,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NoOfbMacMappedIpsV4: Number of B-MAC Mapped IPs

	NoOfbMacMappedIpsV4 *float32 `json:"noOfbMacMappedIpsV4,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// RouterMacAddress: Router's MAC Address
	RouterMacAddress *Multivalue `json:"routerMacAddress,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SupportFastConvergence: Support Fast Convergence
	SupportFastConvergence *Multivalue `json:"supportFastConvergence,omitempty"`
	// SupportMultihomedEsAutoDiscovery: Support Multi-homed ES Auto Discovery
	SupportMultihomedEsAutoDiscovery *Multivalue `json:"supportMultihomedEsAutoDiscovery,omitempty"`
	// UseControlWord: Use Control Word

	UseControlWord *bool `json:"useControlWord,omitempty"`
	// UseSameSequenceNumber: Use B-MAC Same Sequence Number
	UseSameSequenceNumber *Multivalue `json:"useSameSequenceNumber,omitempty"`
	// VtepIpv4Address: VTEP IP Address
	VtepIpv4Address            *Multivalue                           `json:"vtepIpv4Address,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`

	Bgpv4BMacMappedIpList *TopologyBgpv4BMacMappedIpList `json:"bgpv4BMacMappedIpList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpEthernetSegmentV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpEthernetSegmentV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpEthernetSegmentV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpEthernetSegmentV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdvertiseAliasingBeforeAdPerEsRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "AdvertiseAliasingBeforeAdPerEsRoute",
		isMultivalue: true,
	})
	n.AdvertiseInclusiveMulticastRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "AdvertiseInclusiveMulticastRoute",
		isMultivalue: true,
	})
	n.AliasingRouteGranularity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "AliasingRouteGranularity",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseAliasingAutomatically.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseAliasingAutomatically",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigureEsImport.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureEsImport",
		isMultivalue: true,
	})
	n.BMacPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacPrefix",
		isMultivalue: true,
	})
	n.BMacPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacPrefixLength",
		isMultivalue: true,
	})
	n.DfElectionTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dfElectionTimer",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableSingleActive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSingleActive",
		isMultivalue: true,
	})
	n.EnableStickyStaticFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableStickyStaticFlag",
		isMultivalue: true,
	})
	n.EsImport.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esImport",
		isMultivalue: true,
	})
	n.EsiLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiLabel",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.EsiValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiValue",
		isMultivalue: true,
	})
	n.IncludeMacMobilityExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMacMobilityExtendedCommunity",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.IrbIPv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbIPv4Address",
		isMultivalue: true,
	})
	n.IrbInterfaceLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbInterfaceLabel",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.RouterMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerMacAddress",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SupportFastConvergence.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportFastConvergence",
		isMultivalue: true,
	})
	n.SupportMultihomedEsAutoDiscovery.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportMultihomedEsAutoDiscovery",
		isMultivalue: true,
	})
	n.UseSameSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useSameSequenceNumber",
		isMultivalue: true,
	})
	n.VtepIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vtepIpv4Address",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Bgpv4BMacMappedIpList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpv4BMacMappedIpList",
	})
}

// TopologyBgpEthernetSegmentV6: BGP V6 Ethernet Segment Configuration
type TopologyBgpEthernetSegmentV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvertiseAliasingBeforeAdPerEsRoute: Advertise Aliasing Before A-D/ES Route
	AdvertiseAliasingBeforeAdPerEsRoute *Multivalue `json:"AdvertiseAliasingBeforeAdPerEsRoute,omitempty"`
	// AdvertiseInclusiveMulticastRoute: Support Inclusive Multicast Ethernet Tag Route (RT Type 3)
	AdvertiseInclusiveMulticastRoute *Multivalue `json:"AdvertiseInclusiveMulticastRoute,omitempty"`
	// AliasingRouteGranularity: Aliasing Route Granularity
	AliasingRouteGranularity *Multivalue `json:"AliasingRouteGranularity,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseAliasingAutomatically: Advertise Aliasing Automatically
	AdvertiseAliasingAutomatically *Multivalue `json:"advertiseAliasingAutomatically,omitempty"`
	// AdvertiseSRv6ESIFilteringSID: Advertise SRv6 ESI Filtering SID
	AdvertiseSRv6ESIFilteringSID *Multivalue `json:"advertiseSRv6ESIFilteringSID,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigureEsImport: Auto Configure ES-Import
	AutoConfigureEsImport *Multivalue `json:"autoConfigureEsImport,omitempty"`
	// BMacPrefix: B-MAC Prefix
	BMacPrefix *Multivalue `json:"bMacPrefix,omitempty"`
	// BMacPrefixLength: B-MAC Prefix Length
	BMacPrefixLength *Multivalue `json:"bMacPrefixLength,omitempty"`
	// DfElectionTimer: DF Election Timer(s)
	DfElectionTimer *Multivalue `json:"dfElectionTimer,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableSingleActive: Enable Single-Active
	EnableSingleActive *Multivalue `json:"enableSingleActive,omitempty"`
	// EnableStickyStaticFlag: Enable B-MAC Sticky/Static Flag
	EnableStickyStaticFlag *Multivalue `json:"enableStickyStaticFlag,omitempty"`
	// EsImport: ES Import
	EsImport *Multivalue `json:"esImport,omitempty"`
	// EsiLabel: ESI Label
	EsiLabel *Multivalue `json:"esiLabel,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// EsiValue: ESI Value
	EsiValue *Multivalue `json:"esiValue,omitempty"`
	// EvisCount: Number of EVIs

	EvisCount *float32 `json:"evisCount,omitempty"`
	// IncludeMacMobilityExtendedCommunity: Include MAC Mobility Extended Community
	IncludeMacMobilityExtendedCommunity *Multivalue `json:"includeMacMobilityExtendedCommunity,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// IrbIPv6Address: IRB IP Address
	IrbIPv6Address *Multivalue `json:"irbIPv6Address,omitempty"`
	// IrbInterfaceLabel: Label to be used for Route Type 2 carrying IRB MAC and/or IRB IP in Route Type 2
	IrbInterfaceLabel *Multivalue `json:"irbInterfaceLabel,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NoOfbMacMappedIpsV6: Number of B-MAC Mapped IPs

	NoOfbMacMappedIpsV6 *float32 `json:"noOfbMacMappedIpsV6,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// RouterMacAddress: Router's MAC Address
	RouterMacAddress *Multivalue `json:"routerMacAddress,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// Srv6Sid: SRv6 SID
	Srv6Sid *Multivalue `json:"srv6Sid,omitempty"`
	// SupportFastConvergence: Support Fast Convergence
	SupportFastConvergence *Multivalue `json:"supportFastConvergence,omitempty"`
	// SupportMultihomedEsAutoDiscovery: Support Multi-homed ES Auto Discovery
	SupportMultihomedEsAutoDiscovery *Multivalue `json:"supportMultihomedEsAutoDiscovery,omitempty"`
	// UseControlWord: Use Control Word

	UseControlWord *bool `json:"useControlWord,omitempty"`
	// UseSameSequenceNumber: Use B-MAC Same Sequence Number
	UseSameSequenceNumber *Multivalue `json:"useSameSequenceNumber,omitempty"`
	// VTEPIP6Address: VTEP IP Address
	VTEPIP6Address             *Multivalue                           `json:"vTEPIP6Address,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`

	Bgpv6BMacMappedIpList *TopologyBgpv6BMacMappedIpList `json:"bgpv6BMacMappedIpList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpEthernetSegmentV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpEthernetSegmentV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpEthernetSegmentV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpEthernetSegmentV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdvertiseAliasingBeforeAdPerEsRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "AdvertiseAliasingBeforeAdPerEsRoute",
		isMultivalue: true,
	})
	n.AdvertiseInclusiveMulticastRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "AdvertiseInclusiveMulticastRoute",
		isMultivalue: true,
	})
	n.AliasingRouteGranularity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "AliasingRouteGranularity",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseAliasingAutomatically.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseAliasingAutomatically",
		isMultivalue: true,
	})
	n.AdvertiseSRv6ESIFilteringSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6ESIFilteringSID",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigureEsImport.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureEsImport",
		isMultivalue: true,
	})
	n.BMacPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacPrefix",
		isMultivalue: true,
	})
	n.BMacPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacPrefixLength",
		isMultivalue: true,
	})
	n.DfElectionTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dfElectionTimer",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableSingleActive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSingleActive",
		isMultivalue: true,
	})
	n.EnableStickyStaticFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableStickyStaticFlag",
		isMultivalue: true,
	})
	n.EsImport.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esImport",
		isMultivalue: true,
	})
	n.EsiLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiLabel",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.EsiValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiValue",
		isMultivalue: true,
	})
	n.IncludeMacMobilityExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMacMobilityExtendedCommunity",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.IrbIPv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbIPv6Address",
		isMultivalue: true,
	})
	n.IrbInterfaceLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbInterfaceLabel",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.RouterMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerMacAddress",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.Srv6Sid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6Sid",
		isMultivalue: true,
	})
	n.SupportFastConvergence.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportFastConvergence",
		isMultivalue: true,
	})
	n.SupportMultihomedEsAutoDiscovery.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportMultihomedEsAutoDiscovery",
		isMultivalue: true,
	})
	n.UseSameSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useSameSequenceNumber",
		isMultivalue: true,
	})
	n.VTEPIP6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vTEPIP6Address",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Bgpv6BMacMappedIpList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpv6BMacMappedIpList",
	})
}

// TopologyBgpExportRouteTargetList: Export RouteTarget
type TopologyBgpExportRouteTargetList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetAs4Number: Export Route Target AS4 Number
	TargetAs4Number *Multivalue `json:"targetAs4Number,omitempty"`
	// TargetAsNumber: Export Route Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Export Route Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddress: Export Route Target IP Address
	TargetIpAddress *Multivalue `json:"targetIpAddress,omitempty"`
	// TargetType: Export Route Target Type
	TargetType *Multivalue `json:"targetType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpExportRouteTargetList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpExportRouteTargetList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpExportRouteTargetList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpExportRouteTargetList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.TargetAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAs4Number",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddress",
		isMultivalue: true,
	})
	n.TargetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetType",
		isMultivalue: true,
	})
}

// TopologyBgpExtendedCommunitiesList: Bgp Non VPN RR External Communities
type TopologyBgpExtendedCommunitiesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AsNumber2Bytes: AS 2-Bytes
	AsNumber2Bytes *Multivalue `json:"asNumber2Bytes,omitempty"`
	// AsNumber4Bytes: AS 4-Bytes
	AsNumber4Bytes *Multivalue `json:"asNumber4Bytes,omitempty"`
	// AssignedNumber2Bytes: Assigned Number(2 Octets)
	AssignedNumber2Bytes *Multivalue `json:"assignedNumber2Bytes,omitempty"`
	// AssignedNumber4Bytes: Assigned Number(4 Octets)
	AssignedNumber4Bytes *Multivalue `json:"assignedNumber4Bytes,omitempty"`
	// ColorCOBits: Color CO Bits
	ColorCOBits *Multivalue `json:"colorCOBits,omitempty"`
	// ColorReservedBits: Color Reserved Bits
	ColorReservedBits *Multivalue `json:"colorReservedBits,omitempty"`
	// ColorValue: Color Value
	ColorValue *Multivalue `json:"colorValue,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// LinkBandwidth: Link Bandwidth
	LinkBandwidth *Multivalue `json:"linkBandwidth,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OpaqueData: Opaque Data
	OpaqueData *Multivalue `json:"opaqueData,omitempty"`
	// SubType: SubType
	SubType *Multivalue `json:"subType,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpExtendedCommunitiesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpExtendedCommunitiesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpExtendedCommunitiesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpExtendedCommunitiesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AsNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber2Bytes",
		isMultivalue: true,
	})
	n.AsNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber4Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber2Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber4Bytes",
		isMultivalue: true,
	})
	n.ColorCOBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorCOBits",
		isMultivalue: true,
	})
	n.ColorReservedBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorReservedBits",
		isMultivalue: true,
	})
	n.ColorValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorValue",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.LinkBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkBandwidth",
		isMultivalue: true,
	})
	n.OpaqueData.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "opaqueData",
		isMultivalue: true,
	})
	n.SubType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subType",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyBgpFlowSpecRangesList: Flow Spec
type TopologyBgpFlowSpecRangesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsNumber2Bytes: AS 2-Bytes
	AsNumber2Bytes *Multivalue `json:"asNumber2Bytes,omitempty"`
	// AsNumber4Bytes: AS 4-Bytes
	AsNumber4Bytes *Multivalue `json:"asNumber4Bytes,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AssignedNumber2Bytes: Assigned Number(2 Octets)
	AssignedNumber2Bytes *Multivalue `json:"assignedNumber2Bytes,omitempty"`
	// AssignedNumber4Bytes: Assigned Number(4 Octets)
	AssignedNumber4Bytes *Multivalue `json:"assignedNumber4Bytes,omitempty"`
	// DestPortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	DestPortMatch *Multivalue `json:"destPortMatch,omitempty"`
	// DestPrefixLengthV4: Destination Prefix Length (bits) - Controlled by Enable Destination Prefix
	DestPrefixLengthV4 *Multivalue `json:"destPrefixLengthV4,omitempty"`
	// DestPrefixV4: Destination Prefix - Controlled by Enable Destination Prefix
	DestPrefixV4 *Multivalue `json:"destPrefixV4,omitempty"`
	// DscpMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 10, 10-20, <10, 10&20, 10|20-30&!25|>=50 etc Keep Empty If Not Requried
	DscpMatch *Multivalue `json:"dscpMatch,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableDestPrefixV4: Click to Enable Destination Prefix and Prefix Length
	EnableDestPrefixV4 *Multivalue `json:"enableDestPrefixV4,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRedirect: Enable Redirect
	EnableRedirect *Multivalue `json:"enableRedirect,omitempty"`
	// EnableSourcePrefixV4: Click to Enable Source Prefix and Prefix Length
	EnableSourcePrefixV4 *Multivalue `json:"enableSourcePrefixV4,omitempty"`
	// EnableTrafficAction: Enable Traffic Action
	EnableTrafficAction *Multivalue `json:"enableTrafficAction,omitempty"`
	// EnableTrafficMarketing: Enable Traffic Marketing
	EnableTrafficMarketing *Multivalue `json:"enableTrafficMarketing,omitempty"`
	// EnableTrafficMarking: Enable Traffic Marking
	EnableTrafficMarking *Multivalue `json:"enableTrafficMarking,omitempty"`
	// EnableTrafficRate: Enable Traffic Rate
	EnableTrafficRate *Multivalue `json:"enableTrafficRate,omitempty"`
	// FlowSpecName: Flow Spec Name
	FlowSpecName *Multivalue `json:"flowSpecName,omitempty"`
	// FragmentMatch: Supported Flags: lf,ff,isf,df join different matchcriteria using | or & join flags using | (bitwise or) Eg. (lf), (lf|ff|isf|df), (not)(lf|isf), (not|match)(df|ff)|(isf|lf) Keep Empty If Not Requried
	FragmentMatch *Multivalue `json:"fragmentMatch,omitempty"`
	// IcmpCodeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpCodeMatch *Multivalue `json:"icmpCodeMatch,omitempty"`
	// IcmpTypeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpTypeMatch *Multivalue `json:"icmpTypeMatch,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// IpPacketLenMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	IpPacketLenMatch *Multivalue `json:"ipPacketLenMatch,omitempty"`
	// IpProto: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IpProto *Multivalue `json:"ipProto,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// NumberOfFlows: Number of Flows in a Flow Range
	NumberOfFlows *Multivalue `json:"numberOfFlows,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried This Field Matches Source OR Destination TCP/UDP Ports
	PortMatch *Multivalue `json:"portMatch,omitempty"`
	// RedirectCBit: C Bit
	RedirectCBit *Multivalue `json:"redirectCBit,omitempty"`
	// RedirectExtCommunityType: Extended Community Type
	RedirectExtCommunityType *Multivalue `json:"redirectExtCommunityType,omitempty"`
	// Redirectnexthop: Next Hop
	Redirectnexthop *Multivalue `json:"redirectnexthop,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourcePortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	SourcePortMatch *Multivalue `json:"sourcePortMatch,omitempty"`
	// SourcePrefixLengthV4: Source Prefix Length (bits) - Controlled by Enable Source Prefix
	SourcePrefixLengthV4 *Multivalue `json:"sourcePrefixLengthV4,omitempty"`
	// SourcePrefixV4: Source Prefix - Controlled by Enable Source Prefix
	SourcePrefixV4 *Multivalue `json:"sourcePrefixV4,omitempty"`
	// TcpFlagsMatch: Supported Flags: ns,cwr,ece,urg,ack,psh,rst,syn,fin join different matchcriteria using | or & join flags using | (bitwise or) Eg. (cwr), (ece|urg|psh|syn), (not)(cwr|syn), (not|match)(ece|psh)|(psh|rst)&(not)(ns) Keep Empty If Not Requried
	TcpFlagsMatch *Multivalue `json:"tcpFlagsMatch,omitempty"`
	// TerminalAction: Terminal Action
	TerminalAction *Multivalue `json:"terminalAction,omitempty"`
	// TrafficActionSample: Sample
	TrafficActionSample *Multivalue `json:"trafficActionSample,omitempty"`
	// TrafficDscp: DSCP
	TrafficDscp *Multivalue `json:"trafficDscp,omitempty"`
	// TrafficRate: Traffic Rate (Bytes/s)
	TrafficRate                *Multivalue                           `json:"trafficRate,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`
	BgpLargeCommunitiesList    []*TopologyBgpLargeCommunitiesList    `json:"bgpLargeCommunitiesList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpFlowSpecRangesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpFlowSpecRangesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpFlowSpecRangesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpFlowSpecRangesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber2Bytes",
		isMultivalue: true,
	})
	n.AsNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber4Bytes",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AssignedNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber2Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber4Bytes",
		isMultivalue: true,
	})
	n.DestPortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPortMatch",
		isMultivalue: true,
	})
	n.DestPrefixLengthV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixLengthV4",
		isMultivalue: true,
	})
	n.DestPrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixV4",
		isMultivalue: true,
	})
	n.DscpMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dscpMatch",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableDestPrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDestPrefixV4",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRedirect.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRedirect",
		isMultivalue: true,
	})
	n.EnableSourcePrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSourcePrefixV4",
		isMultivalue: true,
	})
	n.EnableTrafficAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficAction",
		isMultivalue: true,
	})
	n.EnableTrafficMarketing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarketing",
		isMultivalue: true,
	})
	n.EnableTrafficMarking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarking",
		isMultivalue: true,
	})
	n.EnableTrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficRate",
		isMultivalue: true,
	})
	n.FlowSpecName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowSpecName",
		isMultivalue: true,
	})
	n.FragmentMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fragmentMatch",
		isMultivalue: true,
	})
	n.IcmpCodeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpCodeMatch",
		isMultivalue: true,
	})
	n.IcmpTypeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpTypeMatch",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.IpPacketLenMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipPacketLenMatch",
		isMultivalue: true,
	})
	n.IpProto.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipProto",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NumberOfFlows.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfFlows",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portMatch",
		isMultivalue: true,
	})
	n.RedirectCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectCBit",
		isMultivalue: true,
	})
	n.RedirectExtCommunityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectExtCommunityType",
		isMultivalue: true,
	})
	n.Redirectnexthop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectnexthop",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourcePortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePortMatch",
		isMultivalue: true,
	})
	n.SourcePrefixLengthV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixLengthV4",
		isMultivalue: true,
	})
	n.SourcePrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixV4",
		isMultivalue: true,
	})
	n.TcpFlagsMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpFlagsMatch",
		isMultivalue: true,
	})
	n.TerminalAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "terminalAction",
		isMultivalue: true,
	})
	n.TrafficActionSample.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficActionSample",
		isMultivalue: true,
	})
	n.TrafficDscp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficDscp",
		isMultivalue: true,
	})
	n.TrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficRate",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpFlowSpecRangesListV4: BGP Flow Spec Ranges
type TopologyBgpFlowSpecRangesListV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsNumber2Bytes: AS 2-Bytes
	AsNumber2Bytes *Multivalue `json:"asNumber2Bytes,omitempty"`
	// AsNumber4Bytes: AS 4-Bytes
	AsNumber4Bytes *Multivalue `json:"asNumber4Bytes,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AssignedNumber2Bytes: Assigned Number(2 Octets)
	AssignedNumber2Bytes *Multivalue `json:"assignedNumber2Bytes,omitempty"`
	// AssignedNumber4Bytes: Assigned Number(4 Octets)
	AssignedNumber4Bytes *Multivalue `json:"assignedNumber4Bytes,omitempty"`
	// DestPortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	DestPortMatch *Multivalue `json:"destPortMatch,omitempty"`
	// DestPrefixLengthV4: Destination Prefix Length (bits) - Controlled by Enable Destination Prefix
	DestPrefixLengthV4 *Multivalue `json:"destPrefixLengthV4,omitempty"`
	// DestPrefixV4: Destination Prefix - Controlled by Enable Destination Prefix
	DestPrefixV4 *Multivalue `json:"destPrefixV4,omitempty"`
	// DscpMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 10, 10-20, <10, 10&20, 10|20-30&!25|>=50 etc Keep Empty If Not Requried
	DscpMatch *Multivalue `json:"dscpMatch,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableDestPrefixV4: Click to Enable Destination Prefix and Prefix Length
	EnableDestPrefixV4 *Multivalue `json:"enableDestPrefixV4,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRedirect: Enable Redirect
	EnableRedirect *Multivalue `json:"enableRedirect,omitempty"`
	// EnableSourcePrefixV4: Click to Enable Source Prefix and Prefix Length
	EnableSourcePrefixV4 *Multivalue `json:"enableSourcePrefixV4,omitempty"`
	// EnableTrafficAction: Enable Traffic Action
	EnableTrafficAction *Multivalue `json:"enableTrafficAction,omitempty"`
	// EnableTrafficMarketing: Enable Traffic Marketing
	EnableTrafficMarketing *Multivalue `json:"enableTrafficMarketing,omitempty"`
	// EnableTrafficMarking: Enable Traffic Marking
	EnableTrafficMarking *Multivalue `json:"enableTrafficMarking,omitempty"`
	// EnableTrafficRate: Enable Traffic Rate
	EnableTrafficRate *Multivalue `json:"enableTrafficRate,omitempty"`
	// FlowSpecName: Flow Spec Name
	FlowSpecName *Multivalue `json:"flowSpecName,omitempty"`
	// FragmentMatch: Supported Flags: lf,ff,isf,df join different matchcriteria using | or & join flags using | (bitwise or) Eg. (lf), (lf|ff|isf|df), (not)(lf|isf), (not|match)(df|ff)|(isf|lf) Keep Empty If Not Requried
	FragmentMatch *Multivalue `json:"fragmentMatch,omitempty"`
	// IcmpCodeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpCodeMatch *Multivalue `json:"icmpCodeMatch,omitempty"`
	// IcmpTypeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpTypeMatch *Multivalue `json:"icmpTypeMatch,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// IpPacketLenMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	IpPacketLenMatch *Multivalue `json:"ipPacketLenMatch,omitempty"`
	// IpProto: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IpProto *Multivalue `json:"ipProto,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// NumberOfFlows: Number of Flows in a Flow Range
	NumberOfFlows *Multivalue `json:"numberOfFlows,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried This Field Matches Source OR Destination TCP/UDP Ports
	PortMatch *Multivalue `json:"portMatch,omitempty"`
	// RedirectCBit: C Bit
	RedirectCBit *Multivalue `json:"redirectCBit,omitempty"`
	// RedirectExtCommunityType: Extended Community Type
	RedirectExtCommunityType *Multivalue `json:"redirectExtCommunityType,omitempty"`
	// Redirectnexthop: Next Hop
	Redirectnexthop *Multivalue `json:"redirectnexthop,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourcePortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	SourcePortMatch *Multivalue `json:"sourcePortMatch,omitempty"`
	// SourcePrefixLengthV4: Source Prefix Length (bits) - Controlled by Enable Source Prefix
	SourcePrefixLengthV4 *Multivalue `json:"sourcePrefixLengthV4,omitempty"`
	// SourcePrefixV4: Source Prefix - Controlled by Enable Source Prefix
	SourcePrefixV4 *Multivalue `json:"sourcePrefixV4,omitempty"`
	// TcpFlagsMatch: Supported Flags: ns,cwr,ece,urg,ack,psh,rst,syn,fin join different matchcriteria using | or & join flags using | (bitwise or) Eg. (cwr), (ece|urg|psh|syn), (not)(cwr|syn), (not|match)(ece|psh)|(psh|rst)&(not)(ns) Keep Empty If Not Requried
	TcpFlagsMatch *Multivalue `json:"tcpFlagsMatch,omitempty"`
	// TerminalAction: Terminal Action
	TerminalAction *Multivalue `json:"terminalAction,omitempty"`
	// TrafficActionSample: Sample
	TrafficActionSample *Multivalue `json:"trafficActionSample,omitempty"`
	// TrafficDscp: DSCP
	TrafficDscp *Multivalue `json:"trafficDscp,omitempty"`
	// TrafficRate: Traffic Rate (Bytes/s)
	TrafficRate                *Multivalue                           `json:"trafficRate,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`
	BgpLargeCommunitiesList    []*TopologyBgpLargeCommunitiesList    `json:"bgpLargeCommunitiesList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpFlowSpecRangesListV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpFlowSpecRangesListV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpFlowSpecRangesListV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpFlowSpecRangesListV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber2Bytes",
		isMultivalue: true,
	})
	n.AsNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber4Bytes",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AssignedNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber2Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber4Bytes",
		isMultivalue: true,
	})
	n.DestPortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPortMatch",
		isMultivalue: true,
	})
	n.DestPrefixLengthV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixLengthV4",
		isMultivalue: true,
	})
	n.DestPrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixV4",
		isMultivalue: true,
	})
	n.DscpMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dscpMatch",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableDestPrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDestPrefixV4",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRedirect.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRedirect",
		isMultivalue: true,
	})
	n.EnableSourcePrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSourcePrefixV4",
		isMultivalue: true,
	})
	n.EnableTrafficAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficAction",
		isMultivalue: true,
	})
	n.EnableTrafficMarketing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarketing",
		isMultivalue: true,
	})
	n.EnableTrafficMarking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarking",
		isMultivalue: true,
	})
	n.EnableTrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficRate",
		isMultivalue: true,
	})
	n.FlowSpecName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowSpecName",
		isMultivalue: true,
	})
	n.FragmentMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fragmentMatch",
		isMultivalue: true,
	})
	n.IcmpCodeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpCodeMatch",
		isMultivalue: true,
	})
	n.IcmpTypeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpTypeMatch",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.IpPacketLenMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipPacketLenMatch",
		isMultivalue: true,
	})
	n.IpProto.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipProto",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NumberOfFlows.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfFlows",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portMatch",
		isMultivalue: true,
	})
	n.RedirectCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectCBit",
		isMultivalue: true,
	})
	n.RedirectExtCommunityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectExtCommunityType",
		isMultivalue: true,
	})
	n.Redirectnexthop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectnexthop",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourcePortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePortMatch",
		isMultivalue: true,
	})
	n.SourcePrefixLengthV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixLengthV4",
		isMultivalue: true,
	})
	n.SourcePrefixV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixV4",
		isMultivalue: true,
	})
	n.TcpFlagsMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpFlagsMatch",
		isMultivalue: true,
	})
	n.TerminalAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "terminalAction",
		isMultivalue: true,
	})
	n.TrafficActionSample.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficActionSample",
		isMultivalue: true,
	})
	n.TrafficDscp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficDscp",
		isMultivalue: true,
	})
	n.TrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficRate",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpFlowSpecRangesListV6: BGP Flow Spec Ranges
type TopologyBgpFlowSpecRangesListV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsNumber2Bytes: AS 2-Bytes
	AsNumber2Bytes *Multivalue `json:"asNumber2Bytes,omitempty"`
	// AsNumber4Bytes: AS 4-Bytes
	AsNumber4Bytes *Multivalue `json:"asNumber4Bytes,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AssignedNumber2Bytes: Assigned Number(2 Octets)
	AssignedNumber2Bytes *Multivalue `json:"assignedNumber2Bytes,omitempty"`
	// AssignedNumber4Bytes: Assigned Number(4 Octets)
	AssignedNumber4Bytes *Multivalue `json:"assignedNumber4Bytes,omitempty"`
	// DestPortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	DestPortMatch *Multivalue `json:"destPortMatch,omitempty"`
	// DestPrefixLengthV6: Destination Prefix Length (bits) - Controlled by Enable Destination Prefix
	DestPrefixLengthV6 *Multivalue `json:"destPrefixLengthV6,omitempty"`
	// DestPrefixOffset: Destination Prefix Offset (bits) - Controlled by Enable Destination Prefix
	DestPrefixOffset *Multivalue `json:"destPrefixOffset,omitempty"`
	// DestPrefixV6: Destination Prefix - Controlled by Enable Destination Prefix
	DestPrefixV6 *Multivalue `json:"destPrefixV6,omitempty"`
	// DscpMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 10, 10-20, <10, 10&20, 10|20-30&!25|>=50 etc Keep Empty If Not Requried
	DscpMatch *Multivalue `json:"dscpMatch,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableDestPrefixV6: Click to Enable Destination Prefix and Prefix Length
	EnableDestPrefixV6 *Multivalue `json:"enableDestPrefixV6,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRedirect: Enable Redirect
	EnableRedirect *Multivalue `json:"enableRedirect,omitempty"`
	// EnableReirectIPv6: Enable Redirect-IPv6
	EnableReirectIPv6 *Multivalue `json:"enableReirectIPv6,omitempty"`
	// EnableSourcePrefixV6: Click to Enable Source Prefix and Prefix Length
	EnableSourcePrefixV6 *Multivalue `json:"enableSourcePrefixV6,omitempty"`
	// EnableTrafficAction: Enable Traffic Action
	EnableTrafficAction *Multivalue `json:"enableTrafficAction,omitempty"`
	// EnableTrafficMarketing: Enable Traffic Marketing
	EnableTrafficMarketing *Multivalue `json:"enableTrafficMarketing,omitempty"`
	// EnableTrafficMarking: Enable Traffic Marking
	EnableTrafficMarking *Multivalue `json:"enableTrafficMarking,omitempty"`
	// EnableTrafficRate: Enable Traffic Rate
	EnableTrafficRate *Multivalue `json:"enableTrafficRate,omitempty"`
	// FlowLabel: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	FlowLabel *Multivalue `json:"flowLabel,omitempty"`
	// FlowSpecName: Flow Spec Name
	FlowSpecName *Multivalue `json:"flowSpecName,omitempty"`
	// FragmentMatchV6: Supported Flags: lf,ff,isf join different matchcriteria using | or & join flags using | (bitwise or) Eg. (lf), (lf|ff|isf), (not)(lf|isf), (not|match)(ff)|(isf|lf) Keep Empty If Not Requried
	FragmentMatchV6 *Multivalue `json:"fragmentMatchV6,omitempty"`
	// IcmpCodeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpCodeMatch *Multivalue `json:"icmpCodeMatch,omitempty"`
	// IcmpTypeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpTypeMatch *Multivalue `json:"icmpTypeMatch,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// IpPacketLenMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	IpPacketLenMatch *Multivalue `json:"ipPacketLenMatch,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextHeader: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	NextHeader *Multivalue `json:"nextHeader,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// NumberOfFlows: Number of Flows in a Flow Range
	NumberOfFlows *Multivalue `json:"numberOfFlows,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried This Field Matches Source OR Destination TCP/UDP Ports
	PortMatch *Multivalue `json:"portMatch,omitempty"`
	// RedirectCBit: C Bit
	RedirectCBit *Multivalue `json:"redirectCBit,omitempty"`
	// RedirectExtCommunityType: Extended Community Type
	RedirectExtCommunityType *Multivalue `json:"redirectExtCommunityType,omitempty"`
	// RedirectIPv6: Redirect-IPv6
	RedirectIPv6 *Multivalue `json:"redirectIPv6,omitempty"`
	// Redirectnexthop: Next Hop
	Redirectnexthop *Multivalue `json:"redirectnexthop,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourcePortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	SourcePortMatch *Multivalue `json:"sourcePortMatch,omitempty"`
	// SourcePrefixLengthV6: Source Prefix Length (bits) - Controlled by Enable Source Prefix
	SourcePrefixLengthV6 *Multivalue `json:"sourcePrefixLengthV6,omitempty"`
	// SourcePrefixV6: Source Prefix - Controlled by Enable Source Prefix
	SourcePrefixV6 *Multivalue `json:"sourcePrefixV6,omitempty"`
	// SrcPrefixOffset: Source Prefix Offset (bits) - Controlled by Enable Source Prefix
	SrcPrefixOffset *Multivalue `json:"srcPrefixOffset,omitempty"`
	// TcpFlagsMatch: Supported Flags: ns,cwr,ece,urg,ack,psh,rst,syn,fin join different matchcriteria using | or & join flags using | (bitwise or) Eg. (cwr), (ece|urg|psh|syn), (not)(cwr|syn), (not|match)(ece|psh)|(psh|rst)&(not)(ns) Keep Empty If Not Requried
	TcpFlagsMatch *Multivalue `json:"tcpFlagsMatch,omitempty"`
	// TerminalAction: Terminal Action
	TerminalAction *Multivalue `json:"terminalAction,omitempty"`
	// TrafficActionSample: Sample
	TrafficActionSample *Multivalue `json:"trafficActionSample,omitempty"`
	// TrafficDscp: DSCP
	TrafficDscp *Multivalue `json:"trafficDscp,omitempty"`
	// TrafficRate: Traffic Rate (Bytes/s)
	TrafficRate                *Multivalue                           `json:"trafficRate,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`
	BgpLargeCommunitiesList    []*TopologyBgpLargeCommunitiesList    `json:"bgpLargeCommunitiesList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpFlowSpecRangesListV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpFlowSpecRangesListV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpFlowSpecRangesListV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpFlowSpecRangesListV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber2Bytes",
		isMultivalue: true,
	})
	n.AsNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber4Bytes",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AssignedNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber2Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber4Bytes",
		isMultivalue: true,
	})
	n.DestPortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPortMatch",
		isMultivalue: true,
	})
	n.DestPrefixLengthV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixLengthV6",
		isMultivalue: true,
	})
	n.DestPrefixOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixOffset",
		isMultivalue: true,
	})
	n.DestPrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixV6",
		isMultivalue: true,
	})
	n.DscpMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dscpMatch",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableDestPrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDestPrefixV6",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRedirect.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRedirect",
		isMultivalue: true,
	})
	n.EnableReirectIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableReirectIPv6",
		isMultivalue: true,
	})
	n.EnableSourcePrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSourcePrefixV6",
		isMultivalue: true,
	})
	n.EnableTrafficAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficAction",
		isMultivalue: true,
	})
	n.EnableTrafficMarketing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarketing",
		isMultivalue: true,
	})
	n.EnableTrafficMarking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarking",
		isMultivalue: true,
	})
	n.EnableTrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficRate",
		isMultivalue: true,
	})
	n.FlowLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowLabel",
		isMultivalue: true,
	})
	n.FlowSpecName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowSpecName",
		isMultivalue: true,
	})
	n.FragmentMatchV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fragmentMatchV6",
		isMultivalue: true,
	})
	n.IcmpCodeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpCodeMatch",
		isMultivalue: true,
	})
	n.IcmpTypeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpTypeMatch",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.IpPacketLenMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipPacketLenMatch",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NextHeader.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHeader",
		isMultivalue: true,
	})
	n.NumberOfFlows.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfFlows",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portMatch",
		isMultivalue: true,
	})
	n.RedirectCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectCBit",
		isMultivalue: true,
	})
	n.RedirectExtCommunityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectExtCommunityType",
		isMultivalue: true,
	})
	n.RedirectIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectIPv6",
		isMultivalue: true,
	})
	n.Redirectnexthop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectnexthop",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourcePortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePortMatch",
		isMultivalue: true,
	})
	n.SourcePrefixLengthV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixLengthV6",
		isMultivalue: true,
	})
	n.SourcePrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixV6",
		isMultivalue: true,
	})
	n.SrcPrefixOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcPrefixOffset",
		isMultivalue: true,
	})
	n.TcpFlagsMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpFlagsMatch",
		isMultivalue: true,
	})
	n.TerminalAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "terminalAction",
		isMultivalue: true,
	})
	n.TrafficActionSample.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficActionSample",
		isMultivalue: true,
	})
	n.TrafficDscp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficDscp",
		isMultivalue: true,
	})
	n.TrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficRate",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv4EvpnEvi: BGP IPv4 Peer EVPN EVI Configuration
type TopologyBgpIPv4EvpnEvi struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV4: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV4 *float32 `json:"numBroadcastDomainV4,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV4 *TopologyBroadcastDomainV4 `json:"broadcastDomainV4,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv4EvpnEvi) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv4EvpnEvi) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv4EvpnEvi) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv4EvpnEvi) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV4",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv4EvpnPbb: BGP IPv4 Peer PBB EVPN Configuration
type TopologyBgpIPv4EvpnPbb struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV4: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV4 *float32 `json:"numBroadcastDomainV4,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV4 *TopologyBroadcastDomainV4 `json:"broadcastDomainV4,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv4EvpnPbb) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv4EvpnPbb) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv4EvpnPbb) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv4EvpnPbb) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV4",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv4EvpnVpws: BGP IPv4 Peer VPWS EVPN Configuration
type TopologyBgpIPv4EvpnVpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV4: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV4 *float32 `json:"numBroadcastDomainV4,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV4Vpws *TopologyBroadcastDomainV4Vpws `json:"broadcastDomainV4Vpws,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv4EvpnVpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv4EvpnVpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv4EvpnVpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv4EvpnVpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV4Vpws.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV4Vpws",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv4EvpnVxlan: BGP IPv4 Peer EVPN VXLAN Configuration
type TopologyBgpIPv4EvpnVxlan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// MulticastTunnelTypeVxlan: Multicast Tunnel Type
	MulticastTunnelTypeVxlan *Multivalue `json:"multicastTunnelTypeVxlan,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV4: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV4 *float32 `json:"numBroadcastDomainV4,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV4 *TopologyBroadcastDomainV4 `json:"broadcastDomainV4,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv4EvpnVxlan) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv4EvpnVxlan) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv4EvpnVxlan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv4EvpnVxlan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.MulticastTunnelTypeVxlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelTypeVxlan",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV4",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv4EvpnVxlanVpws: BGP IPv4 Peer EVPN VXLAN VPWS Configuration
type TopologyBgpIPv4EvpnVxlanVpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// MulticastTunnelTypeVxlan: Multicast Tunnel Type
	MulticastTunnelTypeVxlan *Multivalue `json:"multicastTunnelTypeVxlan,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV4: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV4 *float32 `json:"numBroadcastDomainV4,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV4VxlanVpws *TopologyBroadcastDomainV4VxlanVpws `json:"broadcastDomainV4VxlanVpws,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv4EvpnVxlanVpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv4EvpnVxlanVpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv4EvpnVxlanVpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv4EvpnVxlanVpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.MulticastTunnelTypeVxlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelTypeVxlan",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV4VxlanVpws.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV4VxlanVpws",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv6EvpnEvi: BGP IPv6 Peer EVPN EVI Configuration
type TopologyBgpIPv6EvpnEvi struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvSrv6SidInIgpPMSI: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgpPMSI *Multivalue `json:"advSrv6SidInIgpPMSI,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AdvertiseSRv6SID: Advertise SRv6 SID
	AdvertiseSRv6SID *Multivalue `json:"advertiseSRv6SID,omitempty"`
	// AdvertiseSRv6SIDPMSI: Advertise SRv6 SID
	AdvertiseSRv6SIDPMSI *Multivalue `json:"advertiseSRv6SIDPMSI,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV6: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV6 *float32 `json:"numBroadcastDomainV6,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// SendSRv6SIDOptionalInfoPMSI: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfoPMSI *Multivalue `json:"sendSRv6SIDOptionalInfoPMSI,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6EndpointBehaviorPMSI: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehaviorPMSI *Multivalue `json:"srv6EndpointBehaviorPMSI,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SIDOptionalInformationPMSI: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformationPMSI *Multivalue `json:"srv6SIDOptionalInformationPMSI,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags Value
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidFlagsPMSI: SRv6 SID Flags Value
	Srv6SidFlagsPMSI *Multivalue `json:"srv6SidFlagsPMSI,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocLenPMSI: SRv6 SID Locator Length
	Srv6SidLocLenPMSI *Multivalue `json:"srv6SidLocLenPMSI,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidLocMetricPMSI: SRv6 SID Locator Metric
	Srv6SidLocMetricPMSI *Multivalue `json:"srv6SidLocMetricPMSI,omitempty"`
	// Srv6SidLocPMSI: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLocPMSI *Multivalue `json:"srv6SidLocPMSI,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved1PMSI: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1PMSI *Multivalue `json:"srv6SidReserved1PMSI,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// Srv6SidReserved2PMSI: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2PMSI *Multivalue `json:"srv6SidReserved2PMSI,omitempty"`
	// Srv6SidReservedPMSI: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReservedPMSI *Multivalue `json:"srv6SidReservedPMSI,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV6 *TopologyBroadcastDomainV6 `json:"broadcastDomainV6,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv6EvpnEvi) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv6EvpnEvi) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv6EvpnEvi) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv6EvpnEvi) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgpPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgpPMSI",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SID",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SIDPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SIDPMSI",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfoPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfoPMSI",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6EndpointBehaviorPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehaviorPMSI",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformationPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformationPMSI",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidFlagsPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlagsPMSI",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocLenPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLenPMSI",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidLocMetricPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetricPMSI",
		isMultivalue: true,
	})
	n.Srv6SidLocPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocPMSI",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved1PMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1PMSI",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.Srv6SidReserved2PMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2PMSI",
		isMultivalue: true,
	})
	n.Srv6SidReservedPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReservedPMSI",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV6",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv6EvpnPbb: BGP IPv6 Peer PBB EVPN Configuration
type TopologyBgpIPv6EvpnPbb struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV6: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV6 *float32 `json:"numBroadcastDomainV6,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV6 *TopologyBgpIPv6EvpnPbbBroadcastDomainV6 `json:"broadcastDomainV6,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv6EvpnPbb) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv6EvpnPbb) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv6EvpnPbb) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv6EvpnPbb) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV6",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv6EvpnPbbBroadcastDomainV6: BGP V6 Broadcast Domain Configuration
type TopologyBgpIPv6EvpnPbbBroadcastDomainV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan  *bool                `json:"usebVlan,omitempty"`
	PnTLVList []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv6EvpnPbbBroadcastDomainV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv6EvpnPbbBroadcastDomainV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv6EvpnPbbBroadcastDomainV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv6EvpnPbbBroadcastDomainV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv6EvpnVpws: BGP IPv6 Peer VPWS EVPN Configuration
type TopologyBgpIPv6EvpnVpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvSrv6SidInIgpPMSI: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgpPMSI *Multivalue `json:"advSrv6SidInIgpPMSI,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AdvertiseSRv6SID: Advertise SRv6 SID
	AdvertiseSRv6SID *Multivalue `json:"advertiseSRv6SID,omitempty"`
	// AdvertiseSRv6SIDPMSI: Advertise SRv6 SID
	AdvertiseSRv6SIDPMSI *Multivalue `json:"advertiseSRv6SIDPMSI,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// ArgumentLength: Argument Length
	ArgumentLength *Multivalue `json:"argumentLength,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// FunctionLength: Function Length
	FunctionLength *Multivalue `json:"functionLength,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocBlockLength: Locator Block Length
	LocBlockLength *Multivalue `json:"locBlockLength,omitempty"`
	// LocNodeLength: Locator Node Length
	LocNodeLength *Multivalue `json:"locNodeLength,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// MvEnableTransposition: Enable Transposition
	MvEnableTransposition *Multivalue `json:"mvEnableTransposition,omitempty"`
	// MvIncSrv6SidStructSsTlv: Include SRv6 SID Structure Sub-Sub TLV
	MvIncSrv6SidStructSsTlv *Multivalue `json:"mvIncSrv6SidStructSsTlv,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV6: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV6 *float32 `json:"numBroadcastDomainV6,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// SendSRv6SIDOptionalInfoPMSI: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfoPMSI *Multivalue `json:"sendSRv6SIDOptionalInfoPMSI,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6EndpointBehaviorPMSI: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehaviorPMSI *Multivalue `json:"srv6EndpointBehaviorPMSI,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SIDOptionalInformationPMSI: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformationPMSI *Multivalue `json:"srv6SIDOptionalInformationPMSI,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags Value
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidFlagsPMSI: SRv6 SID Flags Value
	Srv6SidFlagsPMSI *Multivalue `json:"srv6SidFlagsPMSI,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocLenPMSI: SRv6 SID Locator Length
	Srv6SidLocLenPMSI *Multivalue `json:"srv6SidLocLenPMSI,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidLocMetricPMSI: SRv6 SID Locator Metric
	Srv6SidLocMetricPMSI *Multivalue `json:"srv6SidLocMetricPMSI,omitempty"`
	// Srv6SidLocPMSI: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLocPMSI *Multivalue `json:"srv6SidLocPMSI,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved1PMSI: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1PMSI *Multivalue `json:"srv6SidReserved1PMSI,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// Srv6SidReserved2PMSI: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2PMSI *Multivalue `json:"srv6SidReserved2PMSI,omitempty"`
	// Srv6SidReservedPMSI: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReservedPMSI *Multivalue `json:"srv6SidReservedPMSI,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TranpositionLength: Transposition Length
	TranpositionLength *Multivalue `json:"tranpositionLength,omitempty"`
	// TranpositionOffset: Transposition Offset
	TranpositionOffset *Multivalue `json:"tranpositionOffset,omitempty"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV6Vpws *TopologyBroadcastDomainV6Vpws `json:"broadcastDomainV6Vpws,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv6EvpnVpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv6EvpnVpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv6EvpnVpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv6EvpnVpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgpPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgpPMSI",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SID",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SIDPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SIDPMSI",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.ArgumentLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLength",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.FunctionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLength",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocBlockLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locBlockLength",
		isMultivalue: true,
	})
	n.LocNodeLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locNodeLength",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.MvEnableTransposition.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvEnableTransposition",
		isMultivalue: true,
	})
	n.MvIncSrv6SidStructSsTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvIncSrv6SidStructSsTlv",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfoPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfoPMSI",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6EndpointBehaviorPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehaviorPMSI",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformationPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformationPMSI",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidFlagsPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlagsPMSI",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocLenPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLenPMSI",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidLocMetricPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetricPMSI",
		isMultivalue: true,
	})
	n.Srv6SidLocPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocPMSI",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved1PMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1PMSI",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.Srv6SidReserved2PMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2PMSI",
		isMultivalue: true,
	})
	n.Srv6SidReservedPMSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReservedPMSI",
		isMultivalue: true,
	})
	n.TranpositionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tranpositionLength",
		isMultivalue: true,
	})
	n.TranpositionOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tranpositionOffset",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV6Vpws.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV6Vpws",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv6EvpnVxlan: BGP IPv6 Peer EVPN VXLAN Configuration
type TopologyBgpIPv6EvpnVxlan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// MulticastTunnelTypeVxlan: Multicast Tunnel Type
	MulticastTunnelTypeVxlan *Multivalue `json:"multicastTunnelTypeVxlan,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV6: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV6 *float32 `json:"numBroadcastDomainV6,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV6 *TopologyBgpIPv6EvpnVxlanBroadcastDomainV6 `json:"broadcastDomainV6,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv6EvpnVxlan) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv6EvpnVxlan) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv6EvpnVxlan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv6EvpnVxlan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.MulticastTunnelTypeVxlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelTypeVxlan",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV6",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv6EvpnVxlanBroadcastDomainV6: BGP V6 Broadcast Domain Configuration
type TopologyBgpIPv6EvpnVxlanBroadcastDomainV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan  *bool                `json:"usebVlan,omitempty"`
	PnTLVList []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv6EvpnVxlanBroadcastDomainV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv6EvpnVxlanBroadcastDomainV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv6EvpnVxlanBroadcastDomainV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv6EvpnVxlanBroadcastDomainV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIPv6EvpnVxlanVpws: BGP IPv6 Peer EVPN VXLAN VPWS Configuration
type TopologyBgpIPv6EvpnVxlanVpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvertiseL3vniSeparately: Advertise L3 Route Separately
	AdvertiseL3vniSeparately *Multivalue `json:"advertiseL3vniSeparately,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AutoConfigOriginatingRouterIp: If set to true, this field enables option to configure Originating router IP address automatically from BGP Router's local IP
	AutoConfigOriginatingRouterIp *Multivalue `json:"autoConfigOriginatingRouterIp,omitempty"`
	// AutoConfigPMSITunnelId: Auto Configure PMSI Tunnel ID
	AutoConfigPMSITunnelId *Multivalue `json:"autoConfigPMSITunnelId,omitempty"`
	// AutoConfigureRdIpAddress: Auto-Configure RD IP Addresses
	AutoConfigureRdIpAddress *Multivalue `json:"autoConfigureRdIpAddress,omitempty"`
	// BMacFirstLabel: B MAC First Label
	BMacFirstLabel *Multivalue `json:"bMacFirstLabel,omitempty"`
	// BMacSecondLabel: B MAC Second Label
	BMacSecondLabel *Multivalue `json:"bMacSecondLabel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableBMacSecondLabel: Enable B MAC Second Label
	EnableBMacSecondLabel *Multivalue `json:"enableBMacSecondLabel,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableL3TargetOnlyForRouteType5: Enable L3 Target only for Route Type 5
	EnableL3TargetOnlyForRouteType5 *Multivalue `json:"enableL3TargetOnlyForRouteType5,omitempty"`
	// EnableL3vniTargetList: Enable L3 Target List
	EnableL3vniTargetList *Multivalue `json:"enableL3vniTargetList,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EsiType: ESI Type
	EsiType *Multivalue `json:"esiType,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// L3vniImportRtListSameAsL3vniExportRtList: L3 Import RT List Same As L3 Export RT List

	L3vniImportRtListSameAsL3vniExportRtList *bool `json:"l3vniImportRtListSameAsL3vniExportRtList,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// MulticastTunnelTypeVxlan: Multicast Tunnel Type
	MulticastTunnelTypeVxlan *Multivalue `json:"multicastTunnelTypeVxlan,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumBroadcastDomainV6: The number of broadcast domain to be configured under EVI

	NumBroadcastDomainV6 *float32 `json:"numBroadcastDomainV6,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInL3vniExportRouteTargetList: Number of RTs in L3 Export Route Target List(multiplier)

	NumRtInL3vniExportRouteTargetList *float32 `json:"numRtInL3vniExportRouteTargetList,omitempty"`
	// NumRtInL3vniImportRouteTargetList: Number of RTs in L3 Import Route Target List(multiplier)

	NumRtInL3vniImportRouteTargetList *float32 `json:"numRtInL3vniImportRouteTargetList,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatingRouterIpv4: Configures Originating Router IP address in IPv4 Address format
	OriginatingRouterIpv4 *Multivalue `json:"originatingRouterIpv4,omitempty"`
	// OriginatingRouterIpv6: Configures Originating Router IP address in IPv6 Address format
	OriginatingRouterIpv6 *Multivalue `json:"originatingRouterIpv6,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PmsiTunnelIDv4: PMSI Tunnel ID
	PmsiTunnelIDv4 *Multivalue `json:"pmsiTunnelIDv4,omitempty"`
	// PmsiTunnelIDv6: PMSI Tunnel ID
	PmsiTunnelIDv6 *Multivalue `json:"pmsiTunnelIDv6,omitempty"`
	// RdASNumber: EVPN Route Distinguisher AS Number (2-byte or 4-Byte)
	RdASNumber *Multivalue `json:"rdASNumber,omitempty"`
	// RdEvi: EVPN Route Distinguisher Assigned Number
	RdEvi *Multivalue `json:"rdEvi,omitempty"`
	// RdIpAddress: RD IP Addresses
	RdIpAddress *Multivalue `json:"rdIpAddress,omitempty"`
	// RdType: EVPN RR Distinguisher Type
	RdType *Multivalue `json:"rdType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpstreamDownstreamAssignedMplsLabel: Upstream/Downstream Assigned MPLS Label
	UpstreamDownstreamAssignedMplsLabel *Multivalue `json:"upstreamDownstreamAssignedMplsLabel,omitempty"`
	// UseIpv4MappedIpv6Address: Use IPv4 Mapped IPv6 Address
	UseIpv4MappedIpv6Address *Multivalue `json:"useIpv4MappedIpv6Address,omitempty"`
	// UseUpstreamDownstreamAssignedMplsLabel: Use Upstream/Downstream Assigned MPLS Label
	UseUpstreamDownstreamAssignedMplsLabel *Multivalue                              `json:"useUpstreamDownstreamAssignedMplsLabel,omitempty"`
	BgpAsPathSegmentList                   []*TopologyBgpAsPathSegmentList          `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                       []*TopologyBgpClusterIdList              `json:"bgpClusterIdList"`
	BgpCommunitiesList                     []*TopologyBgpCommunitiesList            `json:"bgpCommunitiesList"`
	BgpExportRouteTargetList               []*TopologyBgpExportRouteTargetList      `json:"bgpExportRouteTargetList"`
	BgpExtendedCommunitiesList             []*TopologyBgpExtendedCommunitiesList    `json:"bgpExtendedCommunitiesList"`
	BgpImportRouteTargetList               []*TopologyBgpImportRouteTargetList      `json:"bgpImportRouteTargetList"`
	BgpL3VNIExportRouteTargetList          []*TopologyBgpL3VniExportRouteTargetList `json:"bgpL3VNIExportRouteTargetList"`
	BgpL3VNIImportRouteTargetList          []*TopologyBgpL3VniImportRouteTargetList `json:"bgpL3VNIImportRouteTargetList"`

	BroadcastDomainV6VxlanVpws *TopologyBroadcastDomainV6VxlanVpws `json:"broadcastDomainV6VxlanVpws,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIPv6EvpnVxlanVpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIPv6EvpnVxlanVpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIPv6EvpnVxlanVpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIPv6EvpnVxlanVpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvertiseL3vniSeparately.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseL3vniSeparately",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AutoConfigOriginatingRouterIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigOriginatingRouterIp",
		isMultivalue: true,
	})
	n.AutoConfigPMSITunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigPMSITunnelId",
		isMultivalue: true,
	})
	n.AutoConfigureRdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigureRdIpAddress",
		isMultivalue: true,
	})
	n.BMacFirstLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacFirstLabel",
		isMultivalue: true,
	})
	n.BMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableBMacSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBMacSecondLabel",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableL3TargetOnlyForRouteType5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3TargetOnlyForRouteType5",
		isMultivalue: true,
	})
	n.EnableL3vniTargetList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableL3vniTargetList",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EsiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "esiType",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.MulticastTunnelTypeVxlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelTypeVxlan",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv4",
		isMultivalue: true,
	})
	n.OriginatingRouterIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatingRouterIpv6",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv4",
		isMultivalue: true,
	})
	n.PmsiTunnelIDv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pmsiTunnelIDv6",
		isMultivalue: true,
	})
	n.RdASNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdASNumber",
		isMultivalue: true,
	})
	n.RdEvi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdEvi",
		isMultivalue: true,
	})
	n.RdIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdIpAddress",
		isMultivalue: true,
	})
	n.RdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.UpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	n.UseIpv4MappedIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useIpv4MappedIpv6Address",
		isMultivalue: true,
	})
	n.UseUpstreamDownstreamAssignedMplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpstreamDownstreamAssignedMplsLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VNIImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VNIImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BroadcastDomainV6VxlanVpws.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "broadcastDomainV6VxlanVpws",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpImportRouteTargetList: Import RouteTarget
type TopologyBgpImportRouteTargetList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetAs4Number: Import Route Target AS4 Number
	TargetAs4Number *Multivalue `json:"targetAs4Number,omitempty"`
	// TargetAsNumber: Import Route Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Import Route Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddress: Import Route Target IP Address
	TargetIpAddress *Multivalue `json:"targetIpAddress,omitempty"`
	// TargetType: Import Route Target Type
	TargetType *Multivalue `json:"targetType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpImportRouteTargetList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpImportRouteTargetList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpImportRouteTargetList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpImportRouteTargetList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.TargetAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAs4Number",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddress",
		isMultivalue: true,
	})
	n.TargetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetType",
		isMultivalue: true,
	})
}

// TopologyBgpIpRouteProperty: BGP Non-VPN IPv4/v6 Route Range Properties
type TopologyBgpIpRouteProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"OverridePeerAsSetMode,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AddPathId: BGP ADD Path Id
	AddPathId *Multivalue `json:"addPathId,omitempty"`
	// AdvertiseAsBGPLSPrefix: Advertise as BGP-LS Prefix
	AdvertiseAsBGPLSPrefix *Multivalue `json:"advertiseAsBGPLSPrefix,omitempty"`
	// AdvertiseAsBgp3107: Will cause this route to be sent as BGP 3107 MPLS SAFI route

	AdvertiseAsBgp3107 *bool `json:"advertiseAsBgp3107,omitempty"`
	// AdvertiseAsBgp3107Sr: Will cause this route to be sent as BGP 3107 SR MPLS SAFI route

	AdvertiseAsBgp3107Sr *bool `json:"advertiseAsBgp3107Sr,omitempty"`
	// AdvertiseAsRfc8277: Will cause this route to be sent as RFC 8277 MPLS SAFI route

	AdvertiseAsRfc8277 *bool `json:"advertiseAsRfc8277,omitempty"`
	// AdvertiseAsRfc8277SR: Will cause this route to be sent as RFC 8277 MPLS SAFI route

	AdvertiseAsRfc8277SR *bool `json:"advertiseAsRfc8277SR,omitempty"`
	// AdvertiseNexthopAsV4: Advertise Nexthop as V4
	AdvertiseNexthopAsV4 *Multivalue `json:"advertiseNexthopAsV4,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AggregatorIdMode: Aggregator ID Mode
	AggregatorIdMode *Multivalue `json:"aggregatorIdMode,omitempty"`
	// AsNumSuffixRange: Supported Formats: value value1-value2 Values or value ranges separated by comma(,). e.g. 100,150-200,400,600-800 etc. Cannot be kept empty. Should be >= (Max Number of AS Path Segments) x (Max AS Numbers Per Segment)
	AsNumSuffixRange *Multivalue `json:"asNumSuffixRange,omitempty"`
	// AsPathPerRoute: When there are multiple routes in a route range, this option decides whether to use same or different AS paths randomly generated for all the routes within that route range. For the Different option, each route will be sent in different update messages.
	AsPathPerRoute *Multivalue `json:"asPathPerRoute,omitempty"`
	// AsRandomSeed: Seed value decides the way the AS Values are generated. To generate different AS Paths for different Route ranges, select unique Seed Values.
	AsRandomSeed *Multivalue `json:"asRandomSeed,omitempty"`
	// AsSegDist: Type of AS Segment generated. If user selects Random, then any of the four types (AS-SET, AS-SEQ, AS-SET-CONFEDERATION, AS-SEQ-CONFEDERATION) will get randomly generated.
	AsSegDist *Multivalue `json:"asSegDist,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Delay: Delay in Seconds
	Delay *Multivalue `json:"delay,omitempty"`
	// Downtime: Downtime In Seconds
	Downtime *Multivalue `json:"downtime,omitempty"`
	// EnableAddPath: Enable Path ID when ADD Path Capability is enabled in BGP Peer
	EnableAddPath *Multivalue `json:"enableAddPath,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAigp: Enable AIGP
	EnableAigp *Multivalue `json:"enableAigp,omitempty"`
	// EnableAsPathSegments: Enable Non-Random AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableFlapping: Enable Flapping
	EnableFlapping *Multivalue `json:"enableFlapping,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRandomAsPath: Enables generation/advertisement of Random AS Path Segments.
	EnableRandomAsPath *Multivalue `json:"enableRandomAsPath,omitempty"`
	// EnableSRGB: Enable SRGB TLV
	EnableSRGB *Multivalue `json:"enableSRGB,omitempty"`
	// EnableWeight: Enable Weight
	EnableWeight *Multivalue `json:"enableWeight,omitempty"`
	// FlapFromRouteIndex: Flap From Route Index
	FlapFromRouteIndex *Multivalue `json:"flapFromRouteIndex,omitempty"`
	// FlapToRouteIndex: Flap To Route Index
	FlapToRouteIndex *Multivalue `json:"flapToRouteIndex,omitempty"`
	// IncrementMode: Either Fixed or Increment
	IncrementMode *Multivalue `json:"incrementMode,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LabelEnd: Route Range Label End
	LabelEnd *Multivalue `json:"labelEnd,omitempty"`
	// LabelStart: Route Range Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// LabelStep: Route Range Label Step
	LabelStep *Multivalue `json:"labelStep,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MaxASNumPerSegment: Maximum Number Of AS Numbers generated per Segment
	MaxASNumPerSegment *Multivalue `json:"maxASNumPerSegment,omitempty"`
	// MaxNoOfASPathSegmentsPerRouteRange: Maximum Number Of AS Path Segments Per Route Range.
	MaxNoOfASPathSegmentsPerRouteRange *Multivalue `json:"maxNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MinASNumPerSegment: Minimum Number Of AS Numbers generated per Segments.
	MinASNumPerSegment *Multivalue `json:"minASNumPerSegment,omitempty"`
	// MinNoOfASPathSegmentsPerRouteRange: Minimum Number Of AS Path Segments Per Route Range.
	MinNoOfASPathSegmentsPerRouteRange *Multivalue `json:"minNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextHopIPType: Set Next Hop IP Type
	NextHopIPType *Multivalue `json:"nextHopIPType,omitempty"`
	// NextHopIncrementMode: Next Hop Increment Mode
	NextHopIncrementMode *Multivalue `json:"nextHopIncrementMode,omitempty"`
	// NextHopType: Set Next Hop
	NextHopType *Multivalue `json:"nextHopType,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of non-random or manually configured AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExternalCommunities: Number of Extended Communities

	NoOfExternalCommunities *float32 `json:"noOfExternalCommunities,omitempty"`
	// NoOfLabels: Number of Labels

	NoOfLabels *float32 `json:"noOfLabels,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// NoOfSegmentIds: Number of Segment Ids

	NoOfSegmentIds *float32 `json:"noOfSegmentIds,omitempty"`
	// NoOfTlvs: Number of TLVs

	NoOfTlvs *float32 `json:"noOfTlvs,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// PackingFrom: Packing From
	PackingFrom *Multivalue `json:"packingFrom,omitempty"`
	// PackingTo: Packing To
	PackingTo *Multivalue `json:"packingTo,omitempty"`
	// PartialFlap: Partial Flap
	PartialFlap *Multivalue `json:"partialFlap,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// SegmentId: SID or Segment ID, converts to label value by adding offset into SRGB Start Label Value.
	SegmentId *Multivalue `json:"segmentId,omitempty"`
	// SendMulticastWithProperSAFI: Send Routes with SAFI as Multicast (2)
	SendMulticastWithProperSAFI *Multivalue `json:"sendMulticastWithProperSAFI,omitempty"`
	// SkipMulticast: Skip the Multicast routes for this route range
	SkipMulticast *Multivalue `json:"skipMulticast,omitempty"`
	// SpecialLabel: If we are emulating Egress then Label field may not hold Label value calculated based on SRGB and Offset but Implicit IPv4 NULL or Explicit NULL
	SpecialLabel *Multivalue `json:"specialLabel,omitempty"`
	// Uptime: Uptime In Seconds
	Uptime *Multivalue `json:"uptime,omitempty"`
	// UseTraditionalNlri: Use Traditional NLRI
	UseTraditionalNlri *Multivalue `json:"useTraditionalNlri,omitempty"`
	// Weight: Weight
	Weight                          *Multivalue                                `json:"weight,omitempty"`
	Bgp8277SRSegmentIdList          []*TopologyBgp8277SrSegmentIdList          `json:"Bgp8277SRSegmentIdList"`
	Rfc8277LabelStack               []*TopologyRfc8277LabelStack               `json:"Rfc8277LabelStack"`
	BgpAigpList                     []*TopologyBgpAigpList                     `json:"bgpAigpList"`
	BgpAsPathSegmentList            []*TopologyBgpAsPathSegmentList            `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                []*TopologyBgpClusterIdList                `json:"bgpClusterIdList"`
	BgpCommunitiesList              []*TopologyBgpCommunitiesList              `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList      []*TopologyBgpExtendedCommunitiesList      `json:"bgpExtendedCommunitiesList"`
	BgpNonVPNRRLargeCommunitiesList []*TopologyBgpNonVpnrrLargeCommunitiesList `json:"bgpNonVPNRRLargeCommunitiesList"`
	CMacProperties                  []*TopologyCMacProperties                  `json:"cMacProperties"`
	EvpnIPv4PrefixRange             []*TopologyEvpnIPv4PrefixRange             `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange             []*TopologyEvpnIPv6PrefixRange             `json:"evpnIPv6PrefixRange"`

	GenerateIpv6RoutesParams *TopologyGenerateIpv6RoutesParams `json:"generateIpv6RoutesParams,omitempty"`

	GenerateRoutesParams *TopologyGenerateRoutesParams `json:"generateRoutesParams,omitempty"`

	ImportBgpRoutesParams *TopologyImportBgpRoutesParams `json:"importBgpRoutesParams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpRouteProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpRouteProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpRouteProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpRouteProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "OverridePeerAsSetMode",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AddPathId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addPathId",
		isMultivalue: true,
	})
	n.AdvertiseAsBGPLSPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseAsBGPLSPrefix",
		isMultivalue: true,
	})
	n.AdvertiseNexthopAsV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseNexthopAsV4",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AggregatorIdMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorIdMode",
		isMultivalue: true,
	})
	n.AsNumSuffixRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumSuffixRange",
		isMultivalue: true,
	})
	n.AsPathPerRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asPathPerRoute",
		isMultivalue: true,
	})
	n.AsRandomSeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asRandomSeed",
		isMultivalue: true,
	})
	n.AsSegDist.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSegDist",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Delay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delay",
		isMultivalue: true,
	})
	n.Downtime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downtime",
		isMultivalue: true,
	})
	n.EnableAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAddPath",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAigp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAigp",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableFlapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFlapping",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRandomAsPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRandomAsPath",
		isMultivalue: true,
	})
	n.EnableSRGB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSRGB",
		isMultivalue: true,
	})
	n.EnableWeight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWeight",
		isMultivalue: true,
	})
	n.FlapFromRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapFromRouteIndex",
		isMultivalue: true,
	})
	n.FlapToRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapToRouteIndex",
		isMultivalue: true,
	})
	n.IncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "incrementMode",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LabelEnd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelEnd",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.LabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStep",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MaxASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxASNumPerSegment",
		isMultivalue: true,
	})
	n.MaxNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MinASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minASNumPerSegment",
		isMultivalue: true,
	})
	n.MinNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NextHopIPType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIPType",
		isMultivalue: true,
	})
	n.NextHopIncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIncrementMode",
		isMultivalue: true,
	})
	n.NextHopType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.PackingFrom.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingFrom",
		isMultivalue: true,
	})
	n.PackingTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingTo",
		isMultivalue: true,
	})
	n.PartialFlap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partialFlap",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.SegmentId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentId",
		isMultivalue: true,
	})
	n.SendMulticastWithProperSAFI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendMulticastWithProperSAFI",
		isMultivalue: true,
	})
	n.SkipMulticast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "skipMulticast",
		isMultivalue: true,
	})
	n.SpecialLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "specialLabel",
		isMultivalue: true,
	})
	n.Uptime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uptime",
		isMultivalue: true,
	})
	n.UseTraditionalNlri.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useTraditionalNlri",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	for i, o := range n.Bgp8277SRSegmentIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "Bgp8277SRSegmentIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Rfc8277LabelStack {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "Rfc8277LabelStack",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpAigpList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAigpList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpNonVPNRRLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpNonVPNRRLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.GenerateIpv6RoutesParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "generateIpv6RoutesParams",
	})
	n.GenerateRoutesParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "generateRoutesParams",
	})
	n.ImportBgpRoutesParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "importBgpRoutesParams",
	})
}

// TopologyBgpIpv4AdL2Vpn: BGP AD-L2VPN Configuration
type TopologyBgpIpv4AdL2Vpn struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AsNumberVplsId: VPLS ID AS Number
	AsNumberVplsId *Multivalue `json:"asNumberVplsId,omitempty"`
	// AsNumberVplsRd: Route Distinguisher AS Number
	AsNumberVplsRd *Multivalue `json:"asNumberVplsRd,omitempty"`
	// AsNumberVplsRt: Route Target AS Number
	AsNumberVplsRt *Multivalue `json:"asNumberVplsRt,omitempty"`
	// AssignedNumberVplsId: VPLS ID Assigned Number
	AssignedNumberVplsId *Multivalue `json:"assignedNumberVplsId,omitempty"`
	// AssignedNumberVplsRd: Route Distinguisher Assigned Number
	AssignedNumberVplsRd *Multivalue `json:"assignedNumberVplsRd,omitempty"`
	// AssignedNumberVplsRt: Route Target Assigned Number
	AssignedNumberVplsRt *Multivalue `json:"assignedNumberVplsRt,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ImportRDAsRT: Use RD As RT
	ImportRDAsRT *Multivalue `json:"importRDAsRT,omitempty"`
	// ImportVplsIdAsRd: Use VPLS ID As Route Distinguisher
	ImportVplsIdAsRd *Multivalue `json:"importVplsIdAsRd,omitempty"`
	// IpAddressVplsId: VPLS ID IP Address
	IpAddressVplsId *Multivalue `json:"ipAddressVplsId,omitempty"`
	// IpAddressVplsRd: Route Distinguisher IP Address
	IpAddressVplsRd *Multivalue `json:"ipAddressVplsRd,omitempty"`
	// IpAddressVplsRt: Route Target IP Address
	IpAddressVplsRt *Multivalue `json:"ipAddressVplsRt,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberVsiId: VSI ID Number
	NumberVsiId *Multivalue `json:"numberVsiId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TypeVplsId: VPLS ID Type
	TypeVplsId *Multivalue `json:"typeVplsId,omitempty"`
	// TypeVplsRd: RD Type
	TypeVplsRd *Multivalue `json:"typeVplsRd,omitempty"`
	// TypeVplsRt: RT Type
	TypeVplsRt *Multivalue `json:"typeVplsRt,omitempty"`
	// TypeVsiId: VSI ID
	TypeVsiId *Multivalue `json:"typeVsiId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv4AdL2Vpn) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv4AdL2Vpn) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv4AdL2Vpn) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv4AdL2Vpn) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumberVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumberVplsId",
		isMultivalue: true,
	})
	n.AsNumberVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumberVplsRd",
		isMultivalue: true,
	})
	n.AsNumberVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumberVplsRt",
		isMultivalue: true,
	})
	n.AssignedNumberVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumberVplsId",
		isMultivalue: true,
	})
	n.AssignedNumberVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumberVplsRd",
		isMultivalue: true,
	})
	n.AssignedNumberVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumberVplsRt",
		isMultivalue: true,
	})
	n.ImportRDAsRT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "importRDAsRT",
		isMultivalue: true,
	})
	n.ImportVplsIdAsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "importVplsIdAsRd",
		isMultivalue: true,
	})
	n.IpAddressVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressVplsId",
		isMultivalue: true,
	})
	n.IpAddressVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressVplsRd",
		isMultivalue: true,
	})
	n.IpAddressVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressVplsRt",
		isMultivalue: true,
	})
	n.NumberVsiId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberVsiId",
		isMultivalue: true,
	})
	n.TypeVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVplsId",
		isMultivalue: true,
	})
	n.TypeVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVplsRd",
		isMultivalue: true,
	})
	n.TypeVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVplsRt",
		isMultivalue: true,
	})
	n.TypeVsiId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVsiId",
		isMultivalue: true,
	})
}

// TopologyBgpIpv4L2Site: BGP IPv4 Peer L2 Site (Range) Configuration
type TopologyBgpIpv4L2Site struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DistinguishAsNumber: Distinguish AS Number
	DistinguishAsNumber *Multivalue `json:"distinguishAsNumber,omitempty"`
	// DistinguishAssignedNumber: Distinguish Assigned Number
	DistinguishAssignedNumber *Multivalue `json:"distinguishAssignedNumber,omitempty"`
	// DistinguishIpAddr: Distinguish IP Address
	DistinguishIpAddr *Multivalue `json:"distinguishIpAddr,omitempty"`
	// EnCluster: Enable Cluster
	EnCluster *Multivalue `json:"enCluster,omitempty"`
	// EnControlWord: Enable Control Word
	EnControlWord *Multivalue `json:"enControlWord,omitempty"`
	// EnSeqDelivery: Enable Sequenced Delivery
	EnSeqDelivery *Multivalue `json:"enSeqDelivery,omitempty"`
	// EnableBfdVccv: If selected, BFD VCCV MPLS is enabled.
	EnableBfdVccv *Multivalue `json:"enableBfdVccv,omitempty"`
	// EnableVccvPing: If selected, VCCV Ping is enabled
	EnableVccvPing *Multivalue `json:"enableVccvPing,omitempty"`
	// EncapsulationType: Encapsulation Type
	EncapsulationType *Multivalue `json:"encapsulationType,omitempty"`
	// MtuL2Site: MTU
	MtuL2Site *Multivalue `json:"mtuL2Site,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumClusterPerL2Site: Number Of Clusters Per L2 Site

	NumClusterPerL2Site *float32 `json:"numClusterPerL2Site,omitempty"`
	// NumL2Sites: No. Of L2 Sites
	NumL2Sites *Multivalue `json:"numL2Sites,omitempty"`
	// NumLabelBlocksPerL2Site: Number Of Label Blocks Per L2 Site

	NumLabelBlocksPerL2Site *float32 `json:"numLabelBlocksPerL2Site,omitempty"`
	// SiteId: Site ID
	SiteId *Multivalue `json:"siteId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TargetAsNumber: Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddr: Target IP Address
	TargetIpAddr *Multivalue `json:"targetIpAddr,omitempty"`
	// TypeDistinguish: Distinguish Type
	TypeDistinguish *Multivalue `json:"typeDistinguish,omitempty"`
	// TypeTarget: Target Type
	TypeTarget *Multivalue `json:"typeTarget,omitempty"`
	// VpnName: VPN Name
	VpnName     *Multivalue            `json:"vpnName,omitempty"`
	ClusterList []*TopologyClusterList `json:"clusterList"`

	Connector      *TopologyConnector        `json:"connector,omitempty"`
	LabelBlockList []*TopologyLabelBlockList `json:"labelBlockList"`
	Tag            []*TopologyTag            `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv4L2Site) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv4L2Site) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv4L2Site) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv4L2Site) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DistinguishAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguishAsNumber",
		isMultivalue: true,
	})
	n.DistinguishAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguishAssignedNumber",
		isMultivalue: true,
	})
	n.DistinguishIpAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguishIpAddr",
		isMultivalue: true,
	})
	n.EnCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enCluster",
		isMultivalue: true,
	})
	n.EnControlWord.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enControlWord",
		isMultivalue: true,
	})
	n.EnSeqDelivery.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enSeqDelivery",
		isMultivalue: true,
	})
	n.EnableBfdVccv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdVccv",
		isMultivalue: true,
	})
	n.EnableVccvPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVccvPing",
		isMultivalue: true,
	})
	n.EncapsulationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "encapsulationType",
		isMultivalue: true,
	})
	n.MtuL2Site.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtuL2Site",
		isMultivalue: true,
	})
	n.NumL2Sites.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numL2Sites",
		isMultivalue: true,
	})
	n.SiteId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "siteId",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddr",
		isMultivalue: true,
	})
	n.TypeDistinguish.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeDistinguish",
		isMultivalue: true,
	})
	n.TypeTarget.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeTarget",
		isMultivalue: true,
	})
	n.VpnName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vpnName",
		isMultivalue: true,
	})
	for i, o := range n.ClusterList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "clusterList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.LabelBlockList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "labelBlockList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIpv4MVrf: BGP IPv4 Peer mVRF Configuration
type TopologyBgpIpv4MVrf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// BFRId: BFR-Id
	BFRId *Multivalue `json:"BFRId,omitempty"`
	// BFRIpv4Prefix: BFR IPv4 Prefix
	BFRIpv4Prefix *Multivalue `json:"BFRIpv4Prefix,omitempty"`
	// BFRIpv6Prefix: BFR IPv6 Prefix
	BFRIpv6Prefix *Multivalue `json:"BFRIpv6Prefix,omitempty"`
	// BFRPrefixType: BFR Prefix Type
	BFRPrefixType *Multivalue `json:"BFRPrefixType,omitempty"`
	// BIERSubDomainId: BIER Sub-Domain Id
	BIERSubDomainId *Multivalue `json:"BIERSubDomainId,omitempty"`
	// BslMismatchHandlingOption: BIER BSL Mismatch Handling Option
	BslMismatchHandlingOption *Multivalue `json:"BslMismatchHandlingOption,omitempty"`
	// LeafInfoRequiredBit: Leaf Info Required Bit
	LeafInfoRequiredBit *Multivalue `json:"LeafInfoRequiredBit,omitempty"`
	// LeafInfoRequiredPerFlow: Leaf Info Required Per Flow(LIR-PF)
	LeafInfoRequiredPerFlow *Multivalue `json:"LeafInfoRequiredPerFlow,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseIPMSIRoutes: Enables I-PMSI Route Advertisement for MVPN (if True). Disables I-PMSI Route Advertisement for MVPN (if False). - Set to False when Enable TRM is Enabled (by deafult).

	AdvertiseIPMSIRoutes *bool `json:"advertiseIPMSIRoutes,omitempty"`
	// AutoConstructBitString: Use BitString
	AutoConstructBitString *Multivalue `json:"autoConstructBitString,omitempty"`
	// BierBitStringLength: Bit String Length
	BierBitStringLength *Multivalue `json:"bierBitStringLength,omitempty"`
	// BitString: BitString
	BitString *Multivalue `json:"bitString,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Dscp: DSCP
	Dscp *Multivalue `json:"dscp,omitempty"`
	// EnableTRM: Enables Tenant Routed Multicast support in EVPN. Upon Enabling, - Advertise I-PMSI Routes will be disabled (by default). - Multicast Tunnel Type will be PIM-SSM (by default). - VRF Route Import Extended Community is sent with EVPN Route Type 2 & 5 (always).

	EnableTRM *bool `json:"enableTRM,omitempty"`
	// Entropy: Entropy
	Entropy *Multivalue `json:"entropy,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludeBierPTAinLeafAD: Include Bier PTA in Leaf A-D
	IncludeBierPTAinLeafAD *Multivalue `json:"includeBierPTAinLeafAD,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// MulticastDistinguisherAs4Number: VMulticast Distinguisher AS4 Number
	MulticastDistinguisherAs4Number *Multivalue `json:"multicastDistinguisherAs4Number,omitempty"`
	// MulticastDistinguisherAsNumber: VMulticast Distinguisher AS Number
	MulticastDistinguisherAsNumber *Multivalue `json:"multicastDistinguisherAsNumber,omitempty"`
	// MulticastDistinguisherAssignedNumber: Multicast Distinguisher Assigned Number
	MulticastDistinguisherAssignedNumber *Multivalue `json:"multicastDistinguisherAssignedNumber,omitempty"`
	// MulticastDistinguisherIpAddress: Multicast Distinguisher IP Address
	MulticastDistinguisherIpAddress *Multivalue `json:"multicastDistinguisherIpAddress,omitempty"`
	// MulticastDistinguisherType: Multicast Distinguisher Type
	MulticastDistinguisherType *Multivalue `json:"multicastDistinguisherType,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextProtocol: Next Protocol
	NextProtocol *Multivalue `json:"nextProtocol,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInUmhExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInUmhExportRouteTargetList *float32 `json:"numRtInUmhExportRouteTargetList,omitempty"`
	// NumRtInUmhImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInUmhImportRouteTargetList *float32 `json:"numRtInUmhImportRouteTargetList,omitempty"`
	// Oam: OAM
	Oam *Multivalue `json:"oam,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// Rsv: Rsv
	Rsv *Multivalue `json:"rsv,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SameAsExportRT: Same As Export RT Attribute

	SameAsExportRT *bool `json:"sameAsExportRT,omitempty"`
	// SameAsImportRT: Same As Import RT Attribute

	SameAsImportRT *bool `json:"sameAsImportRT,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// SiCount: Set Identifier Range
	SiCount *Multivalue `json:"siCount,omitempty"`
	// SrLabelStart: SR Label Start
	SrLabelStart *Multivalue `json:"srLabelStart,omitempty"`
	// SrLabelStep: SR Label Step
	SrLabelStep *Multivalue `json:"srLabelStep,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SupportLeafADRoutesSending: Support Leaf A-D Routes Sending
	SupportLeafADRoutesSending *Multivalue `json:"supportLeafADRoutesSending,omitempty"`
	// TrafficBfrId: Traffic BFR-Id
	TrafficBfrId *Multivalue `json:"trafficBfrId,omitempty"`
	// UpOrDownStreamAssignedLabel: Upstream/Downstream Assigned Label
	UpOrDownStreamAssignedLabel *Multivalue `json:"upOrDownStreamAssignedLabel,omitempty"`
	// UseSameBfrIdInTraffic: Use Same BFR-Id in Traffic
	UseSameBfrIdInTraffic *Multivalue `json:"useSameBfrIdInTraffic,omitempty"`
	// UseUpOrDownStreamAssigneLabel: Use Upstream/Downstream Assigned Label
	UseUpOrDownStreamAssigneLabel *Multivalue `json:"useUpOrDownStreamAssigneLabel,omitempty"`
	// Version: Version
	Version                     *Multivalue                            `json:"version,omitempty"`
	BgpExportRouteTargetList    []*TopologyBgpExportRouteTargetList    `json:"bgpExportRouteTargetList"`
	BgpImportRouteTargetList    []*TopologyBgpImportRouteTargetList    `json:"bgpImportRouteTargetList"`
	BgpUmhExportRouteTargetList []*TopologyBgpUmhExportRouteTargetList `json:"bgpUmhExportRouteTargetList"`
	BgpUmhImportRouteTargetList []*TopologyBgpUmhImportRouteTargetList `json:"bgpUmhImportRouteTargetList"`

	Connector *TopologyConnector   `json:"connector,omitempty"`
	PnTLVList []*TopologyPnTlvList `json:"pnTLVList"`
	Tag       []*TopologyTag       `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv4MVrf) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv4MVrf) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv4MVrf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv4MVrf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BFRId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRId",
		isMultivalue: true,
	})
	n.BFRIpv4Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIpv4Prefix",
		isMultivalue: true,
	})
	n.BFRIpv6Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIpv6Prefix",
		isMultivalue: true,
	})
	n.BFRPrefixType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRPrefixType",
		isMultivalue: true,
	})
	n.BIERSubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERSubDomainId",
		isMultivalue: true,
	})
	n.BslMismatchHandlingOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BslMismatchHandlingOption",
		isMultivalue: true,
	})
	n.LeafInfoRequiredBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "LeafInfoRequiredBit",
		isMultivalue: true,
	})
	n.LeafInfoRequiredPerFlow.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "LeafInfoRequiredPerFlow",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AutoConstructBitString.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConstructBitString",
		isMultivalue: true,
	})
	n.BierBitStringLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierBitStringLength",
		isMultivalue: true,
	})
	n.BitString.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bitString",
		isMultivalue: true,
	})
	n.Dscp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dscp",
		isMultivalue: true,
	})
	n.Entropy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "entropy",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.IncludeBierPTAinLeafAD.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeBierPTAinLeafAD",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.MulticastDistinguisherAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherAs4Number",
		isMultivalue: true,
	})
	n.MulticastDistinguisherAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherAsNumber",
		isMultivalue: true,
	})
	n.MulticastDistinguisherAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherAssignedNumber",
		isMultivalue: true,
	})
	n.MulticastDistinguisherIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherIpAddress",
		isMultivalue: true,
	})
	n.MulticastDistinguisherType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherType",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.NextProtocol.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextProtocol",
		isMultivalue: true,
	})
	n.Oam.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oam",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.Rsv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsv",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	n.SiCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "siCount",
		isMultivalue: true,
	})
	n.SrLabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srLabelStart",
		isMultivalue: true,
	})
	n.SrLabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srLabelStep",
		isMultivalue: true,
	})
	n.SupportLeafADRoutesSending.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportLeafADRoutesSending",
		isMultivalue: true,
	})
	n.TrafficBfrId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficBfrId",
		isMultivalue: true,
	})
	n.UpOrDownStreamAssignedLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upOrDownStreamAssignedLabel",
		isMultivalue: true,
	})
	n.UseSameBfrIdInTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useSameBfrIdInTraffic",
		isMultivalue: true,
	})
	n.UseUpOrDownStreamAssigneLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpOrDownStreamAssigneLabel",
		isMultivalue: true,
	})
	n.Version.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "version",
		isMultivalue: true,
	})
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIpv4Peer: Bgp IPv4 Peer
type TopologyBgpIpv4Peer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActAsRestarted: Act as restarted
	ActAsRestarted *Multivalue `json:"actAsRestarted,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseEndOfRib: Advertise End-Of-RIB
	AdvertiseEndOfRib *Multivalue `json:"advertiseEndOfRib,omitempty"`
	// AdvertiseEvpnRoutesForOtherVtep: Advertise EVPN routes for other VTEPS

	AdvertiseEvpnRoutesForOtherVtep *bool `json:"advertiseEvpnRoutesForOtherVtep,omitempty"`
	// AdvertiseTunnelEncapsulationExtendedCommunity: Advertise Tunnel Encapsulation Extended Community
	AdvertiseTunnelEncapsulationExtendedCommunity *Multivalue `json:"advertiseTunnelEncapsulationExtendedCommunity,omitempty"`
	// AlwaysIncludeTunnelEncExtCommunity: Always Include Tunnel Encapsulation Extended Community
	AlwaysIncludeTunnelEncExtCommunity *Multivalue `json:"alwaysIncludeTunnelEncExtCommunity,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Authentication: Authentication Type
	Authentication *Multivalue `json:"authentication,omitempty"`
	// BgpId: BGP ID
	BgpId *Multivalue `json:"bgpId,omitempty"`
	// BgpLsAsSetMode: AS# Set Mode
	BgpLsAsSetMode *Multivalue `json:"bgpLsAsSetMode,omitempty"`
	// BgpLsEnableAsPathSegments: Enable AS Path Segments
	BgpLsEnableAsPathSegments *Multivalue `json:"bgpLsEnableAsPathSegments,omitempty"`
	// BgpLsEnableCluster: Enable Cluster
	BgpLsEnableCluster *Multivalue `json:"bgpLsEnableCluster,omitempty"`
	// BgpLsEnableExtendedCommunity: Enable Extended Community
	BgpLsEnableExtendedCommunity *Multivalue `json:"bgpLsEnableExtendedCommunity,omitempty"`
	// BgpLsNoOfASPathSegments: Number Of AS Path Segments Per Route Range

	BgpLsNoOfASPathSegments *float32 `json:"bgpLsNoOfASPathSegments,omitempty"`
	// BgpLsNoOfClusters: Number of Clusters

	BgpLsNoOfClusters *float32 `json:"bgpLsNoOfClusters,omitempty"`
	// BgpLsNoOfCommunities: Number of Communities

	BgpLsNoOfCommunities *float32 `json:"bgpLsNoOfCommunities,omitempty"`
	// BgpLsOverridePeerAsSetMode: Override Peer AS# Set Mode
	BgpLsOverridePeerAsSetMode *Multivalue `json:"bgpLsOverridePeerAsSetMode,omitempty"`
	// CapabilityIpV4Mdt: IPv4 BGP MDT: AFI = 1, SAFI = 66
	CapabilityIpV4Mdt *Multivalue `json:"capabilityIpV4Mdt,omitempty"`
	// CapabilityIpV4Mpls: IPv4 MPLS
	CapabilityIpV4Mpls *Multivalue `json:"capabilityIpV4Mpls,omitempty"`
	// CapabilityIpV4MplsVpn: IPv4 MPLS VPN Capability: AFI=1,SAFI=128
	CapabilityIpV4MplsVpn *Multivalue `json:"capabilityIpV4MplsVpn,omitempty"`
	// CapabilityIpV4Multicast: IPv4 Multicast Capability: AFI=1,SAFI=2
	CapabilityIpV4Multicast *Multivalue `json:"capabilityIpV4Multicast,omitempty"`
	// CapabilityIpV4MulticastVpn: IP MCAST-VPN: AFI = 1, SAFI = 5
	CapabilityIpV4MulticastVpn *Multivalue `json:"capabilityIpV4MulticastVpn,omitempty"`
	// CapabilityIpV4Unicast: IPv4 Unicast Capability: AFI=1,SAFI=1
	CapabilityIpV4Unicast *Multivalue `json:"capabilityIpV4Unicast,omitempty"`
	// CapabilityIpV6Mpls: IPv6 MPLS
	CapabilityIpV6Mpls *Multivalue `json:"capabilityIpV6Mpls,omitempty"`
	// CapabilityIpV6MplsVpn: IPv6 MPLS VPN Capability: AFI=2,SAFI=128
	CapabilityIpV6MplsVpn *Multivalue `json:"capabilityIpV6MplsVpn,omitempty"`
	// CapabilityIpV6Multicast: IPv6 Multicast Capability: AFI=2,SAFI=2
	CapabilityIpV6Multicast *Multivalue `json:"capabilityIpV6Multicast,omitempty"`
	// CapabilityIpV6MulticastVpn: IP6 MCAST-VPN: AFI = 2, SAFI = 5
	CapabilityIpV6MulticastVpn *Multivalue `json:"capabilityIpV6MulticastVpn,omitempty"`
	// CapabilityIpV6Unicast: IPv6 Unicast Capability: AFI=2,SAFI=1
	CapabilityIpV6Unicast *Multivalue `json:"capabilityIpV6Unicast,omitempty"`
	// CapabilityIpv4MplsAddPath: IPv4 MPLS Add Path Capability

	CapabilityIpv4MplsAddPath *bool `json:"capabilityIpv4MplsAddPath,omitempty"`
	// CapabilityIpv4UnicastAddPath: Check box for IPv4 Unicast Add Path
	CapabilityIpv4UnicastAddPath *Multivalue `json:"capabilityIpv4UnicastAddPath,omitempty"`
	// CapabilityIpv6MplsAddPath: IPv6 MPLS Add Path Capability

	CapabilityIpv6MplsAddPath *bool `json:"capabilityIpv6MplsAddPath,omitempty"`
	// CapabilityIpv6UnicastAddPath: Check box for IPv6 Unicast Add Path
	CapabilityIpv6UnicastAddPath *Multivalue `json:"capabilityIpv6UnicastAddPath,omitempty"`
	// CapabilityLinkStateNonVpn: Link State Non-VPN Capability: AFI=16388,SAFI=71
	CapabilityLinkStateNonVpn *Multivalue `json:"capabilityLinkStateNonVpn,omitempty"`
	// CapabilityLinkStateVpn: Select this check box to enable Link State VPN capability on the router.AFI=16388 and SAFI=72 values will be supported.
	CapabilityLinkStateVpn *Multivalue `json:"capabilityLinkStateVpn,omitempty"`
	// CapabilityRouteConstraint: Route Constraint Capability: AFI=1,SAFI=132
	CapabilityRouteConstraint *Multivalue `json:"capabilityRouteConstraint,omitempty"`
	// CapabilityRouteRefresh: Route Refresh
	CapabilityRouteRefresh *Multivalue `json:"capabilityRouteRefresh,omitempty"`
	// CapabilitySRTEPoliciesV4: IPv4 SR TE Policy Capability: AFI=1,SAFI=73
	CapabilitySRTEPoliciesV4 *Multivalue `json:"capabilitySRTEPoliciesV4,omitempty"`
	// CapabilitySRTEPoliciesV6: IPv6 SR TE Policy Capability: AFI=2,SAFI=73
	CapabilitySRTEPoliciesV6 *Multivalue `json:"capabilitySRTEPoliciesV6,omitempty"`
	// CapabilityVpls: VPLS Capability: AFI = 25, SAFI = 65
	CapabilityVpls *Multivalue `json:"capabilityVpls,omitempty"`
	// Capabilityipv4UnicastFlowSpec: IPv4 Unicast Flow Spec Capability: AFI=1,SAFI=133
	Capabilityipv4UnicastFlowSpec *Multivalue `json:"capabilityipv4UnicastFlowSpec,omitempty"`
	// Capabilityipv6UnicastFlowSpec: IPv6 Unicast Flow Spec Capability: AFI=2,SAFI=133
	Capabilityipv6UnicastFlowSpec *Multivalue `json:"capabilityipv6UnicastFlowSpec,omitempty"`
	// ConfigureKeepaliveTimer: Configure Keepalive Timer
	ConfigureKeepaliveTimer *Multivalue `json:"configureKeepaliveTimer,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// CustomSidType: moved to port data in bgp/srv6 Custom SID Type
	CustomSidType *Multivalue `json:"customSidType,omitempty"`
	// DiscardIxiaGeneratedRoutes: Discard Ixia Generated Routes
	DiscardIxiaGeneratedRoutes *Multivalue `json:"discardIxiaGeneratedRoutes,omitempty"`
	// DowntimeInSec: Downtime in Seconds
	DowntimeInSec *Multivalue `json:"downtimeInSec,omitempty"`
	// DutIp: DUT IP
	DutIp *Multivalue `json:"dutIp,omitempty"`
	// Enable4ByteAs: Enable 4-Byte AS
	Enable4ByteAs *Multivalue `json:"enable4ByteAs,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableBgpId: Enable BGP ID
	EnableBgpId *Multivalue `json:"enableBgpId,omitempty"`
	// EnableBgpIdSameasRouterId: BGP ID Same as Router ID
	EnableBgpIdSameasRouterId *Multivalue `json:"enableBgpIdSameasRouterId,omitempty"`
	// EnableBgpLsCommunity: Enable Community
	EnableBgpLsCommunity *Multivalue `json:"enableBgpLsCommunity,omitempty"`
	// EnableEpeTraffic: Enable EPE Traffic

	EnableEpeTraffic *bool `json:"enableEpeTraffic,omitempty"`
	// EnableGracefulRestart: Enable Graceful Restart
	EnableGracefulRestart *Multivalue `json:"enableGracefulRestart,omitempty"`
	// EnableLlgr: Enable LLGR
	EnableLlgr *Multivalue `json:"enableLlgr,omitempty"`
	// EthernetSegmentsCountV4: Number of Ethernet Segments

	EthernetSegmentsCountV4 *float32 `json:"ethernetSegmentsCountV4,omitempty"`
	// Evpn: EVPN Capability: AFI = 25, SAFI = 70
	Evpn *Multivalue `json:"evpn,omitempty"`
	// FilterEvpn: Check box for EVPN filter
	FilterEvpn *Multivalue `json:"filterEvpn,omitempty"`
	// FilterIpV4Mpls: Filter IPv4 MPLS
	FilterIpV4Mpls *Multivalue `json:"filterIpV4Mpls,omitempty"`
	// FilterIpV4MplsVpn: Filter IPv4 MPLS VPN
	FilterIpV4MplsVpn *Multivalue `json:"filterIpV4MplsVpn,omitempty"`
	// FilterIpV4Multicast: Filter IPv4 Multicast
	FilterIpV4Multicast *Multivalue `json:"filterIpV4Multicast,omitempty"`
	// FilterIpV4MulticastVpn: Filter IPv4 Multicast VPN
	FilterIpV4MulticastVpn *Multivalue `json:"filterIpV4MulticastVpn,omitempty"`
	// FilterIpV4Unicast: Filter IPv4 Unicast
	FilterIpV4Unicast *Multivalue `json:"filterIpV4Unicast,omitempty"`
	// FilterIpV6Mpls: Filter IPv6 MPLS
	FilterIpV6Mpls *Multivalue `json:"filterIpV6Mpls,omitempty"`
	// FilterIpV6MplsVpn: Filter IPv6 MPLS VPN
	FilterIpV6MplsVpn *Multivalue `json:"filterIpV6MplsVpn,omitempty"`
	// FilterIpV6Multicast: Filter IPv6 Multicast
	FilterIpV6Multicast *Multivalue `json:"filterIpV6Multicast,omitempty"`
	// FilterIpV6MulticastVpn: Filter IPv6 Multicast VPN
	FilterIpV6MulticastVpn *Multivalue `json:"filterIpV6MulticastVpn,omitempty"`
	// FilterIpV6Unicast: Filter IPv6 Unicast
	FilterIpV6Unicast *Multivalue `json:"filterIpV6Unicast,omitempty"`
	// FilterIpv4MulticastBgpMplsVpn: Check box for IPv4 Multicast BGP/MPLS VPN filter
	FilterIpv4MulticastBgpMplsVpn *Multivalue `json:"filterIpv4MulticastBgpMplsVpn,omitempty"`
	// FilterIpv4UnicastFlowSpec: Filter IPv4 Unicast Flow Spec
	FilterIpv4UnicastFlowSpec *Multivalue `json:"filterIpv4UnicastFlowSpec,omitempty"`
	// FilterIpv6MulticastBgpMplsVpn: Check box for IPv6 Multicast BGP/MPLS VPN filter
	FilterIpv6MulticastBgpMplsVpn *Multivalue `json:"filterIpv6MulticastBgpMplsVpn,omitempty"`
	// FilterIpv6UnicastFlowSpec: Filter IPv6 Unicast Flow Spec
	FilterIpv6UnicastFlowSpec *Multivalue `json:"filterIpv6UnicastFlowSpec,omitempty"`
	// FilterLinkState: Filter Link State
	FilterLinkState *Multivalue `json:"filterLinkState,omitempty"`
	// FilterLinkStateVpn: Select this check box to store incoming BGP LS VPN route info.
	FilterLinkStateVpn *Multivalue `json:"filterLinkStateVpn,omitempty"`
	// FilterSRTEPoliciesV4: Enable IPv4 SR TE Policy Filter
	FilterSRTEPoliciesV4 *Multivalue `json:"filterSRTEPoliciesV4,omitempty"`
	// FilterSRTEPoliciesV6: Enable IPv6 SR TE Policy Filter
	FilterSRTEPoliciesV6 *Multivalue `json:"filterSRTEPoliciesV6,omitempty"`
	// FilterVpls: Filter VPLS
	FilterVpls *Multivalue `json:"filterVpls,omitempty"`
	// Flap: Flap
	Flap *Multivalue `json:"flap,omitempty"`
	// HoldTimer: Hold Timer
	HoldTimer *Multivalue `json:"holdTimer,omitempty"`
	// IpVrfToIpVrfType: IP-VRF-to-IP-VRF Model Type

	IpVrfToIpVrfType *string `json:"ipVrfToIpVrfType,omitempty"`
	// Ipv4MplsAddPathMode: IPv4 MPLS Add Path Mode
	Ipv4MplsAddPathMode *Multivalue `json:"ipv4MplsAddPathMode,omitempty"`
	// Ipv4MplsCapability: IPv4 MPLS Capability: AFI=1, SAFI=4

	Ipv4MplsCapability *bool `json:"ipv4MplsCapability,omitempty"`
	// Ipv4MulticastBgpMplsVpn: IP Multicast for BGP/MPLS IP VPN (UMH): AFI = 1, SAFI = 129
	Ipv4MulticastBgpMplsVpn *Multivalue `json:"ipv4MulticastBgpMplsVpn,omitempty"`
	// Ipv4MultipleMplsLabelsCapability: IPv4 Multiple MPLS Labels Capability: AFI=1, SAFI=4

	Ipv4MultipleMplsLabelsCapability *bool `json:"ipv4MultipleMplsLabelsCapability,omitempty"`
	// Ipv4UnicastAddPathMode: IPv4 Unicast Add Path Mode
	Ipv4UnicastAddPathMode *Multivalue `json:"ipv4UnicastAddPathMode,omitempty"`
	// Ipv6MplsAddPathMode: IPv6 MPLS Add Path Mode
	Ipv6MplsAddPathMode *Multivalue `json:"ipv6MplsAddPathMode,omitempty"`
	// Ipv6MplsCapability: IPv6 MPLS Capability: AFI=2, SAFI=4

	Ipv6MplsCapability *bool `json:"ipv6MplsCapability,omitempty"`
	// Ipv6MulticastBgpMplsVpn: IP6 Multicast for BGP/MPLS IP VPN (UMH): AFI = 2, SAFI = 129
	Ipv6MulticastBgpMplsVpn *Multivalue `json:"ipv6MulticastBgpMplsVpn,omitempty"`
	// Ipv6MultipleMplsLabelsCapability: IPv6 Multiple MPLS Labels Capability: AFI=2, SAFI=4

	Ipv6MultipleMplsLabelsCapability *bool `json:"ipv6MultipleMplsLabelsCapability,omitempty"`
	// Ipv6UnicastAddPathMode: IPv6 Unicast Add Path Mode
	Ipv6UnicastAddPathMode *Multivalue `json:"ipv6UnicastAddPathMode,omitempty"`
	// IrbInterfaceLabel: Label to be used for Route Type 2 carrying IRB MAC and/or IRB IP in Route Type 2
	IrbInterfaceLabel *Multivalue `json:"irbInterfaceLabel,omitempty"`
	// IrbIpv4Address: IRB IPv4 Address
	IrbIpv4Address *Multivalue `json:"irbIpv4Address,omitempty"`
	// KeepaliveTimer: Keepalive Timer
	KeepaliveTimer *Multivalue `json:"keepaliveTimer,omitempty"`
	// L3VPNEncapsulationType: L3VPN Traffic Encapsulation
	L3VPNEncapsulationType *Multivalue `json:"l3VPNEncapsulationType,omitempty"`
	// LocalAs2Bytes: Local AS# (2-Bytes)
	LocalAs2Bytes *Multivalue `json:"localAs2Bytes,omitempty"`
	// LocalAs4Bytes: Local AS# (4-Bytes)
	LocalAs4Bytes *Multivalue `json:"localAs4Bytes,omitempty"`
	// Md5Key: MD5 Key
	Md5Key *Multivalue `json:"md5Key,omitempty"`
	// ModeOfBfdOperations: Mode of BFD Operations
	ModeOfBfdOperations *Multivalue `json:"modeOfBfdOperations,omitempty"`
	// MplsLabelsCountForIpv4MplsRoute: MPLS Labels Count For IPv4 MPLS Route

	MplsLabelsCountForIpv4MplsRoute *float32 `json:"mplsLabelsCountForIpv4MplsRoute,omitempty"`
	// MplsLabelsCountForIpv6MplsRoute: MPLS Labels Count For IPv6 MPLS Route

	MplsLabelsCountForIpv6MplsRoute *float32 `json:"mplsLabelsCountForIpv6MplsRoute,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfEpePeers: Number of EPE Peers

	NoOfEpePeers *float32 `json:"noOfEpePeers,omitempty"`
	// NoOfExtendedCommunities: Number of Extended Communities

	NoOfExtendedCommunities *float32 `json:"noOfExtendedCommunities,omitempty"`
	// NoOfUserDefinedAfiSafi: Count of User Defined AFI SAFI

	NoOfUserDefinedAfiSafi *float32 `json:"noOfUserDefinedAfiSafi,omitempty"`
	// NumBgpLsId: BGP LS Instance ID
	NumBgpLsId *Multivalue `json:"numBgpLsId,omitempty"`
	// NumBgpLsInstanceIdentifier: IGP Multi instance unique identifier. 0 is default single-instance IGP. (e.g. for OSPFv3 it is possible to separately run 4 instances of OSPFv3 with peer, one advertising v4 only, another v6 only and other 2 mcast v4 and v6 respectively) .
	NumBgpLsInstanceIdentifier *Multivalue `json:"numBgpLsInstanceIdentifier,omitempty"`
	// NumBgpUpdatesGeneratedPerIteration: Num BGP Updates Generated Per Iteration
	NumBgpUpdatesGeneratedPerIteration *Multivalue `json:"numBgpUpdatesGeneratedPerIteration,omitempty"`
	// NumberColorFlexAlgoMapping: Number of Color/Flex Algo Mapping Entries

	NumberColorFlexAlgoMapping *float32 `json:"numberColorFlexAlgoMapping,omitempty"`
	// NumberFlowSpecRangeV4: Number of IPv4 Flow Spec Ranges

	NumberFlowSpecRangeV4 *float32 `json:"numberFlowSpecRangeV4,omitempty"`
	// NumberFlowSpecRangeV6: Number of IPv6 Flow Spec Ranges

	NumberFlowSpecRangeV6 *float32 `json:"numberFlowSpecRangeV6,omitempty"`
	// NumberSRTEPolicies: Count of SR TE Policies

	NumberSRTEPolicies *float32 `json:"numberSRTEPolicies,omitempty"`
	// OperationalModel: Operational Model
	OperationalModel *Multivalue `json:"operationalModel,omitempty"`
	// RestartTime: Restart Time
	RestartTime *Multivalue `json:"restartTime,omitempty"`
	// RoutersMacOrIrbMacAddress: Router's MAC/IRB MAC Address
	RoutersMacOrIrbMacAddress *Multivalue `json:"routersMacOrIrbMacAddress,omitempty"`
	// SRGBRangeCount: SRGB Range Count

	SRGBRangeCount *float32 `json:"sRGBRangeCount,omitempty"`
	// SendIxiaSignatureWithRoutes: Send Ixia Signature With Routes
	SendIxiaSignatureWithRoutes *Multivalue `json:"sendIxiaSignatureWithRoutes,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StaleTime: Stale Time/ LLGR Stale Time
	StaleTime *Multivalue `json:"staleTime,omitempty"`
	// TcpWindowSizeInBytes: TCP Window Size (in bytes)
	TcpWindowSizeInBytes *Multivalue `json:"tcpWindowSizeInBytes,omitempty"`
	// Ttl: TTL
	Ttl *Multivalue `json:"ttl,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// UdpPortEndValue: UDP Port End Value

	UdpPortEndValue *float32 `json:"udpPortEndValue,omitempty"`
	// UdpPortStartValue: UDP Port Start Value

	UdpPortStartValue *float32 `json:"udpPortStartValue,omitempty"`
	// UpdateInterval: Update Interval
	UpdateInterval *Multivalue `json:"updateInterval,omitempty"`
	// UptimeInSec: Uptime in Seconds
	UptimeInSec *Multivalue `json:"uptimeInSec,omitempty"`
	// VplsEnableNextHop: VPLS Enable Next Hop
	VplsEnableNextHop *Multivalue `json:"vplsEnableNextHop,omitempty"`
	// VplsNextHop: VPLS Next Hop
	VplsNextHop *Multivalue `json:"vplsNextHop,omitempty"`

	BgpCustomAfiSafiv4 *TopologyBgpCustomAfiSafiv4 `json:"bgpCustomAfiSafiv4,omitempty"`

	BgpEpePeerList *TopologyBgpEpePeerList `json:"bgpEpePeerList,omitempty"`

	BgpEthernetSegmentV4 *TopologyBgpEthernetSegmentV4 `json:"bgpEthernetSegmentV4,omitempty"`

	BgpFlowSpecRangesList *TopologyBgpFlowSpecRangesList `json:"bgpFlowSpecRangesList,omitempty"`

	BgpFlowSpecRangesListV4 *TopologyBgpFlowSpecRangesListV4 `json:"bgpFlowSpecRangesListV4,omitempty"`

	BgpFlowSpecRangesListV6      *TopologyBgpFlowSpecRangesListV6        `json:"bgpFlowSpecRangesListV6,omitempty"`
	BgpIPv4EvpnEvi               []*TopologyBgpIPv4EvpnEvi               `json:"bgpIPv4EvpnEvi"`
	BgpIPv4EvpnPbb               []*TopologyBgpIPv4EvpnPbb               `json:"bgpIPv4EvpnPbb"`
	BgpIPv4EvpnVXLAN             []*TopologyBgpIPv4EvpnVxlan             `json:"bgpIPv4EvpnVXLAN"`
	BgpIPv4EvpnVXLANVpws         []*TopologyBgpIPv4EvpnVxlanVpws         `json:"bgpIPv4EvpnVXLANVpws"`
	BgpIPv4EvpnVpws              []*TopologyBgpIPv4EvpnVpws              `json:"bgpIPv4EvpnVpws"`
	BgpIpv4AdL2Vpn               []*TopologyBgpIpv4AdL2Vpn               `json:"bgpIpv4AdL2Vpn"`
	BgpIpv4L2Site                []*TopologyBgpIpv4L2Site                `json:"bgpIpv4L2Site"`
	BgpIpv4MVrf                  []*TopologyBgpIpv4MVrf                  `json:"bgpIpv4MVrf"`
	BgpLsAsPathSegmentList       []*TopologyBgpLsAsPathSegmentList       `json:"bgpLsAsPathSegmentList"`
	BgpLsClusterIdList           []*TopologyBgpLsClusterIdList           `json:"bgpLsClusterIdList"`
	BgpLsCommunitiesList         []*TopologyBgpLsCommunitiesList         `json:"bgpLsCommunitiesList"`
	BgpLsExtendedCommunitiesList []*TopologyBgpLsExtendedCommunitiesList `json:"bgpLsExtendedCommunitiesList"`
	BgpSRGBRangeSubObjectsList   []*TopologyBgpSrgbRangeSubObjectsList   `json:"bgpSRGBRangeSubObjectsList"`

	BgpSRTEPoliciesListV4 *TopologyBgpSrtePoliciesListV4 `json:"bgpSRTEPoliciesListV4,omitempty"`
	BgpVrf                []*TopologyBgpVrf              `json:"bgpVrf"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	FlexAlgoColorMappingTemplate *TopologyFlexAlgoColorMappingTemplate `json:"flexAlgoColorMappingTemplate,omitempty"`
	LearnedInfo                  []*TopologyLearnedInfo                `json:"learnedInfo"`
	TlvProfile                   []*TopologyTlvProfile                 `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv4Peer) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv4Peer) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv4Peer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv4Peer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActAsRestarted.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actAsRestarted",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseEndOfRib.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseEndOfRib",
		isMultivalue: true,
	})
	n.AdvertiseTunnelEncapsulationExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseTunnelEncapsulationExtendedCommunity",
		isMultivalue: true,
	})
	n.AlwaysIncludeTunnelEncExtCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "alwaysIncludeTunnelEncExtCommunity",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.BgpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpId",
		isMultivalue: true,
	})
	n.BgpLsAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsAsSetMode",
		isMultivalue: true,
	})
	n.BgpLsEnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsEnableAsPathSegments",
		isMultivalue: true,
	})
	n.BgpLsEnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsEnableCluster",
		isMultivalue: true,
	})
	n.BgpLsEnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsEnableExtendedCommunity",
		isMultivalue: true,
	})
	n.BgpLsOverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsOverridePeerAsSetMode",
		isMultivalue: true,
	})
	n.CapabilityIpV4Mdt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Mdt",
		isMultivalue: true,
	})
	n.CapabilityIpV4Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Mpls",
		isMultivalue: true,
	})
	n.CapabilityIpV4MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4MplsVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV4Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Multicast",
		isMultivalue: true,
	})
	n.CapabilityIpV4MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4MulticastVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV4Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Unicast",
		isMultivalue: true,
	})
	n.CapabilityIpV6Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6Mpls",
		isMultivalue: true,
	})
	n.CapabilityIpV6MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6MplsVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV6Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6Multicast",
		isMultivalue: true,
	})
	n.CapabilityIpV6MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6MulticastVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV6Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6Unicast",
		isMultivalue: true,
	})
	n.CapabilityIpv4UnicastAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpv4UnicastAddPath",
		isMultivalue: true,
	})
	n.CapabilityIpv6UnicastAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpv6UnicastAddPath",
		isMultivalue: true,
	})
	n.CapabilityLinkStateNonVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityLinkStateNonVpn",
		isMultivalue: true,
	})
	n.CapabilityLinkStateVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityLinkStateVpn",
		isMultivalue: true,
	})
	n.CapabilityRouteConstraint.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityRouteConstraint",
		isMultivalue: true,
	})
	n.CapabilityRouteRefresh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityRouteRefresh",
		isMultivalue: true,
	})
	n.CapabilitySRTEPoliciesV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitySRTEPoliciesV4",
		isMultivalue: true,
	})
	n.CapabilitySRTEPoliciesV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitySRTEPoliciesV6",
		isMultivalue: true,
	})
	n.CapabilityVpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityVpls",
		isMultivalue: true,
	})
	n.Capabilityipv4UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityipv4UnicastFlowSpec",
		isMultivalue: true,
	})
	n.Capabilityipv6UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityipv6UnicastFlowSpec",
		isMultivalue: true,
	})
	n.ConfigureKeepaliveTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureKeepaliveTimer",
		isMultivalue: true,
	})
	n.CustomSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSidType",
		isMultivalue: true,
	})
	n.DiscardIxiaGeneratedRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardIxiaGeneratedRoutes",
		isMultivalue: true,
	})
	n.DowntimeInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downtimeInSec",
		isMultivalue: true,
	})
	n.DutIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutIp",
		isMultivalue: true,
	})
	n.Enable4ByteAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable4ByteAs",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableBgpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBgpId",
		isMultivalue: true,
	})
	n.EnableBgpIdSameasRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBgpIdSameasRouterId",
		isMultivalue: true,
	})
	n.EnableBgpLsCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBgpLsCommunity",
		isMultivalue: true,
	})
	n.EnableGracefulRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestart",
		isMultivalue: true,
	})
	n.EnableLlgr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLlgr",
		isMultivalue: true,
	})
	n.Evpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "evpn",
		isMultivalue: true,
	})
	n.FilterEvpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterEvpn",
		isMultivalue: true,
	})
	n.FilterIpV4Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4Mpls",
		isMultivalue: true,
	})
	n.FilterIpV4MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4MplsVpn",
		isMultivalue: true,
	})
	n.FilterIpV4Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4Multicast",
		isMultivalue: true,
	})
	n.FilterIpV4MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4MulticastVpn",
		isMultivalue: true,
	})
	n.FilterIpV4Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4Unicast",
		isMultivalue: true,
	})
	n.FilterIpV6Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6Mpls",
		isMultivalue: true,
	})
	n.FilterIpV6MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6MplsVpn",
		isMultivalue: true,
	})
	n.FilterIpV6Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6Multicast",
		isMultivalue: true,
	})
	n.FilterIpV6MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6MulticastVpn",
		isMultivalue: true,
	})
	n.FilterIpV6Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6Unicast",
		isMultivalue: true,
	})
	n.FilterIpv4MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv4MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.FilterIpv4UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv4UnicastFlowSpec",
		isMultivalue: true,
	})
	n.FilterIpv6MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv6MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.FilterIpv6UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv6UnicastFlowSpec",
		isMultivalue: true,
	})
	n.FilterLinkState.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterLinkState",
		isMultivalue: true,
	})
	n.FilterLinkStateVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterLinkStateVpn",
		isMultivalue: true,
	})
	n.FilterSRTEPoliciesV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterSRTEPoliciesV4",
		isMultivalue: true,
	})
	n.FilterSRTEPoliciesV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterSRTEPoliciesV6",
		isMultivalue: true,
	})
	n.FilterVpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterVpls",
		isMultivalue: true,
	})
	n.Flap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flap",
		isMultivalue: true,
	})
	n.HoldTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdTimer",
		isMultivalue: true,
	})
	n.Ipv4MplsAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4MplsAddPathMode",
		isMultivalue: true,
	})
	n.Ipv4MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.Ipv4UnicastAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4UnicastAddPathMode",
		isMultivalue: true,
	})
	n.Ipv6MplsAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6MplsAddPathMode",
		isMultivalue: true,
	})
	n.Ipv6MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.Ipv6UnicastAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6UnicastAddPathMode",
		isMultivalue: true,
	})
	n.IrbInterfaceLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbInterfaceLabel",
		isMultivalue: true,
	})
	n.IrbIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbIpv4Address",
		isMultivalue: true,
	})
	n.KeepaliveTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepaliveTimer",
		isMultivalue: true,
	})
	n.L3VPNEncapsulationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "l3VPNEncapsulationType",
		isMultivalue: true,
	})
	n.LocalAs2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localAs2Bytes",
		isMultivalue: true,
	})
	n.LocalAs4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localAs4Bytes",
		isMultivalue: true,
	})
	n.Md5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "md5Key",
		isMultivalue: true,
	})
	n.ModeOfBfdOperations.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "modeOfBfdOperations",
		isMultivalue: true,
	})
	n.NumBgpLsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numBgpLsId",
		isMultivalue: true,
	})
	n.NumBgpLsInstanceIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numBgpLsInstanceIdentifier",
		isMultivalue: true,
	})
	n.NumBgpUpdatesGeneratedPerIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numBgpUpdatesGeneratedPerIteration",
		isMultivalue: true,
	})
	n.OperationalModel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "operationalModel",
		isMultivalue: true,
	})
	n.RestartTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "restartTime",
		isMultivalue: true,
	})
	n.RoutersMacOrIrbMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routersMacOrIrbMacAddress",
		isMultivalue: true,
	})
	n.SendIxiaSignatureWithRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendIxiaSignatureWithRoutes",
		isMultivalue: true,
	})
	n.StaleTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "staleTime",
		isMultivalue: true,
	})
	n.TcpWindowSizeInBytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpWindowSizeInBytes",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
	n.UpdateInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "updateInterval",
		isMultivalue: true,
	})
	n.UptimeInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uptimeInSec",
		isMultivalue: true,
	})
	n.VplsEnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vplsEnableNextHop",
		isMultivalue: true,
	})
	n.VplsNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vplsNextHop",
		isMultivalue: true,
	})
	n.BgpCustomAfiSafiv4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpCustomAfiSafiv4",
	})
	n.BgpEpePeerList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpEpePeerList",
	})
	n.BgpEthernetSegmentV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpEthernetSegmentV4",
	})
	n.BgpFlowSpecRangesList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpFlowSpecRangesList",
	})
	n.BgpFlowSpecRangesListV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpFlowSpecRangesListV4",
	})
	n.BgpFlowSpecRangesListV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpFlowSpecRangesListV6",
	})
	for i, o := range n.BgpIPv4EvpnEvi {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv4EvpnEvi",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv4EvpnPbb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv4EvpnPbb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv4EvpnVXLAN {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv4EvpnVXLAN",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv4EvpnVXLANVpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv4EvpnVXLANVpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv4EvpnVpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv4EvpnVpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4AdL2Vpn {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4AdL2Vpn",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4L2Site {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4L2Site",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4MVrf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4MVrf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpSRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpSRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BgpSRTEPoliciesListV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesListV4",
	})
	for i, o := range n.BgpVrf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpVrf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.FlexAlgoColorMappingTemplate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "flexAlgoColorMappingTemplate",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIpv6AdL2Vpn: BGP AD-L2VPN Configuration
type TopologyBgpIpv6AdL2Vpn struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AsNumberVplsId: VPLS ID AS Number
	AsNumberVplsId *Multivalue `json:"asNumberVplsId,omitempty"`
	// AsNumberVplsRd: Route Distinguisher AS Number
	AsNumberVplsRd *Multivalue `json:"asNumberVplsRd,omitempty"`
	// AsNumberVplsRt: Route Target AS Number
	AsNumberVplsRt *Multivalue `json:"asNumberVplsRt,omitempty"`
	// AssignedNumberVplsId: VPLS ID Assigned Number
	AssignedNumberVplsId *Multivalue `json:"assignedNumberVplsId,omitempty"`
	// AssignedNumberVplsRd: Route Distinguisher Assigned Number
	AssignedNumberVplsRd *Multivalue `json:"assignedNumberVplsRd,omitempty"`
	// AssignedNumberVplsRt: Route Target Assigned Number
	AssignedNumberVplsRt *Multivalue `json:"assignedNumberVplsRt,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ImportRDAsRT: Use RD As RT
	ImportRDAsRT *Multivalue `json:"importRDAsRT,omitempty"`
	// ImportVplsIdAsRd: Use VPLS ID As Route Distinguisher
	ImportVplsIdAsRd *Multivalue `json:"importVplsIdAsRd,omitempty"`
	// IpAddressVplsId: VPLS ID IP Address
	IpAddressVplsId *Multivalue `json:"ipAddressVplsId,omitempty"`
	// IpAddressVplsRd: Route Distinguisher IP Address
	IpAddressVplsRd *Multivalue `json:"ipAddressVplsRd,omitempty"`
	// IpAddressVplsRt: Route Target IP Address
	IpAddressVplsRt *Multivalue `json:"ipAddressVplsRt,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberVsiId: VSI ID Number
	NumberVsiId *Multivalue `json:"numberVsiId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TypeVplsId: VPLS ID Type
	TypeVplsId *Multivalue `json:"typeVplsId,omitempty"`
	// TypeVplsRd: RD Type
	TypeVplsRd *Multivalue `json:"typeVplsRd,omitempty"`
	// TypeVplsRt: RT Type
	TypeVplsRt *Multivalue `json:"typeVplsRt,omitempty"`
	// TypeVsiId: VSI ID
	TypeVsiId *Multivalue `json:"typeVsiId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv6AdL2Vpn) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv6AdL2Vpn) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv6AdL2Vpn) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv6AdL2Vpn) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumberVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumberVplsId",
		isMultivalue: true,
	})
	n.AsNumberVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumberVplsRd",
		isMultivalue: true,
	})
	n.AsNumberVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumberVplsRt",
		isMultivalue: true,
	})
	n.AssignedNumberVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumberVplsId",
		isMultivalue: true,
	})
	n.AssignedNumberVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumberVplsRd",
		isMultivalue: true,
	})
	n.AssignedNumberVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumberVplsRt",
		isMultivalue: true,
	})
	n.ImportRDAsRT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "importRDAsRT",
		isMultivalue: true,
	})
	n.ImportVplsIdAsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "importVplsIdAsRd",
		isMultivalue: true,
	})
	n.IpAddressVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressVplsId",
		isMultivalue: true,
	})
	n.IpAddressVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressVplsRd",
		isMultivalue: true,
	})
	n.IpAddressVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressVplsRt",
		isMultivalue: true,
	})
	n.NumberVsiId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberVsiId",
		isMultivalue: true,
	})
	n.TypeVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVplsId",
		isMultivalue: true,
	})
	n.TypeVplsRd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVplsRd",
		isMultivalue: true,
	})
	n.TypeVplsRt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVplsRt",
		isMultivalue: true,
	})
	n.TypeVsiId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVsiId",
		isMultivalue: true,
	})
}

// TopologyBgpIpv6L2Site: BGP IPv6 Peer L2 Site (Range) Configuration
type TopologyBgpIpv6L2Site struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DistinguishAsNumber: Distinguish AS Number
	DistinguishAsNumber *Multivalue `json:"distinguishAsNumber,omitempty"`
	// DistinguishAssignedNumber: Distinguish Assigned Number
	DistinguishAssignedNumber *Multivalue `json:"distinguishAssignedNumber,omitempty"`
	// DistinguishIpAddr: Distinguish IP Address
	DistinguishIpAddr *Multivalue `json:"distinguishIpAddr,omitempty"`
	// EnCluster: Enable Cluster
	EnCluster *Multivalue `json:"enCluster,omitempty"`
	// EnControlWord: Enable Control Word
	EnControlWord *Multivalue `json:"enControlWord,omitempty"`
	// EnSeqDelivery: Enable Sequenced Delivery
	EnSeqDelivery *Multivalue `json:"enSeqDelivery,omitempty"`
	// MtuL2Site: MTU
	MtuL2Site *Multivalue `json:"mtuL2Site,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumClusterPerL2Site: Number Of Clusters Per L2 Site

	NumClusterPerL2Site *float32 `json:"numClusterPerL2Site,omitempty"`
	// NumL2Sites: No. Of L2 Sites
	NumL2Sites *Multivalue `json:"numL2Sites,omitempty"`
	// NumLabelBlocksPerL2Site: Number Of Label Blocks Per L2 Site

	NumLabelBlocksPerL2Site *float32 `json:"numLabelBlocksPerL2Site,omitempty"`
	// SiteId: Site ID
	SiteId *Multivalue `json:"siteId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TargetAsNumber: Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddr: Target IP Address
	TargetIpAddr *Multivalue `json:"targetIpAddr,omitempty"`
	// TypeDistinguish: Distinguish Type
	TypeDistinguish *Multivalue `json:"typeDistinguish,omitempty"`
	// TypeTarget: Target Type
	TypeTarget *Multivalue `json:"typeTarget,omitempty"`
	// VpnName: VPN Name
	VpnName     *Multivalue            `json:"vpnName,omitempty"`
	ClusterList []*TopologyClusterList `json:"clusterList"`

	Connector      *TopologyConnector        `json:"connector,omitempty"`
	LabelBlockList []*TopologyLabelBlockList `json:"labelBlockList"`
	Tag            []*TopologyTag            `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv6L2Site) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv6L2Site) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv6L2Site) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv6L2Site) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DistinguishAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguishAsNumber",
		isMultivalue: true,
	})
	n.DistinguishAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguishAssignedNumber",
		isMultivalue: true,
	})
	n.DistinguishIpAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguishIpAddr",
		isMultivalue: true,
	})
	n.EnCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enCluster",
		isMultivalue: true,
	})
	n.EnControlWord.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enControlWord",
		isMultivalue: true,
	})
	n.EnSeqDelivery.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enSeqDelivery",
		isMultivalue: true,
	})
	n.MtuL2Site.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtuL2Site",
		isMultivalue: true,
	})
	n.NumL2Sites.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numL2Sites",
		isMultivalue: true,
	})
	n.SiteId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "siteId",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddr",
		isMultivalue: true,
	})
	n.TypeDistinguish.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeDistinguish",
		isMultivalue: true,
	})
	n.TypeTarget.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeTarget",
		isMultivalue: true,
	})
	n.VpnName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vpnName",
		isMultivalue: true,
	})
	for i, o := range n.ClusterList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "clusterList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.LabelBlockList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "labelBlockList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIpv6MVrf: BGP IPv6 Peer mVRF Configuration
type TopologyBgpIpv6MVrf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// IncludePmsiTunnelAttribute: Include PMSI Tunnel Attribute
	IncludePmsiTunnelAttribute *Multivalue `json:"includePmsiTunnelAttribute,omitempty"`
	// MulticastDistinguisherAs4Number: VMulticast Distinguisher AS4 Number
	MulticastDistinguisherAs4Number *Multivalue `json:"multicastDistinguisherAs4Number,omitempty"`
	// MulticastDistinguisherAsNumber: VMulticast Distinguisher AS Number
	MulticastDistinguisherAsNumber *Multivalue `json:"multicastDistinguisherAsNumber,omitempty"`
	// MulticastDistinguisherAssignedNumber: Multicast Distinguisher Assigned Number
	MulticastDistinguisherAssignedNumber *Multivalue `json:"multicastDistinguisherAssignedNumber,omitempty"`
	// MulticastDistinguisherIpAddress: Multicast Distinguisher IP Address
	MulticastDistinguisherIpAddress *Multivalue `json:"multicastDistinguisherIpAddress,omitempty"`
	// MulticastDistinguisherType: Multicast Distinguisher Type
	MulticastDistinguisherType *Multivalue `json:"multicastDistinguisherType,omitempty"`
	// MulticastTunnelType: Multicast Tunnel Type
	MulticastTunnelType *Multivalue `json:"multicastTunnelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInUmhExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInUmhExportRouteTargetList *float32 `json:"numRtInUmhExportRouteTargetList,omitempty"`
	// NumRtInUmhImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInUmhImportRouteTargetList *float32 `json:"numRtInUmhImportRouteTargetList,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SameAsExportRT: Same As Export RT Attribute

	SameAsExportRT *bool `json:"sameAsExportRT,omitempty"`
	// SameAsImportRT: Same As Import RT Attribute

	SameAsImportRT *bool `json:"sameAsImportRT,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpOrDownStreamAssignedLabel: Upstream/Downstream Assigned Label
	UpOrDownStreamAssignedLabel *Multivalue `json:"upOrDownStreamAssignedLabel,omitempty"`
	// UseUpOrDownStreamAssigneLabel: Use Upstream/Downstream Assigned Label
	UseUpOrDownStreamAssigneLabel *Multivalue                            `json:"useUpOrDownStreamAssigneLabel,omitempty"`
	BgpExportRouteTargetList      []*TopologyBgpExportRouteTargetList    `json:"bgpExportRouteTargetList"`
	BgpImportRouteTargetList      []*TopologyBgpImportRouteTargetList    `json:"bgpImportRouteTargetList"`
	BgpUmhExportRouteTargetList   []*TopologyBgpUmhExportRouteTargetList `json:"bgpUmhExportRouteTargetList"`
	BgpUmhImportRouteTargetList   []*TopologyBgpUmhImportRouteTargetList `json:"bgpUmhImportRouteTargetList"`

	Connector *TopologyConnector   `json:"connector,omitempty"`
	PnTLVList []*TopologyPnTlvList `json:"pnTLVList"`
	Tag       []*TopologyTag       `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv6MVrf) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv6MVrf) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv6MVrf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv6MVrf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.IncludePmsiTunnelAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePmsiTunnelAttribute",
		isMultivalue: true,
	})
	n.MulticastDistinguisherAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherAs4Number",
		isMultivalue: true,
	})
	n.MulticastDistinguisherAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherAsNumber",
		isMultivalue: true,
	})
	n.MulticastDistinguisherAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherAssignedNumber",
		isMultivalue: true,
	})
	n.MulticastDistinguisherIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherIpAddress",
		isMultivalue: true,
	})
	n.MulticastDistinguisherType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDistinguisherType",
		isMultivalue: true,
	})
	n.MulticastTunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastTunnelType",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.UpOrDownStreamAssignedLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upOrDownStreamAssignedLabel",
		isMultivalue: true,
	})
	n.UseUpOrDownStreamAssigneLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useUpOrDownStreamAssigneLabel",
		isMultivalue: true,
	})
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIpv6Peer: Bgp IPv6 Peer
type TopologyBgpIpv6Peer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActAsRestarted: Act as restarted
	ActAsRestarted *Multivalue `json:"actAsRestarted,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvertiseEndOfRib: Advertise End-Of-RIB
	AdvertiseEndOfRib *Multivalue `json:"advertiseEndOfRib,omitempty"`
	// AdvertiseEvpnRoutesForOtherVtep: Advertise EVPN routes for other VTEPS

	AdvertiseEvpnRoutesForOtherVtep *bool `json:"advertiseEvpnRoutesForOtherVtep,omitempty"`
	// AdvertiseSRv6SID: Advertise SRv6 SID
	AdvertiseSRv6SID *Multivalue `json:"advertiseSRv6SID,omitempty"`
	// AdvertiseTunnelEncapsulationExtendedCommunity: Advertise Tunnel Encapsulation Extended Community
	AdvertiseTunnelEncapsulationExtendedCommunity *Multivalue `json:"advertiseTunnelEncapsulationExtendedCommunity,omitempty"`
	// AlwaysIncludeTunnelEncExtCommunity: Always Include Tunnel Encapsulation Extended Community
	AlwaysIncludeTunnelEncExtCommunity *Multivalue `json:"alwaysIncludeTunnelEncExtCommunity,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Authentication: Authentication Type
	Authentication *Multivalue `json:"authentication,omitempty"`
	// AutoGenSegmentLeftValue: If enabled then Segment Left field value will be auto generated

	AutoGenSegmentLeftValue *bool `json:"autoGenSegmentLeftValue,omitempty"`
	// BgpId: BGP ID
	BgpId *Multivalue `json:"bgpId,omitempty"`
	// BgpLsAsSetMode: AS# Set Mode
	BgpLsAsSetMode *Multivalue `json:"bgpLsAsSetMode,omitempty"`
	// BgpLsEnableAsPathSegments: Enable AS Path Segments
	BgpLsEnableAsPathSegments *Multivalue `json:"bgpLsEnableAsPathSegments,omitempty"`
	// BgpLsEnableCluster: Enable Cluster
	BgpLsEnableCluster *Multivalue `json:"bgpLsEnableCluster,omitempty"`
	// BgpLsEnableExtendedCommunity: Enable Extended Community
	BgpLsEnableExtendedCommunity *Multivalue `json:"bgpLsEnableExtendedCommunity,omitempty"`
	// BgpLsNoOfASPathSegments: Number Of AS Path Segments Per Route Range

	BgpLsNoOfASPathSegments *float32 `json:"bgpLsNoOfASPathSegments,omitempty"`
	// BgpLsNoOfClusters: Number of Clusters

	BgpLsNoOfClusters *float32 `json:"bgpLsNoOfClusters,omitempty"`
	// BgpLsNoOfCommunities: Number of Communities

	BgpLsNoOfCommunities *float32 `json:"bgpLsNoOfCommunities,omitempty"`
	// BgpLsOverridePeerAsSetMode: Override Peer AS# Set Mode
	BgpLsOverridePeerAsSetMode *Multivalue `json:"bgpLsOverridePeerAsSetMode,omitempty"`
	// BgpUnnumbered: BGP Unnumbered
	BgpUnnumbered *Multivalue `json:"bgpUnnumbered,omitempty"`
	// CapabilityIpV4Mdt: IPv4 BGP MDT: AFI = 1, SAFI = 66
	CapabilityIpV4Mdt *Multivalue `json:"capabilityIpV4Mdt,omitempty"`
	// CapabilityIpV4Mpls: IPv4 MPLS
	CapabilityIpV4Mpls *Multivalue `json:"capabilityIpV4Mpls,omitempty"`
	// CapabilityIpV4MplsVpn: IPv4 MPLS VPN Capability: AFI=1,SAFI=128
	CapabilityIpV4MplsVpn *Multivalue `json:"capabilityIpV4MplsVpn,omitempty"`
	// CapabilityIpV4Multicast: IPv4 Multicast Capability: AFI=1,SAFI=2
	CapabilityIpV4Multicast *Multivalue `json:"capabilityIpV4Multicast,omitempty"`
	// CapabilityIpV4MulticastVpn: IP MCAST-VPN: AFI = 1, SAFI = 5
	CapabilityIpV4MulticastVpn *Multivalue `json:"capabilityIpV4MulticastVpn,omitempty"`
	// CapabilityIpV4Unicast: IPv4 Unicast Capability: AFI=1,SAFI=1
	CapabilityIpV4Unicast *Multivalue `json:"capabilityIpV4Unicast,omitempty"`
	// CapabilityIpV6Mpls: IPv6 MPLS
	CapabilityIpV6Mpls *Multivalue `json:"capabilityIpV6Mpls,omitempty"`
	// CapabilityIpV6MplsVpn: IPv6 MPLS VPN Capability: AFI=2,SAFI=128
	CapabilityIpV6MplsVpn *Multivalue `json:"capabilityIpV6MplsVpn,omitempty"`
	// CapabilityIpV6Multicast: IPv6 Multicast Capability: AFI=2,SAFI=2
	CapabilityIpV6Multicast *Multivalue `json:"capabilityIpV6Multicast,omitempty"`
	// CapabilityIpV6MulticastVpn: IP6 MCAST-VPN: AFI = 2, SAFI = 5
	CapabilityIpV6MulticastVpn *Multivalue `json:"capabilityIpV6MulticastVpn,omitempty"`
	// CapabilityIpV6Unicast: IPv6 Unicast Capability: AFI=2,SAFI=1
	CapabilityIpV6Unicast *Multivalue `json:"capabilityIpV6Unicast,omitempty"`
	// CapabilityIpv4MplsAddPath: IPv4 MPLS Add Path Capability

	CapabilityIpv4MplsAddPath *bool `json:"capabilityIpv4MplsAddPath,omitempty"`
	// CapabilityIpv4UnicastAddPath: Check box for IPv4 Unicast Add Path
	CapabilityIpv4UnicastAddPath *Multivalue `json:"capabilityIpv4UnicastAddPath,omitempty"`
	// CapabilityIpv6MplsAddPath: IPv6 MPLS Add Path Capability

	CapabilityIpv6MplsAddPath *bool `json:"capabilityIpv6MplsAddPath,omitempty"`
	// CapabilityIpv6UnicastAddPath: Check box for IPv6 Unicast Add Path
	CapabilityIpv6UnicastAddPath *Multivalue `json:"capabilityIpv6UnicastAddPath,omitempty"`
	// CapabilityLinkStateNonVpn: Link State Non-VPN Capability: AFI=16388,SAFI=71
	CapabilityLinkStateNonVpn *Multivalue `json:"capabilityLinkStateNonVpn,omitempty"`
	// CapabilityLinkStateVpn: Select this check box to enable Link State VPN capability on the router.AFI=16388 and SAFI=72 values will be supported.
	CapabilityLinkStateVpn *Multivalue `json:"capabilityLinkStateVpn,omitempty"`
	// CapabilityNHEncodingCapabilities: Extended Next Hop Encoding Capability which needs to be used when advertising IPv4 or VPN-IPv4 routes over IPv6 Core
	CapabilityNHEncodingCapabilities *Multivalue `json:"capabilityNHEncodingCapabilities,omitempty"`
	// CapabilityRouteConstraint: Route Constraint Capability: AFI=1,SAFI=132
	CapabilityRouteConstraint *Multivalue `json:"capabilityRouteConstraint,omitempty"`
	// CapabilityRouteRefresh: Route Refresh
	CapabilityRouteRefresh *Multivalue `json:"capabilityRouteRefresh,omitempty"`
	// CapabilitySRTEPoliciesV4: IPv4 SR TE Policy Capability: AFI=1,SAFI=73
	CapabilitySRTEPoliciesV4 *Multivalue `json:"capabilitySRTEPoliciesV4,omitempty"`
	// CapabilitySRTEPoliciesV6: IPv6 SR TE Policy Capability: AFI=2,SAFI=73
	CapabilitySRTEPoliciesV6 *Multivalue `json:"capabilitySRTEPoliciesV6,omitempty"`
	// CapabilityVpls: VPLS Capability: AFI = 25, SAFI = 65
	CapabilityVpls *Multivalue `json:"capabilityVpls,omitempty"`
	// Capabilityipv4UnicastFlowSpec: IPv4 Unicast Flow Spec Capability: AFI=1,SAFI=133
	Capabilityipv4UnicastFlowSpec *Multivalue `json:"capabilityipv4UnicastFlowSpec,omitempty"`
	// Capabilityipv6UnicastFlowSpec: IPv6 Unicast Flow Spec Capability: AFI=2,SAFI=133
	Capabilityipv6UnicastFlowSpec *Multivalue `json:"capabilityipv6UnicastFlowSpec,omitempty"`
	// ConfigureKeepaliveTimer: Configure Keepalive Timer
	ConfigureKeepaliveTimer *Multivalue `json:"configureKeepaliveTimer,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// CopyTtl: Copy TTL from customer packet to outer IPv6 header

	CopyTtl *bool `json:"copyTtl,omitempty"`
	// CustomSidType: moved to port data in bgp/srv6 Custom SID Type
	CustomSidType *Multivalue `json:"customSidType,omitempty"`
	// DiscardIxiaGeneratedRoutes: Discard Ixia Generated Routes
	DiscardIxiaGeneratedRoutes *Multivalue `json:"discardIxiaGeneratedRoutes,omitempty"`
	// DowntimeInSec: Downtime in Seconds
	DowntimeInSec *Multivalue `json:"downtimeInSec,omitempty"`
	// DutIp: DUT IP
	DutIp *Multivalue `json:"dutIp,omitempty"`
	// EnSRv6DataPlane: Ingress Peer Supports SRv6 VPN

	EnSRv6DataPlane *bool `json:"enSRv6DataPlane,omitempty"`
	// Enable4ByteAs: Enable 4-Byte AS
	Enable4ByteAs *Multivalue `json:"enable4ByteAs,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableBgpId: Enable BGP ID
	EnableBgpId *Multivalue `json:"enableBgpId,omitempty"`
	// EnableBgpIdSameAsRouterId: BGP ID Same as Router ID
	EnableBgpIdSameAsRouterId *Multivalue `json:"enableBgpIdSameAsRouterId,omitempty"`
	// EnableBgpLsCommunity: Enable Community
	EnableBgpLsCommunity *Multivalue `json:"enableBgpLsCommunity,omitempty"`
	// EnableEpeTraffic: Enable EPE Traffic

	EnableEpeTraffic *bool `json:"enableEpeTraffic,omitempty"`
	// EnableGracefulRestart: Enable Graceful Restart
	EnableGracefulRestart *Multivalue `json:"enableGracefulRestart,omitempty"`
	// EnableLlgr: Enable LLGR
	EnableLlgr *Multivalue `json:"enableLlgr,omitempty"`
	// EnableReducedEncapsulation: Enable Reduced Encapsulation in Data-Plane for SRv6

	EnableReducedEncapsulation *bool `json:"enableReducedEncapsulation,omitempty"`
	// EthernetSegmentsCountV6: Number of Ethernet Segments

	EthernetSegmentsCountV6 *float32 `json:"ethernetSegmentsCountV6,omitempty"`
	// Evpn: EVPN Capability: AFI = 25, SAFI = 70
	Evpn *Multivalue `json:"evpn,omitempty"`
	// FilterEvpn: Check box for EVPN filter
	FilterEvpn *Multivalue `json:"filterEvpn,omitempty"`
	// FilterIpV4Mpls: Filter IPv4 MPLS
	FilterIpV4Mpls *Multivalue `json:"filterIpV4Mpls,omitempty"`
	// FilterIpV4MplsVpn: Filter IPv4 MPLS VPN
	FilterIpV4MplsVpn *Multivalue `json:"filterIpV4MplsVpn,omitempty"`
	// FilterIpV4Multicast: Filter IPv4 Multicast
	FilterIpV4Multicast *Multivalue `json:"filterIpV4Multicast,omitempty"`
	// FilterIpV4MulticastVpn: Filter IPv4 Multicast VPN
	FilterIpV4MulticastVpn *Multivalue `json:"filterIpV4MulticastVpn,omitempty"`
	// FilterIpV4Unicast: Filter IPv4 Unicast
	FilterIpV4Unicast *Multivalue `json:"filterIpV4Unicast,omitempty"`
	// FilterIpV6Mpls: Filter IPv6 MPLS
	FilterIpV6Mpls *Multivalue `json:"filterIpV6Mpls,omitempty"`
	// FilterIpV6MplsVpn: Filter IPv6 MPLS VPN
	FilterIpV6MplsVpn *Multivalue `json:"filterIpV6MplsVpn,omitempty"`
	// FilterIpV6Multicast: Filter IPv6 Multicast
	FilterIpV6Multicast *Multivalue `json:"filterIpV6Multicast,omitempty"`
	// FilterIpV6MulticastVpn: Filter IPv6 Multicast VPN
	FilterIpV6MulticastVpn *Multivalue `json:"filterIpV6MulticastVpn,omitempty"`
	// FilterIpV6Unicast: Filter IPv6 Unicast
	FilterIpV6Unicast *Multivalue `json:"filterIpV6Unicast,omitempty"`
	// FilterIpv4MulticastBgpMplsVpn: Check box for IPv4 Multicast BGP/MPLS VPN filter
	FilterIpv4MulticastBgpMplsVpn *Multivalue `json:"filterIpv4MulticastBgpMplsVpn,omitempty"`
	// FilterIpv4UnicastFlowSpec: Filter IPv4 Unicast Flow Spec
	FilterIpv4UnicastFlowSpec *Multivalue `json:"filterIpv4UnicastFlowSpec,omitempty"`
	// FilterIpv6MulticastBgpMplsVpn: Check box for IPv6 Multicast BGP/MPLS VPN filter
	FilterIpv6MulticastBgpMplsVpn *Multivalue `json:"filterIpv6MulticastBgpMplsVpn,omitempty"`
	// FilterIpv6UnicastFlowSpec: Filter IPv6 Unicast Flow Spec
	FilterIpv6UnicastFlowSpec *Multivalue `json:"filterIpv6UnicastFlowSpec,omitempty"`
	// FilterLinkState: Filter Link State
	FilterLinkState *Multivalue `json:"filterLinkState,omitempty"`
	// FilterLinkStateVpn: Select this check box to store incoming BGP LS VPN route info.
	FilterLinkStateVpn *Multivalue `json:"filterLinkStateVpn,omitempty"`
	// FilterSRTEPoliciesV4: Enable IPv4 SR TE Policy Filter
	FilterSRTEPoliciesV4 *Multivalue `json:"filterSRTEPoliciesV4,omitempty"`
	// FilterSRTEPoliciesV6: Enable IPv6 SR TE Policy Filter
	FilterSRTEPoliciesV6 *Multivalue `json:"filterSRTEPoliciesV6,omitempty"`
	// FilterVpls: Filter VPLS
	FilterVpls *Multivalue `json:"filterVpls,omitempty"`
	// Flap: Flap
	Flap *Multivalue `json:"flap,omitempty"`
	// HoldTimer: Hold Timer
	HoldTimer *Multivalue `json:"holdTimer,omitempty"`
	// IpVrfToIpVrfType: IP-VRF-to-IP-VRF Model Type

	IpVrfToIpVrfType *string `json:"ipVrfToIpVrfType,omitempty"`
	// Ipv4MplsAddPathMode: IPv4 MPLS Add Path Mode
	Ipv4MplsAddPathMode *Multivalue `json:"ipv4MplsAddPathMode,omitempty"`
	// Ipv4MplsCapability: IPv4 MPLS Capability: AFI=1, SAFI=4

	Ipv4MplsCapability *bool `json:"ipv4MplsCapability,omitempty"`
	// Ipv4MulticastBgpMplsVpn: IP Multicast for BGP/MPLS IP VPN (UMH): AFI = 1, SAFI = 129
	Ipv4MulticastBgpMplsVpn *Multivalue `json:"ipv4MulticastBgpMplsVpn,omitempty"`
	// Ipv4MultipleMplsLabelsCapability: IPv4 Multiple MPLS Labels Capability: AFI=1, SAFI=4

	Ipv4MultipleMplsLabelsCapability *bool `json:"ipv4MultipleMplsLabelsCapability,omitempty"`
	// Ipv4UnicastAddPathMode: IPv4 Unicast Add Path Mode
	Ipv4UnicastAddPathMode *Multivalue `json:"ipv4UnicastAddPathMode,omitempty"`
	// Ipv6MplsAddPathMode: IPv6 MPLS Add Path Mode
	Ipv6MplsAddPathMode *Multivalue `json:"ipv6MplsAddPathMode,omitempty"`
	// Ipv6MplsCapability: IPv6 MPLS Capability: AFI=2, SAFI=4

	Ipv6MplsCapability *bool `json:"ipv6MplsCapability,omitempty"`
	// Ipv6MulticastBgpMplsVpn: IP6 Multicast for BGP/MPLS IP VPN (UMH): AFI = 2, SAFI = 129
	Ipv6MulticastBgpMplsVpn *Multivalue `json:"ipv6MulticastBgpMplsVpn,omitempty"`
	// Ipv6MultipleMplsLabelsCapability: IPv6 Multiple MPLS Labels Capability: AFI=2, SAFI=4

	Ipv6MultipleMplsLabelsCapability *bool `json:"ipv6MultipleMplsLabelsCapability,omitempty"`
	// Ipv6UnicastAddPathMode: IPv6 Unicast Add Path Mode
	Ipv6UnicastAddPathMode *Multivalue `json:"ipv6UnicastAddPathMode,omitempty"`
	// IrbInterfaceLabel: Label to be used for Route Type 2 carrying IRB MAC and/or IRB IP in Route Type 2
	IrbInterfaceLabel *Multivalue `json:"irbInterfaceLabel,omitempty"`
	// IrbIpv6Address: IRB IPv6 Address
	IrbIpv6Address *Multivalue `json:"irbIpv6Address,omitempty"`
	// KeepaliveTimer: Keepalive Timer
	KeepaliveTimer *Multivalue `json:"keepaliveTimer,omitempty"`
	// L3VPNEncapsulationType: L3VPN Traffic Encapsulation
	L3VPNEncapsulationType *Multivalue `json:"l3VPNEncapsulationType,omitempty"`
	// LocalAs2Bytes: Local AS# (2-Bytes)
	LocalAs2Bytes *Multivalue `json:"localAs2Bytes,omitempty"`
	// LocalAs4Bytes: Local AS# (4-Bytes)
	LocalAs4Bytes *Multivalue `json:"localAs4Bytes,omitempty"`
	// MaxSidPerSrh: Max number of SIDs a SRH can have

	MaxSidPerSrh *float32 `json:"maxSidPerSrh,omitempty"`
	// Md5Key: MD5 Key
	Md5Key *Multivalue `json:"md5Key,omitempty"`
	// ModeOfBfdOperations: Mode of BFD Operations
	ModeOfBfdOperations *Multivalue `json:"modeOfBfdOperations,omitempty"`
	// MplsLabelsCountForIpv4MplsRoute: MPLS Labels Count For IPv4 MPLS Route

	MplsLabelsCountForIpv4MplsRoute *float32 `json:"mplsLabelsCountForIpv4MplsRoute,omitempty"`
	// MplsLabelsCountForIpv6MplsRoute: MPLS Labels Count For IPv6 MPLS Route

	MplsLabelsCountForIpv6MplsRoute *float32 `json:"mplsLabelsCountForIpv6MplsRoute,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfEpePeers: Number of EPE Peers

	NoOfEpePeers *float32 `json:"noOfEpePeers,omitempty"`
	// NoOfExtendedCommunities: Number of Extended Communities

	NoOfExtendedCommunities *float32 `json:"noOfExtendedCommunities,omitempty"`
	// NoOfUserDefinedAfiSafi: Count of User defined AFI SAFI

	NoOfUserDefinedAfiSafi *float32 `json:"noOfUserDefinedAfiSafi,omitempty"`
	// NumBgpLsId: BGP LS Instance ID
	NumBgpLsId *Multivalue `json:"numBgpLsId,omitempty"`
	// NumBgpLsInstanceIdentifier: IGP Multi instance unique identifier. 0 is default single-instance IGP. (e.g. for OSPFv3 it is possible to separately run 4 instances of OSPFv3 with peer, one advertising v4 only, another v6 only and other 2 mcast v4 and v6 respectively) .
	NumBgpLsInstanceIdentifier *Multivalue `json:"numBgpLsInstanceIdentifier,omitempty"`
	// NumBgpUpdatesGeneratedPerIteration: Num BGP Updates Generated Per Iteration
	NumBgpUpdatesGeneratedPerIteration *Multivalue `json:"numBgpUpdatesGeneratedPerIteration,omitempty"`
	// NumberColorFlexAlgoMapping: Number of Color/Flex Algo Mapping Entries

	NumberColorFlexAlgoMapping *float32 `json:"numberColorFlexAlgoMapping,omitempty"`
	// NumberFlowSpecRangeV4: Number of IPv4 Flow Spec Ranges

	NumberFlowSpecRangeV4 *float32 `json:"numberFlowSpecRangeV4,omitempty"`
	// NumberFlowSpecRangeV6: Number of IPv6 Flow Spec Ranges

	NumberFlowSpecRangeV6 *float32 `json:"numberFlowSpecRangeV6,omitempty"`
	// NumberSRTEPolicies: Count of SR TE Policies

	NumberSRTEPolicies *float32 `json:"numberSRTEPolicies,omitempty"`
	// OperationalModel: Operational Model
	OperationalModel *Multivalue `json:"operationalModel,omitempty"`
	// RestartTime: Restart Time
	RestartTime *Multivalue `json:"restartTime,omitempty"`
	// RoutersMacOrIrbMacAddress: Router's MAC/IRB MAC Address
	RoutersMacOrIrbMacAddress *Multivalue `json:"routersMacOrIrbMacAddress,omitempty"`
	// SRGBRangeCount: SRGB Range Count

	SRGBRangeCount *float32 `json:"sRGBRangeCount,omitempty"`
	// SegmentLeftValue: Segment Left value to be used in top SRH. This zero index based value start from egress node.

	SegmentLeftValue *float32 `json:"segmentLeftValue,omitempty"`
	// SendIxiaSignatureWithRoutes: Send Ixia Signature With Routes
	SendIxiaSignatureWithRoutes *Multivalue `json:"sendIxiaSignatureWithRoutes,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags Value
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// Srv6Ttl: TTL value to be used in outer IPv6 header

	Srv6Ttl *float32 `json:"srv6Ttl,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StaleTime: Stale Time/ LLGR Stale Time
	StaleTime *Multivalue `json:"staleTime,omitempty"`
	// TcpWindowSizeInBytes: TCP Window Size (in bytes)
	TcpWindowSizeInBytes *Multivalue `json:"tcpWindowSizeInBytes,omitempty"`
	// Ttl: TTL
	Ttl *Multivalue `json:"ttl,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// UdpPortEndValue: UDP Port End Value

	UdpPortEndValue *float32 `json:"udpPortEndValue,omitempty"`
	// UdpPortStartValue: UDP Port Start Value

	UdpPortStartValue *float32 `json:"udpPortStartValue,omitempty"`
	// UpdateInterval: Update Interval
	UpdateInterval *Multivalue `json:"updateInterval,omitempty"`
	// UptimeInSec: Uptime in Seconds
	UptimeInSec *Multivalue `json:"uptimeInSec,omitempty"`
	// UseGatewayAsDutIp: Use Gateway as DUT IP
	UseGatewayAsDutIp *Multivalue `json:"useGatewayAsDutIp,omitempty"`
	// UseStaticPolicy: If enabled then SRTE policy will be advertised

	UseStaticPolicy *bool `json:"useStaticPolicy,omitempty"`
	// VplsEnableNextHop: VPLS Enable Next Hop
	VplsEnableNextHop *Multivalue `json:"vplsEnableNextHop,omitempty"`
	// VplsNextHop: VPLS Next Hop
	VplsNextHop *Multivalue `json:"vplsNextHop,omitempty"`

	BgpCustomAfiSafiv6 *TopologyBgpCustomAfiSafiv6 `json:"bgpCustomAfiSafiv6,omitempty"`

	BgpEpePeerList *TopologyBgpEpePeerList `json:"bgpEpePeerList,omitempty"`

	BgpEthernetSegmentV6 *TopologyBgpEthernetSegmentV6 `json:"bgpEthernetSegmentV6,omitempty"`

	BgpFlowSpecRangesList *TopologyBgpIpv6PeerBgpFlowSpecRangesList `json:"bgpFlowSpecRangesList,omitempty"`

	BgpFlowSpecRangesListV4 *TopologyBgpFlowSpecRangesListV4 `json:"bgpFlowSpecRangesListV4,omitempty"`

	BgpFlowSpecRangesListV6      *TopologyBgpFlowSpecRangesListV6        `json:"bgpFlowSpecRangesListV6,omitempty"`
	BgpIPv6EvpnEvi               []*TopologyBgpIPv6EvpnEvi               `json:"bgpIPv6EvpnEvi"`
	BgpIPv6EvpnPbb               []*TopologyBgpIPv6EvpnPbb               `json:"bgpIPv6EvpnPbb"`
	BgpIPv6EvpnVXLAN             []*TopologyBgpIPv6EvpnVxlan             `json:"bgpIPv6EvpnVXLAN"`
	BgpIPv6EvpnVXLANVpws         []*TopologyBgpIPv6EvpnVxlanVpws         `json:"bgpIPv6EvpnVXLANVpws"`
	BgpIPv6EvpnVpws              []*TopologyBgpIPv6EvpnVpws              `json:"bgpIPv6EvpnVpws"`
	BgpIpv6AdL2Vpn               []*TopologyBgpIpv6AdL2Vpn               `json:"bgpIpv6AdL2Vpn"`
	BgpIpv6L2Site                []*TopologyBgpIpv6L2Site                `json:"bgpIpv6L2Site"`
	BgpIpv6MVrf                  []*TopologyBgpIpv6MVrf                  `json:"bgpIpv6MVrf"`
	BgpLsAsPathSegmentList       []*TopologyBgpLsAsPathSegmentList       `json:"bgpLsAsPathSegmentList"`
	BgpLsClusterIdList           []*TopologyBgpLsClusterIdList           `json:"bgpLsClusterIdList"`
	BgpLsCommunitiesList         []*TopologyBgpLsCommunitiesList         `json:"bgpLsCommunitiesList"`
	BgpLsExtendedCommunitiesList []*TopologyBgpLsExtendedCommunitiesList `json:"bgpLsExtendedCommunitiesList"`
	BgpSRGBRangeSubObjectsList   []*TopologyBgpSrgbRangeSubObjectsList   `json:"bgpSRGBRangeSubObjectsList"`

	BgpSRTEPoliciesListV6 *TopologyBgpSrtePoliciesListV6 `json:"bgpSRTEPoliciesListV6,omitempty"`
	BgpV6Vrf              []*TopologyBgpV6Vrf            `json:"bgpV6Vrf"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	FlexAlgoColorMappingTemplate *TopologyFlexAlgoColorMappingTemplate `json:"flexAlgoColorMappingTemplate,omitempty"`
	LearnedInfo                  []*TopologyLearnedInfo                `json:"learnedInfo"`
	TlvProfile                   []*TopologyTlvProfile                 `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv6Peer) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv6Peer) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv6Peer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv6Peer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActAsRestarted.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actAsRestarted",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvertiseEndOfRib.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseEndOfRib",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SID",
		isMultivalue: true,
	})
	n.AdvertiseTunnelEncapsulationExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseTunnelEncapsulationExtendedCommunity",
		isMultivalue: true,
	})
	n.AlwaysIncludeTunnelEncExtCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "alwaysIncludeTunnelEncExtCommunity",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.BgpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpId",
		isMultivalue: true,
	})
	n.BgpLsAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsAsSetMode",
		isMultivalue: true,
	})
	n.BgpLsEnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsEnableAsPathSegments",
		isMultivalue: true,
	})
	n.BgpLsEnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsEnableCluster",
		isMultivalue: true,
	})
	n.BgpLsEnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsEnableExtendedCommunity",
		isMultivalue: true,
	})
	n.BgpLsOverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpLsOverridePeerAsSetMode",
		isMultivalue: true,
	})
	n.BgpUnnumbered.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bgpUnnumbered",
		isMultivalue: true,
	})
	n.CapabilityIpV4Mdt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Mdt",
		isMultivalue: true,
	})
	n.CapabilityIpV4Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Mpls",
		isMultivalue: true,
	})
	n.CapabilityIpV4MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4MplsVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV4Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Multicast",
		isMultivalue: true,
	})
	n.CapabilityIpV4MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4MulticastVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV4Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV4Unicast",
		isMultivalue: true,
	})
	n.CapabilityIpV6Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6Mpls",
		isMultivalue: true,
	})
	n.CapabilityIpV6MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6MplsVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV6Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6Multicast",
		isMultivalue: true,
	})
	n.CapabilityIpV6MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6MulticastVpn",
		isMultivalue: true,
	})
	n.CapabilityIpV6Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpV6Unicast",
		isMultivalue: true,
	})
	n.CapabilityIpv4UnicastAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpv4UnicastAddPath",
		isMultivalue: true,
	})
	n.CapabilityIpv6UnicastAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityIpv6UnicastAddPath",
		isMultivalue: true,
	})
	n.CapabilityLinkStateNonVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityLinkStateNonVpn",
		isMultivalue: true,
	})
	n.CapabilityLinkStateVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityLinkStateVpn",
		isMultivalue: true,
	})
	n.CapabilityNHEncodingCapabilities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityNHEncodingCapabilities",
		isMultivalue: true,
	})
	n.CapabilityRouteConstraint.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityRouteConstraint",
		isMultivalue: true,
	})
	n.CapabilityRouteRefresh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityRouteRefresh",
		isMultivalue: true,
	})
	n.CapabilitySRTEPoliciesV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitySRTEPoliciesV4",
		isMultivalue: true,
	})
	n.CapabilitySRTEPoliciesV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitySRTEPoliciesV6",
		isMultivalue: true,
	})
	n.CapabilityVpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityVpls",
		isMultivalue: true,
	})
	n.Capabilityipv4UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityipv4UnicastFlowSpec",
		isMultivalue: true,
	})
	n.Capabilityipv6UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityipv6UnicastFlowSpec",
		isMultivalue: true,
	})
	n.ConfigureKeepaliveTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureKeepaliveTimer",
		isMultivalue: true,
	})
	n.CustomSidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSidType",
		isMultivalue: true,
	})
	n.DiscardIxiaGeneratedRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardIxiaGeneratedRoutes",
		isMultivalue: true,
	})
	n.DowntimeInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downtimeInSec",
		isMultivalue: true,
	})
	n.DutIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutIp",
		isMultivalue: true,
	})
	n.Enable4ByteAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable4ByteAs",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableBgpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBgpId",
		isMultivalue: true,
	})
	n.EnableBgpIdSameAsRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBgpIdSameAsRouterId",
		isMultivalue: true,
	})
	n.EnableBgpLsCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBgpLsCommunity",
		isMultivalue: true,
	})
	n.EnableGracefulRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestart",
		isMultivalue: true,
	})
	n.EnableLlgr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLlgr",
		isMultivalue: true,
	})
	n.Evpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "evpn",
		isMultivalue: true,
	})
	n.FilterEvpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterEvpn",
		isMultivalue: true,
	})
	n.FilterIpV4Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4Mpls",
		isMultivalue: true,
	})
	n.FilterIpV4MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4MplsVpn",
		isMultivalue: true,
	})
	n.FilterIpV4Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4Multicast",
		isMultivalue: true,
	})
	n.FilterIpV4MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4MulticastVpn",
		isMultivalue: true,
	})
	n.FilterIpV4Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV4Unicast",
		isMultivalue: true,
	})
	n.FilterIpV6Mpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6Mpls",
		isMultivalue: true,
	})
	n.FilterIpV6MplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6MplsVpn",
		isMultivalue: true,
	})
	n.FilterIpV6Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6Multicast",
		isMultivalue: true,
	})
	n.FilterIpV6MulticastVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6MulticastVpn",
		isMultivalue: true,
	})
	n.FilterIpV6Unicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpV6Unicast",
		isMultivalue: true,
	})
	n.FilterIpv4MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv4MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.FilterIpv4UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv4UnicastFlowSpec",
		isMultivalue: true,
	})
	n.FilterIpv6MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv6MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.FilterIpv6UnicastFlowSpec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterIpv6UnicastFlowSpec",
		isMultivalue: true,
	})
	n.FilterLinkState.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterLinkState",
		isMultivalue: true,
	})
	n.FilterLinkStateVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterLinkStateVpn",
		isMultivalue: true,
	})
	n.FilterSRTEPoliciesV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterSRTEPoliciesV4",
		isMultivalue: true,
	})
	n.FilterSRTEPoliciesV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterSRTEPoliciesV6",
		isMultivalue: true,
	})
	n.FilterVpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterVpls",
		isMultivalue: true,
	})
	n.Flap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flap",
		isMultivalue: true,
	})
	n.HoldTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdTimer",
		isMultivalue: true,
	})
	n.Ipv4MplsAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4MplsAddPathMode",
		isMultivalue: true,
	})
	n.Ipv4MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.Ipv4UnicastAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4UnicastAddPathMode",
		isMultivalue: true,
	})
	n.Ipv6MplsAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6MplsAddPathMode",
		isMultivalue: true,
	})
	n.Ipv6MulticastBgpMplsVpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6MulticastBgpMplsVpn",
		isMultivalue: true,
	})
	n.Ipv6UnicastAddPathMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6UnicastAddPathMode",
		isMultivalue: true,
	})
	n.IrbInterfaceLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbInterfaceLabel",
		isMultivalue: true,
	})
	n.IrbIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "irbIpv6Address",
		isMultivalue: true,
	})
	n.KeepaliveTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepaliveTimer",
		isMultivalue: true,
	})
	n.L3VPNEncapsulationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "l3VPNEncapsulationType",
		isMultivalue: true,
	})
	n.LocalAs2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localAs2Bytes",
		isMultivalue: true,
	})
	n.LocalAs4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localAs4Bytes",
		isMultivalue: true,
	})
	n.Md5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "md5Key",
		isMultivalue: true,
	})
	n.ModeOfBfdOperations.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "modeOfBfdOperations",
		isMultivalue: true,
	})
	n.NumBgpLsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numBgpLsId",
		isMultivalue: true,
	})
	n.NumBgpLsInstanceIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numBgpLsInstanceIdentifier",
		isMultivalue: true,
	})
	n.NumBgpUpdatesGeneratedPerIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numBgpUpdatesGeneratedPerIteration",
		isMultivalue: true,
	})
	n.OperationalModel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "operationalModel",
		isMultivalue: true,
	})
	n.RestartTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "restartTime",
		isMultivalue: true,
	})
	n.RoutersMacOrIrbMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routersMacOrIrbMacAddress",
		isMultivalue: true,
	})
	n.SendIxiaSignatureWithRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendIxiaSignatureWithRoutes",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.StaleTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "staleTime",
		isMultivalue: true,
	})
	n.TcpWindowSizeInBytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpWindowSizeInBytes",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
	n.UpdateInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "updateInterval",
		isMultivalue: true,
	})
	n.UptimeInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uptimeInSec",
		isMultivalue: true,
	})
	n.UseGatewayAsDutIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useGatewayAsDutIp",
		isMultivalue: true,
	})
	n.VplsEnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vplsEnableNextHop",
		isMultivalue: true,
	})
	n.VplsNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vplsNextHop",
		isMultivalue: true,
	})
	n.BgpCustomAfiSafiv6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpCustomAfiSafiv6",
	})
	n.BgpEpePeerList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpEpePeerList",
	})
	n.BgpEthernetSegmentV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpEthernetSegmentV6",
	})
	n.BgpFlowSpecRangesList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpFlowSpecRangesList",
	})
	n.BgpFlowSpecRangesListV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpFlowSpecRangesListV4",
	})
	n.BgpFlowSpecRangesListV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpFlowSpecRangesListV6",
	})
	for i, o := range n.BgpIPv6EvpnEvi {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv6EvpnEvi",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv6EvpnPbb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv6EvpnPbb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv6EvpnVXLAN {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv6EvpnVXLAN",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv6EvpnVXLANVpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv6EvpnVXLANVpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIPv6EvpnVpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPv6EvpnVpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6AdL2Vpn {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6AdL2Vpn",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6L2Site {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6L2Site",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6MVrf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6MVrf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLsExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLsExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpSRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpSRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BgpSRTEPoliciesListV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesListV6",
	})
	for i, o := range n.BgpV6Vrf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpV6Vrf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.FlexAlgoColorMappingTemplate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "flexAlgoColorMappingTemplate",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpIpv6PeerBgpFlowSpecRangesList: Flow Spec
type TopologyBgpIpv6PeerBgpFlowSpecRangesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsNumber2Bytes: AS 2-Bytes
	AsNumber2Bytes *Multivalue `json:"asNumber2Bytes,omitempty"`
	// AsNumber4Bytes: AS 4-Bytes
	AsNumber4Bytes *Multivalue `json:"asNumber4Bytes,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// AssignedNumber2Bytes: Assigned Number(2 Octets)
	AssignedNumber2Bytes *Multivalue `json:"assignedNumber2Bytes,omitempty"`
	// AssignedNumber4Bytes: Assigned Number(4 Octets)
	AssignedNumber4Bytes *Multivalue `json:"assignedNumber4Bytes,omitempty"`
	// DestPortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	DestPortMatch *Multivalue `json:"destPortMatch,omitempty"`
	// DestPrefixLengthV6: Destination Prefix Length (bits) - Controlled by Enable Destination Prefix
	DestPrefixLengthV6 *Multivalue `json:"destPrefixLengthV6,omitempty"`
	// DestPrefixOffset: Destination Prefix Offset (bits) - Controlled by Enable Destination Prefix
	DestPrefixOffset *Multivalue `json:"destPrefixOffset,omitempty"`
	// DestPrefixV6: Destination Prefix - Controlled by Enable Destination Prefix
	DestPrefixV6 *Multivalue `json:"destPrefixV6,omitempty"`
	// DscpMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 10, 10-20, <10, 10&20, 10|20-30&!25|>=50 etc Keep Empty If Not Requried
	DscpMatch *Multivalue `json:"dscpMatch,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableDestPrefixV6: Click to Enable Destination Prefix and Prefix Length
	EnableDestPrefixV6 *Multivalue `json:"enableDestPrefixV6,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRedirect: Enable Redirect
	EnableRedirect *Multivalue `json:"enableRedirect,omitempty"`
	// EnableReirectIPv6: Enable Redirect-IPv6
	EnableReirectIPv6 *Multivalue `json:"enableReirectIPv6,omitempty"`
	// EnableSourcePrefixV6: Click to Enable Source Prefix and Prefix Length
	EnableSourcePrefixV6 *Multivalue `json:"enableSourcePrefixV6,omitempty"`
	// EnableTrafficAction: Enable Traffic Action
	EnableTrafficAction *Multivalue `json:"enableTrafficAction,omitempty"`
	// EnableTrafficMarketing: Enable Traffic Marketing
	EnableTrafficMarketing *Multivalue `json:"enableTrafficMarketing,omitempty"`
	// EnableTrafficMarking: Enable Traffic Marking
	EnableTrafficMarking *Multivalue `json:"enableTrafficMarking,omitempty"`
	// EnableTrafficRate: Enable Traffic Rate
	EnableTrafficRate *Multivalue `json:"enableTrafficRate,omitempty"`
	// FlowLabel: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	FlowLabel *Multivalue `json:"flowLabel,omitempty"`
	// FlowSpecName: Flow Spec Name
	FlowSpecName *Multivalue `json:"flowSpecName,omitempty"`
	// FragmentMatchV6: Supported Flags: lf,ff,isf join different matchcriteria using | or & join flags using | (bitwise or) Eg. (lf), (lf|ff|isf), (not)(lf|isf), (not|match)(ff)|(isf|lf) Keep Empty If Not Requried
	FragmentMatchV6 *Multivalue `json:"fragmentMatchV6,omitempty"`
	// IcmpCodeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpCodeMatch *Multivalue `json:"icmpCodeMatch,omitempty"`
	// IcmpTypeMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	IcmpTypeMatch *Multivalue `json:"icmpTypeMatch,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// IpPacketLenMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	IpPacketLenMatch *Multivalue `json:"ipPacketLenMatch,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextHeader: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-220&!210|>=230 etc Keep Empty If Not Requried
	NextHeader *Multivalue `json:"nextHeader,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// NumberOfFlows: Number of Flows in a Flow Range
	NumberOfFlows *Multivalue `json:"numberOfFlows,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried This Field Matches Source OR Destination TCP/UDP Ports
	PortMatch *Multivalue `json:"portMatch,omitempty"`
	// RedirectCBit: C Bit
	RedirectCBit *Multivalue `json:"redirectCBit,omitempty"`
	// RedirectExtCommunityType: Extended Community Type
	RedirectExtCommunityType *Multivalue `json:"redirectExtCommunityType,omitempty"`
	// RedirectIPv6: Redirect-IPv6
	RedirectIPv6 *Multivalue `json:"redirectIPv6,omitempty"`
	// Redirectnexthop: Next Hop
	Redirectnexthop *Multivalue `json:"redirectnexthop,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourcePortMatch: Supported Formats: value value1-value2 >value (!, >, <, >=, <= supported) join using | or & Eg. 100, 100-200, <100, 100&200, 100|200-300&!250|>=500 etc Keep Empty If Not Requried
	SourcePortMatch *Multivalue `json:"sourcePortMatch,omitempty"`
	// SourcePrefixLengthV6: Source Prefix Length (bits) - Controlled by Enable Source Prefix
	SourcePrefixLengthV6 *Multivalue `json:"sourcePrefixLengthV6,omitempty"`
	// SourcePrefixV6: Source Prefix - Controlled by Enable Source Prefix
	SourcePrefixV6 *Multivalue `json:"sourcePrefixV6,omitempty"`
	// SrcPrefixOffset: Source Prefix Offset (bits) - Controlled by Enable Source Prefix
	SrcPrefixOffset *Multivalue `json:"srcPrefixOffset,omitempty"`
	// TcpFlagsMatch: Supported Flags: ns,cwr,ece,urg,ack,psh,rst,syn,fin join different matchcriteria using | or & join flags using | (bitwise or) Eg. (cwr), (ece|urg|psh|syn), (not)(cwr|syn), (not|match)(ece|psh)|(psh|rst)&(not)(ns) Keep Empty If Not Requried
	TcpFlagsMatch *Multivalue `json:"tcpFlagsMatch,omitempty"`
	// TerminalAction: Terminal Action
	TerminalAction *Multivalue `json:"terminalAction,omitempty"`
	// TrafficActionSample: Sample
	TrafficActionSample *Multivalue `json:"trafficActionSample,omitempty"`
	// TrafficDscp: DSCP
	TrafficDscp *Multivalue `json:"trafficDscp,omitempty"`
	// TrafficRate: Traffic Rate (Bytes/s)
	TrafficRate                *Multivalue                           `json:"trafficRate,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`
	BgpLargeCommunitiesList    []*TopologyBgpLargeCommunitiesList    `json:"bgpLargeCommunitiesList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpIpv6PeerBgpFlowSpecRangesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpIpv6PeerBgpFlowSpecRangesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpIpv6PeerBgpFlowSpecRangesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpIpv6PeerBgpFlowSpecRangesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber2Bytes",
		isMultivalue: true,
	})
	n.AsNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber4Bytes",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.AssignedNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber2Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber4Bytes",
		isMultivalue: true,
	})
	n.DestPortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPortMatch",
		isMultivalue: true,
	})
	n.DestPrefixLengthV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixLengthV6",
		isMultivalue: true,
	})
	n.DestPrefixOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixOffset",
		isMultivalue: true,
	})
	n.DestPrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destPrefixV6",
		isMultivalue: true,
	})
	n.DscpMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dscpMatch",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableDestPrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDestPrefixV6",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRedirect.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRedirect",
		isMultivalue: true,
	})
	n.EnableReirectIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableReirectIPv6",
		isMultivalue: true,
	})
	n.EnableSourcePrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSourcePrefixV6",
		isMultivalue: true,
	})
	n.EnableTrafficAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficAction",
		isMultivalue: true,
	})
	n.EnableTrafficMarketing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarketing",
		isMultivalue: true,
	})
	n.EnableTrafficMarking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficMarking",
		isMultivalue: true,
	})
	n.EnableTrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTrafficRate",
		isMultivalue: true,
	})
	n.FlowLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowLabel",
		isMultivalue: true,
	})
	n.FlowSpecName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowSpecName",
		isMultivalue: true,
	})
	n.FragmentMatchV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fragmentMatchV6",
		isMultivalue: true,
	})
	n.IcmpCodeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpCodeMatch",
		isMultivalue: true,
	})
	n.IcmpTypeMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "icmpTypeMatch",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.IpPacketLenMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipPacketLenMatch",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NextHeader.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHeader",
		isMultivalue: true,
	})
	n.NumberOfFlows.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfFlows",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portMatch",
		isMultivalue: true,
	})
	n.RedirectCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectCBit",
		isMultivalue: true,
	})
	n.RedirectExtCommunityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectExtCommunityType",
		isMultivalue: true,
	})
	n.RedirectIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectIPv6",
		isMultivalue: true,
	})
	n.Redirectnexthop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redirectnexthop",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourcePortMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePortMatch",
		isMultivalue: true,
	})
	n.SourcePrefixLengthV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixLengthV6",
		isMultivalue: true,
	})
	n.SourcePrefixV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourcePrefixV6",
		isMultivalue: true,
	})
	n.SrcPrefixOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcPrefixOffset",
		isMultivalue: true,
	})
	n.TcpFlagsMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpFlagsMatch",
		isMultivalue: true,
	})
	n.TerminalAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "terminalAction",
		isMultivalue: true,
	})
	n.TrafficActionSample.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficActionSample",
		isMultivalue: true,
	})
	n.TrafficDscp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficDscp",
		isMultivalue: true,
	})
	n.TrafficRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficRate",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpL3VniExportRouteTargetList: Export RouteTarget
type TopologyBgpL3VniExportRouteTargetList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetAs4Number: Export Route Target AS4 Number
	TargetAs4Number *Multivalue `json:"targetAs4Number,omitempty"`
	// TargetAsNumber: Export Route Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Export Route Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddress: Export Route Target IP Address
	TargetIpAddress *Multivalue `json:"targetIpAddress,omitempty"`
	// TargetType: Export Route Target Type
	TargetType *Multivalue `json:"targetType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpL3VniExportRouteTargetList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpL3VniExportRouteTargetList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpL3VniExportRouteTargetList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpL3VniExportRouteTargetList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.TargetAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAs4Number",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddress",
		isMultivalue: true,
	})
	n.TargetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetType",
		isMultivalue: true,
	})
}

// TopologyBgpL3VniImportRouteTargetList: Import RouteTarget
type TopologyBgpL3VniImportRouteTargetList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetAs4Number: Import Route Target AS4 Number
	TargetAs4Number *Multivalue `json:"targetAs4Number,omitempty"`
	// TargetAsNumber: Import Route Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Import Route Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddress: Import Route Target IP Address
	TargetIpAddress *Multivalue `json:"targetIpAddress,omitempty"`
	// TargetType: Import Route Target Type
	TargetType *Multivalue `json:"targetType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpL3VniImportRouteTargetList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpL3VniImportRouteTargetList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpL3VniImportRouteTargetList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpL3VniImportRouteTargetList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.TargetAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAs4Number",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddress",
		isMultivalue: true,
	})
	n.TargetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetType",
		isMultivalue: true,
	})
}

// TopologyBgpL3VpnRouteProperty: BGP L3-VPN Route Range Properties
type TopologyBgpL3VpnRouteProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"OverridePeerAsSetMode,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseNexthopAsV4: Advertise Nexthop as V4
	AdvertiseNexthopAsV4 *Multivalue `json:"advertiseNexthopAsV4,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AggregatorIdMode: Aggregator ID Mode
	AggregatorIdMode *Multivalue `json:"aggregatorIdMode,omitempty"`
	// AsNumSuffixRange: Supported Formats: value value1-value2 Values or value ranges separated by comma(,). e.g. 100,150-200,400,600-800 etc. Cannot be kept empty. Should be >= (Max Number of AS Path Segments) x (Max AS Numbers Per Segment)
	AsNumSuffixRange *Multivalue `json:"asNumSuffixRange,omitempty"`
	// AsPathPerRoute: When there are multiple routes in a route range, this option decides whether to use same or different AS paths randomly generated for all the routes within that route range. For the Different option, each route will be sent in different update messages.
	AsPathPerRoute *Multivalue `json:"asPathPerRoute,omitempty"`
	// AsRandomSeed: Seed value decides the way the AS Values are generated. To generate different AS Paths for different Route ranges, select unique Seed Values.
	AsRandomSeed *Multivalue `json:"asRandomSeed,omitempty"`
	// AsSegDist: Type of AS Segment generated. If user selects Random, then any of the four types (AS-SET, AS-SEQ, AS-SET-CONFEDERATION, AS-SEQ-CONFEDERATION) will get randomly generated.
	AsSegDist *Multivalue `json:"asSegDist,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Delay: Delay in Seconds
	Delay *Multivalue `json:"delay,omitempty"`
	// DistinguisherAsNumber: L3VPN RR Distinguisher AS Number (2-byte or 4-Byte)
	DistinguisherAsNumber *Multivalue `json:"distinguisherAsNumber,omitempty"`
	// DistinguisherAssignedNumber: L3VPN RR Distinguisher Assigned Number
	DistinguisherAssignedNumber *Multivalue `json:"distinguisherAssignedNumber,omitempty"`
	// DistinguisherIpAddress: L3VPN RR Distinguisher IP Address
	DistinguisherIpAddress *Multivalue `json:"distinguisherIpAddress,omitempty"`
	// DistinguisherType: L3VPN RR Distinguisher Type
	DistinguisherType *Multivalue `json:"distinguisherType,omitempty"`
	// Downtime: Downtime In Seconds
	Downtime *Multivalue `json:"downtime,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable Non-Random AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableFlapping: Enable Flapping
	EnableFlapping *Multivalue `json:"enableFlapping,omitempty"`
	// EnableIpv4Receiver: Enable IPv4 Receiver

	EnableIpv4Receiver *bool `json:"enableIpv4Receiver,omitempty"`
	// EnableIpv4Sender: Enable IPv4 Sender

	EnableIpv4Sender *bool `json:"enableIpv4Sender,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRandomAsPath: Enables generation/advertisement of Random AS Path Segments.
	EnableRandomAsPath *Multivalue `json:"enableRandomAsPath,omitempty"`
	// EnableWeight: Enable Weight
	EnableWeight *Multivalue `json:"enableWeight,omitempty"`
	// FlapFromRouteIndex: Flap From Route Index
	FlapFromRouteIndex *Multivalue `json:"flapFromRouteIndex,omitempty"`
	// FlapToRouteIndex: Flap To Route Index
	FlapToRouteIndex *Multivalue `json:"flapToRouteIndex,omitempty"`
	// IncludeRdInNextHopLength: If RD is included in NH Len then NH Len is NH size + RD size else NH len is NH size.
	IncludeRdInNextHopLength *Multivalue `json:"includeRdInNextHopLength,omitempty"`
	// IncludeSourceAsExtComm: Include Source AS ExtComm
	IncludeSourceAsExtComm *Multivalue `json:"includeSourceAsExtComm,omitempty"`
	// IncludeVrfRouteImportExtComm: Include VRF Route Import ExtComm
	IncludeVrfRouteImportExtComm *Multivalue `json:"includeVrfRouteImportExtComm,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LabelEnd: L3VPN RR Label End
	LabelEnd *Multivalue `json:"labelEnd,omitempty"`
	// LabelMode: L3VPN RR Label Mode
	LabelMode *Multivalue `json:"labelMode,omitempty"`
	// LabelSpaceId: L3VPN RR Label Space ID
	LabelSpaceId *Multivalue `json:"labelSpaceId,omitempty"`
	// LabelStart: L3VPN RR Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// LabelStep: L3VPN RR Label Step
	LabelStep *Multivalue `json:"labelStep,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MaxASNumPerSegment: Maximum Number Of AS Numbers generated per Segment
	MaxASNumPerSegment *Multivalue `json:"maxASNumPerSegment,omitempty"`
	// MaxNoOfASPathSegmentsPerRouteRange: Maximum Number Of AS Path Segments Per Route Range.
	MaxNoOfASPathSegmentsPerRouteRange *Multivalue `json:"maxNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MinASNumPerSegment: Minimum Number Of AS Numbers generated per Segments.
	MinASNumPerSegment *Multivalue `json:"minASNumPerSegment,omitempty"`
	// MinNoOfASPathSegmentsPerRouteRange: Minimum Number Of AS Path Segments Per Route Range.
	MinNoOfASPathSegmentsPerRouteRange *Multivalue `json:"minNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextHopIPType: Set Next Hop IP Type
	NextHopIPType *Multivalue `json:"nextHopIPType,omitempty"`
	// NextHopIncrementMode: Next Hop Increment Mode
	NextHopIncrementMode *Multivalue `json:"nextHopIncrementMode,omitempty"`
	// NextHopType: Set Next Hop
	NextHopType *Multivalue `json:"nextHopType,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of non-random or manually configured AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExternalCommunities: Number of Extended Communities

	NoOfExternalCommunities *float32 `json:"noOfExternalCommunities,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// PackingFrom: Packing From
	PackingFrom *Multivalue `json:"packingFrom,omitempty"`
	// PackingTo: Packing To
	PackingTo *Multivalue `json:"packingTo,omitempty"`
	// PartialFlap: Partial Flap
	PartialFlap *Multivalue `json:"partialFlap,omitempty"`
	// Uptime: Uptime In Seconds
	Uptime *Multivalue `json:"uptime,omitempty"`
	// UseAsIpv4UmhRoutes: Use As IPv4 UMH Routes

	UseAsIpv4UmhRoutes *bool `json:"useAsIpv4UmhRoutes,omitempty"`
	// UseAsUmhRoutes: Use As UMH Routes
	UseAsUmhRoutes *Multivalue `json:"useAsUmhRoutes,omitempty"`
	// UseTraditionalNlri: Use Traditional NLRI
	UseTraditionalNlri *Multivalue `json:"useTraditionalNlri,omitempty"`
	// Weight: Weight
	Weight                          *Multivalue                                `json:"weight,omitempty"`
	BgpAsPathSegmentList            []*TopologyBgpAsPathSegmentList            `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                []*TopologyBgpClusterIdList                `json:"bgpClusterIdList"`
	BgpCommunitiesList              []*TopologyBgpCommunitiesList              `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList      []*TopologyBgpExtendedCommunitiesList      `json:"bgpExtendedCommunitiesList"`
	BgpNonVPNRRLargeCommunitiesList []*TopologyBgpNonVpnrrLargeCommunitiesList `json:"bgpNonVPNRRLargeCommunitiesList"`
	CMacProperties                  []*TopologyCMacProperties                  `json:"cMacProperties"`
	EvpnIPv4PrefixRange             []*TopologyEvpnIPv4PrefixRange             `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange             []*TopologyEvpnIPv6PrefixRange             `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpL3VpnRouteProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpL3VpnRouteProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpL3VpnRouteProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpL3VpnRouteProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "OverridePeerAsSetMode",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseNexthopAsV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseNexthopAsV4",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AggregatorIdMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorIdMode",
		isMultivalue: true,
	})
	n.AsNumSuffixRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumSuffixRange",
		isMultivalue: true,
	})
	n.AsPathPerRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asPathPerRoute",
		isMultivalue: true,
	})
	n.AsRandomSeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asRandomSeed",
		isMultivalue: true,
	})
	n.AsSegDist.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSegDist",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Delay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delay",
		isMultivalue: true,
	})
	n.DistinguisherAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherAsNumber",
		isMultivalue: true,
	})
	n.DistinguisherAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherAssignedNumber",
		isMultivalue: true,
	})
	n.DistinguisherIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherIpAddress",
		isMultivalue: true,
	})
	n.DistinguisherType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherType",
		isMultivalue: true,
	})
	n.Downtime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downtime",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableFlapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFlapping",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRandomAsPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRandomAsPath",
		isMultivalue: true,
	})
	n.EnableWeight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWeight",
		isMultivalue: true,
	})
	n.FlapFromRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapFromRouteIndex",
		isMultivalue: true,
	})
	n.FlapToRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapToRouteIndex",
		isMultivalue: true,
	})
	n.IncludeRdInNextHopLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeRdInNextHopLength",
		isMultivalue: true,
	})
	n.IncludeSourceAsExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSourceAsExtComm",
		isMultivalue: true,
	})
	n.IncludeVrfRouteImportExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeVrfRouteImportExtComm",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LabelEnd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelEnd",
		isMultivalue: true,
	})
	n.LabelMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelMode",
		isMultivalue: true,
	})
	n.LabelSpaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceId",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.LabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStep",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MaxASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxASNumPerSegment",
		isMultivalue: true,
	})
	n.MaxNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MinASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minASNumPerSegment",
		isMultivalue: true,
	})
	n.MinNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NextHopIPType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIPType",
		isMultivalue: true,
	})
	n.NextHopIncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIncrementMode",
		isMultivalue: true,
	})
	n.NextHopType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.PackingFrom.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingFrom",
		isMultivalue: true,
	})
	n.PackingTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingTo",
		isMultivalue: true,
	})
	n.PartialFlap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partialFlap",
		isMultivalue: true,
	})
	n.Uptime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uptime",
		isMultivalue: true,
	})
	n.UseAsUmhRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useAsUmhRoutes",
		isMultivalue: true,
	})
	n.UseTraditionalNlri.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useTraditionalNlri",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpNonVPNRRLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpNonVPNRRLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpLargeCommunitiesList: Bgp Non VPN RR Large Communities
type TopologyBgpLargeCommunitiesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// LargeCommunity: Large Community in cannonical format as defined in RFC8092 which is: GlobalAdmin:LocalDataPart1:LocalDataPart2 where each value must have range 1-4294967295. e.g. 65535:100:10 or 4294967295:1:65535
	LargeCommunity *Multivalue `json:"largeCommunity,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpLargeCommunitiesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpLargeCommunitiesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpLargeCommunitiesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpLargeCommunitiesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LargeCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "largeCommunity",
		isMultivalue: true,
	})
}

// TopologyBgpLsAsPathSegmentList: Bgp LS Path segments
type TopologyBgpLsAsPathSegmentList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableASPathSegment: Enable AS Path Segment
	EnableASPathSegment *Multivalue `json:"enableASPathSegment,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfAsNumberInSegment: Number of AS Number In Segment

	NumberOfAsNumberInSegment *float32 `json:"numberOfAsNumberInSegment,omitempty"`
	// SegmentType: SegmentType
	SegmentType     *Multivalue                `json:"segmentType,omitempty"`
	BgpAsNumberList []*TopologyBgpAsNumberList `json:"bgpAsNumberList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpLsAsPathSegmentList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpLsAsPathSegmentList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpLsAsPathSegmentList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpLsAsPathSegmentList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableASPathSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableASPathSegment",
		isMultivalue: true,
	})
	n.SegmentType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentType",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsNumberList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsNumberList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpLsClusterIdList: Bgp Non VPN RR Cluster ID
type TopologyBgpLsClusterIdList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ClusterId: Cluster ID
	ClusterId *Multivalue `json:"clusterId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpLsClusterIdList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpLsClusterIdList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpLsClusterIdList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpLsClusterIdList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ClusterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clusterId",
		isMultivalue: true,
	})
}

// TopologyBgpLsCommunitiesList: Bgp Non VPN RR Communities
type TopologyBgpLsCommunitiesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AsNumber: AS #
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// LastTwoOctets: Last Two Octets
	LastTwoOctets *Multivalue `json:"lastTwoOctets,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpLsCommunitiesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpLsCommunitiesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpLsCommunitiesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpLsCommunitiesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.LastTwoOctets.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lastTwoOctets",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyBgpLsExtendedCommunitiesList: Bgp Non VPN RR External Communities
type TopologyBgpLsExtendedCommunitiesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AsNumber2Bytes: AS 2-Bytes
	AsNumber2Bytes *Multivalue `json:"asNumber2Bytes,omitempty"`
	// AsNumber4Bytes: AS 4-Bytes
	AsNumber4Bytes *Multivalue `json:"asNumber4Bytes,omitempty"`
	// AssignedNumber2Bytes: Assigned Number(2 Octets)
	AssignedNumber2Bytes *Multivalue `json:"assignedNumber2Bytes,omitempty"`
	// AssignedNumber4Bytes: Assigned Number(4 Octets)
	AssignedNumber4Bytes *Multivalue `json:"assignedNumber4Bytes,omitempty"`
	// ColorCOBits: Color CO Bits
	ColorCOBits *Multivalue `json:"colorCOBits,omitempty"`
	// ColorReservedBits: Color Reserved Bits
	ColorReservedBits *Multivalue `json:"colorReservedBits,omitempty"`
	// ColorValue: Color Value
	ColorValue *Multivalue `json:"colorValue,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// LinkBandwidth: Link Bandwidth
	LinkBandwidth *Multivalue `json:"linkBandwidth,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OpaqueData: Opaque Data
	OpaqueData *Multivalue `json:"opaqueData,omitempty"`
	// SubType: SubType
	SubType *Multivalue `json:"subType,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpLsExtendedCommunitiesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpLsExtendedCommunitiesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpLsExtendedCommunitiesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpLsExtendedCommunitiesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AsNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber2Bytes",
		isMultivalue: true,
	})
	n.AsNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber4Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber2Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber2Bytes",
		isMultivalue: true,
	})
	n.AssignedNumber4Bytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumber4Bytes",
		isMultivalue: true,
	})
	n.ColorCOBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorCOBits",
		isMultivalue: true,
	})
	n.ColorReservedBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorReservedBits",
		isMultivalue: true,
	})
	n.ColorValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorValue",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.LinkBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkBandwidth",
		isMultivalue: true,
	})
	n.OpaqueData.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "opaqueData",
		isMultivalue: true,
	})
	n.SubType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subType",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyBgpMVpnReceiverSitesIpv4: Bgp MVPN Receiver Sites Properties
type TopologyBgpMVpnReceiverSitesIpv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// BFRId: BFR-Id
	BFRId *Multivalue `json:"BFRId,omitempty"`
	// BFRIpv4Prefix: BFR IPv4 Prefix
	BFRIpv4Prefix *Multivalue `json:"BFRIpv4Prefix,omitempty"`
	// BFRIpv6Prefix: BFR IPv6 Prefix
	BFRIpv6Prefix *Multivalue `json:"BFRIpv6Prefix,omitempty"`
	// BFRPrefixType: BFR Prefix Type
	BFRPrefixType *Multivalue `json:"BFRPrefixType,omitempty"`
	// SubDomainId: Sub-Domain Id
	SubDomainId *Multivalue `json:"SubDomainId,omitempty"`
	// UseAutoSubDomainId: Use Auto Sub-Domain Id
	UseAutoSubDomainId *Multivalue `json:"UseAutoSubDomainId,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CMulticastRouteType: C-Multicast Route Type
	CMulticastRouteType *Multivalue `json:"cMulticastRouteType,omitempty"`
	// DownstreamLabel: Downstream Assigned Label in Leaf A-D route when tunnel type is Ingress Replication
	DownstreamLabel *Multivalue `json:"downstreamLabel,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// GroupAddressCount: Group Address Count
	GroupAddressCount *Multivalue `json:"groupAddressCount,omitempty"`
	// GroupMaskWidth: Group Mask Width
	GroupMaskWidth *Multivalue `json:"groupMaskWidth,omitempty"`
	// IncludeBierPtainLeafAd: Include Bier PTA in Leaf A-D

	IncludeBierPtainLeafAd *bool `json:"includeBierPtainLeafAd,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SendTriggeredMulticastRoute: Send Triggered Multicast Route
	SendTriggeredMulticastRoute *Multivalue `json:"sendTriggeredMulticastRoute,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourceAddressCount: Source Address Count
	SourceAddressCount *Multivalue `json:"sourceAddressCount,omitempty"`
	// SourceGroupMapping: Source Group Mapping
	SourceGroupMapping *Multivalue `json:"sourceGroupMapping,omitempty"`
	// SourceMaskWidth: Source Mask Width
	SourceMaskWidth *Multivalue `json:"sourceMaskWidth,omitempty"`
	// StartGroupAddressIpv4: Start Group Address
	StartGroupAddressIpv4 *Multivalue `json:"startGroupAddressIpv4,omitempty"`
	// StartSourceAddressIpv4: Start Source Address IPv4
	StartSourceAddressIpv4 *Multivalue `json:"startSourceAddressIpv4,omitempty"`
	// StartSourceOrCrpAddressIpv4: C-RP Address IPv4
	StartSourceOrCrpAddressIpv4 *Multivalue `json:"startSourceOrCrpAddressIpv4,omitempty"`
	// SupportLeafADRoutesSending: Support Leaf A-D Routes Sending
	SupportLeafADRoutesSending *Multivalue `json:"supportLeafADRoutesSending,omitempty"`
	// WildCardLeafAdForBierPta: Wildcard Leaf A-D For Bier PTA

	WildCardLeafAdForBierPta *bool                          `json:"wildCardLeafAdForBierPta,omitempty"`
	CMacProperties           []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange      []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange      []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	Tag                      []*TopologyTag                 `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpMVpnReceiverSitesIpv4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpMVpnReceiverSitesIpv4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpMVpnReceiverSitesIpv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpMVpnReceiverSitesIpv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BFRId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRId",
		isMultivalue: true,
	})
	n.BFRIpv4Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIpv4Prefix",
		isMultivalue: true,
	})
	n.BFRIpv6Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIpv6Prefix",
		isMultivalue: true,
	})
	n.BFRPrefixType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRPrefixType",
		isMultivalue: true,
	})
	n.SubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "SubDomainId",
		isMultivalue: true,
	})
	n.UseAutoSubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "UseAutoSubDomainId",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CMulticastRouteType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cMulticastRouteType",
		isMultivalue: true,
	})
	n.DownstreamLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downstreamLabel",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.GroupAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressCount",
		isMultivalue: true,
	})
	n.GroupMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupMaskWidth",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.SendTriggeredMulticastRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendTriggeredMulticastRoute",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressCount",
		isMultivalue: true,
	})
	n.SourceGroupMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceGroupMapping",
		isMultivalue: true,
	})
	n.SourceMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMaskWidth",
		isMultivalue: true,
	})
	n.StartGroupAddressIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressIpv4",
		isMultivalue: true,
	})
	n.StartSourceAddressIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSourceAddressIpv4",
		isMultivalue: true,
	})
	n.StartSourceOrCrpAddressIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSourceOrCrpAddressIpv4",
		isMultivalue: true,
	})
	n.SupportLeafADRoutesSending.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportLeafADRoutesSending",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpMVpnReceiverSitesIpv6: Bgp MVPN Receiver Sites Properties
type TopologyBgpMVpnReceiverSitesIpv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// BFRId: BFR-Id
	BFRId *Multivalue `json:"BFRId,omitempty"`
	// BFRIpv4Prefix: BFR IPv4 Prefix
	BFRIpv4Prefix *Multivalue `json:"BFRIpv4Prefix,omitempty"`
	// BFRIpv6Prefix: BFR IPv6 Prefix
	BFRIpv6Prefix *Multivalue `json:"BFRIpv6Prefix,omitempty"`
	// BFRPrefixType: BFR Prefix Type
	BFRPrefixType *Multivalue `json:"BFRPrefixType,omitempty"`
	// SubDomainId: Sub-Domain Id
	SubDomainId *Multivalue `json:"SubDomainId,omitempty"`
	// UseAutoSubDomainId: Use Auto Sub-Domain Id
	UseAutoSubDomainId *Multivalue `json:"UseAutoSubDomainId,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CMulticastRouteType: C-Multicast Route Type
	CMulticastRouteType *Multivalue `json:"cMulticastRouteType,omitempty"`
	// DownstreamLabel: Downstream Assigned Label in Leaf A-D route when tunnel type is Ingress Replication
	DownstreamLabel *Multivalue `json:"downstreamLabel,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// GroupAddressCount: Group Address Count
	GroupAddressCount *Multivalue `json:"groupAddressCount,omitempty"`
	// GroupMaskWidth: Group Mask Width
	GroupMaskWidth *Multivalue `json:"groupMaskWidth,omitempty"`
	// IncludeBierPtainLeafAd: Include Bier PTA in Leaf A-D

	IncludeBierPtainLeafAd *bool `json:"includeBierPtainLeafAd,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SendTriggeredMulticastRoute: Send Triggered Multicast Route
	SendTriggeredMulticastRoute *Multivalue `json:"sendTriggeredMulticastRoute,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourceAddressCount: Source Address Count
	SourceAddressCount *Multivalue `json:"sourceAddressCount,omitempty"`
	// SourceGroupMapping: Source Group Mapping
	SourceGroupMapping *Multivalue `json:"sourceGroupMapping,omitempty"`
	// SourceMaskWidth: Source Mask Width
	SourceMaskWidth *Multivalue `json:"sourceMaskWidth,omitempty"`
	// StartGroupAddressIpv6: Start Group Address
	StartGroupAddressIpv6 *Multivalue `json:"startGroupAddressIpv6,omitempty"`
	// StartSourceAddressIpv6: Start Source Address IPv6
	StartSourceAddressIpv6 *Multivalue `json:"startSourceAddressIpv6,omitempty"`
	// StartSourceOrCrpAddressIpv6: C-RP Address IPv6
	StartSourceOrCrpAddressIpv6 *Multivalue `json:"startSourceOrCrpAddressIpv6,omitempty"`
	// SupportLeafADRoutesSending: Support Leaf A-D Routes Sending
	SupportLeafADRoutesSending *Multivalue `json:"supportLeafADRoutesSending,omitempty"`
	// WildCardLeafAdForBierPta: Wildcard Leaf A-D For Bier PTA

	WildCardLeafAdForBierPta *bool                          `json:"wildCardLeafAdForBierPta,omitempty"`
	CMacProperties           []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange      []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange      []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	Tag                      []*TopologyTag                 `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpMVpnReceiverSitesIpv6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpMVpnReceiverSitesIpv6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpMVpnReceiverSitesIpv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpMVpnReceiverSitesIpv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BFRId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRId",
		isMultivalue: true,
	})
	n.BFRIpv4Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIpv4Prefix",
		isMultivalue: true,
	})
	n.BFRIpv6Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIpv6Prefix",
		isMultivalue: true,
	})
	n.BFRPrefixType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRPrefixType",
		isMultivalue: true,
	})
	n.SubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "SubDomainId",
		isMultivalue: true,
	})
	n.UseAutoSubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "UseAutoSubDomainId",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CMulticastRouteType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cMulticastRouteType",
		isMultivalue: true,
	})
	n.DownstreamLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downstreamLabel",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.GroupAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressCount",
		isMultivalue: true,
	})
	n.GroupMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupMaskWidth",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.SendTriggeredMulticastRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendTriggeredMulticastRoute",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressCount",
		isMultivalue: true,
	})
	n.SourceGroupMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceGroupMapping",
		isMultivalue: true,
	})
	n.SourceMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMaskWidth",
		isMultivalue: true,
	})
	n.StartGroupAddressIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressIpv6",
		isMultivalue: true,
	})
	n.StartSourceAddressIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSourceAddressIpv6",
		isMultivalue: true,
	})
	n.StartSourceOrCrpAddressIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSourceOrCrpAddressIpv6",
		isMultivalue: true,
	})
	n.SupportLeafADRoutesSending.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportLeafADRoutesSending",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpMVpnSenderSitesIpv4: Bgp MVPN Sender Sites Properties
type TopologyBgpMVpnSenderSitesIpv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// GroupAddressCount: Group Address Count
	GroupAddressCount *Multivalue `json:"groupAddressCount,omitempty"`
	// GroupMaskWidth: Group Mask Width
	GroupMaskWidth *Multivalue `json:"groupMaskWidth,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SendTriggeredSourceActiveADRoute: Send Triggered Source Active A-D Route
	SendTriggeredSourceActiveADRoute *Multivalue `json:"sendTriggeredSourceActiveADRoute,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourceAddressCount: Source Address Count
	SourceAddressCount *Multivalue `json:"sourceAddressCount,omitempty"`
	// SourceGroupMapping: Source Group Mapping
	SourceGroupMapping *Multivalue `json:"sourceGroupMapping,omitempty"`
	// SourceMaskWidth: Source Mask Width
	SourceMaskWidth *Multivalue `json:"sourceMaskWidth,omitempty"`
	// StartGroupAddressIpv4: Start Group Address
	StartGroupAddressIpv4 *Multivalue `json:"startGroupAddressIpv4,omitempty"`
	// StartSourceAddressIpv4: Start Source Address IPv4
	StartSourceAddressIpv4 *Multivalue                    `json:"startSourceAddressIpv4,omitempty"`
	CMacProperties         []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange    []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange    []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	Tag                    []*TopologyTag                 `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpMVpnSenderSitesIpv4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpMVpnSenderSitesIpv4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpMVpnSenderSitesIpv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpMVpnSenderSitesIpv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.GroupAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressCount",
		isMultivalue: true,
	})
	n.GroupMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupMaskWidth",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.SendTriggeredSourceActiveADRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendTriggeredSourceActiveADRoute",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressCount",
		isMultivalue: true,
	})
	n.SourceGroupMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceGroupMapping",
		isMultivalue: true,
	})
	n.SourceMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMaskWidth",
		isMultivalue: true,
	})
	n.StartGroupAddressIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressIpv4",
		isMultivalue: true,
	})
	n.StartSourceAddressIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSourceAddressIpv4",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpMVpnSenderSitesIpv6: Bgp MVPN Sender Sites Properties
type TopologyBgpMVpnSenderSitesIpv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// GroupAddressCount: Group Address Count
	GroupAddressCount *Multivalue `json:"groupAddressCount,omitempty"`
	// GroupMaskWidth: Group Mask Width
	GroupMaskWidth *Multivalue `json:"groupMaskWidth,omitempty"`
	// IncludeIpv6ExplicitNullLabel: Include IPv6 Explicit NULL Label
	IncludeIpv6ExplicitNullLabel *Multivalue `json:"includeIpv6ExplicitNullLabel,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SendTriggeredSourceActiveADRoute: Send Triggered Source Active A-D Route
	SendTriggeredSourceActiveADRoute *Multivalue `json:"sendTriggeredSourceActiveADRoute,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SourceAddressCount: Source Address Count
	SourceAddressCount *Multivalue `json:"sourceAddressCount,omitempty"`
	// SourceGroupMapping: Source Group Mapping
	SourceGroupMapping *Multivalue `json:"sourceGroupMapping,omitempty"`
	// SourceMaskWidth: Source Mask Width
	SourceMaskWidth *Multivalue `json:"sourceMaskWidth,omitempty"`
	// StartGroupAddressIpv6: Start Group Address
	StartGroupAddressIpv6 *Multivalue `json:"startGroupAddressIpv6,omitempty"`
	// StartSourceAddressIpv6: Start Source Address IPv6
	StartSourceAddressIpv6 *Multivalue                    `json:"startSourceAddressIpv6,omitempty"`
	CMacProperties         []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange    []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange    []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	Tag                    []*TopologyTag                 `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpMVpnSenderSitesIpv6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpMVpnSenderSitesIpv6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpMVpnSenderSitesIpv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpMVpnSenderSitesIpv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.GroupAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressCount",
		isMultivalue: true,
	})
	n.GroupMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupMaskWidth",
		isMultivalue: true,
	})
	n.IncludeIpv6ExplicitNullLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeIpv6ExplicitNullLabel",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.SendTriggeredSourceActiveADRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendTriggeredSourceActiveADRoute",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressCount",
		isMultivalue: true,
	})
	n.SourceGroupMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceGroupMapping",
		isMultivalue: true,
	})
	n.SourceMaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMaskWidth",
		isMultivalue: true,
	})
	n.StartGroupAddressIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressIpv6",
		isMultivalue: true,
	})
	n.StartSourceAddressIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSourceAddressIpv6",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpNonVpnrrLargeCommunitiesList: Bgp Non VPN RR Large Communities
type TopologyBgpNonVpnrrLargeCommunitiesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// LargeCommunity: Large Community in cannonical format as defined in RFC8092 which is: GlobalAdmin:LocalDataPart1:LocalDataPart2 where each value must have range 1-4294967295. e.g. 65535:100:10 or 4294967295:1:65535
	LargeCommunity *Multivalue `json:"largeCommunity,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpNonVpnrrLargeCommunitiesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpNonVpnrrLargeCommunitiesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpNonVpnrrLargeCommunitiesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpNonVpnrrLargeCommunitiesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LargeCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "largeCommunity",
		isMultivalue: true,
	})
}

// TopologyBgpSrgbRangeSubObjectsList: Bgp SRGB Range Sub Objects
type TopologyBgpSrgbRangeSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SIDCount: The size of the SRGB Block
	SIDCount *Multivalue `json:"sIDCount,omitempty"`
	// StartSID: Start Segment ID of the SRGB Block
	StartSID *Multivalue `json:"startSID,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrgbRangeSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrgbRangeSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrgbRangeSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrgbRangeSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SIDCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDCount",
		isMultivalue: true,
	})
	n.StartSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSID",
		isMultivalue: true,
	})
}

// TopologyBgpSrtePoliciesListV4: TBD
type TopologyBgpSrtePoliciesListV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AddPathId: BGP ADD Path Id
	AddPathId *Multivalue `json:"addPathId,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Distinguisher: Distinguisher
	Distinguisher *Multivalue `json:"distinguisher,omitempty"`
	// EnableAddPath: Enable Path ID when ADD Path Capability is enabled in BGP Peer
	EnableAddPath *Multivalue `json:"enableAddPath,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EndPointV4: IPv4 End Point
	EndPointV4 *Multivalue `json:"endPointV4,omitempty"`
	// EndPointV6: IPv6 End Point
	EndPointV6 *Multivalue `json:"endPointV6,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumberOfTunnelsV4: Count of Tunnel TLVs Per Policy

	NumberOfTunnelsV4 *float32 `json:"numberOfTunnelsV4,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PolicyColor: Policy Color
	PolicyColor *Multivalue `json:"policyColor,omitempty"`
	// PolicyType: Policy Type
	PolicyType *Multivalue `json:"policyType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SrtepolicyName: Policy Name For Reference
	SrtepolicyName             *Multivalue                           `json:"srtepolicyName,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`

	BgpSRTEPoliciesTunnelEncapsulationListV4 *TopologyBgpSrtePoliciesTunnelEncapsulationListV4 `json:"bgpSRTEPoliciesTunnelEncapsulationListV4,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesListV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesListV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesListV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesListV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AddPathId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addPathId",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Distinguisher.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisher",
		isMultivalue: true,
	})
	n.EnableAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAddPath",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EndPointV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointV4",
		isMultivalue: true,
	})
	n.EndPointV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointV6",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PolicyColor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyColor",
		isMultivalue: true,
	})
	n.PolicyType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SrtepolicyName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtepolicyName",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BgpSRTEPoliciesTunnelEncapsulationListV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesTunnelEncapsulationListV4",
	})
}

// TopologyBgpSrtePoliciesListV6: TBD
type TopologyBgpSrtePoliciesListV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AddPathId: BGP ADD Path Id
	AddPathId *Multivalue `json:"addPathId,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Distinguisher: Distinguisher
	Distinguisher *Multivalue `json:"distinguisher,omitempty"`
	// EnableAddPath: Enable Path ID when ADD Path Capability is enabled in BGP Peer
	EnableAddPath *Multivalue `json:"enableAddPath,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EndPointV4: IPv4 End Point
	EndPointV4 *Multivalue `json:"endPointV4,omitempty"`
	// EndPointV6: IPv6 End Point
	EndPointV6 *Multivalue `json:"endPointV6,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// NumberOfTunnelsV6: Count of Tunnel TLVs Per Policy

	NumberOfTunnelsV6 *float32 `json:"numberOfTunnelsV6,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PolicyColor: Policy Color
	PolicyColor *Multivalue `json:"policyColor,omitempty"`
	// PolicyType: Policy Type
	PolicyType *Multivalue `json:"policyType,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// SrtepolicyName: Policy Name For Reference
	SrtepolicyName             *Multivalue                           `json:"srtepolicyName,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`

	BgpSRTEPoliciesTunnelEncapsulationListV6 *TopologyBgpSrtePoliciesTunnelEncapsulationListV6 `json:"bgpSRTEPoliciesTunnelEncapsulationListV6,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesListV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesListV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesListV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesListV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AddPathId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addPathId",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Distinguisher.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisher",
		isMultivalue: true,
	})
	n.EnableAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAddPath",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EndPointV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointV4",
		isMultivalue: true,
	})
	n.EndPointV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointV6",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PolicyColor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyColor",
		isMultivalue: true,
	})
	n.PolicyType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyType",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.SrtepolicyName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srtepolicyName",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.BgpSRTEPoliciesTunnelEncapsulationListV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesTunnelEncapsulationListV6",
	})
}

// TopologyBgpSrtePoliciesSegmentListV4: TBD
type TopologyBgpSrtePoliciesSegmentListV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnWeight: Enable Weight Sub-TLV
	EnWeight *Multivalue `json:"enWeight,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfActiveSegments: Count of Segment
	NumberOfActiveSegments *Multivalue `json:"numberOfActiveSegments,omitempty"`
	// NumberOfSegmentsV4: Count of Segments Per Segment List

	NumberOfSegmentsV4 *float32 `json:"numberOfSegmentsV4,omitempty"`
	// SegmentListNumber: Segment List Number For Reference
	SegmentListNumber *Multivalue `json:"segmentListNumber,omitempty"`
	// Weight: Weight Value
	Weight *Multivalue `json:"weight,omitempty"`

	BgpSRTEPoliciesSegmentsCollectionV4 *TopologyBgpSrtePoliciesSegmentsCollectionV4 `json:"bgpSRTEPoliciesSegmentsCollectionV4,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesSegmentListV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesSegmentListV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesSegmentListV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesSegmentListV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnWeight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enWeight",
		isMultivalue: true,
	})
	n.NumberOfActiveSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfActiveSegments",
		isMultivalue: true,
	})
	n.SegmentListNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentListNumber",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.BgpSRTEPoliciesSegmentsCollectionV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesSegmentsCollectionV4",
	})
}

// TopologyBgpSrtePoliciesSegmentListV6: TBD
type TopologyBgpSrtePoliciesSegmentListV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnWeight: Enable Weight Sub-TLV
	EnWeight *Multivalue `json:"enWeight,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfActiveSegments: Count of Segment
	NumberOfActiveSegments *Multivalue `json:"numberOfActiveSegments,omitempty"`
	// NumberOfSegmentsV6: Count of Segments Per Segment List

	NumberOfSegmentsV6 *float32 `json:"numberOfSegmentsV6,omitempty"`
	// SegmentListNumber: Segment List Number For Reference
	SegmentListNumber *Multivalue `json:"segmentListNumber,omitempty"`
	// Weight: Weight Value
	Weight *Multivalue `json:"weight,omitempty"`

	BgpSRTEPoliciesSegmentsCollectionV6 *TopologyBgpSrtePoliciesSegmentsCollectionV6 `json:"bgpSRTEPoliciesSegmentsCollectionV6,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesSegmentListV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesSegmentListV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesSegmentListV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesSegmentListV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnWeight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enWeight",
		isMultivalue: true,
	})
	n.NumberOfActiveSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfActiveSegments",
		isMultivalue: true,
	})
	n.SegmentListNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentListNumber",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.BgpSRTEPoliciesSegmentsCollectionV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesSegmentsCollectionV6",
	})
}

// TopologyBgpSrtePoliciesSegmentsCollectionV4: TBD
type TopologyBgpSrtePoliciesSegmentsCollectionV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BottomOfStack: Bottom Of Stack
	BottomOfStack *Multivalue `json:"bottomOfStack,omitempty"`
	// InterfaceIndex: Interface Index
	InterfaceIndex *Multivalue `json:"interfaceIndex,omitempty"`
	// Ipv4LocalAddress: IPv4 Local Address
	Ipv4LocalAddress *Multivalue `json:"ipv4LocalAddress,omitempty"`
	// Ipv4NodeAddress: IPv4 Node Address
	Ipv4NodeAddress *Multivalue `json:"ipv4NodeAddress,omitempty"`
	// Ipv4RemoteAddress: IPv4 Remote Address
	Ipv4RemoteAddress *Multivalue `json:"ipv4RemoteAddress,omitempty"`
	// Ipv6LocalAddress: IPv6 Local Address
	Ipv6LocalAddress *Multivalue `json:"ipv6LocalAddress,omitempty"`
	// Ipv6NodeAddress: IPv6 Node Address
	Ipv6NodeAddress *Multivalue `json:"ipv6NodeAddress,omitempty"`
	// Ipv6RemoteAddress: IPv6 Remote Address
	Ipv6RemoteAddress *Multivalue `json:"ipv6RemoteAddress,omitempty"`
	// Ipv6SID: IPv6 SID
	Ipv6SID *Multivalue `json:"ipv6SID,omitempty"`
	// Label: Label
	Label *Multivalue `json:"label,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OptionalBottomOfStack: Bottom Of Stack
	OptionalBottomOfStack *Multivalue `json:"optionalBottomOfStack,omitempty"`
	// OptionalIpv6SID: IPv6 SID
	OptionalIpv6SID *Multivalue `json:"optionalIpv6SID,omitempty"`
	// OptionalLabel: Label
	OptionalLabel *Multivalue `json:"optionalLabel,omitempty"`
	// OptionalTLVType: Optional TLV Type
	OptionalTLVType *Multivalue `json:"optionalTLVType,omitempty"`
	// OptionalTimeToLive: TTL
	OptionalTimeToLive *Multivalue `json:"optionalTimeToLive,omitempty"`
	// OptionalTrafficClass: Traffic Class
	OptionalTrafficClass *Multivalue `json:"optionalTrafficClass,omitempty"`
	// SegmentType: Segment Type
	SegmentType *Multivalue `json:"segmentType,omitempty"`
	// TimeToLive: TTL
	TimeToLive *Multivalue `json:"timeToLive,omitempty"`
	// TrafficClass: Traffic Class
	TrafficClass *Multivalue `json:"trafficClass,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesSegmentsCollectionV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesSegmentsCollectionV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesSegmentsCollectionV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesSegmentsCollectionV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BottomOfStack.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bottomOfStack",
		isMultivalue: true,
	})
	n.InterfaceIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceIndex",
		isMultivalue: true,
	})
	n.Ipv4LocalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4LocalAddress",
		isMultivalue: true,
	})
	n.Ipv4NodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NodeAddress",
		isMultivalue: true,
	})
	n.Ipv4RemoteAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4RemoteAddress",
		isMultivalue: true,
	})
	n.Ipv6LocalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6LocalAddress",
		isMultivalue: true,
	})
	n.Ipv6NodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NodeAddress",
		isMultivalue: true,
	})
	n.Ipv6RemoteAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6RemoteAddress",
		isMultivalue: true,
	})
	n.Ipv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6SID",
		isMultivalue: true,
	})
	n.Label.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "label",
		isMultivalue: true,
	})
	n.OptionalBottomOfStack.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalBottomOfStack",
		isMultivalue: true,
	})
	n.OptionalIpv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalIpv6SID",
		isMultivalue: true,
	})
	n.OptionalLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalLabel",
		isMultivalue: true,
	})
	n.OptionalTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalTLVType",
		isMultivalue: true,
	})
	n.OptionalTimeToLive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalTimeToLive",
		isMultivalue: true,
	})
	n.OptionalTrafficClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalTrafficClass",
		isMultivalue: true,
	})
	n.SegmentType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentType",
		isMultivalue: true,
	})
	n.TimeToLive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeToLive",
		isMultivalue: true,
	})
	n.TrafficClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficClass",
		isMultivalue: true,
	})
}

// TopologyBgpSrtePoliciesSegmentsCollectionV6: TBD
type TopologyBgpSrtePoliciesSegmentsCollectionV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BottomOfStack: Bottom Of Stack
	BottomOfStack *Multivalue `json:"bottomOfStack,omitempty"`
	// InterfaceIndex: Interface Index
	InterfaceIndex *Multivalue `json:"interfaceIndex,omitempty"`
	// Ipv4LocalAddress: IPv4 Local Address
	Ipv4LocalAddress *Multivalue `json:"ipv4LocalAddress,omitempty"`
	// Ipv4NodeAddress: IPv4 Node Address
	Ipv4NodeAddress *Multivalue `json:"ipv4NodeAddress,omitempty"`
	// Ipv4RemoteAddress: IPv4 Remote Address
	Ipv4RemoteAddress *Multivalue `json:"ipv4RemoteAddress,omitempty"`
	// Ipv6LocalAddress: IPv6 Local Address
	Ipv6LocalAddress *Multivalue `json:"ipv6LocalAddress,omitempty"`
	// Ipv6NodeAddress: IPv6 Node Address
	Ipv6NodeAddress *Multivalue `json:"ipv6NodeAddress,omitempty"`
	// Ipv6RemoteAddress: IPv6 Remote Address
	Ipv6RemoteAddress *Multivalue `json:"ipv6RemoteAddress,omitempty"`
	// Ipv6SID: IPv6 SID
	Ipv6SID *Multivalue `json:"ipv6SID,omitempty"`
	// Label: Label
	Label *Multivalue `json:"label,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OptionalBottomOfStack: Bottom Of Stack
	OptionalBottomOfStack *Multivalue `json:"optionalBottomOfStack,omitempty"`
	// OptionalIpv6SID: IPv6 SID
	OptionalIpv6SID *Multivalue `json:"optionalIpv6SID,omitempty"`
	// OptionalLabel: Label
	OptionalLabel *Multivalue `json:"optionalLabel,omitempty"`
	// OptionalTLVType: Optional TLV Type
	OptionalTLVType *Multivalue `json:"optionalTLVType,omitempty"`
	// OptionalTimeToLive: TTL
	OptionalTimeToLive *Multivalue `json:"optionalTimeToLive,omitempty"`
	// OptionalTrafficClass: Traffic Class
	OptionalTrafficClass *Multivalue `json:"optionalTrafficClass,omitempty"`
	// SegmentType: Segment Type
	SegmentType *Multivalue `json:"segmentType,omitempty"`
	// TimeToLive: TTL
	TimeToLive *Multivalue `json:"timeToLive,omitempty"`
	// TrafficClass: Traffic Class
	TrafficClass *Multivalue `json:"trafficClass,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesSegmentsCollectionV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesSegmentsCollectionV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesSegmentsCollectionV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesSegmentsCollectionV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BottomOfStack.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bottomOfStack",
		isMultivalue: true,
	})
	n.InterfaceIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceIndex",
		isMultivalue: true,
	})
	n.Ipv4LocalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4LocalAddress",
		isMultivalue: true,
	})
	n.Ipv4NodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NodeAddress",
		isMultivalue: true,
	})
	n.Ipv4RemoteAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4RemoteAddress",
		isMultivalue: true,
	})
	n.Ipv6LocalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6LocalAddress",
		isMultivalue: true,
	})
	n.Ipv6NodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NodeAddress",
		isMultivalue: true,
	})
	n.Ipv6RemoteAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6RemoteAddress",
		isMultivalue: true,
	})
	n.Ipv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6SID",
		isMultivalue: true,
	})
	n.Label.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "label",
		isMultivalue: true,
	})
	n.OptionalBottomOfStack.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalBottomOfStack",
		isMultivalue: true,
	})
	n.OptionalIpv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalIpv6SID",
		isMultivalue: true,
	})
	n.OptionalLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalLabel",
		isMultivalue: true,
	})
	n.OptionalTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalTLVType",
		isMultivalue: true,
	})
	n.OptionalTimeToLive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalTimeToLive",
		isMultivalue: true,
	})
	n.OptionalTrafficClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "optionalTrafficClass",
		isMultivalue: true,
	})
	n.SegmentType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentType",
		isMultivalue: true,
	})
	n.TimeToLive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeToLive",
		isMultivalue: true,
	})
	n.TrafficClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "trafficClass",
		isMultivalue: true,
	})
}

// TopologyBgpSrtePoliciesTunnelEncapsulationListV4: TBD
type TopologyBgpSrtePoliciesTunnelEncapsulationListV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ENLPValue: Enable Explicit NULL Label Policy Value
	ENLPValue *Multivalue `json:"ENLPValue,omitempty"`
	// IPv6SID: IPv6 SID
	IPv6SID *Multivalue `json:"IPv6SID,omitempty"`
	// SID4Octet: 4 Octet SID
	SID4Octet *Multivalue `json:"SID4Octet,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AddressFamily: Address Family
	AddressFamily *Multivalue `json:"addressFamily,omitempty"`
	// As4Number: AS Number (4 Octects)
	As4Number *Multivalue `json:"as4Number,omitempty"`
	// BindingSIDType: Binding SID Type
	BindingSIDType *Multivalue `json:"bindingSIDType,omitempty"`
	// ColorCOBits: Color CO Bits
	ColorCOBits *Multivalue `json:"colorCOBits,omitempty"`
	// ColorReservedBits: Color Reserved Bits
	ColorReservedBits *Multivalue `json:"colorReservedBits,omitempty"`
	// ColorValue: Color Value
	ColorValue *Multivalue `json:"colorValue,omitempty"`
	// EnBindingTLV: Enable Binding Sub-TLV
	EnBindingTLV *Multivalue `json:"enBindingTLV,omitempty"`
	// EnColorTLV: Enable Color Sub-TLV
	EnColorTLV *Multivalue `json:"enColorTLV,omitempty"`
	// EnENLPTLV: Enable Explicit NULL Label Policy Sub-TLV
	EnENLPTLV *Multivalue `json:"enENLPTLV,omitempty"`
	// EnPolicyNameTLV: Enable Policy Name Sub-TLV
	EnPolicyNameTLV *Multivalue `json:"enPolicyNameTLV,omitempty"`
	// EnPolicyPrioritySubTLV: Enable Policy Priority Sub-TLV
	EnPolicyPrioritySubTLV *Multivalue `json:"enPolicyPrioritySubTLV,omitempty"`
	// EnPrefTLV: Enable Preference Sub-TLV
	EnPrefTLV *Multivalue `json:"enPrefTLV,omitempty"`
	// EnRemoteEndPointTLV: Enable Remote Endpoint Sub-TLV
	EnRemoteEndPointTLV *Multivalue `json:"enRemoteEndPointTLV,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfActiveSegmentList: TBD
	NumberOfActiveSegmentList *Multivalue `json:"numberOfActiveSegmentList,omitempty"`
	// NumberOfSegmentListV4: Count of Segment Lists Per Tunnel

	NumberOfSegmentListV4 *float32 `json:"numberOfSegmentListV4,omitempty"`
	// PolicyName: Policy Name
	PolicyName *Multivalue `json:"policyName,omitempty"`
	// PrefValue: Preference
	PrefValue *Multivalue `json:"prefValue,omitempty"`
	// Priority: Priority
	Priority *Multivalue `json:"priority,omitempty"`
	// RemoteEndpointIPv4: IPv4 Address
	RemoteEndpointIPv4 *Multivalue `json:"remoteEndpointIPv4,omitempty"`
	// RemoteEndpointIPv6: IPv6 Address
	RemoteEndpointIPv6 *Multivalue `json:"remoteEndpointIPv6,omitempty"`
	// TunnelType: Tunnel Type
	TunnelType *Multivalue `json:"tunnelType,omitempty"`
	// UseAsMPLSLabel: Use BSID (SID 4 Octet) As MPLS Label
	UseAsMPLSLabel *Multivalue `json:"useAsMPLSLabel,omitempty"`

	BgpSRTEPoliciesSegmentListV4 *TopologyBgpSrtePoliciesSegmentListV4 `json:"bgpSRTEPoliciesSegmentListV4,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ENLPValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ENLPValue",
		isMultivalue: true,
	})
	n.IPv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "IPv6SID",
		isMultivalue: true,
	})
	n.SID4Octet.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "SID4Octet",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AddressFamily.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addressFamily",
		isMultivalue: true,
	})
	n.As4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "as4Number",
		isMultivalue: true,
	})
	n.BindingSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingSIDType",
		isMultivalue: true,
	})
	n.ColorCOBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorCOBits",
		isMultivalue: true,
	})
	n.ColorReservedBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorReservedBits",
		isMultivalue: true,
	})
	n.ColorValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorValue",
		isMultivalue: true,
	})
	n.EnBindingTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enBindingTLV",
		isMultivalue: true,
	})
	n.EnColorTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enColorTLV",
		isMultivalue: true,
	})
	n.EnENLPTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enENLPTLV",
		isMultivalue: true,
	})
	n.EnPolicyNameTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enPolicyNameTLV",
		isMultivalue: true,
	})
	n.EnPolicyPrioritySubTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enPolicyPrioritySubTLV",
		isMultivalue: true,
	})
	n.EnPrefTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enPrefTLV",
		isMultivalue: true,
	})
	n.EnRemoteEndPointTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enRemoteEndPointTLV",
		isMultivalue: true,
	})
	n.NumberOfActiveSegmentList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfActiveSegmentList",
		isMultivalue: true,
	})
	n.PolicyName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyName",
		isMultivalue: true,
	})
	n.PrefValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefValue",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.RemoteEndpointIPv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteEndpointIPv4",
		isMultivalue: true,
	})
	n.RemoteEndpointIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteEndpointIPv6",
		isMultivalue: true,
	})
	n.TunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelType",
		isMultivalue: true,
	})
	n.UseAsMPLSLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useAsMPLSLabel",
		isMultivalue: true,
	})
	n.BgpSRTEPoliciesSegmentListV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesSegmentListV4",
	})
}

// TopologyBgpSrtePoliciesTunnelEncapsulationListV6: TBD
type TopologyBgpSrtePoliciesTunnelEncapsulationListV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ENLPValue: Enable Explicit NULL Label Policy Value
	ENLPValue *Multivalue `json:"ENLPValue,omitempty"`
	// IPv6SID: IPv6 SID
	IPv6SID *Multivalue `json:"IPv6SID,omitempty"`
	// SID4Octet: 4 Octet SID
	SID4Octet *Multivalue `json:"SID4Octet,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AddressFamily: Address Family
	AddressFamily *Multivalue `json:"addressFamily,omitempty"`
	// As4Number: AS Number (4 Octects)
	As4Number *Multivalue `json:"as4Number,omitempty"`
	// BindingSIDType: Binding SID Type
	BindingSIDType *Multivalue `json:"bindingSIDType,omitempty"`
	// ColorCOBits: Color CO Bits
	ColorCOBits *Multivalue `json:"colorCOBits,omitempty"`
	// ColorReservedBits: Color Reserved Bits
	ColorReservedBits *Multivalue `json:"colorReservedBits,omitempty"`
	// ColorValue: Color Value
	ColorValue *Multivalue `json:"colorValue,omitempty"`
	// EnBindingTLV: Enable Binding Sub-TLV
	EnBindingTLV *Multivalue `json:"enBindingTLV,omitempty"`
	// EnColorTLV: Enable Color Sub-TLV
	EnColorTLV *Multivalue `json:"enColorTLV,omitempty"`
	// EnENLPTLV: Enable Explicit NULL Label Policy Sub-TLV
	EnENLPTLV *Multivalue `json:"enENLPTLV,omitempty"`
	// EnPolicyNameTLV: Enable Policy Name Sub-TLV
	EnPolicyNameTLV *Multivalue `json:"enPolicyNameTLV,omitempty"`
	// EnPolicyPrioritySubTLV: Enable Policy Priority Sub-TLV
	EnPolicyPrioritySubTLV *Multivalue `json:"enPolicyPrioritySubTLV,omitempty"`
	// EnPrefTLV: Enable Preference Sub-TLV
	EnPrefTLV *Multivalue `json:"enPrefTLV,omitempty"`
	// EnRemoteEndPointTLV: Enable Remote Endpoint Sub-TLV
	EnRemoteEndPointTLV *Multivalue `json:"enRemoteEndPointTLV,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfActiveSegmentList: TBD
	NumberOfActiveSegmentList *Multivalue `json:"numberOfActiveSegmentList,omitempty"`
	// NumberOfSegmentListV6: Count of Segment Lists Per Tunnel

	NumberOfSegmentListV6 *float32 `json:"numberOfSegmentListV6,omitempty"`
	// PolicyName: Policy Name
	PolicyName *Multivalue `json:"policyName,omitempty"`
	// PrefValue: Preference
	PrefValue *Multivalue `json:"prefValue,omitempty"`
	// Priority: Priority
	Priority *Multivalue `json:"priority,omitempty"`
	// RemoteEndpointIPv4: IPv4 Address
	RemoteEndpointIPv4 *Multivalue `json:"remoteEndpointIPv4,omitempty"`
	// RemoteEndpointIPv6: IPv6 Address
	RemoteEndpointIPv6 *Multivalue `json:"remoteEndpointIPv6,omitempty"`
	// TunnelType: Tunnel Type
	TunnelType *Multivalue `json:"tunnelType,omitempty"`
	// UseAsMPLSLabel: Use BSID (SID 4 Octet) As MPLS Label
	UseAsMPLSLabel *Multivalue `json:"useAsMPLSLabel,omitempty"`

	BgpSRTEPoliciesSegmentListV6 *TopologyBgpSrtePoliciesSegmentListV6 `json:"bgpSRTEPoliciesSegmentListV6,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpSrtePoliciesTunnelEncapsulationListV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ENLPValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ENLPValue",
		isMultivalue: true,
	})
	n.IPv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "IPv6SID",
		isMultivalue: true,
	})
	n.SID4Octet.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "SID4Octet",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AddressFamily.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addressFamily",
		isMultivalue: true,
	})
	n.As4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "as4Number",
		isMultivalue: true,
	})
	n.BindingSIDType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingSIDType",
		isMultivalue: true,
	})
	n.ColorCOBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorCOBits",
		isMultivalue: true,
	})
	n.ColorReservedBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorReservedBits",
		isMultivalue: true,
	})
	n.ColorValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "colorValue",
		isMultivalue: true,
	})
	n.EnBindingTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enBindingTLV",
		isMultivalue: true,
	})
	n.EnColorTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enColorTLV",
		isMultivalue: true,
	})
	n.EnENLPTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enENLPTLV",
		isMultivalue: true,
	})
	n.EnPolicyNameTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enPolicyNameTLV",
		isMultivalue: true,
	})
	n.EnPolicyPrioritySubTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enPolicyPrioritySubTLV",
		isMultivalue: true,
	})
	n.EnPrefTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enPrefTLV",
		isMultivalue: true,
	})
	n.EnRemoteEndPointTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enRemoteEndPointTLV",
		isMultivalue: true,
	})
	n.NumberOfActiveSegmentList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfActiveSegmentList",
		isMultivalue: true,
	})
	n.PolicyName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "policyName",
		isMultivalue: true,
	})
	n.PrefValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefValue",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.RemoteEndpointIPv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteEndpointIPv4",
		isMultivalue: true,
	})
	n.RemoteEndpointIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteEndpointIPv6",
		isMultivalue: true,
	})
	n.TunnelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelType",
		isMultivalue: true,
	})
	n.UseAsMPLSLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useAsMPLSLabel",
		isMultivalue: true,
	})
	n.BgpSRTEPoliciesSegmentListV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "bgpSRTEPoliciesSegmentListV6",
	})
}

// TopologyBgpUmhExportRouteTargetList: Export RouteTarget
type TopologyBgpUmhExportRouteTargetList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetAs4Number: Export Route Target AS4 Number
	TargetAs4Number *Multivalue `json:"targetAs4Number,omitempty"`
	// TargetAsNumber: Export Route Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Export Route Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddress: Export Route Target IP Address
	TargetIpAddress *Multivalue `json:"targetIpAddress,omitempty"`
	// TargetType: Export Route Target Type
	TargetType *Multivalue `json:"targetType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpUmhExportRouteTargetList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpUmhExportRouteTargetList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpUmhExportRouteTargetList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpUmhExportRouteTargetList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.TargetAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAs4Number",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddress",
		isMultivalue: true,
	})
	n.TargetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetType",
		isMultivalue: true,
	})
}

// TopologyBgpUmhImportRouteTargetList: Import RouteTarget
type TopologyBgpUmhImportRouteTargetList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetAs4Number: Import Route Target AS4 Number
	TargetAs4Number *Multivalue `json:"targetAs4Number,omitempty"`
	// TargetAsNumber: Import Route Target AS Number
	TargetAsNumber *Multivalue `json:"targetAsNumber,omitempty"`
	// TargetAssignedNumber: Import Route Target Assigned Number
	TargetAssignedNumber *Multivalue `json:"targetAssignedNumber,omitempty"`
	// TargetIpAddress: Import Route Target IP Address
	TargetIpAddress *Multivalue `json:"targetIpAddress,omitempty"`
	// TargetType: Import Route Target Type
	TargetType *Multivalue `json:"targetType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpUmhImportRouteTargetList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpUmhImportRouteTargetList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpUmhImportRouteTargetList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpUmhImportRouteTargetList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.TargetAs4Number.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAs4Number",
		isMultivalue: true,
	})
	n.TargetAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAsNumber",
		isMultivalue: true,
	})
	n.TargetAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAssignedNumber",
		isMultivalue: true,
	})
	n.TargetIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetIpAddress",
		isMultivalue: true,
	})
	n.TargetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetType",
		isMultivalue: true,
	})
}

// TopologyBgpV6IpRouteProperty: BGP+ Non-VPN IPv4/v6 Route Range Properties
type TopologyBgpV6IpRouteProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"OverridePeerAsSetMode,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AddPathId: BGP ADD Path Id
	AddPathId *Multivalue `json:"addPathId,omitempty"`
	// AdvertiseAsBGPLSPrefix: Advertise as BGP-LS Prefix
	AdvertiseAsBGPLSPrefix *Multivalue `json:"advertiseAsBGPLSPrefix,omitempty"`
	// AdvertiseAsBgp3107: Will cause this route to be sent as BGP 3107 MPLS SAFI route

	AdvertiseAsBgp3107 *bool `json:"advertiseAsBgp3107,omitempty"`
	// AdvertiseAsBgp3107Sr: Will cause this route to be sent as BGP 3107 SR MPLS SAFI route

	AdvertiseAsBgp3107Sr *bool `json:"advertiseAsBgp3107Sr,omitempty"`
	// AdvertiseAsRfc8277: Will cause this route to be sent as RFC 8277 MPLS SAFI route

	AdvertiseAsRfc8277 *bool `json:"advertiseAsRfc8277,omitempty"`
	// AdvertiseAsRfc8277SR: Will cause this route to be sent as RFC 8277 MPLS SAFI route

	AdvertiseAsRfc8277SR *bool `json:"advertiseAsRfc8277SR,omitempty"`
	// AdvertiseNexthopAsV4: Advertise Nexthop as V4
	AdvertiseNexthopAsV4 *Multivalue `json:"advertiseNexthopAsV4,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AggregatorIdMode: Aggregator ID Mode
	AggregatorIdMode *Multivalue `json:"aggregatorIdMode,omitempty"`
	// AsNumSuffixRange: Supported Formats: value value1-value2 Values or value ranges separated by comma(,). e.g. 100,150-200,400,600-800 etc. Cannot be kept empty. Should be >= (Max Number of AS Path Segments) x (Max AS Numbers Per Segment)
	AsNumSuffixRange *Multivalue `json:"asNumSuffixRange,omitempty"`
	// AsPathPerRoute: When there are multiple routes in a route range, this option decides whether to use same or different AS paths randomly generated for all the routes within that route range. For the Different option, each route will be sent in different update messages.
	AsPathPerRoute *Multivalue `json:"asPathPerRoute,omitempty"`
	// AsRandomSeed: Seed value decides the way the AS Values are generated. To generate different AS Paths for different Route ranges, select unique Seed Values.
	AsRandomSeed *Multivalue `json:"asRandomSeed,omitempty"`
	// AsSegDist: Type of AS Segment generated. If user selects Random, then any of the four types (AS-SET, AS-SEQ, AS-SET-CONFEDERATION, AS-SEQ-CONFEDERATION) will get randomly generated.
	AsSegDist *Multivalue `json:"asSegDist,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Delay: Delay in Seconds
	Delay *Multivalue `json:"delay,omitempty"`
	// Downtime: Downtime In Seconds
	Downtime *Multivalue `json:"downtime,omitempty"`
	// EnableAddPath: Enable Path ID when ADD Path Capability is enabled in BGP Peer
	EnableAddPath *Multivalue `json:"enableAddPath,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAigp: Enable AIGP
	EnableAigp *Multivalue `json:"enableAigp,omitempty"`
	// EnableAsPathSegments: Enable Non-Random AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableFlapping: Enable Flapping
	EnableFlapping *Multivalue `json:"enableFlapping,omitempty"`
	// EnableLLNextHop: Enable Link-local address in Next Hop
	EnableLLNextHop *Multivalue `json:"enableLLNextHop,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRandomAsPath: Enables generation/advertisement of Random AS Path Segments.
	EnableRandomAsPath *Multivalue `json:"enableRandomAsPath,omitempty"`
	// EnableSRGB: Enable SRGB TLV
	EnableSRGB *Multivalue `json:"enableSRGB,omitempty"`
	// EnableWeight: Enable Weight
	EnableWeight *Multivalue `json:"enableWeight,omitempty"`
	// FlapFromRouteIndex: Flap From Route Index
	FlapFromRouteIndex *Multivalue `json:"flapFromRouteIndex,omitempty"`
	// FlapToRouteIndex: Flap To Route Index
	FlapToRouteIndex *Multivalue `json:"flapToRouteIndex,omitempty"`
	// IncrementMode: Either Fixed or Increment
	IncrementMode *Multivalue `json:"incrementMode,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LabelEnd: Route Range Label End
	LabelEnd *Multivalue `json:"labelEnd,omitempty"`
	// LabelStart: Route Range Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// LabelStep: Route Range Label Step
	LabelStep *Multivalue `json:"labelStep,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MaxASNumPerSegment: Maximum Number Of AS Numbers generated per Segment
	MaxASNumPerSegment *Multivalue `json:"maxASNumPerSegment,omitempty"`
	// MaxNoOfASPathSegmentsPerRouteRange: Maximum Number Of AS Path Segments Per Route Range.
	MaxNoOfASPathSegmentsPerRouteRange *Multivalue `json:"maxNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MinASNumPerSegment: Minimum Number Of AS Numbers generated per Segments.
	MinASNumPerSegment *Multivalue `json:"minASNumPerSegment,omitempty"`
	// MinNoOfASPathSegmentsPerRouteRange: Minimum Number Of AS Path Segments Per Route Range.
	MinNoOfASPathSegmentsPerRouteRange *Multivalue `json:"minNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextHopIPType: Set Next Hop IP Type
	NextHopIPType *Multivalue `json:"nextHopIPType,omitempty"`
	// NextHopIncrementMode: Next Hop Increment Mode
	NextHopIncrementMode *Multivalue `json:"nextHopIncrementMode,omitempty"`
	// NextHopType: Set Next Hop
	NextHopType *Multivalue `json:"nextHopType,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of non-random or manually configured AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExternalCommunities: Number of Extended Communities

	NoOfExternalCommunities *float32 `json:"noOfExternalCommunities,omitempty"`
	// NoOfLabels: Number of Labels

	NoOfLabels *float32 `json:"noOfLabels,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// NoOfSegmentIds: Number of Segment Ids

	NoOfSegmentIds *float32 `json:"noOfSegmentIds,omitempty"`
	// NoOfTlvs: Number of TLVs

	NoOfTlvs *float32 `json:"noOfTlvs,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// PackingFrom: Packing From
	PackingFrom *Multivalue `json:"packingFrom,omitempty"`
	// PackingTo: Packing To
	PackingTo *Multivalue `json:"packingTo,omitempty"`
	// PartialFlap: Partial Flap
	PartialFlap *Multivalue `json:"partialFlap,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// SegmentId: SID or Segment ID, converts to label value by adding offset into SRGB Start Label Value.
	SegmentId *Multivalue `json:"segmentId,omitempty"`
	// SendMulticastWithProperSAFI: Send Routes with SAFI as Multicast (2)
	SendMulticastWithProperSAFI *Multivalue `json:"sendMulticastWithProperSAFI,omitempty"`
	// SkipMulticast: Skip the Multicast routes for this route range
	SkipMulticast *Multivalue `json:"skipMulticast,omitempty"`
	// SpecialLabel: If we are emulating Egress then Label field may not hold Label value calculated based on SRGB and Offset but Implicit IPv4 NULL or Explicit NULL
	SpecialLabel *Multivalue `json:"specialLabel,omitempty"`
	// Uptime: Uptime In Seconds
	Uptime *Multivalue `json:"uptime,omitempty"`
	// UseTraditionalNlri: Use Traditional NLRI
	UseTraditionalNlri *Multivalue `json:"useTraditionalNlri,omitempty"`
	// Weight: Weight
	Weight                          *Multivalue                                `json:"weight,omitempty"`
	Bgp8277SRSegmentIdList          []*TopologyBgp8277SrSegmentIdList          `json:"Bgp8277SRSegmentIdList"`
	Rfc8277LabelStack               []*TopologyRfc8277LabelStack               `json:"Rfc8277LabelStack"`
	BgpAigpList                     []*TopologyBgpAigpList                     `json:"bgpAigpList"`
	BgpAsPathSegmentList            []*TopologyBgpAsPathSegmentList            `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                []*TopologyBgpClusterIdList                `json:"bgpClusterIdList"`
	BgpCommunitiesList              []*TopologyBgpCommunitiesList              `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList      []*TopologyBgpExtendedCommunitiesList      `json:"bgpExtendedCommunitiesList"`
	BgpNonVPNRRLargeCommunitiesList []*TopologyBgpNonVpnrrLargeCommunitiesList `json:"bgpNonVPNRRLargeCommunitiesList"`
	CMacProperties                  []*TopologyCMacProperties                  `json:"cMacProperties"`
	EvpnIPv4PrefixRange             []*TopologyEvpnIPv4PrefixRange             `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange             []*TopologyEvpnIPv6PrefixRange             `json:"evpnIPv6PrefixRange"`

	GenerateIpv6RoutesParams *TopologyGenerateIpv6RoutesParams `json:"generateIpv6RoutesParams,omitempty"`

	GenerateRoutesParams *TopologyGenerateRoutesParams `json:"generateRoutesParams,omitempty"`

	ImportBgpRoutesParams *TopologyImportBgpRoutesParams `json:"importBgpRoutesParams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpV6IpRouteProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpV6IpRouteProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpV6IpRouteProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpV6IpRouteProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "OverridePeerAsSetMode",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AddPathId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addPathId",
		isMultivalue: true,
	})
	n.AdvertiseAsBGPLSPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseAsBGPLSPrefix",
		isMultivalue: true,
	})
	n.AdvertiseNexthopAsV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseNexthopAsV4",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AggregatorIdMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorIdMode",
		isMultivalue: true,
	})
	n.AsNumSuffixRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumSuffixRange",
		isMultivalue: true,
	})
	n.AsPathPerRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asPathPerRoute",
		isMultivalue: true,
	})
	n.AsRandomSeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asRandomSeed",
		isMultivalue: true,
	})
	n.AsSegDist.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSegDist",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Delay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delay",
		isMultivalue: true,
	})
	n.Downtime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downtime",
		isMultivalue: true,
	})
	n.EnableAddPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAddPath",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAigp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAigp",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableFlapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFlapping",
		isMultivalue: true,
	})
	n.EnableLLNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLLNextHop",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRandomAsPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRandomAsPath",
		isMultivalue: true,
	})
	n.EnableSRGB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSRGB",
		isMultivalue: true,
	})
	n.EnableWeight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWeight",
		isMultivalue: true,
	})
	n.FlapFromRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapFromRouteIndex",
		isMultivalue: true,
	})
	n.FlapToRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapToRouteIndex",
		isMultivalue: true,
	})
	n.IncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "incrementMode",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LabelEnd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelEnd",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.LabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStep",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MaxASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxASNumPerSegment",
		isMultivalue: true,
	})
	n.MaxNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MinASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minASNumPerSegment",
		isMultivalue: true,
	})
	n.MinNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NextHopIPType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIPType",
		isMultivalue: true,
	})
	n.NextHopIncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIncrementMode",
		isMultivalue: true,
	})
	n.NextHopType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.PackingFrom.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingFrom",
		isMultivalue: true,
	})
	n.PackingTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingTo",
		isMultivalue: true,
	})
	n.PartialFlap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partialFlap",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.SegmentId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentId",
		isMultivalue: true,
	})
	n.SendMulticastWithProperSAFI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendMulticastWithProperSAFI",
		isMultivalue: true,
	})
	n.SkipMulticast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "skipMulticast",
		isMultivalue: true,
	})
	n.SpecialLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "specialLabel",
		isMultivalue: true,
	})
	n.Uptime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uptime",
		isMultivalue: true,
	})
	n.UseTraditionalNlri.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useTraditionalNlri",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	for i, o := range n.Bgp8277SRSegmentIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "Bgp8277SRSegmentIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Rfc8277LabelStack {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "Rfc8277LabelStack",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpAigpList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAigpList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpNonVPNRRLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpNonVPNRRLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.GenerateIpv6RoutesParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "generateIpv6RoutesParams",
	})
	n.GenerateRoutesParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "generateRoutesParams",
	})
	n.ImportBgpRoutesParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "importBgpRoutesParams",
	})
}

// TopologyBgpV6L3VpnRouteProperty: BGP+ L3-VPN Route Range Properties
type TopologyBgpV6L3VpnRouteProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"OverridePeerAsSetMode,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID Locator in IGP (ISIS)
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvertiseNexthopAsV4: Advertise Nexthop as V4
	AdvertiseNexthopAsV4 *Multivalue `json:"advertiseNexthopAsV4,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AggregatorIdMode: Aggregator ID Mode
	AggregatorIdMode *Multivalue `json:"aggregatorIdMode,omitempty"`
	// ArgumentLength: Argument Length
	ArgumentLength *Multivalue `json:"argumentLength,omitempty"`
	// AsNumSuffixRange: Supported Formats: value value1-value2 Values or value ranges separated by comma(,). e.g. 100,150-200,400,600-800 etc. Cannot be kept empty. Should be >= (Max Number of AS Path Segments) x (Max AS Numbers Per Segment)
	AsNumSuffixRange *Multivalue `json:"asNumSuffixRange,omitempty"`
	// AsPathPerRoute: When there are multiple routes in a route range, this option decides whether to use same or different AS paths randomly generated for all the routes within that route range. For the Different option, each route will be sent in different update messages.
	AsPathPerRoute *Multivalue `json:"asPathPerRoute,omitempty"`
	// AsRandomSeed: Seed value decides the way the AS Values are generated. To generate different AS Paths for different Route ranges, select unique Seed Values.
	AsRandomSeed *Multivalue `json:"asRandomSeed,omitempty"`
	// AsSegDist: Type of AS Segment generated. If user selects Random, then any of the four types (AS-SET, AS-SEQ, AS-SET-CONFEDERATION, AS-SEQ-CONFEDERATION) will get randomly generated.
	AsSegDist *Multivalue `json:"asSegDist,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// Delay: Delay in Seconds
	Delay *Multivalue `json:"delay,omitempty"`
	// DistinguisherAsNumber: L3VPN RR Distinguisher AS Number (2-byte or 4-Byte)
	DistinguisherAsNumber *Multivalue `json:"distinguisherAsNumber,omitempty"`
	// DistinguisherAssignedNumber: L3VPN RR Distinguisher Assigned Number
	DistinguisherAssignedNumber *Multivalue `json:"distinguisherAssignedNumber,omitempty"`
	// DistinguisherIpAddress: L3VPN RR Distinguisher IP Address
	DistinguisherIpAddress *Multivalue `json:"distinguisherIpAddress,omitempty"`
	// DistinguisherType: L3VPN RR Distinguisher Type
	DistinguisherType *Multivalue `json:"distinguisherType,omitempty"`
	// Downtime: Downtime In Seconds
	Downtime *Multivalue `json:"downtime,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable Non-Random AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableFlapping: Enable Flapping
	EnableFlapping *Multivalue `json:"enableFlapping,omitempty"`
	// EnableIpv6Receiver: Enable IPv6 Receiver

	EnableIpv6Receiver *bool `json:"enableIpv6Receiver,omitempty"`
	// EnableIpv6Sender: Enable IPv6 Sender

	EnableIpv6Sender *bool `json:"enableIpv6Sender,omitempty"`
	// EnableLLNextHop: Enable Link-local address in Next Hop
	EnableLLNextHop *Multivalue `json:"enableLLNextHop,omitempty"`
	// EnableLargeCommunities: Enable Large Communities Attribute
	EnableLargeCommunities *Multivalue `json:"enableLargeCommunities,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableRandomAsPath: Enables generation/advertisement of Random AS Path Segments.
	EnableRandomAsPath *Multivalue `json:"enableRandomAsPath,omitempty"`
	// EnableSrv6Sid: Enable SRv6 SID With VPN Route
	EnableSrv6Sid *Multivalue `json:"enableSrv6Sid,omitempty"`
	// EnableTransposition: Enable Transposition
	EnableTransposition *Multivalue `json:"enableTransposition,omitempty"`
	// EnableWeight: Enable Weight
	EnableWeight *Multivalue `json:"enableWeight,omitempty"`
	// FlapFromRouteIndex: Flap From Route Index
	FlapFromRouteIndex *Multivalue `json:"flapFromRouteIndex,omitempty"`
	// FlapToRouteIndex: Flap To Route Index
	FlapToRouteIndex *Multivalue `json:"flapToRouteIndex,omitempty"`
	// FunctionLength: Function Length
	FunctionLength *Multivalue `json:"functionLength,omitempty"`
	// IncSrv6SidStructSsTlv: Include SRv6 SID Structure Sub-Sub TLV
	IncSrv6SidStructSsTlv *Multivalue `json:"incSrv6SidStructSsTlv,omitempty"`
	// IncludeRdInNextHopLength: If RD is included in NH Len then NH Len is NH size + RD size else NH len is NH size.
	IncludeRdInNextHopLength *Multivalue `json:"includeRdInNextHopLength,omitempty"`
	// IncludeSourceAsExtComm: Include Source AS ExtComm
	IncludeSourceAsExtComm *Multivalue `json:"includeSourceAsExtComm,omitempty"`
	// IncludeVrfRouteImportExtComm: Include VRF Route Import ExtComm
	IncludeVrfRouteImportExtComm *Multivalue `json:"includeVrfRouteImportExtComm,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LabelEnd: L3VPN RR Label End
	LabelEnd *Multivalue `json:"labelEnd,omitempty"`
	// LabelMode: L3VPN RR Label Mode
	LabelMode *Multivalue `json:"labelMode,omitempty"`
	// LabelSpaceId: L3VPN RR Label Space ID
	LabelSpaceId *Multivalue `json:"labelSpaceId,omitempty"`
	// LabelStart: L3VPN RR Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// LabelStep: L3VPN RR Label Step
	LabelStep *Multivalue `json:"labelStep,omitempty"`
	// LocBlockLength: Locator Block Length
	LocBlockLength *Multivalue `json:"locBlockLength,omitempty"`
	// LocNodeLength: Locator Node Length
	LocNodeLength *Multivalue `json:"locNodeLength,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MaxASNumPerSegment: Maximum Number Of AS Numbers generated per Segment
	MaxASNumPerSegment *Multivalue `json:"maxASNumPerSegment,omitempty"`
	// MaxNoOfASPathSegmentsPerRouteRange: Maximum Number Of AS Path Segments Per Route Range.
	MaxNoOfASPathSegmentsPerRouteRange *Multivalue `json:"maxNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MinASNumPerSegment: Minimum Number Of AS Numbers generated per Segments.
	MinASNumPerSegment *Multivalue `json:"minASNumPerSegment,omitempty"`
	// MinNoOfASPathSegmentsPerRouteRange: Minimum Number Of AS Path Segments Per Route Range.
	MinNoOfASPathSegmentsPerRouteRange *Multivalue `json:"minNoOfASPathSegmentsPerRouteRange,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextHopIPType: Set Next Hop IP Type
	NextHopIPType *Multivalue `json:"nextHopIPType,omitempty"`
	// NextHopIncrementMode: Next Hop Increment Mode
	NextHopIncrementMode *Multivalue `json:"nextHopIncrementMode,omitempty"`
	// NextHopType: Set Next Hop
	NextHopType *Multivalue `json:"nextHopType,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of non-random or manually configured AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExternalCommunities: Number of Extended Communities

	NoOfExternalCommunities *float32 `json:"noOfExternalCommunities,omitempty"`
	// NoOfLargeCommunities: Number of Large Communities (Should be in the range 1-32)

	NoOfLargeCommunities *float32 `json:"noOfLargeCommunities,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// PackingFrom: Packing From
	PackingFrom *Multivalue `json:"packingFrom,omitempty"`
	// PackingTo: Packing To
	PackingTo *Multivalue `json:"packingTo,omitempty"`
	// PartialFlap: Partial Flap
	PartialFlap *Multivalue `json:"partialFlap,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags field Value for all route in this Route Range
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidFuncAllocType: SRv6 Func Allocation Type
	Srv6SidFuncAllocType *Multivalue `json:"srv6SidFuncAllocType,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length to be advertised in IGP
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric for advertisement in IGP
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// Srv6SidStep: Route Range SRv6 SID Step
	Srv6SidStep *Multivalue `json:"srv6SidStep,omitempty"`
	// TranspositionAlignment: Transposition Alignment
	TranspositionAlignment *Multivalue `json:"transpositionAlignment,omitempty"`
	// TranspositionLength: Transposition Length
	TranspositionLength *Multivalue `json:"transpositionLength,omitempty"`
	// TranspositionMode: Transposition Mode
	TranspositionMode *Multivalue `json:"transpositionMode,omitempty"`
	// TranspositionOffset: Transposition Offset
	TranspositionOffset *Multivalue `json:"transpositionOffset,omitempty"`
	// Uptime: Uptime In Seconds
	Uptime *Multivalue `json:"uptime,omitempty"`
	// UseAsIpv6UmhRoutes: Use As IPv6 UMH Routes

	UseAsIpv6UmhRoutes *bool `json:"useAsIpv6UmhRoutes,omitempty"`
	// UseAsUmhRoutes: Use As UMH Routes
	UseAsUmhRoutes *Multivalue `json:"useAsUmhRoutes,omitempty"`
	// UseTraditionalNlri: Use Traditional NLRI
	UseTraditionalNlri *Multivalue `json:"useTraditionalNlri,omitempty"`
	// Weight: Weight
	Weight                          *Multivalue                                `json:"weight,omitempty"`
	BgpAsPathSegmentList            []*TopologyBgpAsPathSegmentList            `json:"bgpAsPathSegmentList"`
	BgpClusterIdList                []*TopologyBgpClusterIdList                `json:"bgpClusterIdList"`
	BgpCommunitiesList              []*TopologyBgpCommunitiesList              `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList      []*TopologyBgpExtendedCommunitiesList      `json:"bgpExtendedCommunitiesList"`
	BgpNonVPNRRLargeCommunitiesList []*TopologyBgpNonVpnrrLargeCommunitiesList `json:"bgpNonVPNRRLargeCommunitiesList"`
	CMacProperties                  []*TopologyCMacProperties                  `json:"cMacProperties"`
	EvpnIPv4PrefixRange             []*TopologyEvpnIPv4PrefixRange             `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange             []*TopologyEvpnIPv6PrefixRange             `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpV6L3VpnRouteProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpV6L3VpnRouteProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpV6L3VpnRouteProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpV6L3VpnRouteProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "OverridePeerAsSetMode",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvertiseNexthopAsV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseNexthopAsV4",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AggregatorIdMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorIdMode",
		isMultivalue: true,
	})
	n.ArgumentLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLength",
		isMultivalue: true,
	})
	n.AsNumSuffixRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumSuffixRange",
		isMultivalue: true,
	})
	n.AsPathPerRoute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asPathPerRoute",
		isMultivalue: true,
	})
	n.AsRandomSeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asRandomSeed",
		isMultivalue: true,
	})
	n.AsSegDist.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSegDist",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.Delay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delay",
		isMultivalue: true,
	})
	n.DistinguisherAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherAsNumber",
		isMultivalue: true,
	})
	n.DistinguisherAssignedNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherAssignedNumber",
		isMultivalue: true,
	})
	n.DistinguisherIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherIpAddress",
		isMultivalue: true,
	})
	n.DistinguisherType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distinguisherType",
		isMultivalue: true,
	})
	n.Downtime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downtime",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableFlapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFlapping",
		isMultivalue: true,
	})
	n.EnableLLNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLLNextHop",
		isMultivalue: true,
	})
	n.EnableLargeCommunities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLargeCommunities",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableRandomAsPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRandomAsPath",
		isMultivalue: true,
	})
	n.EnableSrv6Sid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSrv6Sid",
		isMultivalue: true,
	})
	n.EnableTransposition.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTransposition",
		isMultivalue: true,
	})
	n.EnableWeight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWeight",
		isMultivalue: true,
	})
	n.FlapFromRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapFromRouteIndex",
		isMultivalue: true,
	})
	n.FlapToRouteIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapToRouteIndex",
		isMultivalue: true,
	})
	n.FunctionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLength",
		isMultivalue: true,
	})
	n.IncSrv6SidStructSsTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "incSrv6SidStructSsTlv",
		isMultivalue: true,
	})
	n.IncludeRdInNextHopLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeRdInNextHopLength",
		isMultivalue: true,
	})
	n.IncludeSourceAsExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSourceAsExtComm",
		isMultivalue: true,
	})
	n.IncludeVrfRouteImportExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeVrfRouteImportExtComm",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LabelEnd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelEnd",
		isMultivalue: true,
	})
	n.LabelMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelMode",
		isMultivalue: true,
	})
	n.LabelSpaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceId",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.LabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStep",
		isMultivalue: true,
	})
	n.LocBlockLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locBlockLength",
		isMultivalue: true,
	})
	n.LocNodeLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locNodeLength",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MaxASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxASNumPerSegment",
		isMultivalue: true,
	})
	n.MaxNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MinASNumPerSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minASNumPerSegment",
		isMultivalue: true,
	})
	n.MinNoOfASPathSegmentsPerRouteRange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minNoOfASPathSegmentsPerRouteRange",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.NextHopIPType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIPType",
		isMultivalue: true,
	})
	n.NextHopIncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopIncrementMode",
		isMultivalue: true,
	})
	n.NextHopType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextHopType",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.PackingFrom.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingFrom",
		isMultivalue: true,
	})
	n.PackingTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packingTo",
		isMultivalue: true,
	})
	n.PartialFlap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partialFlap",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidFuncAllocType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFuncAllocType",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.Srv6SidStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidStep",
		isMultivalue: true,
	})
	n.TranspositionAlignment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transpositionAlignment",
		isMultivalue: true,
	})
	n.TranspositionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transpositionLength",
		isMultivalue: true,
	})
	n.TranspositionMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transpositionMode",
		isMultivalue: true,
	})
	n.TranspositionOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transpositionOffset",
		isMultivalue: true,
	})
	n.Uptime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uptime",
		isMultivalue: true,
	})
	n.UseAsUmhRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useAsUmhRoutes",
		isMultivalue: true,
	})
	n.UseTraditionalNlri.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useTraditionalNlri",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpNonVPNRRLargeCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpNonVPNRRLargeCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpV6Vrf: BGP IPv6 Peer L3 Site (Range) Configuration
type TopologyBgpV6Vrf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInUmhExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInUmhExportRouteTargetList *float32 `json:"numRtInUmhExportRouteTargetList,omitempty"`
	// NumRtInUmhImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInUmhImportRouteTargetList *float32 `json:"numRtInUmhImportRouteTargetList,omitempty"`
	// SameAsExportRT: Same As Export RT Attribute

	SameAsExportRT *bool `json:"sameAsExportRT,omitempty"`
	// SameAsImportRT: Same As Import RT Attribute

	SameAsImportRT *bool `json:"sameAsImportRT,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs           []Href                                 `json:"-"`
	BgpExportRouteTargetList    []*TopologyBgpExportRouteTargetList    `json:"bgpExportRouteTargetList"`
	BgpImportRouteTargetList    []*TopologyBgpImportRouteTargetList    `json:"bgpImportRouteTargetList"`
	BgpUmhExportRouteTargetList []*TopologyBgpUmhExportRouteTargetList `json:"bgpUmhExportRouteTargetList"`
	BgpUmhImportRouteTargetList []*TopologyBgpUmhImportRouteTargetList `json:"bgpUmhImportRouteTargetList"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpV6Vrf) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpV6Vrf) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpV6Vrf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpV6Vrf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpVrf: BGP IPv4 Peer L3 Site (Range) Configuration
type TopologyBgpVrf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ImportRtListSameAsExportRtList: Import RT List Same As Export RT List

	ImportRtListSameAsExportRtList *bool `json:"importRtListSameAsExportRtList,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumRtInExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInExportRouteTargetList *float32 `json:"numRtInExportRouteTargetList,omitempty"`
	// NumRtInImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInImportRouteTargetList *float32 `json:"numRtInImportRouteTargetList,omitempty"`
	// NumRtInUmhExportRouteTargetList: Number of RTs in Export Route Target List(multiplier)

	NumRtInUmhExportRouteTargetList *float32 `json:"numRtInUmhExportRouteTargetList,omitempty"`
	// NumRtInUmhImportRouteTargetList: Number of RTs in Import Route Target List(multiplier)

	NumRtInUmhImportRouteTargetList *float32 `json:"numRtInUmhImportRouteTargetList,omitempty"`
	// SameAsExportRT: Same As Export RT Attribute

	SameAsExportRT *bool `json:"sameAsExportRT,omitempty"`
	// SameAsImportRT: Same As Import RT Attribute

	SameAsImportRT *bool `json:"sameAsImportRT,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs           []Href                                 `json:"-"`
	BgpExportRouteTargetList    []*TopologyBgpExportRouteTargetList    `json:"bgpExportRouteTargetList"`
	BgpImportRouteTargetList    []*TopologyBgpImportRouteTargetList    `json:"bgpImportRouteTargetList"`
	BgpUmhExportRouteTargetList []*TopologyBgpUmhExportRouteTargetList `json:"bgpUmhExportRouteTargetList"`
	BgpUmhImportRouteTargetList []*TopologyBgpUmhImportRouteTargetList `json:"bgpUmhImportRouteTargetList"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpVrf) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpVrf) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpVrf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpVrf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	for i, o := range n.BgpExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhExportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhExportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpUmhImportRouteTargetList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpUmhImportRouteTargetList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBgpv4BMacMappedIpList: BGPv4 BMAC Mapped IP Configuration
type TopologyBgpv4BMacMappedIpList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// IpAddress: IPv4 Address
	IpAddress *Multivalue `json:"ipAddress,omitempty"`
	// IpType: IP Type
	IpType *Multivalue `json:"ipType,omitempty"`
	// Ipv6Address: IPv6 Address
	Ipv6Address *Multivalue `json:"ipv6Address,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpv4BMacMappedIpList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpv4BMacMappedIpList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpv4BMacMappedIpList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpv4BMacMappedIpList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.IpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddress",
		isMultivalue: true,
	})
	n.IpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipType",
		isMultivalue: true,
	})
	n.Ipv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Address",
		isMultivalue: true,
	})
}

// TopologyBgpv6BMacMappedIpList: BGPv6 BMAC Mapped IP Configuration
type TopologyBgpv6BMacMappedIpList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// IpAddress: IPv4 Address
	IpAddress *Multivalue `json:"ipAddress,omitempty"`
	// IpType: IP Type
	IpType *Multivalue `json:"ipType,omitempty"`
	// Ipv6Address: IPv6 Address
	Ipv6Address *Multivalue `json:"ipv6Address,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBgpv6BMacMappedIpList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBgpv6BMacMappedIpList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBgpv6BMacMappedIpList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBgpv6BMacMappedIpList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.IpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddress",
		isMultivalue: true,
	})
	n.IpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipType",
		isMultivalue: true,
	})
	n.Ipv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Address",
		isMultivalue: true,
	})
}

// TopologyBondedGre: TBD
type TopologyBondedGre struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BypassTraffic: The Bypass Traffic Rate attribute is used to inform the HAAP of the downstream bypass bandwidth for the DSL WAN interface
	BypassTraffic *Multivalue `json:"bypassTraffic,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DslSyncRate: DSL Synchronization Rate is used to notify the HAAP about the downstream bandwidth of the DSL link.
	DslSyncRate *Multivalue `json:"dslSyncRate,omitempty"`
	// IdName: This is a 40-byte string value(Allowed upto 80 bytes). It is used as the identification of the HG in the operator's network.
	IdName *Multivalue `json:"idName,omitempty"`
	// Ipv6Prefix: IPv6 Prefix Assigned to Host
	Ipv6Prefix *Multivalue `json:"ipv6Prefix,omitempty"`
	// Ipv6PrefixLen: IPv6 Prefix length
	Ipv6PrefixLen *Multivalue `json:"ipv6PrefixLen,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TunnelGrp: Displays the Mapping ID of the tunnel
	TunnelGrp *Multivalue `json:"tunnelGrp,omitempty"`
	// TunnelType: Determines the Tunnel type to be used

	TunnelType *string               `json:"tunnelType,omitempty"`
	Tag        []*TopologyTag        `json:"tag"`
	TlvProfile []*TopologyTlvProfile `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBondedGre) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBondedGre) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBondedGre) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBondedGre) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BypassTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bypassTraffic",
		isMultivalue: true,
	})
	n.DslSyncRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dslSyncRate",
		isMultivalue: true,
	})
	n.IdName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "idName",
		isMultivalue: true,
	})
	n.Ipv6Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Prefix",
		isMultivalue: true,
	})
	n.Ipv6PrefixLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6PrefixLen",
		isMultivalue: true,
	})
	n.TunnelGrp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelGrp",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBridgeData: Bridge related configuration settings.
type TopologyBridgeData struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SystemId: 6 Byte System Id in Hex format.
	SystemId *Multivalue `json:"systemId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBridgeData) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBridgeData) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBridgeData) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBridgeData) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
}

// TopologyBroadcastDomainV4: BGP V4 Broadcast Domain Configuration
type TopologyBroadcastDomainV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan  *bool                `json:"usebVlan,omitempty"`
	PnTLVList []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBroadcastDomainV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBroadcastDomainV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBroadcastDomainV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBroadcastDomainV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBroadcastDomainV4Vpws: BGP V4 Broadcast Domain Configuration
type TopologyBroadcastDomainV4Vpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// BackupFlag: Backup Flag
	BackupFlag *Multivalue `json:"backupFlag,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// FxcType: FXC Type
	FxcType *Multivalue `json:"fxcType,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// IncludeVpwsL2AttrExtComm: Include VPWS Layer 2 Attributes Extended Community
	IncludeVpwsL2AttrExtComm *Multivalue `json:"includeVpwsL2AttrExtComm,omitempty"`
	// L2Mtu: L2 MTU
	L2Mtu *Multivalue `json:"l2Mtu,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// PrimaryPE: Primary PE
	PrimaryPE *Multivalue `json:"primaryPE,omitempty"`
	// RemoteServiceId: Remote Service ID
	RemoteServiceId *Multivalue `json:"remoteServiceId,omitempty"`
	// RequireCW: Require CW
	RequireCW *Multivalue `json:"requireCW,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan *bool `json:"usebVlan,omitempty"`
	// VidNormalization: VID Normalization
	VidNormalization *Multivalue          `json:"vidNormalization,omitempty"`
	PnTLVList        []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBroadcastDomainV4Vpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBroadcastDomainV4Vpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBroadcastDomainV4Vpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBroadcastDomainV4Vpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.BackupFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupFlag",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.FxcType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fxcType",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.IncludeVpwsL2AttrExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeVpwsL2AttrExtComm",
		isMultivalue: true,
	})
	n.L2Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "l2Mtu",
		isMultivalue: true,
	})
	n.PrimaryPE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "primaryPE",
		isMultivalue: true,
	})
	n.RemoteServiceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteServiceId",
		isMultivalue: true,
	})
	n.RequireCW.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requireCW",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	n.VidNormalization.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vidNormalization",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBroadcastDomainV4VxlanVpws: BGP V4 Broadcast Domain Configuration
type TopologyBroadcastDomainV4VxlanVpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// BackupFlag: Backup Flag
	BackupFlag *Multivalue `json:"backupFlag,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// FxcType: FXC Type
	FxcType *Multivalue `json:"fxcType,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// IncludeVpwsL2AttrExtComm: Include VPWS Layer 2 Attributes Extended Community
	IncludeVpwsL2AttrExtComm *Multivalue `json:"includeVpwsL2AttrExtComm,omitempty"`
	// L2Mtu: L2 MTU
	L2Mtu *Multivalue `json:"l2Mtu,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// PrimaryPE: Primary PE
	PrimaryPE *Multivalue `json:"primaryPE,omitempty"`
	// RemoteServiceId: Remote Service ID
	RemoteServiceId *Multivalue `json:"remoteServiceId,omitempty"`
	// RequireCW: Require CW
	RequireCW *Multivalue `json:"requireCW,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan *bool `json:"usebVlan,omitempty"`
	// VidNormalization: VID Normalization
	VidNormalization *Multivalue          `json:"vidNormalization,omitempty"`
	PnTLVList        []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBroadcastDomainV4VxlanVpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBroadcastDomainV4VxlanVpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBroadcastDomainV4VxlanVpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBroadcastDomainV4VxlanVpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.BackupFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupFlag",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.FxcType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fxcType",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.IncludeVpwsL2AttrExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeVpwsL2AttrExtComm",
		isMultivalue: true,
	})
	n.L2Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "l2Mtu",
		isMultivalue: true,
	})
	n.PrimaryPE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "primaryPE",
		isMultivalue: true,
	})
	n.RemoteServiceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteServiceId",
		isMultivalue: true,
	})
	n.RequireCW.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requireCW",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	n.VidNormalization.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vidNormalization",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBroadcastDomainV6: BGP V6 Broadcast Domain Configuration
type TopologyBroadcastDomainV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvertiseSRv6SID: Advertise SRv6 SID
	AdvertiseSRv6SID *Multivalue `json:"advertiseSRv6SID,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags Value
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan  *bool                `json:"usebVlan,omitempty"`
	PnTLVList []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBroadcastDomainV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBroadcastDomainV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBroadcastDomainV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBroadcastDomainV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SID",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBroadcastDomainV6Vpws: BGP V6 Broadcast Domain Configuration
type TopologyBroadcastDomainV6Vpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvertiseSRv6SID: Advertise SRv6 SID
	AdvertiseSRv6SID *Multivalue `json:"advertiseSRv6SID,omitempty"`
	// ArgumentLength: Argument Length
	ArgumentLength *Multivalue `json:"argumentLength,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// BackupFlag: Backup Flag
	BackupFlag *Multivalue `json:"backupFlag,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// FunctionLength: Function Length
	FunctionLength *Multivalue `json:"functionLength,omitempty"`
	// FxcType: FXC Type
	FxcType *Multivalue `json:"fxcType,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// IncludeVpwsL2AttrExtComm: Include VPWS Layer 2 Attributes Extended Community
	IncludeVpwsL2AttrExtComm *Multivalue `json:"includeVpwsL2AttrExtComm,omitempty"`
	// L2Mtu: L2 MTU
	L2Mtu *Multivalue `json:"l2Mtu,omitempty"`
	// LocBlockLength: Locator Block Length
	LocBlockLength *Multivalue `json:"locBlockLength,omitempty"`
	// LocNodeLength: Locator Node Length
	LocNodeLength *Multivalue `json:"locNodeLength,omitempty"`
	// MvEnableTransposition: Enable Transposition
	MvEnableTransposition *Multivalue `json:"mvEnableTransposition,omitempty"`
	// MvIncSrv6SidStructSsTlv: Include SRv6 SID Structure Sub-Sub TLV
	MvIncSrv6SidStructSsTlv *Multivalue `json:"mvIncSrv6SidStructSsTlv,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// PrimaryPE: Primary PE
	PrimaryPE *Multivalue `json:"primaryPE,omitempty"`
	// RemoteServiceId: Remote Service ID
	RemoteServiceId *Multivalue `json:"remoteServiceId,omitempty"`
	// RequireCW: Require CW
	RequireCW *Multivalue `json:"requireCW,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags Value
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// TranpositionLength: Transposition Length
	TranpositionLength *Multivalue `json:"tranpositionLength,omitempty"`
	// TranpositionOffset: Transposition Offset
	TranpositionOffset *Multivalue `json:"tranpositionOffset,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan *bool `json:"usebVlan,omitempty"`
	// VidNormalization: VID Normalization
	VidNormalization *Multivalue          `json:"vidNormalization,omitempty"`
	PnTLVList        []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBroadcastDomainV6Vpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBroadcastDomainV6Vpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBroadcastDomainV6Vpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBroadcastDomainV6Vpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SID",
		isMultivalue: true,
	})
	n.ArgumentLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLength",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.BackupFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupFlag",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.FunctionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLength",
		isMultivalue: true,
	})
	n.FxcType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fxcType",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.IncludeVpwsL2AttrExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeVpwsL2AttrExtComm",
		isMultivalue: true,
	})
	n.L2Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "l2Mtu",
		isMultivalue: true,
	})
	n.LocBlockLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locBlockLength",
		isMultivalue: true,
	})
	n.LocNodeLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locNodeLength",
		isMultivalue: true,
	})
	n.MvEnableTransposition.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvEnableTransposition",
		isMultivalue: true,
	})
	n.MvIncSrv6SidStructSsTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvIncSrv6SidStructSsTlv",
		isMultivalue: true,
	})
	n.PrimaryPE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "primaryPE",
		isMultivalue: true,
	})
	n.RemoteServiceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteServiceId",
		isMultivalue: true,
	})
	n.RequireCW.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requireCW",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.TranpositionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tranpositionLength",
		isMultivalue: true,
	})
	n.TranpositionOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tranpositionOffset",
		isMultivalue: true,
	})
	n.VidNormalization.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vidNormalization",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBroadcastDomainV6VxlanVpws: BGP V6 Broadcast Domain Configuration
type TopologyBroadcastDomainV6VxlanVpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdRouteLabel: AD Route Label
	AdRouteLabel *Multivalue `json:"adRouteLabel,omitempty"`
	// BVlanId: B VLAN ID
	BVlanId *Multivalue `json:"bVlanId,omitempty"`
	// BVlanPriority: B VLAN Priority
	BVlanPriority *Multivalue `json:"bVlanPriority,omitempty"`
	// BVlanTpid: B VLAN TPID
	BVlanTpid *Multivalue `json:"bVlanTpid,omitempty"`
	// BackupFlag: Backup Flag
	BackupFlag *Multivalue `json:"backupFlag,omitempty"`
	// EnableVlanAwareService: Enable VLAN Aware Service
	EnableVlanAwareService *Multivalue `json:"enableVlanAwareService,omitempty"`
	// EthernetTagId: Ethernet Tag ID. For VPWS, this acts as VPWS Service ID
	EthernetTagId *Multivalue `json:"ethernetTagId,omitempty"`
	// FxcType: FXC Type
	FxcType *Multivalue `json:"fxcType,omitempty"`
	// GroupAddress: Group Address
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// IncludeVpwsL2AttrExtComm: Include VPWS Layer 2 Attributes Extended Community
	IncludeVpwsL2AttrExtComm *Multivalue `json:"includeVpwsL2AttrExtComm,omitempty"`
	// L2Mtu: L2 MTU
	L2Mtu *Multivalue `json:"l2Mtu,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMacPools: Number of Mac Pools

	NoOfMacPools *float32 `json:"noOfMacPools,omitempty"`
	// PrimaryPE: Primary PE
	PrimaryPE *Multivalue `json:"primaryPE,omitempty"`
	// RemoteServiceId: Remote Service ID
	RemoteServiceId *Multivalue `json:"remoteServiceId,omitempty"`
	// RequireCW: Require CW
	RequireCW *Multivalue `json:"requireCW,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RsvpP2mpId: RSVP P2MP ID
	RsvpP2mpId *Multivalue `json:"rsvpP2mpId,omitempty"`
	// RsvpP2mpIdAsNumber: RSVP P2MP ID as Number
	RsvpP2mpIdAsNumber *Multivalue `json:"rsvpP2mpIdAsNumber,omitempty"`
	// RsvpTunnelId: RSVP Tunnel ID
	RsvpTunnelId *Multivalue `json:"rsvpTunnelId,omitempty"`
	// SenderAddressPRootNodeAddress: Sender Address/P-Root Node Address
	SenderAddressPRootNodeAddress *Multivalue `json:"senderAddressPRootNodeAddress,omitempty"`
	// UsebVlan: Use B-VLAN

	UsebVlan *bool `json:"usebVlan,omitempty"`
	// VidNormalization: VID Normalization
	VidNormalization *Multivalue          `json:"vidNormalization,omitempty"`
	PnTLVList        []*TopologyPnTlvList `json:"pnTLVList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBroadcastDomainV6VxlanVpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBroadcastDomainV6VxlanVpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBroadcastDomainV6VxlanVpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBroadcastDomainV6VxlanVpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdRouteLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adRouteLabel",
		isMultivalue: true,
	})
	n.BVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanId",
		isMultivalue: true,
	})
	n.BVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanPriority",
		isMultivalue: true,
	})
	n.BVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bVlanTpid",
		isMultivalue: true,
	})
	n.BackupFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupFlag",
		isMultivalue: true,
	})
	n.EnableVlanAwareService.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlanAwareService",
		isMultivalue: true,
	})
	n.EthernetTagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ethernetTagId",
		isMultivalue: true,
	})
	n.FxcType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fxcType",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.IncludeVpwsL2AttrExtComm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeVpwsL2AttrExtComm",
		isMultivalue: true,
	})
	n.L2Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "l2Mtu",
		isMultivalue: true,
	})
	n.PrimaryPE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "primaryPE",
		isMultivalue: true,
	})
	n.RemoteServiceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteServiceId",
		isMultivalue: true,
	})
	n.RequireCW.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requireCW",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RsvpP2mpId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpId",
		isMultivalue: true,
	})
	n.RsvpP2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpP2mpIdAsNumber",
		isMultivalue: true,
	})
	n.RsvpTunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rsvpTunnelId",
		isMultivalue: true,
	})
	n.SenderAddressPRootNodeAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "senderAddressPRootNodeAddress",
		isMultivalue: true,
	})
	n.VidNormalization.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vidNormalization",
		isMultivalue: true,
	})
	for i, o := range n.PnTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pnTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyBuckets: Bucket configuration
type TopologyBuckets struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BucketDescription: A description for the bucket.
	BucketDescription *Multivalue `json:"bucketDescription,omitempty"`
	// Multiplier: Number of instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// WatchGroup: A group whose state determines whether this bucket is live or not.
	WatchGroup *Multivalue `json:"watchGroup,omitempty"`
	// WatchPort: A Port whose state determines whether this bucket is live or not.
	WatchPort *Multivalue `json:"watchPort,omitempty"`
	// Weight: Specify the weight of buckets. The permissible range is 0-65535.
	Weight *Multivalue `json:"weight,omitempty"`

	ActionsProfile *TopologyActionsProfile `json:"actionsProfile,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyBuckets) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyBuckets) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyBuckets) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyBuckets) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BucketDescription.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bucketDescription",
		isMultivalue: true,
	})
	n.WatchGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "watchGroup",
		isMultivalue: true,
	})
	n.WatchPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "watchPort",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.ActionsProfile.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "actionsProfile",
	})
}

// TopologyCMacProperties: BGP C-MAC Properties
type TopologyCMacProperties struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ActiveTs: Active TS
	ActiveTs *Multivalue `json:"activeTs,omitempty"`
	// AdvSrv6L2SidInIgp: Advertise SRv6 L2 SID in IGP
	AdvSrv6L2SidInIgp *Multivalue `json:"advSrv6L2SidInIgp,omitempty"`
	// AdvSrv6L3SidInIgp: Advertise SRv6 L3 SID in IGP
	AdvSrv6L3SidInIgp *Multivalue `json:"advSrv6L3SidInIgp,omitempty"`
	// AdvertiseIpv4Address: Advertise IPv4 Address
	AdvertiseIpv4Address *Multivalue `json:"advertiseIpv4Address,omitempty"`
	// AdvertiseIpv6Address: Advertise IPv6 Address
	AdvertiseIpv6Address *Multivalue `json:"advertiseIpv6Address,omitempty"`
	// AdvertiseSRv6L2SID: Advertise SRv6 SID
	AdvertiseSRv6L2SID *Multivalue `json:"advertiseSRv6L2SID,omitempty"`
	// AdvertiseSRv6L3SID: Enable SRv6 L3 SID
	AdvertiseSRv6L3SID *Multivalue `json:"advertiseSRv6L3SID,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// EnableSecondLabel: Enable Second Label (L3)
	EnableSecondLabel *Multivalue `json:"enableSecondLabel,omitempty"`
	// EnableStickyStaticFlag: Enable Sticky/Static Flag
	EnableStickyStaticFlag *Multivalue `json:"enableStickyStaticFlag,omitempty"`
	// EnableUserDefinedSequenceNumber: Enable User Defined Sequence Number
	EnableUserDefinedSequenceNumber *Multivalue `json:"enableUserDefinedSequenceNumber,omitempty"`
	// EviId: EVI ID
	EviId *Multivalue `json:"eviId,omitempty"`
	// FirstLabelStart: First Label (L2) Start
	FirstLabelStart *Multivalue `json:"firstLabelStart,omitempty"`
	// IncludeDefaultGatewayExtendedCommunity: Include Default Gateway Extended Community
	IncludeDefaultGatewayExtendedCommunity *Multivalue `json:"includeDefaultGatewayExtendedCommunity,omitempty"`
	// Ipv4AddressPrefixLength: IPv4 Address Prefix Length which is used to determine the intersubnetting between local and remote host
	Ipv4AddressPrefixLength *Multivalue `json:"ipv4AddressPrefixLength,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6AddressPrefixLength: IPv6 Address Prefix Length which is used to determine the intersubnetting between local and remote host
	Ipv6AddressPrefixLength *Multivalue `json:"ipv6AddressPrefixLength,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LabelMode: Label Mode
	LabelMode *Multivalue `json:"labelMode,omitempty"`
	// LabelStep: Label Step
	LabelStep *Multivalue `json:"labelStep,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// PeerAddress: Peer IP Address
	PeerAddress *Multivalue `json:"peerAddress,omitempty"`
	// SecondLabelStart: Second Label (L3) Start
	SecondLabelStart *Multivalue `json:"secondLabelStart,omitempty"`
	// SendSRv6L3SIDOptionalInfo: If we need to advertise SRv6 L3 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6L3SIDOptionalInfo *Multivalue `json:"sendSRv6L3SIDOptionalInfo,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 L2 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// SequenceNumber: Sequence Number
	SequenceNumber *Multivalue `json:"sequenceNumber,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// Srv6EndpointBehavior: SRv6 L2 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6L2SidFlags: SRv6 L2 SID Flags Value
	Srv6L2SidFlags *Multivalue `json:"srv6L2SidFlags,omitempty"`
	// Srv6L2SidLoc: SRv6 L2 SID. It consists of Locator, Func and Args
	Srv6L2SidLoc *Multivalue `json:"srv6L2SidLoc,omitempty"`
	// Srv6L2SidLocLen: SRv6 L2 SID Locator Length
	Srv6L2SidLocLen *Multivalue `json:"srv6L2SidLocLen,omitempty"`
	// Srv6L2SidLocMetric: SRv6 L2 SID Locator Metric
	Srv6L2SidLocMetric *Multivalue `json:"srv6L2SidLocMetric,omitempty"`
	// Srv6L2SidReserved: SRv6 L2 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6L2SidReserved *Multivalue `json:"srv6L2SidReserved,omitempty"`
	// Srv6L2SidStep: Route Range SRv6 SID Step
	Srv6L2SidStep *Multivalue `json:"srv6L2SidStep,omitempty"`
	// Srv6L3EndpointBehavior: SRv6 L3 Endpoint Behavior field Value for all routes in this Route Range
	Srv6L3EndpointBehavior *Multivalue `json:"srv6L3EndpointBehavior,omitempty"`
	// Srv6L3SIDOptionalInformation: SRv6 L3 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6L3SIDOptionalInformation *Multivalue `json:"srv6L3SIDOptionalInformation,omitempty"`
	// Srv6L3SidFlags: SRv6 L3 SID Flags Value
	Srv6L3SidFlags *Multivalue `json:"srv6L3SidFlags,omitempty"`
	// Srv6L3SidLoc: SRv6 L3 SID. It consists of Locator, Func and Args
	Srv6L3SidLoc *Multivalue `json:"srv6L3SidLoc,omitempty"`
	// Srv6L3SidLocLen: SRv6 L3 SID Locator Length
	Srv6L3SidLocLen *Multivalue `json:"srv6L3SidLocLen,omitempty"`
	// Srv6L3SidLocMetric: SRv6 L3 SID Locator Metric
	Srv6L3SidLocMetric *Multivalue `json:"srv6L3SidLocMetric,omitempty"`
	// Srv6L3SidReserved: SRv6 L3 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6L3SidReserved *Multivalue `json:"srv6L3SidReserved,omitempty"`
	// Srv6L3SidReserved1: SRv6 L3 SID Reserved1 Field for Service Information sub-TLV
	Srv6L3SidReserved1 *Multivalue `json:"srv6L3SidReserved1,omitempty"`
	// Srv6L3SidReserved2: SRv6 L3 SID Reserved2 Field for Service Information sub-TLV
	Srv6L3SidReserved2 *Multivalue `json:"srv6L3SidReserved2,omitempty"`
	// Srv6L3SidStep: Route Range SRv6 SID Step
	Srv6L3SidStep *Multivalue `json:"srv6L3SidStep,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 L2 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SidReserved1: SRv6 L2 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved2: SRv6 L2 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// UseSameSequenceNumber: Use Same Sequence Number
	UseSameSequenceNumber      *Multivalue                           `json:"useSameSequenceNumber,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`
	CMacProperties             []*TopologyCMacProperties             `json:"cMacProperties"`
	EvpnIPv4PrefixRange        []*TopologyEvpnIPv4PrefixRange        `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange        []*TopologyEvpnIPv6PrefixRange        `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCMacProperties) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCMacProperties) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCMacProperties) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCMacProperties) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActiveTs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeTs",
		isMultivalue: true,
	})
	n.AdvSrv6L2SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6L2SidInIgp",
		isMultivalue: true,
	})
	n.AdvSrv6L3SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6L3SidInIgp",
		isMultivalue: true,
	})
	n.AdvertiseIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseIpv4Address",
		isMultivalue: true,
	})
	n.AdvertiseIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseIpv6Address",
		isMultivalue: true,
	})
	n.AdvertiseSRv6L2SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6L2SID",
		isMultivalue: true,
	})
	n.AdvertiseSRv6L3SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6L3SID",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.EnableSecondLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSecondLabel",
		isMultivalue: true,
	})
	n.EnableStickyStaticFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableStickyStaticFlag",
		isMultivalue: true,
	})
	n.EnableUserDefinedSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableUserDefinedSequenceNumber",
		isMultivalue: true,
	})
	n.EviId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eviId",
		isMultivalue: true,
	})
	n.FirstLabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "firstLabelStart",
		isMultivalue: true,
	})
	n.IncludeDefaultGatewayExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeDefaultGatewayExtendedCommunity",
		isMultivalue: true,
	})
	n.Ipv4AddressPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4AddressPrefixLength",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6AddressPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6AddressPrefixLength",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LabelMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelMode",
		isMultivalue: true,
	})
	n.LabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStep",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.PeerAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerAddress",
		isMultivalue: true,
	})
	n.SecondLabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "secondLabelStart",
		isMultivalue: true,
	})
	n.SendSRv6L3SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6L3SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sequenceNumber",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6L2SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L2SidFlags",
		isMultivalue: true,
	})
	n.Srv6L2SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L2SidLoc",
		isMultivalue: true,
	})
	n.Srv6L2SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L2SidLocLen",
		isMultivalue: true,
	})
	n.Srv6L2SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L2SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6L2SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L2SidReserved",
		isMultivalue: true,
	})
	n.Srv6L2SidStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L2SidStep",
		isMultivalue: true,
	})
	n.Srv6L3EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6L3SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6L3SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidFlags",
		isMultivalue: true,
	})
	n.Srv6L3SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidLoc",
		isMultivalue: true,
	})
	n.Srv6L3SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidLocLen",
		isMultivalue: true,
	})
	n.Srv6L3SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6L3SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidReserved",
		isMultivalue: true,
	})
	n.Srv6L3SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidReserved1",
		isMultivalue: true,
	})
	n.Srv6L3SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidReserved2",
		isMultivalue: true,
	})
	n.Srv6L3SidStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6L3SidStep",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.UseSameSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useSameSequenceNumber",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyCakCache: CAK Cache configuration.
type TopologyCakCache struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CakName: CAK Name
	CakName *Multivalue `json:"cakName,omitempty"`
	// CakValue128: 128 bit CAK value
	CakValue128 *Multivalue `json:"cakValue128,omitempty"`
	// CakValue256: 256 bit CAK value
	CakValue256 *Multivalue `json:"cakValue256,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCakCache) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCakCache) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCakCache) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCakCache) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.CakName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cakName",
		isMultivalue: true,
	})
	n.CakValue128.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cakValue128",
		isMultivalue: true,
	})
	n.CakValue256.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cakValue256",
		isMultivalue: true,
	})
}

// TopologyCellTable: The node where learned information is grouped into tables or columns and rows.
type TopologyCellTable struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath         `json:"xpath,omitempty"`
	Col   []*TopologyCol `json:"col"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCellTable) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCellTable) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCellTable) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCellTable) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Col {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "col",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyCfmBridge: TBD
type TopologyCfmBridge struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AllowCfmMaidFormatsinY1731: Allow CFM MAID Formats in Y.1731
	AllowCfmMaidFormatsinY1731 *Multivalue `json:"allowCfmMaidFormatsinY1731,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableOutOfSequenceCcmDetection: Enable Out of Sequence CCM Detection
	EnableOutOfSequenceCcmDetection *Multivalue `json:"enableOutOfSequenceCcmDetection,omitempty"`
	// EncapsulationType: Encapsulation
	EncapsulationType *Multivalue `json:"encapsulationType,omitempty"`
	// EtherType: Ether Type
	EtherType *Multivalue `json:"etherType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfMPs: Number of MPs

	NumberOfMPs *float32 `json:"numberOfMPs,omitempty"`
	// OperationMode: Operation Mode
	OperationMode *Multivalue `json:"operationMode,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	AdvancedLearnedInfoOptions *TopologyAdvancedLearnedInfoOptions `json:"advancedLearnedInfoOptions,omitempty"`

	CfmMp *TopologyCfmMp `json:"cfmMp,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	CustomTLV   *TopologyCustomTlv     `json:"customTLV,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`

	Link *TopologyLink `json:"link,omitempty"`

	MdLevels *TopologyMdLevels `json:"mdLevels,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCfmBridge) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCfmBridge) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCfmBridge) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCfmBridge) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AllowCfmMaidFormatsinY1731.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allowCfmMaidFormatsinY1731",
		isMultivalue: true,
	})
	n.EnableOutOfSequenceCcmDetection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOutOfSequenceCcmDetection",
		isMultivalue: true,
	})
	n.EncapsulationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "encapsulationType",
		isMultivalue: true,
	})
	n.EtherType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "etherType",
		isMultivalue: true,
	})
	n.OperationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "operationMode",
		isMultivalue: true,
	})
	n.AdvancedLearnedInfoOptions.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "advancedLearnedInfoOptions",
	})
	n.CfmMp.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "cfmMp",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.CustomTLV.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "customTLV",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Link.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "link",
	})
	n.MdLevels.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "mdLevels",
	})
}

// TopologyCfmCustomTlvList: TBD
type TopologyCfmCustomTlvList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeTLVinCCM: Include Custom TLV in CCM
	IncludeTLVinCCM *Multivalue `json:"includeTLVinCCM,omitempty"`
	// IncludeTLVinLBM: Include Custom TLV in LBM
	IncludeTLVinLBM *Multivalue `json:"includeTLVinLBM,omitempty"`
	// IncludeTLVinLBR: Include Custom TLV in LBR
	IncludeTLVinLBR *Multivalue `json:"includeTLVinLBR,omitempty"`
	// IncludeTLVinLMM: Include Custom TLV in LMM
	IncludeTLVinLMM *Multivalue `json:"includeTLVinLMM,omitempty"`
	// IncludeTLVinLMR: Include Custom TLV in LMR
	IncludeTLVinLMR *Multivalue `json:"includeTLVinLMR,omitempty"`
	// IncludeTLVinLTM: Include Custom TLV in LTM
	IncludeTLVinLTM *Multivalue `json:"includeTLVinLTM,omitempty"`
	// IncludeTLVinLTR: Include Custom TLV in LTR
	IncludeTLVinLTR *Multivalue `json:"includeTLVinLTR,omitempty"`
	// Length: TLV Length
	Length *Multivalue `json:"length,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Type_: TLV Type
	Type_ *Multivalue `json:"type,omitempty"`
	// Value: TLV Value
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCfmCustomTlvList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCfmCustomTlvList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCfmCustomTlvList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCfmCustomTlvList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.IncludeTLVinCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinCCM",
		isMultivalue: true,
	})
	n.IncludeTLVinLBM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLBM",
		isMultivalue: true,
	})
	n.IncludeTLVinLBR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLBR",
		isMultivalue: true,
	})
	n.IncludeTLVinLMM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLMM",
		isMultivalue: true,
	})
	n.IncludeTLVinLMR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLMR",
		isMultivalue: true,
	})
	n.IncludeTLVinLTM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLTM",
		isMultivalue: true,
	})
	n.IncludeTLVinLTR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLTR",
		isMultivalue: true,
	})
	n.Length.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "length",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyCfmMp: MP exposing network configuration
type TopologyCfmMp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AisEnableUnicastMac: Enable the unicast MAC address of the remote MEP
	AisEnableUnicastMac *Multivalue `json:"aisEnableUnicastMac,omitempty"`
	// AisInterval: Interval
	AisInterval *Multivalue `json:"aisInterval,omitempty"`
	// AisMode: AIS Mode
	AisMode *Multivalue `json:"aisMode,omitempty"`
	// AisPriority: AIS Priority
	AisPriority *Multivalue `json:"aisPriority,omitempty"`
	// AisUnicastMac: The MAC address of the remote MEP.
	AisUnicastMac *Multivalue `json:"aisUnicastMac,omitempty"`
	// AutoDmTimeout: Auto DM Timeout (sec)
	AutoDmTimeout *Multivalue `json:"autoDmTimeout,omitempty"`
	// AutoDmTimer: Auto DM Timer (sec)
	AutoDmTimer *Multivalue `json:"autoDmTimer,omitempty"`
	// AutoLbIteration: Auto LB Iteration
	AutoLbIteration *Multivalue `json:"autoLbIteration,omitempty"`
	// AutoLbTimeoutInSec: Auto LB Timeout (sec)
	AutoLbTimeoutInSec *Multivalue `json:"autoLbTimeoutInSec,omitempty"`
	// AutoLbTimerInSec: Auto LB Timer (sec)
	AutoLbTimerInSec *Multivalue `json:"autoLbTimerInSec,omitempty"`
	// AutoLmIteration: Auto LM Iteration
	AutoLmIteration *Multivalue `json:"autoLmIteration,omitempty"`
	// AutoLmTimeout: Auto LM Timeout (msec)
	AutoLmTimeout *Multivalue `json:"autoLmTimeout,omitempty"`
	// AutoLmTimer: Auto LM Timer (msec)
	AutoLmTimer *Multivalue `json:"autoLmTimer,omitempty"`
	// AutoLtIteration: Auto LT Iteration
	AutoLtIteration *Multivalue `json:"autoLtIteration,omitempty"`
	// AutoLtTimeoutInSec: Auto LT Timeout (sec)
	AutoLtTimeoutInSec *Multivalue `json:"autoLtTimeoutInSec,omitempty"`
	// AutoLtTimerInSec: Auto LT Timer (sec)
	AutoLtTimerInSec *Multivalue `json:"autoLtTimerInSec,omitempty"`
	// AutoLtTtl: TTL
	AutoLtTtl *Multivalue `json:"autoLtTtl,omitempty"`
	// AutodmIteration: Auto DM Iteration
	AutodmIteration *Multivalue `json:"autodmIteration,omitempty"`
	// CVlanId: C-VLAN ID
	CVlanId *Multivalue `json:"cVlanId,omitempty"`
	// CVlanPriority: C-VLAN Priority
	CVlanPriority *Multivalue `json:"cVlanPriority,omitempty"`
	// CVlanTpid: C-VLAN TPID
	CVlanTpid *Multivalue `json:"cVlanTpid,omitempty"`
	// CciInterval: CCI Interval
	CciInterval *Multivalue `json:"cciInterval,omitempty"`
	// CcmLmmTxFcf: CCM/LMM TxFCf
	CcmLmmTxFcf *Multivalue `json:"ccmLmmTxFcf,omitempty"`
	// CcmLmmTxFcfStepPer100mSec: CCM/LMM TxFCf Step/100 msec
	CcmLmmTxFcfStepPer100mSec *Multivalue `json:"ccmLmmTxFcfStepPer100mSec,omitempty"`
	// CcmPriority: CCM Priority
	CcmPriority *Multivalue `json:"ccmPriority,omitempty"`
	// CcmRxFcb: CCM RxFCb
	CcmRxFcb *Multivalue `json:"ccmRxFcb,omitempty"`
	// CcmRxFcbStepPer100mSec: CCM RxFCb Step/100 msec
	CcmRxFcbStepPer100mSec *Multivalue `json:"ccmRxFcbStepPer100mSec,omitempty"`
	// ChassisId: Chassis ID
	ChassisId *Multivalue `json:"chassisId,omitempty"`
	// ChassisIdLength: Chassis ID Length
	ChassisIdLength *Multivalue `json:"chassisIdLength,omitempty"`
	// ChassisIdSubType: Chassis ID SubType
	ChassisIdSubType *Multivalue `json:"chassisIdSubType,omitempty"`
	// DataTlvLength: Data TLV Length
	DataTlvLength *Multivalue `json:"dataTlvLength,omitempty"`
	// DataTlvValue: Data TLV Value
	DataTlvValue *Multivalue `json:"dataTlvValue,omitempty"`
	// DmAllRemoteMeps: DM All Remote MEPS
	DmAllRemoteMeps *Multivalue `json:"dmAllRemoteMeps,omitempty"`
	// DmDestinationMacAddress: DM Destination MAC Address
	DmDestinationMacAddress *Multivalue `json:"dmDestinationMacAddress,omitempty"`
	// DmMethod: DM Method
	DmMethod *Multivalue `json:"dmMethod,omitempty"`
	// DmPriority: DM Priority
	DmPriority *Multivalue `json:"dmPriority,omitempty"`
	// EnableAisRx: Enable AIS Rx
	EnableAisRx *Multivalue `json:"enableAisRx,omitempty"`
	// EnableAutoDm: Enable Auto DM
	EnableAutoDm *Multivalue `json:"enableAutoDm,omitempty"`
	// EnableAutoLb: Enable Auto LB
	EnableAutoLb *Multivalue `json:"enableAutoLb,omitempty"`
	// EnableAutoLm: Enable Auto LM
	EnableAutoLm *Multivalue `json:"enableAutoLm,omitempty"`
	// EnableAutoLt: Enable Auto LT
	EnableAutoLt *Multivalue `json:"enableAutoLt,omitempty"`
	// EnableDataTlv: Enable Data TLV
	EnableDataTlv *Multivalue `json:"enableDataTlv,omitempty"`
	// EnableInterfaceStatusTlv: Enable Interface Status TLV
	EnableInterfaceStatusTlv *Multivalue `json:"enableInterfaceStatusTlv,omitempty"`
	// EnableLckRx: Enable LCK Rx
	EnableLckRx *Multivalue `json:"enableLckRx,omitempty"`
	// EnableLmCounterUpdate: Enable LM Counter Update
	EnableLmCounterUpdate *Multivalue `json:"enableLmCounterUpdate,omitempty"`
	// EnableOrganizationSpecificTlv: Enable Organization Specific TLV
	EnableOrganizationSpecificTlv *Multivalue `json:"enableOrganizationSpecificTlv,omitempty"`
	// EnablePortStatusTlv: Enable Port Status TLV
	EnablePortStatusTlv *Multivalue `json:"enablePortStatusTlv,omitempty"`
	// EnableSenderIdTlv: Enable Sender ID TLV
	EnableSenderIdTlv *Multivalue `json:"enableSenderIdTlv,omitempty"`
	// EnableTstRx: Enable TST Rx
	EnableTstRx *Multivalue `json:"enableTstRx,omitempty"`
	// EnableVlan: Enable VLAN
	EnableVlan *Multivalue `json:"enableVlan,omitempty"`
	// InterRemoteMepRxIncrementStep: Inter Remote MEP Rx Increment Step
	InterRemoteMepRxIncrementStep *Multivalue `json:"interRemoteMepRxIncrementStep,omitempty"`
	// InterRemoteMepTxIncrementStep: Inter Remote MEP Tx Increment Step
	InterRemoteMepTxIncrementStep *Multivalue `json:"interRemoteMepTxIncrementStep,omitempty"`
	// LbAllRemoteMeps: LB All Remote MEPS
	LbAllRemoteMeps *Multivalue `json:"lbAllRemoteMeps,omitempty"`
	// LbDestinationMacAddress: LB Destination MAC Address
	LbDestinationMacAddress *Multivalue `json:"lbDestinationMacAddress,omitempty"`
	// LbmPriority: LBM Priority
	LbmPriority *Multivalue `json:"lbmPriority,omitempty"`
	// LckEnableUnicastMac: Enable Unicast MAC
	LckEnableUnicastMac *Multivalue `json:"lckEnableUnicastMac,omitempty"`
	// LckInterval: Interval
	LckInterval *Multivalue `json:"lckInterval,omitempty"`
	// LckMode: LCK Mode
	LckMode *Multivalue `json:"lckMode,omitempty"`
	// LckPriority: LCK Priority
	LckPriority *Multivalue `json:"lckPriority,omitempty"`
	// LckSupportAisGeneration: Support AIS Generation
	LckSupportAisGeneration *Multivalue `json:"lckSupportAisGeneration,omitempty"`
	// LckUnicastMac: Unicast MAC
	LckUnicastMac *Multivalue `json:"lckUnicastMac,omitempty"`
	// LmAllRemoteMeps: LM All Remote MEPS
	LmAllRemoteMeps *Multivalue `json:"lmAllRemoteMeps,omitempty"`
	// LmDestinationMacAddress: LM Destination MAC Address
	LmDestinationMacAddress *Multivalue `json:"lmDestinationMacAddress,omitempty"`
	// LmMethodType: LM Method
	LmMethodType *Multivalue `json:"lmMethodType,omitempty"`
	// LmmPriority: LMM Priority
	LmmPriority *Multivalue `json:"lmmPriority,omitempty"`
	// LmrPriority: LMR Priority
	LmrPriority *Multivalue `json:"lmrPriority,omitempty"`
	// LmrRxFcf: LMR RxFCf
	LmrRxFcf *Multivalue `json:"lmrRxFcf,omitempty"`
	// LmrRxFcfStepPer100mSec: LMR RxFCf Step/100 msec
	LmrRxFcfStepPer100mSec *Multivalue `json:"lmrRxFcfStepPer100mSec,omitempty"`
	// LmrTxFcb: LMR TxFCb (CCM/LLM TxFCf)
	LmrTxFcb *Multivalue `json:"lmrTxFcb,omitempty"`
	// LmrTxFcbStepPer100mSec: LMR TxFCb Step/100 msec (CCM/LMM TxFCf Step / 100 msec)
	LmrTxFcbStepPer100mSec *Multivalue `json:"lmrTxFcbStepPer100mSec,omitempty"`
	// LtAllRemoteMeps: LT All Remote MEPS
	LtAllRemoteMeps *Multivalue `json:"ltAllRemoteMeps,omitempty"`
	// LtDestinationMacAddress: LT Destination MAC Address
	LtDestinationMacAddress *Multivalue `json:"ltDestinationMacAddress,omitempty"`
	// LtmPriority: LTM Priority
	LtmPriority *Multivalue `json:"ltmPriority,omitempty"`
	// ManagementAddress: Management Address
	ManagementAddress *Multivalue `json:"managementAddress,omitempty"`
	// ManagementAddressDomain: Management Address Domain
	ManagementAddressDomain *Multivalue `json:"managementAddressDomain,omitempty"`
	// ManagementAddressDomainLength: Management Address Domain Length
	ManagementAddressDomainLength *Multivalue `json:"managementAddressDomainLength,omitempty"`
	// ManagementAddressLength: Management Address Length
	ManagementAddressLength *Multivalue `json:"managementAddressLength,omitempty"`
	// MdMegLevel: MD/MEG Level
	MdMegLevel *Multivalue `json:"mdMegLevel,omitempty"`
	// MdName: MD Name For MAC + Int, Please Use MAC-Int eg. 11:22:33:44:55:66-1 For Others, Use Any String
	MdName *Multivalue `json:"mdName,omitempty"`
	// MdNameFormat: MD Name Format
	MdNameFormat *Multivalue `json:"mdNameFormat,omitempty"`
	// MegId: MEG ID
	MegId *Multivalue `json:"megId,omitempty"`
	// MegIdFormat: MEG ID Format
	MegIdFormat *Multivalue `json:"megIdFormat,omitempty"`
	// MepId: MP ID
	MepId *Multivalue `json:"mepId,omitempty"`
	// MpType: Type
	MpType *Multivalue `json:"mpType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfCustomTLVs: Number of Custom TLVs

	NumberOfCustomTLVs *float32 `json:"numberOfCustomTLVs,omitempty"`
	// OrganizationSpecificTlvLength: Organization Specific TLV Length
	OrganizationSpecificTlvLength *Multivalue `json:"organizationSpecificTlvLength,omitempty"`
	// OrganizationSpecificTlvValue: Organization Specific TLV Value
	OrganizationSpecificTlvValue *Multivalue `json:"organizationSpecificTlvValue,omitempty"`
	// OverrideVlanPriority: Override VLAN Priority
	OverrideVlanPriority *Multivalue `json:"overrideVlanPriority,omitempty"`
	// Rdi: RDI (Auto Update/On/Off)
	Rdi *Multivalue `json:"rdi,omitempty"`
	// SVlanId: S-VLAN ID
	SVlanId *Multivalue `json:"sVlanId,omitempty"`
	// SVlanPriority: S-VLAN Priority
	SVlanPriority *Multivalue `json:"sVlanPriority,omitempty"`
	// SVlanTpid: S-VLAN TPID
	SVlanTpid *Multivalue `json:"sVlanTpid,omitempty"`
	// ShortMaName: Short MA Name
	ShortMaName *Multivalue `json:"shortMaName,omitempty"`
	// ShortMaNameFormat: Short MA Name Format
	ShortMaNameFormat *Multivalue `json:"shortMaNameFormat,omitempty"`
	// TstEnableUnicastMac: Enable Unicast MAC
	TstEnableUnicastMac *Multivalue `json:"tstEnableUnicastMac,omitempty"`
	// TstIncrementPacketLength: Increment Packet Length
	TstIncrementPacketLength *Multivalue `json:"tstIncrementPacketLength,omitempty"`
	// TstInitialPatternValue: Initial Pattern Value
	TstInitialPatternValue *Multivalue `json:"tstInitialPatternValue,omitempty"`
	// TstInterval: Interval (ms)
	TstInterval *Multivalue `json:"tstInterval,omitempty"`
	// TstMode: TST Mode
	TstMode *Multivalue `json:"tstMode,omitempty"`
	// TstOverwriteSequenceNumber: Overwrite Sequence Number
	TstOverwriteSequenceNumber *Multivalue `json:"tstOverwriteSequenceNumber,omitempty"`
	// TstPacketLength: Packet Length
	TstPacketLength *Multivalue `json:"tstPacketLength,omitempty"`
	// TstPacketLengthStep: Increment Packet Length Step
	TstPacketLengthStep *Multivalue `json:"tstPacketLengthStep,omitempty"`
	// TstPatternType: Pattern Type
	TstPatternType *Multivalue `json:"tstPatternType,omitempty"`
	// TstPriority: TST Priority
	TstPriority *Multivalue `json:"tstPriority,omitempty"`
	// TstSequenceNumber: Sequence Number
	TstSequenceNumber *Multivalue `json:"tstSequenceNumber,omitempty"`
	// TstTestType: Test Type
	TstTestType *Multivalue `json:"tstTestType,omitempty"`
	// TstUnicastMac: Unicast MAC
	TstUnicastMac *Multivalue `json:"tstUnicastMac,omitempty"`
	// VlanId: VLAN ID
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// VlanPriority: VLAN Priority
	VlanPriority *Multivalue `json:"vlanPriority,omitempty"`
	// VlanStacking: VLAN Stacking
	VlanStacking *Multivalue `json:"vlanStacking,omitempty"`
	// VlanTpid: VLAN TPID
	VlanTpid         *Multivalue                 `json:"vlanTpid,omitempty"`
	CfmCustomTLVList []*TopologyCfmCustomTlvList `json:"cfmCustomTLVList"`

	StartCCMEmulatedMpParams *TopologyStartCcmEmulatedMpParams `json:"start_CCM_emulated_mpParams,omitempty"`

	StopCCMEmulatedMpParams *TopologyStopCcmEmulatedMpParams `json:"stop_CCM_emulated_mpParams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCfmMp) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCfmMp) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCfmMp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCfmMp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AisEnableUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisEnableUnicastMac",
		isMultivalue: true,
	})
	n.AisInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisInterval",
		isMultivalue: true,
	})
	n.AisMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisMode",
		isMultivalue: true,
	})
	n.AisPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisPriority",
		isMultivalue: true,
	})
	n.AisUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisUnicastMac",
		isMultivalue: true,
	})
	n.AutoDmTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoDmTimeout",
		isMultivalue: true,
	})
	n.AutoDmTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoDmTimer",
		isMultivalue: true,
	})
	n.AutoLbIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLbIteration",
		isMultivalue: true,
	})
	n.AutoLbTimeoutInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLbTimeoutInSec",
		isMultivalue: true,
	})
	n.AutoLbTimerInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLbTimerInSec",
		isMultivalue: true,
	})
	n.AutoLmIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLmIteration",
		isMultivalue: true,
	})
	n.AutoLmTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLmTimeout",
		isMultivalue: true,
	})
	n.AutoLmTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLmTimer",
		isMultivalue: true,
	})
	n.AutoLtIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtIteration",
		isMultivalue: true,
	})
	n.AutoLtTimeoutInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtTimeoutInSec",
		isMultivalue: true,
	})
	n.AutoLtTimerInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtTimerInSec",
		isMultivalue: true,
	})
	n.AutoLtTtl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtTtl",
		isMultivalue: true,
	})
	n.AutodmIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autodmIteration",
		isMultivalue: true,
	})
	n.CVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanId",
		isMultivalue: true,
	})
	n.CVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanPriority",
		isMultivalue: true,
	})
	n.CVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanTpid",
		isMultivalue: true,
	})
	n.CciInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cciInterval",
		isMultivalue: true,
	})
	n.CcmLmmTxFcf.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmLmmTxFcf",
		isMultivalue: true,
	})
	n.CcmLmmTxFcfStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmLmmTxFcfStepPer100mSec",
		isMultivalue: true,
	})
	n.CcmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmPriority",
		isMultivalue: true,
	})
	n.CcmRxFcb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmRxFcb",
		isMultivalue: true,
	})
	n.CcmRxFcbStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmRxFcbStepPer100mSec",
		isMultivalue: true,
	})
	n.ChassisId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chassisId",
		isMultivalue: true,
	})
	n.ChassisIdLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chassisIdLength",
		isMultivalue: true,
	})
	n.ChassisIdSubType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chassisIdSubType",
		isMultivalue: true,
	})
	n.DataTlvLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataTlvLength",
		isMultivalue: true,
	})
	n.DataTlvValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataTlvValue",
		isMultivalue: true,
	})
	n.DmAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmAllRemoteMeps",
		isMultivalue: true,
	})
	n.DmDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmDestinationMacAddress",
		isMultivalue: true,
	})
	n.DmMethod.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmMethod",
		isMultivalue: true,
	})
	n.DmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmPriority",
		isMultivalue: true,
	})
	n.EnableAisRx.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAisRx",
		isMultivalue: true,
	})
	n.EnableAutoDm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoDm",
		isMultivalue: true,
	})
	n.EnableAutoLb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoLb",
		isMultivalue: true,
	})
	n.EnableAutoLm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoLm",
		isMultivalue: true,
	})
	n.EnableAutoLt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoLt",
		isMultivalue: true,
	})
	n.EnableDataTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDataTlv",
		isMultivalue: true,
	})
	n.EnableInterfaceStatusTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableInterfaceStatusTlv",
		isMultivalue: true,
	})
	n.EnableLckRx.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLckRx",
		isMultivalue: true,
	})
	n.EnableLmCounterUpdate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLmCounterUpdate",
		isMultivalue: true,
	})
	n.EnableOrganizationSpecificTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrganizationSpecificTlv",
		isMultivalue: true,
	})
	n.EnablePortStatusTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePortStatusTlv",
		isMultivalue: true,
	})
	n.EnableSenderIdTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSenderIdTlv",
		isMultivalue: true,
	})
	n.EnableTstRx.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTstRx",
		isMultivalue: true,
	})
	n.EnableVlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlan",
		isMultivalue: true,
	})
	n.InterRemoteMepRxIncrementStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interRemoteMepRxIncrementStep",
		isMultivalue: true,
	})
	n.InterRemoteMepTxIncrementStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interRemoteMepTxIncrementStep",
		isMultivalue: true,
	})
	n.LbAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lbAllRemoteMeps",
		isMultivalue: true,
	})
	n.LbDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lbDestinationMacAddress",
		isMultivalue: true,
	})
	n.LbmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lbmPriority",
		isMultivalue: true,
	})
	n.LckEnableUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckEnableUnicastMac",
		isMultivalue: true,
	})
	n.LckInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckInterval",
		isMultivalue: true,
	})
	n.LckMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckMode",
		isMultivalue: true,
	})
	n.LckPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckPriority",
		isMultivalue: true,
	})
	n.LckSupportAisGeneration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckSupportAisGeneration",
		isMultivalue: true,
	})
	n.LckUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckUnicastMac",
		isMultivalue: true,
	})
	n.LmAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmAllRemoteMeps",
		isMultivalue: true,
	})
	n.LmDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmDestinationMacAddress",
		isMultivalue: true,
	})
	n.LmMethodType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmMethodType",
		isMultivalue: true,
	})
	n.LmmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmmPriority",
		isMultivalue: true,
	})
	n.LmrPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrPriority",
		isMultivalue: true,
	})
	n.LmrRxFcf.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrRxFcf",
		isMultivalue: true,
	})
	n.LmrRxFcfStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrRxFcfStepPer100mSec",
		isMultivalue: true,
	})
	n.LmrTxFcb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrTxFcb",
		isMultivalue: true,
	})
	n.LmrTxFcbStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrTxFcbStepPer100mSec",
		isMultivalue: true,
	})
	n.LtAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ltAllRemoteMeps",
		isMultivalue: true,
	})
	n.LtDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ltDestinationMacAddress",
		isMultivalue: true,
	})
	n.LtmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ltmPriority",
		isMultivalue: true,
	})
	n.ManagementAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddress",
		isMultivalue: true,
	})
	n.ManagementAddressDomain.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddressDomain",
		isMultivalue: true,
	})
	n.ManagementAddressDomainLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddressDomainLength",
		isMultivalue: true,
	})
	n.ManagementAddressLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddressLength",
		isMultivalue: true,
	})
	n.MdMegLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdMegLevel",
		isMultivalue: true,
	})
	n.MdName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdName",
		isMultivalue: true,
	})
	n.MdNameFormat.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdNameFormat",
		isMultivalue: true,
	})
	n.MegId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "megId",
		isMultivalue: true,
	})
	n.MegIdFormat.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "megIdFormat",
		isMultivalue: true,
	})
	n.MepId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mepId",
		isMultivalue: true,
	})
	n.MpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mpType",
		isMultivalue: true,
	})
	n.OrganizationSpecificTlvLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "organizationSpecificTlvLength",
		isMultivalue: true,
	})
	n.OrganizationSpecificTlvValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "organizationSpecificTlvValue",
		isMultivalue: true,
	})
	n.OverrideVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideVlanPriority",
		isMultivalue: true,
	})
	n.Rdi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdi",
		isMultivalue: true,
	})
	n.SVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanId",
		isMultivalue: true,
	})
	n.SVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanPriority",
		isMultivalue: true,
	})
	n.SVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanTpid",
		isMultivalue: true,
	})
	n.ShortMaName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shortMaName",
		isMultivalue: true,
	})
	n.ShortMaNameFormat.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shortMaNameFormat",
		isMultivalue: true,
	})
	n.TstEnableUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstEnableUnicastMac",
		isMultivalue: true,
	})
	n.TstIncrementPacketLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstIncrementPacketLength",
		isMultivalue: true,
	})
	n.TstInitialPatternValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstInitialPatternValue",
		isMultivalue: true,
	})
	n.TstInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstInterval",
		isMultivalue: true,
	})
	n.TstMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstMode",
		isMultivalue: true,
	})
	n.TstOverwriteSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstOverwriteSequenceNumber",
		isMultivalue: true,
	})
	n.TstPacketLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPacketLength",
		isMultivalue: true,
	})
	n.TstPacketLengthStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPacketLengthStep",
		isMultivalue: true,
	})
	n.TstPatternType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPatternType",
		isMultivalue: true,
	})
	n.TstPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPriority",
		isMultivalue: true,
	})
	n.TstSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstSequenceNumber",
		isMultivalue: true,
	})
	n.TstTestType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstTestType",
		isMultivalue: true,
	})
	n.TstUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstUnicastMac",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
	n.VlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanPriority",
		isMultivalue: true,
	})
	n.VlanStacking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanStacking",
		isMultivalue: true,
	})
	n.VlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanTpid",
		isMultivalue: true,
	})
	for i, o := range n.CfmCustomTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmCustomTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.StartCCMEmulatedMpParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "start_CCM_emulated_mpParams",
	})
	n.StopCCMEmulatedMpParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stop_CCM_emulated_mpParams",
	})
}

// TopologyCfmSimulatedLinks: Information for Simulated Links between Simulated MPs
type TopologyCfmSimulatedLinks struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Simulated Link
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCfmSimulatedLinks) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCfmSimulatedLinks) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCfmSimulatedLinks) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCfmSimulatedLinks) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyCfmSimulatedMp: Simulated Node Information
type TopologyCfmSimulatedMp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AisEnableUnicastMac: Enable the unicast MAC address of the remote MEP
	AisEnableUnicastMac *Multivalue `json:"aisEnableUnicastMac,omitempty"`
	// AisInterval: Interval
	AisInterval *Multivalue `json:"aisInterval,omitempty"`
	// AisMode: AIS Mode
	AisMode *Multivalue `json:"aisMode,omitempty"`
	// AisPriority: AIS Priority
	AisPriority *Multivalue `json:"aisPriority,omitempty"`
	// AisUnicastMac: The MAC address of the remote MEP.
	AisUnicastMac *Multivalue `json:"aisUnicastMac,omitempty"`
	// AutoDmTimeout: Auto DM Timeout (sec)
	AutoDmTimeout *Multivalue `json:"autoDmTimeout,omitempty"`
	// AutoDmTimer: Auto DM Timer (sec)
	AutoDmTimer *Multivalue `json:"autoDmTimer,omitempty"`
	// AutoLbIteration: Auto LB Iteration
	AutoLbIteration *Multivalue `json:"autoLbIteration,omitempty"`
	// AutoLbTimeoutInSec: Auto LB Timeout (sec)
	AutoLbTimeoutInSec *Multivalue `json:"autoLbTimeoutInSec,omitempty"`
	// AutoLbTimerInSec: Auto LB Timer (sec)
	AutoLbTimerInSec *Multivalue `json:"autoLbTimerInSec,omitempty"`
	// AutoLmIteration: Auto LM Iteration
	AutoLmIteration *Multivalue `json:"autoLmIteration,omitempty"`
	// AutoLmTimeout: Auto LM Timeout (msec)
	AutoLmTimeout *Multivalue `json:"autoLmTimeout,omitempty"`
	// AutoLmTimer: Auto LM Timer (msec)
	AutoLmTimer *Multivalue `json:"autoLmTimer,omitempty"`
	// AutoLtIteration: Auto LT Iteration
	AutoLtIteration *Multivalue `json:"autoLtIteration,omitempty"`
	// AutoLtTimeoutInSec: Auto LT Timeout (sec)
	AutoLtTimeoutInSec *Multivalue `json:"autoLtTimeoutInSec,omitempty"`
	// AutoLtTimerInSec: Auto LT Timer (sec)
	AutoLtTimerInSec *Multivalue `json:"autoLtTimerInSec,omitempty"`
	// AutoLtTtl: TTL
	AutoLtTtl *Multivalue `json:"autoLtTtl,omitempty"`
	// AutodmIteration: Auto DM Iteration
	AutodmIteration *Multivalue `json:"autodmIteration,omitempty"`
	// CVlanId: C-VLAN ID
	CVlanId *Multivalue `json:"cVlanId,omitempty"`
	// CVlanPriority: C-VLAN Priority
	CVlanPriority *Multivalue `json:"cVlanPriority,omitempty"`
	// CVlanTpid: C-VLAN TPID
	CVlanTpid *Multivalue `json:"cVlanTpid,omitempty"`
	// CciInterval: CCI Interval
	CciInterval *Multivalue `json:"cciInterval,omitempty"`
	// CcmLmmTxFcf: CCM/LMM TxFCf
	CcmLmmTxFcf *Multivalue `json:"ccmLmmTxFcf,omitempty"`
	// CcmLmmTxFcfStepPer100mSec: CCM/LMM TxFCf Step/100 msec
	CcmLmmTxFcfStepPer100mSec *Multivalue `json:"ccmLmmTxFcfStepPer100mSec,omitempty"`
	// CcmPriority: CCM Priority
	CcmPriority *Multivalue `json:"ccmPriority,omitempty"`
	// CcmRxFcb: CCM RxFCb
	CcmRxFcb *Multivalue `json:"ccmRxFcb,omitempty"`
	// CcmRxFcbStepPer100mSec: CCM RxFCb Step/100 msec
	CcmRxFcbStepPer100mSec *Multivalue `json:"ccmRxFcbStepPer100mSec,omitempty"`
	// ChassisId: Chassis ID
	ChassisId *Multivalue `json:"chassisId,omitempty"`
	// ChassisIdLength: Chassis ID Length
	ChassisIdLength *Multivalue `json:"chassisIdLength,omitempty"`
	// ChassisIdSubType: Chassis ID SubType
	ChassisIdSubType *Multivalue `json:"chassisIdSubType,omitempty"`
	// DataTlvLength: Data TLV Length
	DataTlvLength *Multivalue `json:"dataTlvLength,omitempty"`
	// DataTlvValue: Data TLV Value
	DataTlvValue *Multivalue `json:"dataTlvValue,omitempty"`
	// DmAllRemoteMeps: DM All Remote MEPS
	DmAllRemoteMeps *Multivalue `json:"dmAllRemoteMeps,omitempty"`
	// DmDestinationMacAddress: DM Destination MAC Address
	DmDestinationMacAddress *Multivalue `json:"dmDestinationMacAddress,omitempty"`
	// DmMethod: DM Method
	DmMethod *Multivalue `json:"dmMethod,omitempty"`
	// DmPriority: DM Priority
	DmPriority *Multivalue `json:"dmPriority,omitempty"`
	// EnableAisRx: Enable AIS Rx
	EnableAisRx *Multivalue `json:"enableAisRx,omitempty"`
	// EnableAutoDm: Enable Auto DM
	EnableAutoDm *Multivalue `json:"enableAutoDm,omitempty"`
	// EnableAutoLb: Enable Auto LB
	EnableAutoLb *Multivalue `json:"enableAutoLb,omitempty"`
	// EnableAutoLm: Enable Auto LM
	EnableAutoLm *Multivalue `json:"enableAutoLm,omitempty"`
	// EnableAutoLt: Enable Auto LT
	EnableAutoLt *Multivalue `json:"enableAutoLt,omitempty"`
	// EnableDataTlv: Enable Data TLV
	EnableDataTlv *Multivalue `json:"enableDataTlv,omitempty"`
	// EnableInterfaceStatusTlv: Enable Interface Status TLV
	EnableInterfaceStatusTlv *Multivalue `json:"enableInterfaceStatusTlv,omitempty"`
	// EnableLckRx: Enable LCK Rx
	EnableLckRx *Multivalue `json:"enableLckRx,omitempty"`
	// EnableLmCounterUpdate: Enable LM Counter Update
	EnableLmCounterUpdate *Multivalue `json:"enableLmCounterUpdate,omitempty"`
	// EnableOrganizationSpecificTlv: Enable Organization Specific TLV
	EnableOrganizationSpecificTlv *Multivalue `json:"enableOrganizationSpecificTlv,omitempty"`
	// EnablePortStatusTlv: Enable Port Status TLV
	EnablePortStatusTlv *Multivalue `json:"enablePortStatusTlv,omitempty"`
	// EnableSenderIdTlv: Enable Sender ID TLV
	EnableSenderIdTlv *Multivalue `json:"enableSenderIdTlv,omitempty"`
	// EnableTstRx: Enable TST Rx
	EnableTstRx *Multivalue `json:"enableTstRx,omitempty"`
	// EnableVlan: Enable VLAN
	EnableVlan *Multivalue `json:"enableVlan,omitempty"`
	// InterRemoteMepRxIncrementStep: Inter Remote MEP Rx Increment Step
	InterRemoteMepRxIncrementStep *Multivalue `json:"interRemoteMepRxIncrementStep,omitempty"`
	// InterRemoteMepTxIncrementStep: Inter Remote MEP Tx Increment Step
	InterRemoteMepTxIncrementStep *Multivalue `json:"interRemoteMepTxIncrementStep,omitempty"`
	// LbAllRemoteMeps: LB All Remote MEPS
	LbAllRemoteMeps *Multivalue `json:"lbAllRemoteMeps,omitempty"`
	// LbDestinationMacAddress: LB Destination MAC Address
	LbDestinationMacAddress *Multivalue `json:"lbDestinationMacAddress,omitempty"`
	// LbmPriority: LBM Priority
	LbmPriority *Multivalue `json:"lbmPriority,omitempty"`
	// LckEnableUnicastMac: Enable Unicast MAC
	LckEnableUnicastMac *Multivalue `json:"lckEnableUnicastMac,omitempty"`
	// LckInterval: Interval
	LckInterval *Multivalue `json:"lckInterval,omitempty"`
	// LckMode: LCK Mode
	LckMode *Multivalue `json:"lckMode,omitempty"`
	// LckPriority: LCK Priority
	LckPriority *Multivalue `json:"lckPriority,omitempty"`
	// LckSupportAisGeneration: Support AIS Generation
	LckSupportAisGeneration *Multivalue `json:"lckSupportAisGeneration,omitempty"`
	// LckUnicastMac: Unicast MAC
	LckUnicastMac *Multivalue `json:"lckUnicastMac,omitempty"`
	// LmAllRemoteMeps: LM All Remote MEPS
	LmAllRemoteMeps *Multivalue `json:"lmAllRemoteMeps,omitempty"`
	// LmDestinationMacAddress: LM Destination MAC Address
	LmDestinationMacAddress *Multivalue `json:"lmDestinationMacAddress,omitempty"`
	// LmMethodType: LM Method
	LmMethodType *Multivalue `json:"lmMethodType,omitempty"`
	// LmmPriority: LMM Priority
	LmmPriority *Multivalue `json:"lmmPriority,omitempty"`
	// LmrPriority: LMR Priority
	LmrPriority *Multivalue `json:"lmrPriority,omitempty"`
	// LmrRxFcf: LMR RxFCf
	LmrRxFcf *Multivalue `json:"lmrRxFcf,omitempty"`
	// LmrRxFcfStepPer100mSec: LMR RxFCf Step/100 msec
	LmrRxFcfStepPer100mSec *Multivalue `json:"lmrRxFcfStepPer100mSec,omitempty"`
	// LmrTxFcb: LMR TxFCb (CCM/LLM TxFCf)
	LmrTxFcb *Multivalue `json:"lmrTxFcb,omitempty"`
	// LmrTxFcbStepPer100mSec: LMR TxFCb Step/100 msec (CCM/LMM TxFCf Step / 100 msec)
	LmrTxFcbStepPer100mSec *Multivalue `json:"lmrTxFcbStepPer100mSec,omitempty"`
	// LtAllRemoteMeps: LT All Remote MEPS
	LtAllRemoteMeps *Multivalue `json:"ltAllRemoteMeps,omitempty"`
	// LtDestinationMacAddress: LT Destination MAC Address
	LtDestinationMacAddress *Multivalue `json:"ltDestinationMacAddress,omitempty"`
	// LtmPriority: LTM Priority
	LtmPriority *Multivalue `json:"ltmPriority,omitempty"`
	// ManagementAddress: Management Address
	ManagementAddress *Multivalue `json:"managementAddress,omitempty"`
	// ManagementAddressDomain: Management Address Domain
	ManagementAddressDomain *Multivalue `json:"managementAddressDomain,omitempty"`
	// ManagementAddressDomainLength: Management Address Domain Length
	ManagementAddressDomainLength *Multivalue `json:"managementAddressDomainLength,omitempty"`
	// ManagementAddressLength: Management Address Length
	ManagementAddressLength *Multivalue `json:"managementAddressLength,omitempty"`
	// MdMegLevel: MD/MEG Level
	MdMegLevel *Multivalue `json:"mdMegLevel,omitempty"`
	// MdName: MD Name For MAC + Int, Please Use MAC-Int eg. 11:22:33:44:55:66-1 For Others, Use Any String
	MdName *Multivalue `json:"mdName,omitempty"`
	// MdNameFormat: MD Name Format
	MdNameFormat *Multivalue `json:"mdNameFormat,omitempty"`
	// MegId: MEG ID
	MegId *Multivalue `json:"megId,omitempty"`
	// MegIdFormat: MEG ID Format
	MegIdFormat *Multivalue `json:"megIdFormat,omitempty"`
	// MepId: MP ID
	MepId *Multivalue `json:"mepId,omitempty"`
	// MpType: Type
	MpType *Multivalue `json:"mpType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfCustomTLVs: Number of Custom TLVs

	NumberOfCustomTLVs *float32 `json:"numberOfCustomTLVs,omitempty"`
	// OrganizationSpecificTlvLength: Organization Specific TLV Length
	OrganizationSpecificTlvLength *Multivalue `json:"organizationSpecificTlvLength,omitempty"`
	// OrganizationSpecificTlvValue: Organization Specific TLV Value
	OrganizationSpecificTlvValue *Multivalue `json:"organizationSpecificTlvValue,omitempty"`
	// OverrideVlanPriority: Override VLAN Priority
	OverrideVlanPriority *Multivalue `json:"overrideVlanPriority,omitempty"`
	// Rdi: RDI (Auto Update/On/Off)
	Rdi *Multivalue `json:"rdi,omitempty"`
	// SVlanId: S-VLAN ID
	SVlanId *Multivalue `json:"sVlanId,omitempty"`
	// SVlanPriority: S-VLAN Priority
	SVlanPriority *Multivalue `json:"sVlanPriority,omitempty"`
	// SVlanTpid: S-VLAN TPID
	SVlanTpid *Multivalue `json:"sVlanTpid,omitempty"`
	// ShortMaName: Short MA Name
	ShortMaName *Multivalue `json:"shortMaName,omitempty"`
	// ShortMaNameFormat: Short MA Name Format
	ShortMaNameFormat *Multivalue `json:"shortMaNameFormat,omitempty"`
	// TstEnableUnicastMac: Enable Unicast MAC
	TstEnableUnicastMac *Multivalue `json:"tstEnableUnicastMac,omitempty"`
	// TstIncrementPacketLength: Increment Packet Length
	TstIncrementPacketLength *Multivalue `json:"tstIncrementPacketLength,omitempty"`
	// TstInitialPatternValue: Initial Pattern Value
	TstInitialPatternValue *Multivalue `json:"tstInitialPatternValue,omitempty"`
	// TstInterval: Interval (ms)
	TstInterval *Multivalue `json:"tstInterval,omitempty"`
	// TstMode: TST Mode
	TstMode *Multivalue `json:"tstMode,omitempty"`
	// TstOverwriteSequenceNumber: Overwrite Sequence Number
	TstOverwriteSequenceNumber *Multivalue `json:"tstOverwriteSequenceNumber,omitempty"`
	// TstPacketLength: Packet Length
	TstPacketLength *Multivalue `json:"tstPacketLength,omitempty"`
	// TstPacketLengthStep: Increment Packet Length Step
	TstPacketLengthStep *Multivalue `json:"tstPacketLengthStep,omitempty"`
	// TstPatternType: Pattern Type
	TstPatternType *Multivalue `json:"tstPatternType,omitempty"`
	// TstPriority: TST Priority
	TstPriority *Multivalue `json:"tstPriority,omitempty"`
	// TstSequenceNumber: Sequence Number
	TstSequenceNumber *Multivalue `json:"tstSequenceNumber,omitempty"`
	// TstTestType: Test Type
	TstTestType *Multivalue `json:"tstTestType,omitempty"`
	// TstUnicastMac: Unicast MAC
	TstUnicastMac *Multivalue `json:"tstUnicastMac,omitempty"`
	// VlanId: VLAN ID
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// VlanPriority: VLAN Priority
	VlanPriority *Multivalue `json:"vlanPriority,omitempty"`
	// VlanStacking: VLAN Stacking
	VlanStacking *Multivalue `json:"vlanStacking,omitempty"`
	// VlanTpid: VLAN TPID
	VlanTpid         *Multivalue                 `json:"vlanTpid,omitempty"`
	CfmCustomTLVList []*TopologyCfmCustomTlvList `json:"cfmCustomTLVList"`

	StartCCMSimmulatedMpParams *TopologyStartCcmSimmulatedMpParams `json:"start_CCM_simmulated_mpParams,omitempty"`

	StopCCMSimmulatedMpParams *TopologyStopCcmSimmulatedMpParams `json:"stop_CCM_simmulated_mpParams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCfmSimulatedMp) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCfmSimulatedMp) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCfmSimulatedMp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCfmSimulatedMp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AisEnableUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisEnableUnicastMac",
		isMultivalue: true,
	})
	n.AisInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisInterval",
		isMultivalue: true,
	})
	n.AisMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisMode",
		isMultivalue: true,
	})
	n.AisPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisPriority",
		isMultivalue: true,
	})
	n.AisUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aisUnicastMac",
		isMultivalue: true,
	})
	n.AutoDmTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoDmTimeout",
		isMultivalue: true,
	})
	n.AutoDmTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoDmTimer",
		isMultivalue: true,
	})
	n.AutoLbIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLbIteration",
		isMultivalue: true,
	})
	n.AutoLbTimeoutInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLbTimeoutInSec",
		isMultivalue: true,
	})
	n.AutoLbTimerInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLbTimerInSec",
		isMultivalue: true,
	})
	n.AutoLmIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLmIteration",
		isMultivalue: true,
	})
	n.AutoLmTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLmTimeout",
		isMultivalue: true,
	})
	n.AutoLmTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLmTimer",
		isMultivalue: true,
	})
	n.AutoLtIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtIteration",
		isMultivalue: true,
	})
	n.AutoLtTimeoutInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtTimeoutInSec",
		isMultivalue: true,
	})
	n.AutoLtTimerInSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtTimerInSec",
		isMultivalue: true,
	})
	n.AutoLtTtl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoLtTtl",
		isMultivalue: true,
	})
	n.AutodmIteration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autodmIteration",
		isMultivalue: true,
	})
	n.CVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanId",
		isMultivalue: true,
	})
	n.CVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanPriority",
		isMultivalue: true,
	})
	n.CVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cVlanTpid",
		isMultivalue: true,
	})
	n.CciInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cciInterval",
		isMultivalue: true,
	})
	n.CcmLmmTxFcf.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmLmmTxFcf",
		isMultivalue: true,
	})
	n.CcmLmmTxFcfStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmLmmTxFcfStepPer100mSec",
		isMultivalue: true,
	})
	n.CcmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmPriority",
		isMultivalue: true,
	})
	n.CcmRxFcb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmRxFcb",
		isMultivalue: true,
	})
	n.CcmRxFcbStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ccmRxFcbStepPer100mSec",
		isMultivalue: true,
	})
	n.ChassisId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chassisId",
		isMultivalue: true,
	})
	n.ChassisIdLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chassisIdLength",
		isMultivalue: true,
	})
	n.ChassisIdSubType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chassisIdSubType",
		isMultivalue: true,
	})
	n.DataTlvLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataTlvLength",
		isMultivalue: true,
	})
	n.DataTlvValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataTlvValue",
		isMultivalue: true,
	})
	n.DmAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmAllRemoteMeps",
		isMultivalue: true,
	})
	n.DmDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmDestinationMacAddress",
		isMultivalue: true,
	})
	n.DmMethod.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmMethod",
		isMultivalue: true,
	})
	n.DmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dmPriority",
		isMultivalue: true,
	})
	n.EnableAisRx.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAisRx",
		isMultivalue: true,
	})
	n.EnableAutoDm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoDm",
		isMultivalue: true,
	})
	n.EnableAutoLb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoLb",
		isMultivalue: true,
	})
	n.EnableAutoLm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoLm",
		isMultivalue: true,
	})
	n.EnableAutoLt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAutoLt",
		isMultivalue: true,
	})
	n.EnableDataTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDataTlv",
		isMultivalue: true,
	})
	n.EnableInterfaceStatusTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableInterfaceStatusTlv",
		isMultivalue: true,
	})
	n.EnableLckRx.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLckRx",
		isMultivalue: true,
	})
	n.EnableLmCounterUpdate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLmCounterUpdate",
		isMultivalue: true,
	})
	n.EnableOrganizationSpecificTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrganizationSpecificTlv",
		isMultivalue: true,
	})
	n.EnablePortStatusTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePortStatusTlv",
		isMultivalue: true,
	})
	n.EnableSenderIdTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSenderIdTlv",
		isMultivalue: true,
	})
	n.EnableTstRx.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTstRx",
		isMultivalue: true,
	})
	n.EnableVlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlan",
		isMultivalue: true,
	})
	n.InterRemoteMepRxIncrementStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interRemoteMepRxIncrementStep",
		isMultivalue: true,
	})
	n.InterRemoteMepTxIncrementStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interRemoteMepTxIncrementStep",
		isMultivalue: true,
	})
	n.LbAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lbAllRemoteMeps",
		isMultivalue: true,
	})
	n.LbDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lbDestinationMacAddress",
		isMultivalue: true,
	})
	n.LbmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lbmPriority",
		isMultivalue: true,
	})
	n.LckEnableUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckEnableUnicastMac",
		isMultivalue: true,
	})
	n.LckInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckInterval",
		isMultivalue: true,
	})
	n.LckMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckMode",
		isMultivalue: true,
	})
	n.LckPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckPriority",
		isMultivalue: true,
	})
	n.LckSupportAisGeneration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckSupportAisGeneration",
		isMultivalue: true,
	})
	n.LckUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lckUnicastMac",
		isMultivalue: true,
	})
	n.LmAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmAllRemoteMeps",
		isMultivalue: true,
	})
	n.LmDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmDestinationMacAddress",
		isMultivalue: true,
	})
	n.LmMethodType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmMethodType",
		isMultivalue: true,
	})
	n.LmmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmmPriority",
		isMultivalue: true,
	})
	n.LmrPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrPriority",
		isMultivalue: true,
	})
	n.LmrRxFcf.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrRxFcf",
		isMultivalue: true,
	})
	n.LmrRxFcfStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrRxFcfStepPer100mSec",
		isMultivalue: true,
	})
	n.LmrTxFcb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrTxFcb",
		isMultivalue: true,
	})
	n.LmrTxFcbStepPer100mSec.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lmrTxFcbStepPer100mSec",
		isMultivalue: true,
	})
	n.LtAllRemoteMeps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ltAllRemoteMeps",
		isMultivalue: true,
	})
	n.LtDestinationMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ltDestinationMacAddress",
		isMultivalue: true,
	})
	n.LtmPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ltmPriority",
		isMultivalue: true,
	})
	n.ManagementAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddress",
		isMultivalue: true,
	})
	n.ManagementAddressDomain.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddressDomain",
		isMultivalue: true,
	})
	n.ManagementAddressDomainLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddressDomainLength",
		isMultivalue: true,
	})
	n.ManagementAddressLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managementAddressLength",
		isMultivalue: true,
	})
	n.MdMegLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdMegLevel",
		isMultivalue: true,
	})
	n.MdName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdName",
		isMultivalue: true,
	})
	n.MdNameFormat.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdNameFormat",
		isMultivalue: true,
	})
	n.MegId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "megId",
		isMultivalue: true,
	})
	n.MegIdFormat.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "megIdFormat",
		isMultivalue: true,
	})
	n.MepId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mepId",
		isMultivalue: true,
	})
	n.MpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mpType",
		isMultivalue: true,
	})
	n.OrganizationSpecificTlvLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "organizationSpecificTlvLength",
		isMultivalue: true,
	})
	n.OrganizationSpecificTlvValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "organizationSpecificTlvValue",
		isMultivalue: true,
	})
	n.OverrideVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideVlanPriority",
		isMultivalue: true,
	})
	n.Rdi.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rdi",
		isMultivalue: true,
	})
	n.SVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanId",
		isMultivalue: true,
	})
	n.SVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanPriority",
		isMultivalue: true,
	})
	n.SVlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sVlanTpid",
		isMultivalue: true,
	})
	n.ShortMaName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shortMaName",
		isMultivalue: true,
	})
	n.ShortMaNameFormat.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shortMaNameFormat",
		isMultivalue: true,
	})
	n.TstEnableUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstEnableUnicastMac",
		isMultivalue: true,
	})
	n.TstIncrementPacketLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstIncrementPacketLength",
		isMultivalue: true,
	})
	n.TstInitialPatternValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstInitialPatternValue",
		isMultivalue: true,
	})
	n.TstInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstInterval",
		isMultivalue: true,
	})
	n.TstMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstMode",
		isMultivalue: true,
	})
	n.TstOverwriteSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstOverwriteSequenceNumber",
		isMultivalue: true,
	})
	n.TstPacketLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPacketLength",
		isMultivalue: true,
	})
	n.TstPacketLengthStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPacketLengthStep",
		isMultivalue: true,
	})
	n.TstPatternType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPatternType",
		isMultivalue: true,
	})
	n.TstPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstPriority",
		isMultivalue: true,
	})
	n.TstSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstSequenceNumber",
		isMultivalue: true,
	})
	n.TstTestType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstTestType",
		isMultivalue: true,
	})
	n.TstUnicastMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tstUnicastMac",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
	n.VlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanPriority",
		isMultivalue: true,
	})
	n.VlanStacking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanStacking",
		isMultivalue: true,
	})
	n.VlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanTpid",
		isMultivalue: true,
	})
	for i, o := range n.CfmCustomTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmCustomTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.StartCCMSimmulatedMpParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "start_CCM_simmulated_mpParams",
	})
	n.StopCCMSimmulatedMpParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "stop_CCM_simmulated_mpParams",
	})
}

// TopologyCfmSimulatedTopology: CFM Simulated Topology specific configuration
type TopologyCfmSimulatedTopology struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	ConfigMANamesParams *TopologyConfigMaNamesParams `json:"configMANamesParams,omitempty"`

	ConfigMDLevelsParams *TopologyConfigMdLevelsParams `json:"configMDLevelsParams,omitempty"`

	ConfigVLANParams *TopologyConfigVlanParams `json:"configVLANParams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCfmSimulatedTopology) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCfmSimulatedTopology) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCfmSimulatedTopology) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCfmSimulatedTopology) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ConfigMANamesParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "configMANamesParams",
	})
	n.ConfigMDLevelsParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "configMDLevelsParams",
	})
	n.ConfigVLANParams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "configVLANParams",
	})
}

// TopologyClusterData: Ovsdb Controller Cluster Specific Data
type TopologyClusterData struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ActionTriggered: Displays what Action Triggered for each Binding. Possible values: No Action, Attach, Detach
	ActionTriggered *Multivalue `json:"actionTriggered,omitempty"`
	// AttachAtStart: Attach at Start
	AttachAtStart *Multivalue `json:"attachAtStart,omitempty"`
	// AutoSyncAtStart: Synchronize TOR Database at Start.
	AutoSyncAtStart *Multivalue `json:"autoSyncAtStart,omitempty"`
	// BindingsCount: Bindings Count

	BindingsCount *float32 `json:"bindingsCount,omitempty"`
	// LogicalSwitchName: Logical_Switch Name
	LogicalSwitchName *Multivalue `json:"logicalSwitchName,omitempty"`
	// MaxRetryCount: Maximum number of Retries Controller will do the TOR Database Synchronization Automatically, If TOR is reconnecting while doing the action

	MaxRetryCount *float32 `json:"maxRetryCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PhysicalPortName: Physical_Port name
	PhysicalPortName *Multivalue `json:"physicalPortName,omitempty"`
	// PhysicalSwitchName: Physical_Switch name
	PhysicalSwitchName *Multivalue `json:"physicalSwitchName,omitempty"`
	// Vlan: VLAN ID
	Vlan *Multivalue `json:"vlan,omitempty"`
	// Vni: VNI
	Vni *Multivalue `json:"vni,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyClusterData) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyClusterData) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyClusterData) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyClusterData) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActionTriggered.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actionTriggered",
		isMultivalue: true,
	})
	n.AttachAtStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attachAtStart",
		isMultivalue: true,
	})
	n.AutoSyncAtStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoSyncAtStart",
		isMultivalue: true,
	})
	n.LogicalSwitchName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logicalSwitchName",
		isMultivalue: true,
	})
	n.PhysicalPortName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "physicalPortName",
		isMultivalue: true,
	})
	n.PhysicalSwitchName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "physicalSwitchName",
		isMultivalue: true,
	})
	n.Vlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlan",
		isMultivalue: true,
	})
	n.Vni.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vni",
		isMultivalue: true,
	})
}

// TopologyClusterList: Bgp L2Site Cluster ID
type TopologyClusterList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ClusterId: Cluster ID
	ClusterId *Multivalue `json:"clusterId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyClusterList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyClusterList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyClusterList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyClusterList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ClusterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clusterId",
		isMultivalue: true,
	})
}

// TopologyCol: A column view of learned information.
type TopologyCol struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath     *XPath               `json:"xpath,omitempty"`
	CellTable []*TopologyCellTable `json:"cellTable"`
	Row       []*TopologyRow       `json:"row"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCol) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCol) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCol) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCol) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.CellTable {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cellTable",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Row {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "row",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyCommandSnippetsData: Command Snippets Data allows user to fire Yang commands to DUT
type TopologyCommandSnippetsData struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// CommandSnippetDirectory: Directory containing XML based Netconf compliant command snippets.
	CommandSnippetDirectory *Multivalue `json:"commandSnippetDirectory,omitempty"`
	// CommandSnippetFile: File containing XML based Netconf compliant command snippet. For multiple command snippets with assymetric file names( which cannot be expressed easily as a pattern) please explore File option in Master Row Pattern Editor by putting the file namesin a .csv and pulling those values into the column cells.
	CommandSnippetFile *Multivalue `json:"commandSnippetFile,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeriodicTransmissionInterval: Minimum interval between scheduling of two transmits of the Command Snippet.
	PeriodicTransmissionInterval *Multivalue `json:"periodicTransmissionInterval,omitempty"`
	// TransmissionBehaviour: Transmission behaviour for command snippet.Don't Send : This means that command will not be automatically executed. This choice should beused if user wants to control the order or/and timing of sending the command snippet to the DUTusing Test Composer or Automation Script.Once: The command will be sent only once to the DUT every time session comes up with the DUT.Periodic - Continuous: The command will be sent every Transmission Interval for the full lifetime of the session.Capture should be enabled with care if this option is selected.Periodic - Fixed Count: The command will be sent Transmission Count number of times, every Periodic Transmission Interval.
	TransmissionBehaviour *Multivalue `json:"transmissionBehaviour,omitempty"`
	// TransmissionCount: Number of times to transmit the Command Snippet.
	TransmissionCount *Multivalue `json:"transmissionCount,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCommandSnippetsData) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCommandSnippetsData) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCommandSnippetsData) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCommandSnippetsData) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CommandSnippetDirectory.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "commandSnippetDirectory",
		isMultivalue: true,
	})
	n.CommandSnippetFile.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "commandSnippetFile",
		isMultivalue: true,
	})
	n.PeriodicTransmissionInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicTransmissionInterval",
		isMultivalue: true,
	})
	n.TransmissionBehaviour.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transmissionBehaviour",
		isMultivalue: true,
	})
	n.TransmissionCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transmissionCount",
		isMultivalue: true,
	})
}

// TopologyConfigMaNamesParams: Import IPv6 routes from standard route file. Supported format - Cisco IOS, Juniper JUNOS, Classis Ixia (.csv) and standard CSV.
type TopologyConfigMaNamesParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IncrementMaName: Import only the best routes (provided route file has this information).

	IncrementMaName *bool `json:"incrementMaName,omitempty"`
	// MaName: Import only the best routes (provided route file has this information).

	MaName *string `json:"maName,omitempty"`
	// SmaFormat: Import only the best routes (provided route file has this information).

	SmaFormat *string `json:"smaFormat,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyConfigMaNamesParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyConfigMaNamesParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyConfigMaNamesParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyConfigMaNamesParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyConfigMdLevelsParams: Import IPv6 routes from standard route file. Supported format - Cisco IOS, Juniper JUNOS, Classis Ixia (.csv) and standard CSV.
type TopologyConfigMdLevelsParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// MdLevel1: Text

	MdLevel1 *float32 `json:"mdLevel1,omitempty"`
	// MdLevel2: Text

	MdLevel2 *float32 `json:"mdLevel2,omitempty"`
	// MdLevel3: Text

	MdLevel3 *float32 `json:"mdLevel3,omitempty"`
	// MdLevel4: Text

	MdLevel4 *float32 `json:"mdLevel4,omitempty"`
	// MdLevel5: Text

	MdLevel5 *float32 `json:"mdLevel5,omitempty"`
	// MdLevel6: Text

	MdLevel6 *float32 `json:"mdLevel6,omitempty"`
	// MdLevel7: Text

	MdLevel7 *float32 `json:"mdLevel7,omitempty"`
	// MdLevel8: Text

	MdLevel8 *float32 `json:"mdLevel8,omitempty"`
	// MdName1: Network Address Step Value.

	MdName1 *string `json:"mdName1,omitempty"`
	// MdName2: Network Address Step Value.

	MdName2 *string `json:"mdName2,omitempty"`
	// MdName3: Network Address Step Value.

	MdName3 *string `json:"mdName3,omitempty"`
	// MdName4: Network Address Step Value.

	MdName4 *string `json:"mdName4,omitempty"`
	// MdName5: Network Address Step Value.

	MdName5 *string `json:"mdName5,omitempty"`
	// MdName6: Network Address Step Value.

	MdName6 *string `json:"mdName6,omitempty"`
	// MdName7: Network Address Step Value.

	MdName7 *string `json:"mdName7,omitempty"`
	// MdName8: Network Address Step Value.

	MdName8 *string `json:"mdName8,omitempty"`
	// MdNameFormat1: Text

	MdNameFormat1 *string `json:"mdNameFormat1,omitempty"`
	// MdNameFormat2: Text

	MdNameFormat2 *string `json:"mdNameFormat2,omitempty"`
	// MdNameFormat3: Text

	MdNameFormat3 *string `json:"mdNameFormat3,omitempty"`
	// MdNameFormat4: Text

	MdNameFormat4 *string `json:"mdNameFormat4,omitempty"`
	// MdNameFormat5: Text

	MdNameFormat5 *string `json:"mdNameFormat5,omitempty"`
	// MdNameFormat6: Text

	MdNameFormat6 *string `json:"mdNameFormat6,omitempty"`
	// MdNameFormat7: Text

	MdNameFormat7 *string `json:"mdNameFormat7,omitempty"`
	// MdNameFormat8: Text

	MdNameFormat8 *string `json:"mdNameFormat8,omitempty"`
	// NumMDLevels: Import only the best routes (provided route file has this information).

	NumMDLevels *float32 `json:"numMDLevels,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyConfigMdLevelsParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyConfigMdLevelsParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyConfigMdLevelsParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyConfigMdLevelsParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyConfigVlanParams: Import IPv6 routes from standard route file. Supported format - Cisco IOS, Juniper JUNOS, Classis Ixia (.csv) and standard CSV.
type TopologyConfigVlanParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CvlanID: Import only the best routes (provided route file has this information).

	CvlanID *float32 `json:"cvlanID,omitempty"`
	// CvlanIDStep: Import only the best routes (provided route file has this information).

	CvlanIDStep *float32 `json:"cvlanIDStep,omitempty"`
	// CvlanPriority: Import only the best routes (provided route file has this information).

	CvlanPriority *float32 `json:"cvlanPriority,omitempty"`
	// CvlanTpid: Import only the best routes (provided route file has this information).

	CvlanTpid *string `json:"cvlanTpid,omitempty"`
	// EnableVLAN: Import only the best routes (provided route file has this information).

	EnableVLAN *bool `json:"enableVLAN,omitempty"`
	// SvlanID: Import only the best routes (provided route file has this information).

	SvlanID *float32 `json:"svlanID,omitempty"`
	// SvlanIDStep: Import only the best routes (provided route file has this information).

	SvlanIDStep *float32 `json:"svlanIDStep,omitempty"`
	// SvlanPriority: Import only the best routes (provided route file has this information).

	SvlanPriority *float32 `json:"svlanPriority,omitempty"`
	// SvlanTpid: Import only the best routes (provided route file has this information).

	SvlanTpid *string `json:"svlanTpid,omitempty"`
	// VlanID: Import only the best routes (provided route file has this information).

	VlanID *float32 `json:"vlanID,omitempty"`
	// VlanIDStep: Import only the best routes (provided route file has this information).

	VlanIDStep *float32 `json:"vlanIDStep,omitempty"`
	// VlanPriority: Import only the best routes (provided route file has this information).

	VlanPriority *float32 `json:"vlanPriority,omitempty"`
	// VlanTpid: Import only the best routes (provided route file has this information).

	VlanTpid *string `json:"vlanTpid,omitempty"`
	// VlanType: Import only the best routes (provided route file has this information).

	VlanType *string `json:"vlanType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyConfigVlanParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyConfigVlanParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyConfigVlanParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyConfigVlanParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyConnector: Connects scenario elements
type TopologyConnector struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedTo: Scenario element this connector is connecting to

	ConnectedTo *string `json:"connectedTo,omitempty"`
	// ConnectedToRefs: Track refs for ConnectedTo.
	ConnectedToRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyConnector) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyConnector) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyConnector) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyConnector) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyContainer: Tlv container used to group multiple object containers
type TopologyContainer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsEnabled: Enables/disables this field

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Name: Name of the tlv

	Name   *string           `json:"name,omitempty"`
	Object []*TopologyObject `json:"object"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyContainer) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyContainer) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyContainer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyContainer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Object {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "object",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyCustomTlv: TBD
type TopologyCustomTlv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeTLVinCCM: Include Custom TLV in CCM
	IncludeTLVinCCM *Multivalue `json:"includeTLVinCCM,omitempty"`
	// IncludeTLVinLBM: Include Custom TLV in LBM
	IncludeTLVinLBM *Multivalue `json:"includeTLVinLBM,omitempty"`
	// IncludeTLVinLBR: Include Custom TLV in LBR
	IncludeTLVinLBR *Multivalue `json:"includeTLVinLBR,omitempty"`
	// IncludeTLVinLMM: Include Custom TLV in LMM
	IncludeTLVinLMM *Multivalue `json:"includeTLVinLMM,omitempty"`
	// IncludeTLVinLMR: Include Custom TLV in LMR
	IncludeTLVinLMR *Multivalue `json:"includeTLVinLMR,omitempty"`
	// IncludeTLVinLTM: Include Custom TLV in LTM
	IncludeTLVinLTM *Multivalue `json:"includeTLVinLTM,omitempty"`
	// IncludeTLVinLTR: Include Custom TLV in LTR
	IncludeTLVinLTR *Multivalue `json:"includeTLVinLTR,omitempty"`
	// Length: TLV Length
	Length *Multivalue `json:"length,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Type_: TLV Type
	Type_ *Multivalue `json:"type,omitempty"`
	// Value: TLV Value
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyCustomTlv) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyCustomTlv) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyCustomTlv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyCustomTlv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.IncludeTLVinCCM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinCCM",
		isMultivalue: true,
	})
	n.IncludeTLVinLBM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLBM",
		isMultivalue: true,
	})
	n.IncludeTLVinLBR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLBR",
		isMultivalue: true,
	})
	n.IncludeTLVinLMM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLMM",
		isMultivalue: true,
	})
	n.IncludeTLVinLMR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLMR",
		isMultivalue: true,
	})
	n.IncludeTLVinLTM.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLTM",
		isMultivalue: true,
	})
	n.IncludeTLVinLTR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTLVinLTR",
		isMultivalue: true,
	})
	n.Length.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "length",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyDceMCastIpv4GroupList: Fabric-Path Multicast IPv4 Groups
type TopologyDceMCastIpv4GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceMCastIpv4GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceMCastIpv4GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceMCastIpv4GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceMCastIpv4GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyDceMCastIpv6GroupList: Fabric-Path Multicast IPv6 Groups
type TopologyDceMCastIpv6GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceMCastIpv6GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceMCastIpv6GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceMCastIpv6GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceMCastIpv6GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyDceMCastMacGroupList: Fabric-Path Multicast MAC Groups
type TopologyDceMCastMacGroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceMCastMacGroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceMCastMacGroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceMCastMacGroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceMCastMacGroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyDceNodeTopologyList: Fabric-Path Node Topology
type TopologyDceNodeTopologyList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnableFTAG: Enable FTAG
	EnableFTAG *Multivalue `json:"enableFTAG,omitempty"`
	// InterestedVlanRangeCount: Interested VLAN Range Count(multiplier)

	InterestedVlanRangeCount *float32 `json:"interestedVlanRangeCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfTreesToCompute: No. of Trees to Compute
	NoOfTreesToCompute *Multivalue `json:"noOfTreesToCompute,omitempty"`
	// StartFTAGValue: Start FTAG Value
	StartFTAGValue *Multivalue `json:"startFTAGValue,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`

	InterestedVlanList *TopologyDceNodeTopologyListInterestedVlanList `json:"interestedVlanList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceNodeTopologyList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceNodeTopologyList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceNodeTopologyList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceNodeTopologyList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableFTAG.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFTAG",
		isMultivalue: true,
	})
	n.NoOfTreesToCompute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfTreesToCompute",
		isMultivalue: true,
	})
	n.StartFTAGValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startFTAGValue",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.InterestedVlanList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "interestedVlanList",
	})
}

// TopologyDceNodeTopologyListInterestedVlanList: Fabric-Path Node Interested Vlans
type TopologyDceNodeTopologyListInterestedVlanList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// IncludeInLSP: Include in LSP
	IncludeInLSP *Multivalue `json:"includeInLSP,omitempty"`
	// IncludeInMGroupPDU: Include in MGROUP-PDU
	IncludeInMGroupPDU *Multivalue `json:"includeInMGroupPDU,omitempty"`
	// InterNodeVlanIdIncr: Inter-Node Vlan Id Increment
	InterNodeVlanIdIncr *Multivalue `json:"interNodeVlanIdIncr,omitempty"`
	// M4BitEnabled: M4 Bit Enabled
	M4BitEnabled *Multivalue `json:"m4BitEnabled,omitempty"`
	// M6BitEnabled: M6 Bit Enabled
	M6BitEnabled *Multivalue `json:"m6BitEnabled,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// NoOfSpanningTreeRoots: No. of Spanning Tree Roots
	NoOfSpanningTreeRoots *Multivalue `json:"noOfSpanningTreeRoots,omitempty"`
	// StartSpanningTreeRootBridgeId: Start Spanning Tree Root Bridge ID
	StartSpanningTreeRootBridgeId *Multivalue `json:"startSpanningTreeRootBridgeId,omitempty"`
	// StartVlanId: Start Vlan Id
	StartVlanId *Multivalue `json:"startVlanId,omitempty"`
	// VlanCount: Vlan Count
	VlanCount *Multivalue `json:"vlanCount,omitempty"`
	// VlanIdIncr: Vlan Id Increment
	VlanIdIncr *Multivalue `json:"vlanIdIncr,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceNodeTopologyListInterestedVlanList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceNodeTopologyListInterestedVlanList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceNodeTopologyListInterestedVlanList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceNodeTopologyListInterestedVlanList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.IncludeInLSP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeInLSP",
		isMultivalue: true,
	})
	n.IncludeInMGroupPDU.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeInMGroupPDU",
		isMultivalue: true,
	})
	n.InterNodeVlanIdIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interNodeVlanIdIncr",
		isMultivalue: true,
	})
	n.M4BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m4BitEnabled",
		isMultivalue: true,
	})
	n.M6BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m6BitEnabled",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.NoOfSpanningTreeRoots.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfSpanningTreeRoots",
		isMultivalue: true,
	})
	n.StartSpanningTreeRootBridgeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSpanningTreeRootBridgeId",
		isMultivalue: true,
	})
	n.StartVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startVlanId",
		isMultivalue: true,
	})
	n.VlanCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanCount",
		isMultivalue: true,
	})
	n.VlanIdIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdIncr",
		isMultivalue: true,
	})
}

// TopologyDceSimulatedMCastIpv4GroupList: Fabric-Path Multicast IPv4 Groups
type TopologyDceSimulatedMCastIpv4GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceSimulatedMCastIpv4GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceSimulatedMCastIpv4GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceSimulatedMCastIpv4GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceSimulatedMCastIpv4GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyDceSimulatedMCastIpv6GroupList: Fabric-Path Multicast IPv6 Groups
type TopologyDceSimulatedMCastIpv6GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceSimulatedMCastIpv6GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceSimulatedMCastIpv6GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceSimulatedMCastIpv6GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceSimulatedMCastIpv6GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyDceSimulatedMCastMacGroupList: Fabric-Path Simulated Multicast MAC Groups
type TopologyDceSimulatedMCastMacGroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceSimulatedMCastMacGroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceSimulatedMCastMacGroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceSimulatedMCastMacGroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceSimulatedMCastMacGroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyDceTopologyList: Fabric-Path Topology
type TopologyDceTopologyList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnableFTAG: Enable FTAG
	EnableFTAG *Multivalue `json:"enableFTAG,omitempty"`
	// InterestedVlanRangeCount: Interested VLAN Range Count(multiplier)

	InterestedVlanRangeCount *float32 `json:"interestedVlanRangeCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NicknameCount: Nickname Count(multiplier)

	NicknameCount *float32 `json:"nicknameCount,omitempty"`
	// NoOfTreesToCompute: No. of Trees to Compute
	NoOfTreesToCompute *Multivalue `json:"noOfTreesToCompute,omitempty"`
	// StartFTAGValue: Start FTAG Value
	StartFTAGValue *Multivalue `json:"startFTAGValue,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`

	InterestedVlanList *TopologyInterestedVlanList `json:"interestedVlanList,omitempty"`

	NicknameRecordList *TopologyNicknameRecordList `json:"nicknameRecordList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDceTopologyList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDceTopologyList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDceTopologyList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDceTopologyList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableFTAG.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFTAG",
		isMultivalue: true,
	})
	n.NoOfTreesToCompute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfTreesToCompute",
		isMultivalue: true,
	})
	n.StartFTAGValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startFTAGValue",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.InterestedVlanList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "interestedVlanList",
	})
	n.NicknameRecordList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "nicknameRecordList",
	})
}

// TopologyDefaultTlv: Default Tlv container created by protocols
type TopologyDefaultTlv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// EnablePerSession: Enable TLV per session
	EnablePerSession *Multivalue `json:"enablePerSession,omitempty"`
	// IncludeInMessages: Include the TLV in these protocol messages
	IncludeInMessages []string `json:"includeInMessages"`
	// IsEnabled: Enables/disables this tlv

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`

	Value *TopologyValue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDefaultTlv) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDefaultTlv) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDefaultTlv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDefaultTlv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnablePerSession.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePerSession",
		isMultivalue: true,
	})
	n.Value.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "value",
	})
}

// TopologyDestIpv4Address: TBD
type TopologyDestIpv4Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDestIpv4Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDestIpv4Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDestIpv4Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDestIpv4Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyDestIpv6Address: TBD
type TopologyDestIpv6Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDestIpv6Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDestIpv6Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDestIpv6Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDestIpv6Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyDeviceGroup: Describes a set of network devices with similar configuration and the same multiplicity for devices behind.
type TopologyDeviceGroup struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enables/disables device.
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Multiplier: Number of device instances per parent device instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name                   *string                           `json:"name,omitempty"`
	BfdRouter              []*TopologyBfdRouter              `json:"bfdRouter"`
	BridgeData             []*TopologyBridgeData             `json:"bridgeData"`
	DeviceGroup            []*TopologyDeviceGroup            `json:"deviceGroup"`
	Ethernet               []*TopologyEthernet               `json:"ethernet"`
	Ipv4Loopback           []*TopologyIpv4Loopback           `json:"ipv4Loopback"`
	Ipv6Loopback           []*TopologyIpv6Loopback           `json:"ipv6Loopback"`
	IsisFabricPathRouter   []*TopologyIsisFabricPathRouter   `json:"isisFabricPathRouter"`
	IsisL3Router           []*TopologyIsisL3Router           `json:"isisL3Router"`
	IsisSpbRouter          []*TopologyIsisSpbRouter          `json:"isisSpbRouter"`
	IsisTrillRouter        []*TopologyIsisTrillRouter        `json:"isisTrillRouter"`
	LdpBasicRouter         []*TopologyLdpBasicRouter         `json:"ldpBasicRouter"`
	LdpBasicRouterV6       []*TopologyLdpBasicRouterV6       `json:"ldpBasicRouterV6"`
	LdpLpbInterface        []*TopologyLdpLpbInterface        `json:"ldpLpbInterface"`
	LdpTargetedRouter      []*TopologyLdpTargetedRouter      `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6    []*TopologyLdpTargetedRouterV6    `json:"ldpTargetedRouterV6"`
	Ldpv6LoopbackInterface []*TopologyLdpv6LoopbackInterface `json:"ldpv6LoopbackInterface"`
	MplsoamRouter          []*TopologyMplsoamRouter          `json:"mplsoamRouter"`
	NetworkGroup           []*TopologyNetworkGroup           `json:"networkGroup"`

	NetworkTopology *TopologyNetworkTopology `json:"networkTopology,omitempty"`
	OfHostData      []*TopologyOfHostData    `json:"ofHostData"`
	Ospfv2Router    []*TopologyOspfv2Router  `json:"ospfv2Router"`
	Ospfv3Router    []*TopologyOspfv3Router  `json:"ospfv3Router"`
	PimRouter       []*TopologyPimRouter     `json:"pimRouter"`
	RouterData      []*TopologyRouterData    `json:"routerData"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDeviceGroup) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDeviceGroup) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDeviceGroup) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDeviceGroup) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	for i, o := range n.BfdRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BridgeData {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bridgeData",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.DeviceGroup {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "deviceGroup",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisFabricPathRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisFabricPathRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3Router {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3Router",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpLpbInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpLpbInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldpv6LoopbackInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpv6LoopbackInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MplsoamRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsoamRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetworkGroup {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "networkGroup",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.NetworkTopology.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "networkTopology",
	})
	for i, o := range n.OfHostData {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ofHostData",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv2Router {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv2Router",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3Router {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3Router",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RouterData {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "routerData",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp4RelayAgentTlvProfile: DHCPv4 Relay Agent TLV Profiles.
type TopologyDhcp4RelayAgentTlvProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name       *string               `json:"name,omitempty"`
	TlvProfile []*TopologyTlvProfile `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp4RelayAgentTlvProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp4RelayAgentTlvProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp4RelayAgentTlvProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp4RelayAgentTlvProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp4ServerSessions: DHCPv4 Leases.
type TopologyDhcp4ServerSessions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DefaultLeaseTime: The Life Time length in seconds that will be assigned to a lease if the requesting DHCP Client does not specify a specific expiration time.
	DefaultLeaseTime *Multivalue `json:"defaultLeaseTime,omitempty"`
	// EchoRelayInfo: Enable echoing of DHCP option 82.
	EchoRelayInfo *Multivalue `json:"echoRelayInfo,omitempty"`
	// IpAddress: The IP address of the first lease pool.
	IpAddress *Multivalue `json:"ipAddress,omitempty"`
	// IpAddressIncrement: The increment value for the lease address within the lease pool.
	IpAddressIncrement *Multivalue `json:"ipAddressIncrement,omitempty"`
	// IpDns1: The first DNS address advertised in DHCP Offer and Reply messages.
	IpDns1 *Multivalue `json:"ipDns1,omitempty"`
	// IpDns2: The second DNS address advertised in DHCP Offer and Reply messages.
	IpDns2 *Multivalue `json:"ipDns2,omitempty"`
	// IpGateway: The Router address advertised in DHCP Offer and Reply messages.
	IpGateway *Multivalue `json:"ipGateway,omitempty"`
	// IpPrefix: The Subnet Address length used to compute the subnetwork the advertised lease is part of.
	IpPrefix *Multivalue `json:"ipPrefix,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PoolSize: The number of leases to be allocated per each server address.
	PoolSize *Multivalue `json:"poolSize,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp4ServerSessions) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp4ServerSessions) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp4ServerSessions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp4ServerSessions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DefaultLeaseTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "defaultLeaseTime",
		isMultivalue: true,
	})
	n.EchoRelayInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoRelayInfo",
		isMultivalue: true,
	})
	n.IpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddress",
		isMultivalue: true,
	})
	n.IpAddressIncrement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressIncrement",
		isMultivalue: true,
	})
	n.IpDns1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipDns1",
		isMultivalue: true,
	})
	n.IpDns2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipDns2",
		isMultivalue: true,
	})
	n.IpGateway.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipGateway",
		isMultivalue: true,
	})
	n.IpPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipPrefix",
		isMultivalue: true,
	})
	n.PoolSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "poolSize",
		isMultivalue: true,
	})
}

// TopologyDhcp6Iana: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iana1: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana1 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana1) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana1) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana1) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana1) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iana2: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana2 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana2) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana2) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana2) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana2) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iana3: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana3 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana3) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana3) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana3) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana3) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iana4: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iana5: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana5 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana5) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana5) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana5) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana5) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iana6: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iana7: DHCPv6 Iana/Iata endpoint used in traffic
type TopologyDhcp6Iana7 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iana7) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iana7) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iana7) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iana7) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd1: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd1 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd1) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd1) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd1) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd1) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd2: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd2 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd2) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd2) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd2) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd2) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd3: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd3 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd3) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd3) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd3) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd3) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd4: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd5: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd5 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd5) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd5) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd5) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd5) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd6: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6Iapd7: DHCPv6 Iapd endpoint used in traffic
type TopologyDhcp6Iapd7 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string        `json:"name,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6Iapd7) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6Iapd7) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6Iapd7) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6Iapd7) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6LearnedInfo: DHCPv6 Client Learned Info.
type TopologyDhcp6LearnedInfo struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6LearnedInfo) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6LearnedInfo) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6LearnedInfo) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6LearnedInfo) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyDhcp6RelayTlvProfile: DHCPv6 Relay Agent TLV Profiles.
type TopologyDhcp6RelayTlvProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name       *string               `json:"name,omitempty"`
	TlvProfile []*TopologyTlvProfile `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6RelayTlvProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6RelayTlvProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6RelayTlvProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6RelayTlvProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcp6ServerSessions: DHCPv6 Leases.
type TopologyDhcp6ServerSessions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AddressDuidMask: The mask based on which the DUIDs are chosen for address assignment.
	AddressDuidMask *Multivalue `json:"addressDuidMask,omitempty"`
	// AddressDuidPattern: The pattern based on which the DUIDs are chosen for address assignment.
	AddressDuidPattern *Multivalue `json:"addressDuidPattern,omitempty"`
	// AddressesPerIA: Number of addresses to be advertised in a single IANA option.
	AddressesPerIA *Multivalue `json:"addressesPerIA,omitempty"`
	// CustomRebindTime: The Time (in seconds) after the client will start rebinding the leases from the server.
	CustomRebindTime *Multivalue `json:"customRebindTime,omitempty"`
	// CustomRenewTime: The Time (in seconds) after the client will start renewing the leases from the server.
	CustomRenewTime *Multivalue `json:"customRenewTime,omitempty"`
	// DefaultLeaseTime: The Life Time length in seconds that will be assigned to a lease if the requesting DHCP Client does not specify a specific expiration time.
	DefaultLeaseTime *Multivalue `json:"defaultLeaseTime,omitempty"`
	// EnableAddressMatchDuid: If enabled, the requests with DUIDs matching the mask and pattern will be assigned addresses from this pool.
	EnableAddressMatchDuid *Multivalue `json:"enableAddressMatchDuid,omitempty"`
	// EnablePrefixMatchDuid: If enabled, the requests with DUIDs matching DUID start and increment will be given a specific prefix from this pool.
	EnablePrefixMatchDuid *Multivalue `json:"enablePrefixMatchDuid,omitempty"`
	// IaType: The Identity Association type supported by IPv6 address pools .
	IaType *Multivalue `json:"iaType,omitempty"`
	// Ignore: If enabled, the requests with DUIDs matching the mask and pattern will be ignored by the Server.
	Ignore *Multivalue `json:"ignore,omitempty"`
	// IgnoreMask: The mask based on which the DUIDs of ignored addresses are chosen.
	IgnoreMask *Multivalue `json:"ignoreMask,omitempty"`
	// IgnorePattern: The pattern based on which the DUIDs of ignored addresses are chosen.
	IgnorePattern *Multivalue `json:"ignorePattern,omitempty"`
	// IpAddress: The IP address of the first lease pool.
	IpAddress *Multivalue `json:"ipAddress,omitempty"`
	// IpAddressIncrement: The increment value for the lease address within the lease pool.
	IpAddressIncrement *Multivalue `json:"ipAddressIncrement,omitempty"`
	// IpAddressPD: The prefix of the first lease pool.
	IpAddressPD *Multivalue `json:"ipAddressPD,omitempty"`
	// IpPrefix: The Subnet Address length used to compute the subnetwork the advertised lease is part of.
	IpPrefix *Multivalue `json:"ipPrefix,omitempty"`
	// IpPrefixIncrement: The increment value for the lease prefix within the lease pool.
	IpPrefixIncrement *Multivalue `json:"ipPrefixIncrement,omitempty"`
	// LeaseTimeIncrement: Increment step for Lease Time.
	LeaseTimeIncrement *Multivalue `json:"leaseTimeIncrement,omitempty"`
	// Nak: If enabled, the requests with DUIDs matching the mask and pattern will be NAKed by the Server.
	Nak *Multivalue `json:"nak,omitempty"`
	// NakMask: The mask based on which the DUIDs of NAKed addresses are chosen.
	NakMask *Multivalue `json:"nakMask,omitempty"`
	// NakPattern: The pattern based on which the DUIDs of NAKed addresses are chosen.
	NakPattern *Multivalue `json:"nakPattern,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PoolPrefixSize: The number of leases to be allocated per each server prefix.
	PoolPrefixSize *Multivalue `json:"poolPrefixSize,omitempty"`
	// PoolSize: The number of leases to be allocated per each server address.
	PoolSize *Multivalue `json:"poolSize,omitempty"`
	// PrefixDuidIncrement: The increment used to generate the DUIDs which will be chosen for prefix assignment.
	PrefixDuidIncrement *Multivalue `json:"prefixDuidIncrement,omitempty"`
	// PrefixDuidStart: The first DUID which will be chosen for prefix assignment.
	PrefixDuidStart *Multivalue `json:"prefixDuidStart,omitempty"`
	// PrefixLength: The subnet address length advertised in DHCP Offer and Reply messages.
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// PrefixesPerIA: Number of prefixes to be advertised in a single IANA option.
	PrefixesPerIA *Multivalue `json:"prefixesPerIA,omitempty"`
	// UseCustomTimes: >Use Custom Renew/Rebind Times instead of the ones computed from the valability times of the leases.
	UseCustomTimes *Multivalue `json:"useCustomTimes,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcp6ServerSessions) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcp6ServerSessions) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcp6ServerSessions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcp6ServerSessions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AddressDuidMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addressDuidMask",
		isMultivalue: true,
	})
	n.AddressDuidPattern.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addressDuidPattern",
		isMultivalue: true,
	})
	n.AddressesPerIA.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "addressesPerIA",
		isMultivalue: true,
	})
	n.CustomRebindTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customRebindTime",
		isMultivalue: true,
	})
	n.CustomRenewTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customRenewTime",
		isMultivalue: true,
	})
	n.DefaultLeaseTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "defaultLeaseTime",
		isMultivalue: true,
	})
	n.EnableAddressMatchDuid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAddressMatchDuid",
		isMultivalue: true,
	})
	n.EnablePrefixMatchDuid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePrefixMatchDuid",
		isMultivalue: true,
	})
	n.IaType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iaType",
		isMultivalue: true,
	})
	n.Ignore.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignore",
		isMultivalue: true,
	})
	n.IgnoreMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreMask",
		isMultivalue: true,
	})
	n.IgnorePattern.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignorePattern",
		isMultivalue: true,
	})
	n.IpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddress",
		isMultivalue: true,
	})
	n.IpAddressIncrement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressIncrement",
		isMultivalue: true,
	})
	n.IpAddressPD.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressPD",
		isMultivalue: true,
	})
	n.IpPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipPrefix",
		isMultivalue: true,
	})
	n.IpPrefixIncrement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipPrefixIncrement",
		isMultivalue: true,
	})
	n.LeaseTimeIncrement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leaseTimeIncrement",
		isMultivalue: true,
	})
	n.Nak.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nak",
		isMultivalue: true,
	})
	n.NakMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nakMask",
		isMultivalue: true,
	})
	n.NakPattern.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nakPattern",
		isMultivalue: true,
	})
	n.PoolPrefixSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "poolPrefixSize",
		isMultivalue: true,
	})
	n.PoolSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "poolSize",
		isMultivalue: true,
	})
	n.PrefixDuidIncrement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixDuidIncrement",
		isMultivalue: true,
	})
	n.PrefixDuidStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixDuidStart",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.PrefixesPerIA.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixesPerIA",
		isMultivalue: true,
	})
	n.UseCustomTimes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useCustomTimes",
		isMultivalue: true,
	})
}

// TopologyDhcpv4client: DHCPv4 Client protocol.
type TopologyDhcpv4client struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Dhcp4Broadcast: If enabled, ask the server or relay agent to use the broadcast IP address in the replies.
	Dhcp4Broadcast *Multivalue `json:"dhcp4Broadcast,omitempty"`
	// Dhcp4GatewayAddress: Configures the Manual Gateway IP Address for the DHCPv4 Client.
	Dhcp4GatewayAddress *Multivalue `json:"dhcp4GatewayAddress,omitempty"`
	// Dhcp4GatewayMac: Configures the Manual Gateway MAC corresponding to the configured Manual Gateway IP of the DHCPv4 Client session.
	Dhcp4GatewayMac *Multivalue `json:"dhcp4GatewayMac,omitempty"`
	// Dhcp4ServerAddress: The address of the DHCP server from which the subnet will accept IP addresses.
	Dhcp4ServerAddress *Multivalue `json:"dhcp4ServerAddress,omitempty"`
	// Dhcp4UseFirstServer: If enabled, the subnet accepts the IP addresses offered by the first server to respond with an offer of IP addresses.
	Dhcp4UseFirstServer *Multivalue `json:"dhcp4UseFirstServer,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RenewTimer: The used-defined lease renewal timer. The value is estimated in seconds and will override the lease renewal timer if it is not zero and is smaller than server-defined value.
	RenewTimer *Multivalue `json:"renewTimer,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UseRapidCommit: Enables DHCP clients to negotiate leases with rapid commit.
	UseRapidCommit *Multivalue               `json:"useRapidCommit,omitempty"`
	Bfdv4Interface []*TopologyBfdv4Interface `json:"bfdv4Interface"`
	BgpIpv4Peer    []*TopologyBgpIpv4Peer    `json:"bgpIpv4Peer"`
	ECpriRe        []*TopologyECpriRe        `json:"eCpriRe"`
	ECpriRec       []*TopologyECpriRec       `json:"eCpriRec"`
	Geneve         []*TopologyGeneve         `json:"geneve"`
	IgmpHost       []*TopologyIgmpHost       `json:"igmpHost"`
	IgmpQuerier    []*TopologyIgmpQuerier    `json:"igmpQuerier"`
	MplsOam        []*TopologyMplsOam        `json:"mplsOam"`
	NetconfClient  []*TopologyNetconfClient  `json:"netconfClient"`
	NetconfServer  []*TopologyNetconfServer  `json:"netconfServer"`
	Ospfv2         []*TopologyOspfv2         `json:"ospfv2"`
	Pcc            []*TopologyPcc            `json:"pcc"`
	Pce            []*TopologyPce            `json:"pce"`
	PimV4Interface []*TopologyPimV4Interface `json:"pimV4Interface"`
	Tag            []*TopologyTag            `json:"tag"`
	TlvProfile     []*TopologyTlvProfile     `json:"tlvProfile"`
	Vxlan          []*TopologyVxlan          `json:"vxlan"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcpv4client) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcpv4client) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcpv4client) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcpv4client) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Dhcp4Broadcast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4Broadcast",
		isMultivalue: true,
	})
	n.Dhcp4GatewayAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4GatewayAddress",
		isMultivalue: true,
	})
	n.Dhcp4GatewayMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4GatewayMac",
		isMultivalue: true,
	})
	n.Dhcp4ServerAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4ServerAddress",
		isMultivalue: true,
	})
	n.Dhcp4UseFirstServer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4UseFirstServer",
		isMultivalue: true,
	})
	n.RenewTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "renewTimer",
		isMultivalue: true,
	})
	n.UseRapidCommit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useRapidCommit",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Geneve {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "geneve",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MplsOam {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsOam",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfClient {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfClient",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfServer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfServer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv2 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv2",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pcc {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcc",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pce {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pce",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcpv4relayAgent: DHCPv4 Relay Agent protocol.
type TopologyDhcpv4relayAgent struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Dhcp4RelayAddress: Complete description here
	Dhcp4RelayAddress *Multivalue `json:"dhcp4RelayAddress,omitempty"`
	// Dhcp4ServerAddress: Complete description here
	Dhcp4ServerAddress *Multivalue `json:"dhcp4ServerAddress,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Dhcp4RelayAgentTlvProfile *TopologyDhcp4RelayAgentTlvProfile `json:"dhcp4RelayAgentTlvProfile,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcpv4relayAgent) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcpv4relayAgent) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcpv4relayAgent) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcpv4relayAgent) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Dhcp4RelayAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4RelayAddress",
		isMultivalue: true,
	})
	n.Dhcp4ServerAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp4ServerAddress",
		isMultivalue: true,
	})
	n.Dhcp4RelayAgentTlvProfile.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp4RelayAgentTlvProfile",
	})
}

// TopologyDhcpv4server: DHCPv4 Server protocol.
type TopologyDhcpv4server struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PoolCount: number of DHCP pools a single server has

	PoolCount *float32 `json:"poolCount,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// Subnet: Choose which subnet to be used for address assignment.
	Subnet *Multivalue `json:"subnet,omitempty"`
	// SubnetAddrAssign: Enables DHCP Server to assign addresses based on subnet. The leased address is created dynamically by overwriting the subnet portion defined in the Address Pool with the subnet option present in the requests from the clients behind relays.
	SubnetAddrAssign *Multivalue `json:"subnetAddrAssign,omitempty"`
	// UseRapidCommit: Enables DHCP Server to negotiate leases with rapid commit for DHCP Clients that request it.
	UseRapidCommit *Multivalue `json:"useRapidCommit,omitempty"`

	Dhcp4ServerSessions *TopologyDhcp4ServerSessions `json:"dhcp4ServerSessions,omitempty"`
	TlvProfile          []*TopologyTlvProfile        `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcpv4server) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcpv4server) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcpv4server) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcpv4server) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Subnet.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subnet",
		isMultivalue: true,
	})
	n.SubnetAddrAssign.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subnetAddrAssign",
		isMultivalue: true,
	})
	n.UseRapidCommit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useRapidCommit",
		isMultivalue: true,
	})
	n.Dhcp4ServerSessions.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp4ServerSessions",
	})
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcpv6client: DHCPv6 Client protocol.
type TopologyDhcpv6client struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// CustomLinkLocalAddress: Configures the Manual Link-Local IPv6 Address for the DHCPv6 Client.
	CustomLinkLocalAddress *Multivalue `json:"customLinkLocalAddress,omitempty"`
	// Dhcp6DuidEnterpriseId: The enterprise-number is the vendor's registered Private Enterprise Number as maintained by IANA.
	Dhcp6DuidEnterpriseId *Multivalue `json:"dhcp6DuidEnterpriseId,omitempty"`
	// Dhcp6DuidType: DHCP Unique Identifier Type.
	Dhcp6DuidType *Multivalue `json:"dhcp6DuidType,omitempty"`
	// Dhcp6DuidVendorId: The vendor-assigned unique ID for this range. This ID is incremented automaticaly for each DHCP client.
	Dhcp6DuidVendorId *Multivalue `json:"dhcp6DuidVendorId,omitempty"`
	// Dhcp6GatewayAddress: Configures the Manual Gateway IPv6 Address for the DHCPv6 Client.
	Dhcp6GatewayAddress *Multivalue `json:"dhcp6GatewayAddress,omitempty"`
	// Dhcp6GatewayMac: Configures the Manual Gateway MAC corresponding to the configured Manual Gateway IP of the DHCPv6 Client session.
	Dhcp6GatewayMac *Multivalue `json:"dhcp6GatewayMac,omitempty"`
	// Dhcp6IANACount: Number of IANA options to be included in a negotiation. This value must be smaller than Maximum Leases per Client.
	Dhcp6IANACount *Multivalue `json:"dhcp6IANACount,omitempty"`
	// Dhcp6IAPDCount: Number of IAPD options to be included in a negotiation. This value must be smaller than Maximum Leases per Client.
	Dhcp6IAPDCount *Multivalue `json:"dhcp6IAPDCount,omitempty"`
	// Dhcp6IaId: The identity association unique ID for this range.
	Dhcp6IaId *Multivalue `json:"dhcp6IaId,omitempty"`
	// Dhcp6IaIdInc: Increment step for each IAID in a multiple IANA/IAPD case.
	Dhcp6IaIdInc *Multivalue `json:"dhcp6IaIdInc,omitempty"`
	// Dhcp6IaT1: The suggested time at which the client contacts the server from which the addresses were obtained to extend the lifetimes of the addresses assigned.
	Dhcp6IaT1 *Multivalue `json:"dhcp6IaT1,omitempty"`
	// Dhcp6IaT2: The suggested time at which the client contacts any available server to extend the lifetimes of the addresses assigned.
	Dhcp6IaT2 *Multivalue `json:"dhcp6IaT2,omitempty"`
	// Dhcp6IaType: Identity Association Type.
	Dhcp6IaType *Multivalue `json:"dhcp6IaType,omitempty"`
	// Dhcp6UsePDGlobalAddress: Use DHCPc6-PD global addressing.
	Dhcp6UsePDGlobalAddress *Multivalue `json:"dhcp6UsePDGlobalAddress,omitempty"`
	// EnableStateless: Enables DHCP stateless.

	EnableStateless *bool `json:"enableStateless,omitempty"`
	// MaxNoPerClient: Maximum number of Addresses/Prefixes accepted by a Client in a negotiation.

	MaxNoPerClient *float32 `json:"maxNoPerClient,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RenewTimer: The used-defined lease renewal timer. The value is estimated in seconds and will override the lease renewal timer if it is not zero and is smaller than server-defined value.
	RenewTimer *Multivalue `json:"renewTimer,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UseCustomLinkLocalAddress: Enables users to manually set non-EUI link local addresses
	UseCustomLinkLocalAddress *Multivalue `json:"useCustomLinkLocalAddress,omitempty"`
	// UseRapidCommit: Enables DHCP clients to negotiate leases with rapid commit.
	UseRapidCommit *Multivalue               `json:"useRapidCommit,omitempty"`
	Bfdv6Interface []*TopologyBfdv6Interface `json:"bfdv6Interface"`
	BgpIpv6Peer    []*TopologyBgpIpv6Peer    `json:"bgpIpv6Peer"`

	Dhcp6Iana *TopologyDhcp6Iana `json:"dhcp6Iana,omitempty"`

	Dhcp6Iana1 *TopologyDhcp6Iana1 `json:"dhcp6Iana1,omitempty"`

	Dhcp6Iana2 *TopologyDhcp6Iana2 `json:"dhcp6Iana2,omitempty"`

	Dhcp6Iana3 *TopologyDhcp6Iana3 `json:"dhcp6Iana3,omitempty"`

	Dhcp6Iana4 *TopologyDhcp6Iana4 `json:"dhcp6Iana4,omitempty"`

	Dhcp6Iana5 *TopologyDhcp6Iana5 `json:"dhcp6Iana5,omitempty"`

	Dhcp6Iana6 *TopologyDhcp6Iana6 `json:"dhcp6Iana6,omitempty"`

	Dhcp6Iana7 *TopologyDhcp6Iana7 `json:"dhcp6Iana7,omitempty"`

	Dhcp6Iapd *TopologyDhcp6Iapd `json:"dhcp6Iapd,omitempty"`

	Dhcp6Iapd1 *TopologyDhcp6Iapd1 `json:"dhcp6Iapd1,omitempty"`

	Dhcp6Iapd2 *TopologyDhcp6Iapd2 `json:"dhcp6Iapd2,omitempty"`

	Dhcp6Iapd3 *TopologyDhcp6Iapd3 `json:"dhcp6Iapd3,omitempty"`

	Dhcp6Iapd4 *TopologyDhcp6Iapd4 `json:"dhcp6Iapd4,omitempty"`

	Dhcp6Iapd5 *TopologyDhcp6Iapd5 `json:"dhcp6Iapd5,omitempty"`

	Dhcp6Iapd6 *TopologyDhcp6Iapd6 `json:"dhcp6Iapd6,omitempty"`

	Dhcp6Iapd7 *TopologyDhcp6Iapd7 `json:"dhcp6Iapd7,omitempty"`

	Dhcp6LearnedInfo *TopologyDhcp6LearnedInfo `json:"dhcp6LearnedInfo,omitempty"`
	MldHost          []*TopologyMldHost        `json:"mldHost"`
	MldQuerier       []*TopologyMldQuerier     `json:"mldQuerier"`
	Ospfv3           []*TopologyOspfv3         `json:"ospfv3"`
	PimV6Interface   []*TopologyPimV6Interface `json:"pimV6Interface"`
	Tag              []*TopologyTag            `json:"tag"`
	TlvProfile       []*TopologyTlvProfile     `json:"tlvProfile"`
	Vxlanv6          []*TopologyVxlanv6        `json:"vxlanv6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcpv6client) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcpv6client) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcpv6client) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcpv6client) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.CustomLinkLocalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customLinkLocalAddress",
		isMultivalue: true,
	})
	n.Dhcp6DuidEnterpriseId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6DuidEnterpriseId",
		isMultivalue: true,
	})
	n.Dhcp6DuidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6DuidType",
		isMultivalue: true,
	})
	n.Dhcp6DuidVendorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6DuidVendorId",
		isMultivalue: true,
	})
	n.Dhcp6GatewayAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6GatewayAddress",
		isMultivalue: true,
	})
	n.Dhcp6GatewayMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6GatewayMac",
		isMultivalue: true,
	})
	n.Dhcp6IANACount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6IANACount",
		isMultivalue: true,
	})
	n.Dhcp6IAPDCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6IAPDCount",
		isMultivalue: true,
	})
	n.Dhcp6IaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6IaId",
		isMultivalue: true,
	})
	n.Dhcp6IaIdInc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6IaIdInc",
		isMultivalue: true,
	})
	n.Dhcp6IaT1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6IaT1",
		isMultivalue: true,
	})
	n.Dhcp6IaT2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6IaT2",
		isMultivalue: true,
	})
	n.Dhcp6IaType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6IaType",
		isMultivalue: true,
	})
	n.Dhcp6UsePDGlobalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6UsePDGlobalAddress",
		isMultivalue: true,
	})
	n.RenewTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "renewTimer",
		isMultivalue: true,
	})
	n.UseCustomLinkLocalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useCustomLinkLocalAddress",
		isMultivalue: true,
	})
	n.UseRapidCommit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useRapidCommit",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Dhcp6Iana.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana",
	})
	n.Dhcp6Iana1.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana1",
	})
	n.Dhcp6Iana2.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana2",
	})
	n.Dhcp6Iana3.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana3",
	})
	n.Dhcp6Iana4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana4",
	})
	n.Dhcp6Iana5.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana5",
	})
	n.Dhcp6Iana6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana6",
	})
	n.Dhcp6Iana7.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iana7",
	})
	n.Dhcp6Iapd.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd",
	})
	n.Dhcp6Iapd1.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd1",
	})
	n.Dhcp6Iapd2.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd2",
	})
	n.Dhcp6Iapd3.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd3",
	})
	n.Dhcp6Iapd4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd4",
	})
	n.Dhcp6Iapd5.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd5",
	})
	n.Dhcp6Iapd6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd6",
	})
	n.Dhcp6Iapd7.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6Iapd7",
	})
	n.Dhcp6LearnedInfo.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6LearnedInfo",
	})
	for i, o := range n.MldHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlanv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlanv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDhcpv6relayAgent: DHCPv6 Relay Agent protocol.
type TopologyDhcpv6relayAgent struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Dhcp6RelayAddress: Complete description here
	Dhcp6RelayAddress *Multivalue `json:"dhcp6RelayAddress,omitempty"`
	// Dhcp6ServerAddress: Complete description here
	Dhcp6ServerAddress *Multivalue `json:"dhcp6ServerAddress,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ReconfviaRelay: If Enabled allows Reconfigure to be sent from server to Client via RelayAgent
	ReconfviaRelay *Multivalue `json:"reconfviaRelay,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Dhcp6RelayTlvProfile *TopologyDhcp6RelayTlvProfile `json:"dhcp6RelayTlvProfile,omitempty"`

	LightweightDhcp6RelayTlvProfile *TopologyLightweightDhcp6RelayTlvProfile `json:"lightweightDhcp6RelayTlvProfile,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcpv6relayAgent) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcpv6relayAgent) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcpv6relayAgent) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcpv6relayAgent) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Dhcp6RelayAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6RelayAddress",
		isMultivalue: true,
	})
	n.Dhcp6ServerAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dhcp6ServerAddress",
		isMultivalue: true,
	})
	n.ReconfviaRelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconfviaRelay",
		isMultivalue: true,
	})
	n.Dhcp6RelayTlvProfile.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6RelayTlvProfile",
	})
	n.LightweightDhcp6RelayTlvProfile.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lightweightDhcp6RelayTlvProfile",
	})
}

// TopologyDhcpv6server: DHCPv6 Server protocol.
type TopologyDhcpv6server struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DnsDomain: The domain name to be searched during name resolution advertised in DHCP Offer and Reply messages.
	DnsDomain *Multivalue `json:"dnsDomain,omitempty"`
	// IpDns1: The first DNS address advertised in DHCP Offer and Reply messages.
	IpDns1 *Multivalue `json:"ipDns1,omitempty"`
	// IpDns2: The second DNS address advertised in DHCP Offer and Reply messages.
	IpDns2 *Multivalue `json:"ipDns2,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PoolCount: number of DHCP pools a single server has

	PoolCount *float32 `json:"poolCount,omitempty"`
	// ReconfviaRelay: If Enabled allows Reconfigure to be sent from server to Client via RelayAgent
	ReconfviaRelay *Multivalue `json:"reconfviaRelay,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SubnetAddrAssign: Enabled DHCPv6 Server to assign IP based on Relay Agent IP Address Subnet.
	SubnetAddrAssign *Multivalue `json:"subnetAddrAssign,omitempty"`
	// UseRapidCommit: Enables DHCP Server to negotiate leases with rapid commit for DHCP Clients that request it.
	UseRapidCommit *Multivalue `json:"useRapidCommit,omitempty"`

	Dhcp6ServerSessions *TopologyDhcp6ServerSessions `json:"dhcp6ServerSessions,omitempty"`
	TlvProfile          []*TopologyTlvProfile        `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDhcpv6server) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDhcpv6server) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDhcpv6server) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDhcpv6server) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DnsDomain.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dnsDomain",
		isMultivalue: true,
	})
	n.IpDns1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipDns1",
		isMultivalue: true,
	})
	n.IpDns2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipDns2",
		isMultivalue: true,
	})
	n.ReconfviaRelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconfviaRelay",
		isMultivalue: true,
	})
	n.SubnetAddrAssign.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subnetAddrAssign",
		isMultivalue: true,
	})
	n.UseRapidCommit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useRapidCommit",
		isMultivalue: true,
	})
	n.Dhcp6ServerSessions.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dhcp6ServerSessions",
	})
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyDotOneX: TBD
type TopologyDotOneX struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CaCert: The CA certificate to be used
	CaCert *Multivalue `json:"caCert,omitempty"`
	// CertDir: The location to the saved certificates
	CertDir *Multivalue `json:"certDir,omitempty"`
	// CertificateKeySameFile: flag to determine whether to use same Certificate file for both Private Key and User Certificate
	CertificateKeySameFile *Multivalue `json:"certificateKeySameFile,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// FastInnerMethod: FAST Inner Method
	FastInnerMethod *Multivalue `json:"fastInnerMethod,omitempty"`
	// FastProMode: FAST Provision Mode
	FastProMode *Multivalue `json:"fastProMode,omitempty"`
	// Faststateless: FAST Stateless Resume
	Faststateless *Multivalue `json:"faststateless,omitempty"`
	// HostAuthMode: Host Authentication Mode
	HostAuthMode *Multivalue `json:"hostAuthMode,omitempty"`
	// HostCert: The Peer certificate to be used by the host
	HostCert *Multivalue `json:"hostCert,omitempty"`
	// HostKey: The private key certificate to be used by the host
	HostKey *Multivalue `json:"hostKey,omitempty"`
	// HostName: Credential of the host for authentication
	HostName *Multivalue `json:"hostName,omitempty"`
	// HostPwd: Password of the host for authentication
	HostPwd *Multivalue `json:"hostPwd,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ParentEth: TBD

	ParentEth *string `json:"parentEth,omitempty"`
	// ParentEthRefs: Track refs for ParentEth.
	ParentEthRefs []Href `json:"-"`
	// PeerCert: The Peer certificate to be used
	PeerCert *Multivalue `json:"peerCert,omitempty"`
	// PrivateKey: The private key certificate to be used
	PrivateKey *Multivalue `json:"privateKey,omitempty"`
	// Protocol: protocol for authentication
	Protocol *Multivalue `json:"protocol,omitempty"`
	// RunTimeCertGen: Generate Certificate during Run time. Configure details in Global parameters. Common Name will be User Name. Certificate and Key file names will be generated based on corresponding Client User name. Eg: If Client User name is IxiaUser1 then Certificate File will be IxiaUser1.pem, Key File will be IxiaUser1_key.pem, CA certificate File will be root.pem
	RunTimeCertGen *Multivalue `json:"runTimeCertGen,omitempty"`
	// SendCACertOnly: Use this option to send CA Certificate only to Port. Eg: For PEAPv0/v1 case there is no need to send User Certificate to port.
	SendCACertOnly *Multivalue `json:"sendCACertOnly,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TlsVersion: TLS version selecction
	TlsVersion *Multivalue `json:"tlsVersion,omitempty"`
	// UserName: Credential of the user for authentication
	UserName *Multivalue `json:"userName,omitempty"`
	// UserPwd: Password of the user for authentication
	UserPwd *Multivalue `json:"userPwd,omitempty"`
	// VerifyPeer: Verifies the provided peer certificate
	VerifyPeer *Multivalue `json:"verifyPeer,omitempty"`
	// WaitId: When enabled, the supplicant does not send the initial EAPOL Start message. Instead, it waits for the authenticator (the DUT) to send an EAPOL Request / Identity message.
	WaitId                      *Multivalue                            `json:"waitId,omitempty"`
	BondedGRE                   []*TopologyBondedGre                   `json:"bondedGRE"`
	CfmBridge                   []*TopologyCfmBridge                   `json:"cfmBridge"`
	Dhcpv4client                []*TopologyDhcpv4client                `json:"dhcpv4client"`
	Dhcpv6client                []*TopologyDhcpv6client                `json:"dhcpv6client"`
	ECpriRe                     []*TopologyECpriRe                     `json:"eCpriRe"`
	ECpriRec                    []*TopologyECpriRec                    `json:"eCpriRec"`
	Esmc                        []*TopologyEsmc                        `json:"esmc"`
	Ipv4                        []*TopologyIpv4                        `json:"ipv4"`
	Ipv6                        []*TopologyIpv6                        `json:"ipv6"`
	Ipv6Autoconfiguration       []*TopologyIpv6Autoconfiguration       `json:"ipv6Autoconfiguration"`
	IsisDceSimRouter            []*TopologyIsisDceSimRouter            `json:"isisDceSimRouter"`
	IsisFabricPath              []*TopologyIsisFabricPath              `json:"isisFabricPath"`
	IsisL3                      []*TopologyIsisL3                      `json:"isisL3"`
	IsisSpbBcb                  []*TopologyIsisSpbBcb                  `json:"isisSpbBcb"`
	IsisSpbBeb                  []*TopologyIsisSpbBeb                  `json:"isisSpbBeb"`
	IsisSpbSimRouter            []*TopologyIsisSpbSimRouter            `json:"isisSpbSimRouter"`
	IsisTrill                   []*TopologyIsisTrill                   `json:"isisTrill"`
	IsisTrillSimRouter          []*TopologyIsisTrillSimRouter          `json:"isisTrillSimRouter"`
	Lacp                        []*TopologyLacp                        `json:"lacp"`
	Lagportlacp                 []*TopologyLagportlacp                 `json:"lagportlacp"`
	Lagportstaticlag            []*TopologyLagportstaticlag            `json:"lagportstaticlag"`
	LightweightDhcpv6relayAgent []*TopologyLightweightDhcpv6relayAgent `json:"lightweightDhcpv6relayAgent"`
	Macsec                      []*TopologyMacsec                      `json:"macsec"`
	Mka                         []*TopologyMka                         `json:"mka"`
	Mpls                        []*TopologyMpls                        `json:"mpls"`
	MsrpListener                []*TopologyMsrpListener                `json:"msrpListener"`
	MsrpTalker                  []*TopologyMsrpTalker                  `json:"msrpTalker"`
	Pppoxclient                 []*TopologyPppoxclient                 `json:"pppoxclient"`
	Pppoxserver                 []*TopologyPppoxserver                 `json:"pppoxserver"`
	Ptp                         []*TopologyPtp                         `json:"ptp"`
	StaticLag                   []*TopologyStaticLag                   `json:"staticLag"`
	StaticMacsec                []*TopologyStaticMacsec                `json:"staticMacsec"`

	Streams *TopologyStreams `json:"streams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDotOneX) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDotOneX) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDotOneX) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDotOneX) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CaCert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "caCert",
		isMultivalue: true,
	})
	n.CertDir.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "certDir",
		isMultivalue: true,
	})
	n.CertificateKeySameFile.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "certificateKeySameFile",
		isMultivalue: true,
	})
	n.FastInnerMethod.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastInnerMethod",
		isMultivalue: true,
	})
	n.FastProMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastProMode",
		isMultivalue: true,
	})
	n.Faststateless.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "faststateless",
		isMultivalue: true,
	})
	n.HostAuthMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostAuthMode",
		isMultivalue: true,
	})
	n.HostCert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostCert",
		isMultivalue: true,
	})
	n.HostKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostKey",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.HostPwd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostPwd",
		isMultivalue: true,
	})
	n.PeerCert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerCert",
		isMultivalue: true,
	})
	n.PrivateKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "privateKey",
		isMultivalue: true,
	})
	n.Protocol.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protocol",
		isMultivalue: true,
	})
	n.RunTimeCertGen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "runTimeCertGen",
		isMultivalue: true,
	})
	n.SendCACertOnly.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendCACertOnly",
		isMultivalue: true,
	})
	n.TlsVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tlsVersion",
		isMultivalue: true,
	})
	n.UserName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userName",
		isMultivalue: true,
	})
	n.UserPwd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userPwd",
		isMultivalue: true,
	})
	n.VerifyPeer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "verifyPeer",
		isMultivalue: true,
	})
	n.WaitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "waitId",
		isMultivalue: true,
	})
	for i, o := range n.BondedGRE {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bondedGRE",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CfmBridge {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmBridge",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv4client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Esmc {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "esmc",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Autoconfiguration {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Autoconfiguration",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDceSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDceSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisFabricPath {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisFabricPath",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBcb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBcb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBeb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBeb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrill {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrill",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportlacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportlacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportstaticlag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportstaticlag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LightweightDhcpv6relayAgent {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lightweightDhcpv6relayAgent",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Macsec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "macsec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mka {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mka",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpListener {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpListener",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpTalker {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpTalker",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pppoxclient {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pppoxclient",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pppoxserver {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pppoxserver",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ptp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ptp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StaticLag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "staticLag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StaticMacsec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "staticMacsec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Streams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "streams",
	})
}

// TopologyDslPools: Represents an Access Loop connected to a DSLAM running ANCP
type TopologyDslPools struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActualNetDataRateDownstream: Actual downstream net data rate on a DSL access line. Rate in kbits/s as a 32-bit unsigned integer
	ActualNetDataRateDownstream *Multivalue `json:"actualNetDataRateDownstream,omitempty"`
	// ActualNetDataRateDownstreamTolerance: Percentage for variation of Actual Net Data Rate Downstream TLV value when sending port-up messages in flapping behavior
	ActualNetDataRateDownstreamTolerance *Multivalue `json:"actualNetDataRateDownstreamTolerance,omitempty"`
	// ActualNetDataRateUpstream: Actual upstream net data rate on a DSL access line. Rate in kbits/s as a 32-bit unsigned integer
	ActualNetDataRateUpstream *Multivalue `json:"actualNetDataRateUpstream,omitempty"`
	// ActualNetDataRateUpstreamTolerance: Percentage for variation of Actual Net Data Rate Upstream TLV value when sending port-up messages in flapping behavior
	ActualNetDataRateUpstreamTolerance *Multivalue `json:"actualNetDataRateUpstreamTolerance,omitempty"`
	// CircuitId: A locally administered human-readable string generated by or configured on the Access Node, identifying the corresponding access loop logical port on the user side of the Access Node
	CircuitId *Multivalue `json:"circuitId,omitempty"`
	// DslType: DSL Type value for DSL Type TLV
	DslType *Multivalue `json:"dslType,omitempty"`
	// EnableActualNetDataRateDownstream: Enable Actual-Net-Data-Rate-Downstream TLV
	EnableActualNetDataRateDownstream *Multivalue `json:"enableActualNetDataRateDownstream,omitempty"`
	// EnableActualNetDataRateUpstream: Enable Actual-Net-Data-Rate-Upstream TLV
	EnableActualNetDataRateUpstream *Multivalue `json:"enableActualNetDataRateUpstream,omitempty"`
	// EnableDslType: Enable DSL Type TLV
	EnableDslType *Multivalue `json:"enableDslType,omitempty"`
	// EnablePonType: Enable PON Type TLV
	EnablePonType *Multivalue `json:"enablePonType,omitempty"`
	// EnableRemoteId: Enable Access-Loop-Remote-ID TLV
	EnableRemoteId *Multivalue `json:"enableRemoteId,omitempty"`
	// FlappingMode: Enable a flapping profile. Resync will send Port-Up messages, one message every 'Flap Interval' seconds. Reset will send Port-Up followed by Port-Down messages, one message every 'Flap Interval' seconds. Stop will stop the flapping profile, and send one Port-Up message if the line is silent at the time of stopping the flapping profile.
	FlappingMode *Multivalue `json:"flappingMode,omitempty"`
	// InnerVlanId: Inner VLAN ID for N:1 and 1:1 VLAN mapping in Access-Aggregation-Circuit-ID-Binary TLV
	InnerVlanId *Multivalue `json:"innerVlanId,omitempty"`
	// LineDownInterval: Interval in milliseconds to wait after sending port-down message when flapping is enabled
	LineDownInterval *Multivalue `json:"lineDownInterval,omitempty"`
	// LineUpInterval: Interval in milliseconds to wait after sending port-up message when flapping is enabled
	LineUpInterval *Multivalue `json:"lineUpInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OuterVlanId: Outer VLAN ID for 1:1 VLAN mapping in Access-Aggregation-Circuit-ID-Binary TLV
	OuterVlanId *Multivalue `json:"outerVlanId,omitempty"`
	// PonType: PON Type value for PON Type TLV
	PonType *Multivalue `json:"ponType,omitempty"`
	// RemoteId: An operator-configured string that uniquely identifies the user on the associated access line
	RemoteId *Multivalue `json:"remoteId,omitempty"`
	// TechType: Type of Access Loop Technology
	TechType *Multivalue `json:"techType,omitempty"`
	// VlanAllocationModel: Access-Aggregation-Circuit-ID-Binary TLV disable, enable N:1 vlan allocation model or 1:1 vlan allocation model
	VlanAllocationModel *Multivalue `json:"vlanAllocationModel,omitempty"`

	Connector  *TopologyConnector    `json:"connector,omitempty"`
	TlvProfile []*TopologyTlvProfile `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyDslPools) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyDslPools) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyDslPools) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyDslPools) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActualNetDataRateDownstream.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actualNetDataRateDownstream",
		isMultivalue: true,
	})
	n.ActualNetDataRateDownstreamTolerance.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actualNetDataRateDownstreamTolerance",
		isMultivalue: true,
	})
	n.ActualNetDataRateUpstream.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actualNetDataRateUpstream",
		isMultivalue: true,
	})
	n.ActualNetDataRateUpstreamTolerance.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actualNetDataRateUpstreamTolerance",
		isMultivalue: true,
	})
	n.CircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "circuitId",
		isMultivalue: true,
	})
	n.DslType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dslType",
		isMultivalue: true,
	})
	n.EnableActualNetDataRateDownstream.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableActualNetDataRateDownstream",
		isMultivalue: true,
	})
	n.EnableActualNetDataRateUpstream.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableActualNetDataRateUpstream",
		isMultivalue: true,
	})
	n.EnableDslType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDslType",
		isMultivalue: true,
	})
	n.EnablePonType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePonType",
		isMultivalue: true,
	})
	n.EnableRemoteId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRemoteId",
		isMultivalue: true,
	})
	n.FlappingMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flappingMode",
		isMultivalue: true,
	})
	n.InnerVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "innerVlanId",
		isMultivalue: true,
	})
	n.LineDownInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lineDownInterval",
		isMultivalue: true,
	})
	n.LineUpInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lineUpInterval",
		isMultivalue: true,
	})
	n.OuterVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outerVlanId",
		isMultivalue: true,
	})
	n.PonType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ponType",
		isMultivalue: true,
	})
	n.RemoteId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteId",
		isMultivalue: true,
	})
	n.TechType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "techType",
		isMultivalue: true,
	})
	n.VlanAllocationModel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanAllocationModel",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyECpriFaultSubObjectsList: ECPRI Fault Sub Objects
type TopologyECpriFaultSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ElementId: Element ID Number ranging between 0x0000 to 0xFFFE is for vendor specific usage and 0xFFFF is for a fault or notification applicable for all Elements i.e. the node.
	ElementId *Multivalue `json:"elementId,omitempty"`
	// FaultNumber: Fault or Notify Numbers is a 12-bit number indicating a fault or notification divided between 2 bytes.
	FaultNumber *Multivalue `json:"faultNumber,omitempty"`
	// FaultType: In every Raise or Cease value, first nibble in the same byte as the Fault or Notification Number.
	FaultType *Multivalue `json:"faultType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyECpriFaultSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyECpriFaultSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyECpriFaultSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyECpriFaultSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ElementId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "elementId",
		isMultivalue: true,
	})
	n.FaultNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "faultNumber",
		isMultivalue: true,
	})
	n.FaultType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "faultType",
		isMultivalue: true,
	})
}

// TopologyECpriRe: EcpriRe
type TopologyECpriRe struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActionType: Action Type value 0x00 and 0x01 are used when an eCPRI node initiates a one-way delay measurement in direction from its own node to another node. Value 0x02 is used when an eCPRI node needs to know the one-way delay from another node to itself.
	ActionType *Multivalue `json:"actionType,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Address: The Address is a 48-bit value. Details such as whether the memory on the opposite node is organized in one or more memory banks or whether an address offset is signaled over the interface etc. are vendor specific. The Element ID could be used for identifying a specific memory hardware instance.
	Address *Multivalue `json:"address,omitempty"`
	// CompensationValue: When Action Type is set to 0x00 (Request), 0x02 (Response) or 0x05 (Follow_Up) in the message, this field will contain the Compensation Value which is the compensation time measured in nanoseconds and multiplied by 2 to the power 16 and follows the format for the correctionField in the common message header specified in IEEE 1588-2008 Clause 13.3 [13]. When Action Type is set to 0x03 (Remote Request) or 0x04 (Remote Request with Follow_Up) the time information fields TimeStamp and Compensation Value are set to 0b in all bits. A Compensation Value of 0 (zero) is a valid value.Example: A Compensation Value of 183.5 ns is represented as 0000000000B78000 with base 16.
	CompensationValue *Multivalue `json:"compensationValue,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DelayMeasurementId: The Measurement ID is a 1-byte value used by the sender of the request when the response is received to distinguish between different measurements, i.e. the receiver of the request shall copy the ID from the request into the response message.
	DelayMeasurementId *Multivalue `json:"delayMeasurementId,omitempty"`
	// DummyBytesLength: The number of dummy bytes included in the eCPRI-payload will be defined by the eCPRI payload size field in the eCPRI common header. Due to network characteristics, a small message might take shorter time through the network than a large one, with the dummy bytes the one-way delay estimation can be improved. The insertion of dummy bytes is only needed when the Action Type set to 0x00 (Request) or to 0x01(Request with Follow_Up).
	DummyBytesLength *Multivalue `json:"dummyBytesLength,omitempty"`
	// ElementId: Depending on implementation the Element ID could be used for instance to point out a specific instance of a generic hardware function.
	ElementId *Multivalue `json:"elementId,omitempty"`
	// EventId: A 1-byte value set by the transmitter of an Event Indication or a Synchronization Request to enable identification of the acknowledge response.
	EventId *Multivalue `json:"eventId,omitempty"`
	// EventSequenceNumber: The Sequence Number is a 1-byte value that is incremented each time the transmitter sends the Event Indication with Event Type set to 0x00 (Fault(s) Indication). The receiver will use the sequence number to ensure that the correct status for a specific combination of {Element-ID; Fault-value} is used. Due to the nature of the packet based fronthaul network, packets might be delivered out of order and a sequence number is needed to handle this scenario. When a fault indication is not acknowledged the transmitter will re-transmit the fault, setting the sequence number to the same value used in the initial transmission.
	EventSequenceNumber *Multivalue `json:"eventSequenceNumber,omitempty"`
	// EventType: Event Type value ranges from 0x00 to 0xFF, where 0x00 represents Fault(s) Indication, 0x01 represents Fault(s) Indication Acknowledge, 0x02 represents Notification(s) Indication, 0x03 represents Synchronization Request, 0x04 represents Synchronization Acknowledge, 0x05 represents Synchronization End Indication and values from 0x06 to 0xFF are Reserved.
	EventType *Multivalue `json:"eventType,omitempty"`
	// MessageType: Message Type

	MessageType *string `json:"messageType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfFaultSubObjects: Number Of Fault or Notify.

	NumberOfFaultSubObjects *float32 `json:"numberOfFaultSubObjects,omitempty"`
	// ReadWriteType: The field consist of two parts, a read or write indication and a request or response indication. The Response value 0010b (Failure) is used when the receiver of the request is unable to perform the read or write request due to invalid content in received parameters or other faults.
	ReadWriteType *Multivalue `json:"readWriteType,omitempty"`
	// RemoteResetId: Depending on implementation the Reset ID could be used for instance to point out a specific instance of a generic hardware function. Value allocation to Reset ID is vendor specific.
	RemoteResetId *Multivalue `json:"remoteResetId,omitempty"`
	// ReservedActionType: The Action Type is a 1-byte value. Value 0x00 and 0x01 are used when an eCPRI node initiates a one-way delay measurement in direction from its own node to another node. Value 0x02 is used when an eCPRI node needs to know the one-way delay from another node to itself.
	ReservedActionType *Multivalue `json:"reservedActionType,omitempty"`
	// ReservedEventType: Reserved Event Type values from 0x06 to 0xFF are Reserved.
	ReservedEventType *Multivalue `json:"reservedEventType,omitempty"`
	// ReservedResetCode: The Reset Code Op is a 1-byte value. Value 0x00 represents Reserved, 0x01 represents Remote reset request, 0x02 represents Remote reset response and value ranging from 0x03 to 0xFF are Reserved.
	ReservedResetCode *Multivalue `json:"reservedResetCode,omitempty"`
	// ResetCodeOp: The Reset Code Op is a 1-byte value. Value 0x00 represents Reserved, 0x01 represents Remote Reset Request, 0x02 represents Remote Reset Response.Values from 0x03 to 0xFF is Reserved.
	ResetCodeOp *Multivalue `json:"resetCodeOp,omitempty"`
	// RmaAction: RMA Action Type is Request or Response or Failure.
	RmaAction *Multivalue `json:"rmaAction,omitempty"`
	// RmaDataLength: Number of bytes(0 to 255) to read or write from or to remote node.
	RmaDataLength *Multivalue `json:"rmaDataLength,omitempty"`
	// RtcDataLength: Size of RTC data that will be included in the eCPRI message.
	RtcDataLength *Multivalue `json:"rtcDataLength,omitempty"`
	// SequenceId: An identifier of each message in a series of Real-Time Control Data messages. For example, identifier of message sequence, links between request and response messages,etc. Value allocation to SEQ_ID is vendor specific.
	SequenceId *Multivalue `json:"sequenceId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartingRmaId: Identifier of the request message used by the Initiator to match the corresponding response message.
	StartingRmaId *Multivalue `json:"startingRmaId,omitempty"`
	// StartingRtcId: RTC ID of the eRE or eREC.
	StartingRtcId *Multivalue `json:"startingRtcId,omitempty"`
	// TimeStamp: When Action Type is set to 0x00 (Request) in the message this field will contain the time stamp t1 and when Action Type is set to 0x02 (Response) the time stamp t2. When action type is set to 0x01(Request with Follow_Up) the time stamp information fields shall be set to 0b in all bits, the corresponding time information values are sent in the Follow_Up message. When Action Type is set to 0x03 or 0x04 (Remote Request and Remote Request with Follow_Up) the time stamp information fields shall be set to 0b in all bits. When using the Follow_Up message (2-Step version) the Follow_Up message (Action Type set to 0x05) the time information values t1 and tCV1 will be set to the TimeStamp field. The time information values follow the format specified in IEEE 1588-2008 [13] Clause 5.3.3. The value consists of 2 parts, one seconds-part and one nanoseconds-part. The first 6 bytes are the seconds and the next 4 bytes are the nanoseconds.
	TimeStamp *Multivalue `json:"timeStamp,omitempty"`
	// VendorSpecificPayloadLength: Vendor Specific Payload bytes are used to carry optional vendor-specific information. The vendor specific information can contain data items such as authentication parameters or any parameters to select a specific reset behavior. This specification does not detail any concrete reset behavior.
	VendorSpecificPayloadLength *Multivalue `json:"vendorSpecificPayloadLength,omitempty"`

	Connector                *TopologyConnector                  `json:"connector,omitempty"`
	ECpriFaultSubObjectsList []*TopologyECpriFaultSubObjectsList `json:"eCpriFaultSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyECpriRe) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyECpriRe) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyECpriRe) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyECpriRe) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actionType",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "address",
		isMultivalue: true,
	})
	n.CompensationValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "compensationValue",
		isMultivalue: true,
	})
	n.DelayMeasurementId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayMeasurementId",
		isMultivalue: true,
	})
	n.DummyBytesLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dummyBytesLength",
		isMultivalue: true,
	})
	n.ElementId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "elementId",
		isMultivalue: true,
	})
	n.EventId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eventId",
		isMultivalue: true,
	})
	n.EventSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eventSequenceNumber",
		isMultivalue: true,
	})
	n.EventType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eventType",
		isMultivalue: true,
	})
	n.ReadWriteType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "readWriteType",
		isMultivalue: true,
	})
	n.RemoteResetId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteResetId",
		isMultivalue: true,
	})
	n.ReservedActionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedActionType",
		isMultivalue: true,
	})
	n.ReservedEventType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedEventType",
		isMultivalue: true,
	})
	n.ReservedResetCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedResetCode",
		isMultivalue: true,
	})
	n.ResetCodeOp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "resetCodeOp",
		isMultivalue: true,
	})
	n.RmaAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rmaAction",
		isMultivalue: true,
	})
	n.RmaDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rmaDataLength",
		isMultivalue: true,
	})
	n.RtcDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rtcDataLength",
		isMultivalue: true,
	})
	n.SequenceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sequenceId",
		isMultivalue: true,
	})
	n.StartingRmaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingRmaId",
		isMultivalue: true,
	})
	n.StartingRtcId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingRtcId",
		isMultivalue: true,
	})
	n.TimeStamp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeStamp",
		isMultivalue: true,
	})
	n.VendorSpecificPayloadLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vendorSpecificPayloadLength",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.ECpriFaultSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriFaultSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyECpriReRadioChannelsOrUsers: EcpriReRadioChannelsOrUsers
type TopologyECpriReRadioChannelsOrUsers struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ChannelId: Identification of a Channel or User.
	ChannelId *Multivalue `json:"channelId,omitempty"`
	// MessageType: Message Type.

	MessageType *string `json:"messageType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SequenceId: An identifier of each message in a series of IQ Data Transfer messages.
	SequenceId *Multivalue `json:"sequenceId,omitempty"`
	// UserDataLength: The number bytes(0 to 255) to be included as bit sequence of user data.
	UserDataLength *Multivalue               `json:"userDataLength,omitempty"`
	CMacProperties []*TopologyCMacProperties `json:"cMacProperties"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyECpriReRadioChannelsOrUsers) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyECpriReRadioChannelsOrUsers) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyECpriReRadioChannelsOrUsers) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyECpriReRadioChannelsOrUsers) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ChannelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "channelId",
		isMultivalue: true,
	})
	n.SequenceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sequenceId",
		isMultivalue: true,
	})
	n.UserDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDataLength",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyECpriRec: EcpriRe
type TopologyECpriRec struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActionType: Action Type value 0x00 and 0x01 are used when an eCPRI node initiates a one-way delay measurement in direction from its own node to another node. Value 0x02 is used when an eCPRI node needs to know the one-way delay from another node to itself.
	ActionType *Multivalue `json:"actionType,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Address: The Address is a 48-bit value. Details such as whether the memory on the opposite node is organized in one or more memory banks or whether an address offset is signaled over the interface etc. are vendor specific. The Element ID could be used for identifying a specific memory hardware instance.
	Address *Multivalue `json:"address,omitempty"`
	// CompensationValue: When Action Type is set to 0x00 (Request), 0x02 (Response) or 0x05 (Follow_Up) in the message, this field will contain the Compensation Value which is the compensation time measured in nanoseconds and multiplied by 2 to the power 16 and follows the format for the correctionField in the common message header specified in IEEE 1588-2008 Clause 13.3 [13]. When Action Type is set to 0x03 (Remote Request) or 0x04 (Remote Request with Follow_Up) the time information fields TimeStamp and Compensation Value are set to 0b in all bits. A Compensation Value of 0 (zero) is a valid value.Example: A Compensation Value of 183.5 ns is represented as 0000000000B78000 with base 16.
	CompensationValue *Multivalue `json:"compensationValue,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DelayMeasurementId: The Measurement ID is a 1-byte value used by the sender of the request when the response is received to distinguish between different measurements, i.e. the receiver of the request shall copy the ID from the request into the response message.
	DelayMeasurementId *Multivalue `json:"delayMeasurementId,omitempty"`
	// DummyBytesLength: The number of dummy bytes included in the eCPRI-payload will be defined by the eCPRI payload size field in the eCPRI common header. Due to network characteristics, a small message might take shorter time through the network than a large one, with the dummy bytes the one-way delay estimation can be improved. The insertion of dummy bytes is only needed when the Action Type set to 0x00 (Request) or to 0x01(Request with Follow_Up).
	DummyBytesLength *Multivalue `json:"dummyBytesLength,omitempty"`
	// ElementId: Depending on implementation the Element ID could be used for instance to point out a specific instance of a generic hardware function.
	ElementId *Multivalue `json:"elementId,omitempty"`
	// EventId: A 1-byte value set by the transmitter of an Event Indication or a Synchronization Request to enable identification of the acknowledge response.
	EventId *Multivalue `json:"eventId,omitempty"`
	// EventSequenceNumber: The Sequence Number is a 1-byte value that is incremented each time the transmitter sends the Event Indication with Event Type set to 0x00 (Fault(s) Indication). The receiver will use the sequence number to ensure that the correct status for a specific combination of {Element-ID; Fault-value} is used. Due to the nature of the packet based fronthaul network, packets might be delivered out of order and a sequence number is needed to handle this scenario. When a fault indication is not acknowledged the transmitter will re-transmit the fault, setting the sequence number to the same value used in the initial transmission.
	EventSequenceNumber *Multivalue `json:"eventSequenceNumber,omitempty"`
	// EventType: Event Type value ranges from 0x00 to 0xFF, where 0x00 represents Fault(s) Indication, 0x01 represents Fault(s) Indication Acknowledge, 0x02 represents Notification(s) Indication, 0x03 represents Synchronization Request, 0x04 represents Synchronization Acknowledge, 0x05 represents Synchronization End Indication and values from 0x06 to 0xFF are Reserved.
	EventType *Multivalue `json:"eventType,omitempty"`
	// MessageType: Message Type

	MessageType *string `json:"messageType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfFaultSubObjects: Number Of Fault or Notify.

	NumberOfFaultSubObjects *float32 `json:"numberOfFaultSubObjects,omitempty"`
	// ReadWriteType: The field consist of two parts, a read or write indication and a request or response indication. The Response value 0010b (Failure) is used when the receiver of the request is unable to perform the read or write request due to invalid content in received parameters or other faults.
	ReadWriteType *Multivalue `json:"readWriteType,omitempty"`
	// RemoteResetId: Depending on implementation the Reset ID could be used for instance to point out a specific instance of a generic hardware function. Value allocation to Reset ID is vendor specific.
	RemoteResetId *Multivalue `json:"remoteResetId,omitempty"`
	// ReservedActionType: The Action Type is a 1-byte value. Value 0x00 and 0x01 are used when an eCPRI node initiates a one-way delay measurement in direction from its own node to another node. Value 0x02 is used when an eCPRI node needs to know the one-way delay from another node to itself.
	ReservedActionType *Multivalue `json:"reservedActionType,omitempty"`
	// ReservedEventType: Reserved Event Type values from 0x06 to 0xFF are Reserved.
	ReservedEventType *Multivalue `json:"reservedEventType,omitempty"`
	// ReservedResetCode: The Reset Code Op is a 1-byte value. Value 0x00 represents Reserved, 0x01 represents Remote reset request, 0x02 represents Remote reset response and value ranging from 0x03 to 0xFF are Reserved.
	ReservedResetCode *Multivalue `json:"reservedResetCode,omitempty"`
	// ResetCodeOp: The Reset Code Op is a 1-byte value. Value 0x00 represents Reserved, 0x01 represents Remote Reset Request, 0x02 represents Remote Reset Response.Values from 0x03 to 0xFF is Reserved.
	ResetCodeOp *Multivalue `json:"resetCodeOp,omitempty"`
	// RmaAction: RMA Action Type is Request or Response or Failure.
	RmaAction *Multivalue `json:"rmaAction,omitempty"`
	// RmaDataLength: Number of bytes(0 to 255) to read or write from or to remote node.
	RmaDataLength *Multivalue `json:"rmaDataLength,omitempty"`
	// RtcDataLength: Size of RTC data that will be included in the eCPRI message.
	RtcDataLength *Multivalue `json:"rtcDataLength,omitempty"`
	// SequenceId: An identifier of each message in a series of Real-Time Control Data messages. For example, identifier of message sequence, links between request and response messages,etc. Value allocation to SEQ_ID is vendor specific.
	SequenceId *Multivalue `json:"sequenceId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartingRmaId: Identifier of the request message used by the Initiator to match the corresponding response message.
	StartingRmaId *Multivalue `json:"startingRmaId,omitempty"`
	// StartingRtcId: RTC ID of the eRE or eREC.
	StartingRtcId *Multivalue `json:"startingRtcId,omitempty"`
	// TimeStamp: When Action Type is set to 0x00 (Request) in the message this field will contain the time stamp t1 and when Action Type is set to 0x02 (Response) the time stamp t2. When action type is set to 0x01(Request with Follow_Up) the time stamp information fields shall be set to 0b in all bits, the corresponding time information values are sent in the Follow_Up message. When Action Type is set to 0x03 or 0x04 (Remote Request and Remote Request with Follow_Up) the time stamp information fields shall be set to 0b in all bits. When using the Follow_Up message (2-Step version) the Follow_Up message (Action Type set to 0x05) the time information values t1 and tCV1 will be set to the TimeStamp field. The time information values follow the format specified in IEEE 1588-2008 [13] Clause 5.3.3. The value consists of 2 parts, one seconds-part and one nanoseconds-part. The first 6 bytes are the seconds and the next 4 bytes are the nanoseconds.
	TimeStamp *Multivalue `json:"timeStamp,omitempty"`
	// VendorSpecificPayloadLength: Vendor Specific Payload bytes are used to carry optional vendor-specific information. The vendor specific information can contain data items such as authentication parameters or any parameters to select a specific reset behavior. This specification does not detail any concrete reset behavior.
	VendorSpecificPayloadLength *Multivalue `json:"vendorSpecificPayloadLength,omitempty"`

	Connector                *TopologyConnector                  `json:"connector,omitempty"`
	ECpriFaultSubObjectsList []*TopologyECpriFaultSubObjectsList `json:"eCpriFaultSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyECpriRec) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyECpriRec) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyECpriRec) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyECpriRec) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actionType",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "address",
		isMultivalue: true,
	})
	n.CompensationValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "compensationValue",
		isMultivalue: true,
	})
	n.DelayMeasurementId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayMeasurementId",
		isMultivalue: true,
	})
	n.DummyBytesLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dummyBytesLength",
		isMultivalue: true,
	})
	n.ElementId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "elementId",
		isMultivalue: true,
	})
	n.EventId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eventId",
		isMultivalue: true,
	})
	n.EventSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eventSequenceNumber",
		isMultivalue: true,
	})
	n.EventType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eventType",
		isMultivalue: true,
	})
	n.ReadWriteType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "readWriteType",
		isMultivalue: true,
	})
	n.RemoteResetId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteResetId",
		isMultivalue: true,
	})
	n.ReservedActionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedActionType",
		isMultivalue: true,
	})
	n.ReservedEventType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedEventType",
		isMultivalue: true,
	})
	n.ReservedResetCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedResetCode",
		isMultivalue: true,
	})
	n.ResetCodeOp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "resetCodeOp",
		isMultivalue: true,
	})
	n.RmaAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rmaAction",
		isMultivalue: true,
	})
	n.RmaDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rmaDataLength",
		isMultivalue: true,
	})
	n.RtcDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rtcDataLength",
		isMultivalue: true,
	})
	n.SequenceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sequenceId",
		isMultivalue: true,
	})
	n.StartingRmaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingRmaId",
		isMultivalue: true,
	})
	n.StartingRtcId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingRtcId",
		isMultivalue: true,
	})
	n.TimeStamp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeStamp",
		isMultivalue: true,
	})
	n.VendorSpecificPayloadLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vendorSpecificPayloadLength",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.ECpriFaultSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriFaultSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyECpriRecRadioChannelsOrUsers: EcpriRecRadioChannelsOrUsers
type TopologyECpriRecRadioChannelsOrUsers struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ChannelId: Identification of a Channel or User.
	ChannelId *Multivalue `json:"channelId,omitempty"`
	// MessageType: Message Type.

	MessageType *string `json:"messageType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SequenceId: An identifier of each message in a series of IQ Data Transfer messages.
	SequenceId *Multivalue `json:"sequenceId,omitempty"`
	// UserDataLength: The number bytes(0 to 255) to be included as bit sequence of user data.
	UserDataLength *Multivalue               `json:"userDataLength,omitempty"`
	CMacProperties []*TopologyCMacProperties `json:"cMacProperties"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyECpriRecRadioChannelsOrUsers) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyECpriRecRadioChannelsOrUsers) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyECpriRecRadioChannelsOrUsers) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyECpriRecRadioChannelsOrUsers) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ChannelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "channelId",
		isMultivalue: true,
	})
	n.SequenceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sequenceId",
		isMultivalue: true,
	})
	n.UserDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDataLength",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyErrorInfo: TBD
type TopologyErrorInfo struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyErrorInfo) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyErrorInfo) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyErrorInfo) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyErrorInfo) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyEsmc: ESMC protocol
type TopologyEsmc struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// CustomSyncEclockIdentity: This denotes the Sync E clock identity of the originator of the extended QL TLV. By default it is the MAC address of the underlying ethernet stack.
	CustomSyncEclockIdentity *Multivalue `json:"customSyncEclockIdentity,omitempty"`
	// EnableCustomSyncEclockIdentity: Enables user to provide the Sync E clock identity.
	EnableCustomSyncEclockIdentity *Multivalue `json:"enableCustomSyncEclockIdentity,omitempty"`
	// ExtendedQlTlvEnable: Enables addition of extended QL tlv in ESMC PDU.
	ExtendedQlTlvEnable *Multivalue `json:"extendedQlTlvEnable,omitempty"`
	// FlagMode: Sets the event transmition.
	FlagMode *Multivalue `json:"flagMode,omitempty"`
	// MixedEECs: This denotes that whether at least one clock is not eEEC in the chain.
	MixedEECs *Multivalue `json:"mixedEECs,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfCascadedEecs: Denotes the number of cascaded EECs from the nearest SSU/PRC.
	NumberOfCascadedEecs *Multivalue `json:"numberOfCascadedEecs,omitempty"`
	// NumberOfCascadedEeecs: Denotes the number of cascaded eEECs from the nearest SSU/PRC.
	NumberOfCascadedEeecs *Multivalue `json:"numberOfCascadedEeecs,omitempty"`
	// PartialChain: This denotes whether the TLV is generated in the middle of the Chain.
	PartialChain *Multivalue `json:"partialChain,omitempty"`
	// QualityLevel: The SSM clock quality level(QL) code.
	QualityLevel *Multivalue `json:"qualityLevel,omitempty"`
	// QualityLevelExtendedTlv: The Enhanced SSM clock quality level(QL) code for extended QL TLV.
	QualityLevelExtendedTlv *Multivalue `json:"qualityLevelExtendedTlv,omitempty"`
	// SendDnuIfBetterQlReceived: Changes transmitted QL to DNU when better QL received.
	SendDnuIfBetterQlReceived *Multivalue `json:"sendDnuIfBetterQlReceived,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// Timeout: Transmits old QL after not receiving better QL for Timeout seconds.
	Timeout *Multivalue `json:"timeout,omitempty"`
	// TransmissionRate: Sets transmission rate in seconds. Default rate is 1 seconds.
	TransmissionRate *Multivalue `json:"transmissionRate,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyEsmc) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyEsmc) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyEsmc) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyEsmc) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.CustomSyncEclockIdentity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSyncEclockIdentity",
		isMultivalue: true,
	})
	n.EnableCustomSyncEclockIdentity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCustomSyncEclockIdentity",
		isMultivalue: true,
	})
	n.ExtendedQlTlvEnable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extendedQlTlvEnable",
		isMultivalue: true,
	})
	n.FlagMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flagMode",
		isMultivalue: true,
	})
	n.MixedEECs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mixedEECs",
		isMultivalue: true,
	})
	n.NumberOfCascadedEecs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfCascadedEecs",
		isMultivalue: true,
	})
	n.NumberOfCascadedEeecs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfCascadedEeecs",
		isMultivalue: true,
	})
	n.PartialChain.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partialChain",
		isMultivalue: true,
	})
	n.QualityLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "qualityLevel",
		isMultivalue: true,
	})
	n.QualityLevelExtendedTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "qualityLevelExtendedTlv",
		isMultivalue: true,
	})
	n.SendDnuIfBetterQlReceived.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendDnuIfBetterQlReceived",
		isMultivalue: true,
	})
	n.Timeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeout",
		isMultivalue: true,
	})
	n.TransmissionRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transmissionRate",
		isMultivalue: true,
	})
}

// TopologyEthernet: Ethernet
type TopologyEthernet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableVlans: Enables VLANs for the sessions.
	EnableVlans *Multivalue `json:"enableVlans,omitempty"`
	// Mac: MAC addresses of the devices
	Mac *Multivalue `json:"mac,omitempty"`
	// Mtu: Maximum transmission unit, min=68, max=16000
	Mtu *Multivalue `json:"mtu,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NotifyMACMove: Flag to determine if MAC move notification to be sent

	NotifyMACMove *bool `json:"notifyMACMove,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UseVlans: Flag to determine whether VLANs are enabled

	UseVlans *bool `json:"useVlans,omitempty"`
	// VlanCount: Number of active VLANs

	VlanCount *float32             `json:"vlanCount,omitempty"`
	BondedGRE []*TopologyBondedGre `json:"bondedGRE"`
	CfmBridge []*TopologyCfmBridge `json:"cfmBridge"`

	Connector                   *TopologyConnector                     `json:"connector,omitempty"`
	Dhcpv4client                []*TopologyDhcpv4client                `json:"dhcpv4client"`
	Dhcpv6client                []*TopologyDhcpv6client                `json:"dhcpv6client"`
	DotOneX                     []*TopologyDotOneX                     `json:"dotOneX"`
	ECpriRe                     []*TopologyECpriRe                     `json:"eCpriRe"`
	ECpriRec                    []*TopologyECpriRec                    `json:"eCpriRec"`
	Esmc                        []*TopologyEsmc                        `json:"esmc"`
	Ipv4                        []*TopologyIpv4                        `json:"ipv4"`
	Ipv6                        []*TopologyIpv6                        `json:"ipv6"`
	Ipv6Autoconfiguration       []*TopologyIpv6Autoconfiguration       `json:"ipv6Autoconfiguration"`
	IsisDceSimRouter            []*TopologyIsisDceSimRouter            `json:"isisDceSimRouter"`
	IsisFabricPath              []*TopologyIsisFabricPath              `json:"isisFabricPath"`
	IsisL3                      []*TopologyIsisL3                      `json:"isisL3"`
	IsisSpbBcb                  []*TopologyIsisSpbBcb                  `json:"isisSpbBcb"`
	IsisSpbBeb                  []*TopologyIsisSpbBeb                  `json:"isisSpbBeb"`
	IsisSpbSimRouter            []*TopologyIsisSpbSimRouter            `json:"isisSpbSimRouter"`
	IsisTrill                   []*TopologyIsisTrill                   `json:"isisTrill"`
	IsisTrillSimRouter          []*TopologyIsisTrillSimRouter          `json:"isisTrillSimRouter"`
	Lacp                        []*TopologyLacp                        `json:"lacp"`
	Lagportlacp                 []*TopologyLagportlacp                 `json:"lagportlacp"`
	Lagportstaticlag            []*TopologyLagportstaticlag            `json:"lagportstaticlag"`
	LightweightDhcpv6relayAgent []*TopologyLightweightDhcpv6relayAgent `json:"lightweightDhcpv6relayAgent"`
	Macsec                      []*TopologyMacsec                      `json:"macsec"`
	Mka                         []*TopologyMka                         `json:"mka"`
	Mpls                        []*TopologyMpls                        `json:"mpls"`
	MsrpListener                []*TopologyMsrpListener                `json:"msrpListener"`
	MsrpTalker                  []*TopologyMsrpTalker                  `json:"msrpTalker"`

	PbbEVpnParameter *TopologyPbbEVpnParameter `json:"pbbEVpnParameter,omitempty"`
	Pppoxclient      []*TopologyPppoxclient    `json:"pppoxclient"`
	Pppoxserver      []*TopologyPppoxserver    `json:"pppoxserver"`
	Ptp              []*TopologyPtp            `json:"ptp"`
	StaticLag        []*TopologyStaticLag      `json:"staticLag"`
	StaticMacsec     []*TopologyStaticMacsec   `json:"staticMacsec"`

	Streams *TopologyStreams `json:"streams,omitempty"`
	Tag     []*TopologyTag   `json:"tag"`
	Vlan    []*TopologyVlan  `json:"vlan"`

	VpnParameter *TopologyVpnParameter `json:"vpnParameter,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyEthernet) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyEthernet) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyEthernet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyEthernet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableVlans.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlans",
		isMultivalue: true,
	})
	n.Mac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mac",
		isMultivalue: true,
	})
	n.Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtu",
		isMultivalue: true,
	})
	for i, o := range n.BondedGRE {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bondedGRE",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CfmBridge {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmBridge",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Dhcpv4client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.DotOneX {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dotOneX",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Esmc {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "esmc",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Autoconfiguration {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Autoconfiguration",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDceSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDceSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisFabricPath {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisFabricPath",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBcb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBcb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBeb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBeb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrill {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrill",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportlacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportlacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportstaticlag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportstaticlag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LightweightDhcpv6relayAgent {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lightweightDhcpv6relayAgent",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Macsec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "macsec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mka {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mka",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpListener {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpListener",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpTalker {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpTalker",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.PbbEVpnParameter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pbbEVpnParameter",
	})
	for i, o := range n.Pppoxclient {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pppoxclient",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pppoxserver {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pppoxserver",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ptp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ptp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StaticLag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "staticLag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StaticMacsec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "staticMacsec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Streams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "streams",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.VpnParameter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "vpnParameter",
	})
}

// TopologyEvpnIPv4PrefixRange: BGP EVPN IPv4 Prefix Range
type TopologyEvpnIPv4PrefixRange struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvertiseSRv6SID: Advertise SRv6 SID
	AdvertiseSRv6SID *Multivalue `json:"advertiseSRv6SID,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LabelMode: Label Mode
	LabelMode *Multivalue `json:"labelMode,omitempty"`
	// LabelStart: Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// LabelStep: Label Step
	LabelStep *Multivalue `json:"labelStep,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags Value
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// Srv6SidStep: Route Range SRv6 SID Step
	Srv6SidStep                *Multivalue                           `json:"srv6SidStep,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`
	CMacProperties             []*TopologyCMacProperties             `json:"cMacProperties"`
	EvpnIPv4PrefixRange        []*TopologyEvpnIPv4PrefixRange        `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange        []*TopologyEvpnIPv6PrefixRange        `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyEvpnIPv4PrefixRange) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyEvpnIPv4PrefixRange) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyEvpnIPv4PrefixRange) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyEvpnIPv4PrefixRange) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SID",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LabelMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelMode",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.LabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStep",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.Srv6SidStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidStep",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyEvpnIPv6PrefixRange: BGP EVPN IPv6 Prefix Range
type TopologyEvpnIPv6PrefixRange struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvSrv6SidInIgp: Advertise SRv6 SID in IGP
	AdvSrv6SidInIgp *Multivalue `json:"advSrv6SidInIgp,omitempty"`
	// AdvertiseSRv6SID: Advertise SRv6 SID
	AdvertiseSRv6SID *Multivalue `json:"advertiseSRv6SID,omitempty"`
	// AggregatorAs: Aggregator AS
	AggregatorAs *Multivalue `json:"aggregatorAs,omitempty"`
	// AggregatorId: Aggregator ID
	AggregatorId *Multivalue `json:"aggregatorId,omitempty"`
	// AsSetMode: AS# Set Mode
	AsSetMode *Multivalue `json:"asSetMode,omitempty"`
	// EnableAggregatorId: Enable Aggregator ID
	EnableAggregatorId *Multivalue `json:"enableAggregatorId,omitempty"`
	// EnableAsPathSegments: Enable AS Path Segments
	EnableAsPathSegments *Multivalue `json:"enableAsPathSegments,omitempty"`
	// EnableAtomicAggregate: Enable Atomic Aggregate
	EnableAtomicAggregate *Multivalue `json:"enableAtomicAggregate,omitempty"`
	// EnableCluster: Enable Cluster
	EnableCluster *Multivalue `json:"enableCluster,omitempty"`
	// EnableCommunity: Enable Community
	EnableCommunity *Multivalue `json:"enableCommunity,omitempty"`
	// EnableExtendedCommunity: Enable Extended Community
	EnableExtendedCommunity *Multivalue `json:"enableExtendedCommunity,omitempty"`
	// EnableLocalPreference: Enable Local Preference
	EnableLocalPreference *Multivalue `json:"enableLocalPreference,omitempty"`
	// EnableMultiExitDiscriminator: Enable Multi Exit
	EnableMultiExitDiscriminator *Multivalue `json:"enableMultiExitDiscriminator,omitempty"`
	// EnableNextHop: Enable Next Hop
	EnableNextHop *Multivalue `json:"enableNextHop,omitempty"`
	// EnableOrigin: Enable Origin
	EnableOrigin *Multivalue `json:"enableOrigin,omitempty"`
	// EnableOriginatorId: Enable Originator ID
	EnableOriginatorId *Multivalue `json:"enableOriginatorId,omitempty"`
	// Ipv4NextHop: IPv4 Next Hop
	Ipv4NextHop *Multivalue `json:"ipv4NextHop,omitempty"`
	// Ipv6NextHop: IPv6 Next Hop
	Ipv6NextHop *Multivalue `json:"ipv6NextHop,omitempty"`
	// LabelMode: Label Mode
	LabelMode *Multivalue `json:"labelMode,omitempty"`
	// LabelStart: Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// LabelStep: Label Step
	LabelStep *Multivalue `json:"labelStep,omitempty"`
	// LocalPreference: Local Preference
	LocalPreference *Multivalue `json:"localPreference,omitempty"`
	// MultiExitDiscriminator: Multi Exit
	MultiExitDiscriminator *Multivalue `json:"multiExitDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfASPathSegmentsPerRouteRange: Number Of AS Path Segments Per Route Range

	NoOfASPathSegmentsPerRouteRange *float32 `json:"noOfASPathSegmentsPerRouteRange,omitempty"`
	// NoOfClusters: Number of Clusters

	NoOfClusters *float32 `json:"noOfClusters,omitempty"`
	// NoOfCommunities: Number of Communities

	NoOfCommunities *float32 `json:"noOfCommunities,omitempty"`
	// NoOfExtendedCommunity: Number of Extended Communities

	NoOfExtendedCommunity *float32 `json:"noOfExtendedCommunity,omitempty"`
	// Origin: Origin
	Origin *Multivalue `json:"origin,omitempty"`
	// OriginatorId: Originator ID
	OriginatorId *Multivalue `json:"originatorId,omitempty"`
	// OverridePeerAsSetMode: Override Peer AS# Set Mode
	OverridePeerAsSetMode *Multivalue `json:"overridePeerAsSetMode,omitempty"`
	// SendSRv6SIDOptionalInfo: If we need to advertise SRv6 SID Optional Information (Service Information sub-TLV) which is specified in next column(s)
	SendSRv6SIDOptionalInfo *Multivalue `json:"sendSRv6SIDOptionalInfo,omitempty"`
	// SetNextHop: Set Next Hop
	SetNextHop *Multivalue `json:"setNextHop,omitempty"`
	// SetNextHopIpType: Set Next Hop IP Type
	SetNextHopIpType *Multivalue `json:"setNextHopIpType,omitempty"`
	// Srv6EndpointBehavior: SRv6 Endpoint Behavior field Value for all routes in this Route Range
	Srv6EndpointBehavior *Multivalue `json:"srv6EndpointBehavior,omitempty"`
	// Srv6SIDOptionalInformation: SRv6 SID Optional Information field Value (Service Information sub-TLV) for all routes in this Route Range
	Srv6SIDOptionalInformation *Multivalue `json:"srv6SIDOptionalInformation,omitempty"`
	// Srv6SidFlags: SRv6 SID Flags Value
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Srv6SidLoc: SRv6 SID. It consists of Locator, Func and Args
	Srv6SidLoc *Multivalue `json:"srv6SidLoc,omitempty"`
	// Srv6SidLocLen: SRv6 SID Locator Length
	Srv6SidLocLen *Multivalue `json:"srv6SidLocLen,omitempty"`
	// Srv6SidLocMetric: SRv6 SID Locator Metric
	Srv6SidLocMetric *Multivalue `json:"srv6SidLocMetric,omitempty"`
	// Srv6SidReserved: SRv6 SID Reserved Value (SRv6 SID Service TLV Level)
	Srv6SidReserved *Multivalue `json:"srv6SidReserved,omitempty"`
	// Srv6SidReserved1: SRv6 SID Reserved1 Field for Service Information sub-TLV
	Srv6SidReserved1 *Multivalue `json:"srv6SidReserved1,omitempty"`
	// Srv6SidReserved2: SRv6 SID Reserved2 Field for Service Information sub-TLV
	Srv6SidReserved2 *Multivalue `json:"srv6SidReserved2,omitempty"`
	// Srv6SidStep: Route Range SRv6 SID Step
	Srv6SidStep                *Multivalue                           `json:"srv6SidStep,omitempty"`
	BgpAsPathSegmentList       []*TopologyBgpAsPathSegmentList       `json:"bgpAsPathSegmentList"`
	BgpClusterIdList           []*TopologyBgpClusterIdList           `json:"bgpClusterIdList"`
	BgpCommunitiesList         []*TopologyBgpCommunitiesList         `json:"bgpCommunitiesList"`
	BgpExtendedCommunitiesList []*TopologyBgpExtendedCommunitiesList `json:"bgpExtendedCommunitiesList"`
	CMacProperties             []*TopologyCMacProperties             `json:"cMacProperties"`
	EvpnIPv4PrefixRange        []*TopologyEvpnIPv4PrefixRange        `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange        []*TopologyEvpnIPv6PrefixRange        `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyEvpnIPv6PrefixRange) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyEvpnIPv6PrefixRange) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyEvpnIPv6PrefixRange) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyEvpnIPv6PrefixRange) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvSrv6SidInIgp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advSrv6SidInIgp",
		isMultivalue: true,
	})
	n.AdvertiseSRv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRv6SID",
		isMultivalue: true,
	})
	n.AggregatorAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorAs",
		isMultivalue: true,
	})
	n.AggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregatorId",
		isMultivalue: true,
	})
	n.AsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asSetMode",
		isMultivalue: true,
	})
	n.EnableAggregatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAggregatorId",
		isMultivalue: true,
	})
	n.EnableAsPathSegments.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAsPathSegments",
		isMultivalue: true,
	})
	n.EnableAtomicAggregate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAtomicAggregate",
		isMultivalue: true,
	})
	n.EnableCluster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCluster",
		isMultivalue: true,
	})
	n.EnableCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCommunity",
		isMultivalue: true,
	})
	n.EnableExtendedCommunity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExtendedCommunity",
		isMultivalue: true,
	})
	n.EnableLocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLocalPreference",
		isMultivalue: true,
	})
	n.EnableMultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMultiExitDiscriminator",
		isMultivalue: true,
	})
	n.EnableNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableNextHop",
		isMultivalue: true,
	})
	n.EnableOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOrigin",
		isMultivalue: true,
	})
	n.EnableOriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOriginatorId",
		isMultivalue: true,
	})
	n.Ipv4NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NextHop",
		isMultivalue: true,
	})
	n.Ipv6NextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NextHop",
		isMultivalue: true,
	})
	n.LabelMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelMode",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.LabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStep",
		isMultivalue: true,
	})
	n.LocalPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localPreference",
		isMultivalue: true,
	})
	n.MultiExitDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multiExitDiscriminator",
		isMultivalue: true,
	})
	n.Origin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origin",
		isMultivalue: true,
	})
	n.OriginatorId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "originatorId",
		isMultivalue: true,
	})
	n.OverridePeerAsSetMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overridePeerAsSetMode",
		isMultivalue: true,
	})
	n.SendSRv6SIDOptionalInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendSRv6SIDOptionalInfo",
		isMultivalue: true,
	})
	n.SetNextHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHop",
		isMultivalue: true,
	})
	n.SetNextHopIpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNextHopIpType",
		isMultivalue: true,
	})
	n.Srv6EndpointBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6EndpointBehavior",
		isMultivalue: true,
	})
	n.Srv6SIDOptionalInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SIDOptionalInformation",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Srv6SidLoc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLoc",
		isMultivalue: true,
	})
	n.Srv6SidLocLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocLen",
		isMultivalue: true,
	})
	n.Srv6SidLocMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidLocMetric",
		isMultivalue: true,
	})
	n.Srv6SidReserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved",
		isMultivalue: true,
	})
	n.Srv6SidReserved1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved1",
		isMultivalue: true,
	})
	n.Srv6SidReserved2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidReserved2",
		isMultivalue: true,
	})
	n.Srv6SidStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidStep",
		isMultivalue: true,
	})
	for i, o := range n.BgpAsPathSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpAsPathSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpClusterIdList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpClusterIdList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpExtendedCommunitiesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpExtendedCommunitiesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyExpectedInitiatedLspList: This specifies the Expected Initiated LSPs from the PCE for traffic generation.
type TopologyExpectedInitiatedLspList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// InsertIpv6ExplicitNull: Insert IPv6 Explicit Null MPLS header if the traffic type is of type IPv6

	InsertIpv6ExplicitNull *bool `json:"insertIpv6ExplicitNull,omitempty"`
	// MaxExpectedSegmentCount: This control is used to set the maximum Segment count/ MPLS labels that would be present in the generted traffic.

	MaxExpectedSegmentCount *float32 `json:"maxExpectedSegmentCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SourceIpv4Address: This is used to set the Source IPv4 address in the IP header of the generated traffic.
	SourceIpv4Address *Multivalue `json:"sourceIpv4Address,omitempty"`
	// SourceIpv6Address: This is used to set the Source IPv6 address in the IP header of the generated traffic.
	SourceIpv6Address *Multivalue `json:"sourceIpv6Address,omitempty"`
	// SymbolicPathName: This is used for generating the traffic for those LSPs from PCE for which the Symbolic Path Name is configured and matches the value.
	SymbolicPathName *Multivalue    `json:"symbolicPathName,omitempty"`
	Tag              []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyExpectedInitiatedLspList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyExpectedInitiatedLspList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyExpectedInitiatedLspList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyExpectedInitiatedLspList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.SourceIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv4Address",
		isMultivalue: true,
	})
	n.SourceIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv6Address",
		isMultivalue: true,
	})
	n.SymbolicPathName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "symbolicPathName",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyExternalLink: Links to NetTopologies with each other
type TopologyExternalLink struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// FromNodeIndex: Index of the originating node as defined in fromNetworkTopology

	FromNodeIndex *float32 `json:"fromNodeIndex,omitempty"`
	// ToNetworkTopology: Network Topology this link is pointing to

	ToNetworkTopology *string `json:"toNetworkTopology,omitempty"`
	// ToNetworkTopologyRefs: Track refs for ToNetworkTopology.
	ToNetworkTopologyRefs []Href `json:"-"`
	// ToNodeIndex: Index of the target node as defined in toNetworkTopology

	ToNodeIndex *float32 `json:"toNodeIndex,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyExternalLink) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyExternalLink) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyExternalLink) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyExternalLink) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyExternalRoutes: External routes with external metric
type TopologyExternalRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EBit: External Metric Bit
	EBit *Multivalue `json:"eBit,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6) before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// ExternalRouteTag: External Route Tag
	ExternalRouteTag *Multivalue `json:"externalRouteTag,omitempty"`
	// FBit: Forwarding Address Bit
	FBit *Multivalue `json:"fBit,omitempty"`
	// ForwardingAddress: 128 Bits IPv6 address.
	ForwardingAddress *Multivalue `json:"forwardingAddress,omitempty"`
	// LABit: Options-LA Bit(Local Address)
	LABit *Multivalue `json:"lABit,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LinkStateId: Link State Id of the simulated IPv6 network
	LinkStateId *Multivalue `json:"linkStateId,omitempty"`
	// LinkStateIdStep: Link State Id Step for the LSAs to be generated for this set of IPv6 Inter-Area networks.
	LinkStateIdStep *Multivalue `json:"linkStateIdStep,omitempty"`
	// MCBit: Options-MC Bit(Multicast)
	MCBit *Multivalue `json:"mCBit,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised by a Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// NUBit: Options-NU Bit(No Unicast)
	NUBit *Multivalue `json:"nUBit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Prefixes of the simulated IPv6 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PBit: Options-P Bit(Propagate)
	PBit *Multivalue `json:"pBit,omitempty"`
	// Prefix: Prefix Length
	Prefix *Multivalue `json:"prefix,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// RefLSType: Reference LS Type
	RefLSType *Multivalue `json:"refLSType,omitempty"`
	// ReferencedLinkStateId: Referenced Link State Id
	ReferencedLinkStateId *Multivalue `json:"referencedLinkStateId,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// TBit: External Route Tag Bit
	TBit *Multivalue `json:"tBit,omitempty"`
	// UnusedBit4: Options-(4)Unused
	UnusedBit4 *Multivalue `json:"unusedBit4,omitempty"`
	// UnusedBit5: Options-(5)Unused
	UnusedBit5 *Multivalue `json:"unusedBit5,omitempty"`
	// UnusedBit6: Options-(6)Unused
	UnusedBit6 *Multivalue `json:"unusedBit6,omitempty"`
	// UnusedBit7: Options-(7)Unused
	UnusedBit7 *Multivalue `json:"unusedBit7,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyExternalRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyExternalRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyExternalRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyExternalRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eBit",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.ExternalRouteTag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "externalRouteTag",
		isMultivalue: true,
	})
	n.FBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fBit",
		isMultivalue: true,
	})
	n.ForwardingAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forwardingAddress",
		isMultivalue: true,
	})
	n.LABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lABit",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateId",
		isMultivalue: true,
	})
	n.LinkStateIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateIdStep",
		isMultivalue: true,
	})
	n.MCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mCBit",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NUBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nUBit",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pBit",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.RefLSType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "refLSType",
		isMultivalue: true,
	})
	n.ReferencedLinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "referencedLinkStateId",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.TBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tBit",
		isMultivalue: true,
	})
	n.UnusedBit4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit4",
		isMultivalue: true,
	})
	n.UnusedBit5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit5",
		isMultivalue: true,
	})
	n.UnusedBit6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit6",
		isMultivalue: true,
	})
	n.UnusedBit7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit7",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyField: Tlv field
type TopologyField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// Encoding: Encoding of the tlv value, any change will result in the value being reset

	Encoding *string `json:"encoding,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables/disables this field

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`
	// Size: Size of the tlv value in bits/bytes based on sizeType, any change will result in the value being reset

	Size *float32 `json:"size,omitempty"`
	// SizeType: Size type of the tlv value, any change will result in the value being reset

	SizeType *string `json:"sizeType,omitempty"`
	// Value: Value represented as a multivalue object
	Value       *Multivalue            `json:"value,omitempty"`
	Restriction []*TopologyRestriction `json:"restriction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyField) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyField) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
	for i, o := range n.Restriction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "restriction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyFlexAlgoColorMappingTemplate: TBD
type TopologyFlexAlgoColorMappingTemplate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Color: Color associated with routes
	Color *Multivalue `json:"color,omitempty"`
	// FlexAlgo: Flex Algo mapped with color
	FlexAlgo *Multivalue `json:"flexAlgo,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyFlexAlgoColorMappingTemplate) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyFlexAlgoColorMappingTemplate) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyFlexAlgoColorMappingTemplate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyFlexAlgoColorMappingTemplate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Color.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "color",
		isMultivalue: true,
	})
	n.FlexAlgo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flexAlgo",
		isMultivalue: true,
	})
}

// TopologyFlowProfile: Flow Range Profile
type TopologyFlowProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name        *string                `json:"name,omitempty"`
	MatchAction []*TopologyMatchAction `json:"matchAction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyFlowProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyFlowProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyFlowProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyFlowProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.MatchAction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "matchAction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyFlowSet: Flow Set Configuration
type TopologyFlowSet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Cookie: Cookie of the flow entry that was looked up. This is the opaque controller-issued identifier.
	Cookie *Multivalue `json:"cookie,omitempty"`
	// CookieMask: The mask used to restrict the cookie bits.
	CookieMask *Multivalue `json:"cookieMask,omitempty"`
	// FlowAdvertise: If selected, the flows are advertised by the OF Channel.

	FlowAdvertise *bool `json:"flowAdvertise,omitempty"`
	// FlowFlags: Allows to configure the Flow Flags. Options are: 1) Send Flow Removed 2) Check Overlap 3) Reset Counts 4) No Packet Count 5) No Byte Count
	FlowFlags *Multivalue `json:"flowFlags,omitempty"`
	// FlowMatchType: The type of match to be configured. Options include the following: 1) Strict 2) Loose
	FlowMatchType *Multivalue `json:"flowMatchType,omitempty"`
	// FlowSetId: Specify the controller Flow Set identifier.

	FlowSetId *string `json:"flowSetId,omitempty"`
	// HardTimeout: The inactive time in seconds after which the Flow range will hard timeout and close.
	HardTimeout *Multivalue `json:"hardTimeout,omitempty"`
	// IdleTimeout: The inactive time in seconds after which the Flow range will timeout and become idle.
	IdleTimeout *Multivalue `json:"idleTimeout,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfFlows: The number of flows to be configured for the controller table.

	NumberOfFlows *float32 `json:"numberOfFlows,omitempty"`
	// Priority: The priority level for the Flow Range.
	Priority *Multivalue `json:"priority,omitempty"`

	FlowProfile *TopologyFlowProfile `json:"flowProfile,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyFlowSet) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyFlowSet) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyFlowSet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyFlowSet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Cookie.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cookie",
		isMultivalue: true,
	})
	n.CookieMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cookieMask",
		isMultivalue: true,
	})
	n.FlowFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowFlags",
		isMultivalue: true,
	})
	n.FlowMatchType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowMatchType",
		isMultivalue: true,
	})
	n.HardTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hardTimeout",
		isMultivalue: true,
	})
	n.IdleTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "idleTimeout",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.FlowProfile.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "flowProfile",
	})
}

// TopologyGenerateIpv6RoutesParams: Generate Primary and Duplicate Routes with advanced prefix length distribution options.
type TopologyGenerateIpv6RoutesParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AddressRangesToSkip: Address Ranges that will be skipped. You can provide multiple ranges separated by ','. Example: aa:0:1:b: - bb:0:2:c:, aa00: - bb00:1

	AddressRangesToSkip *string `json:"addressRangesToSkip,omitempty"`
	// CustomDistributionFile: Source file having custom distribution information.

	CustomDistributionFile *string `json:"customDistributionFile,omitempty"`
	// DuplicateRoutesAsPathSuffix: AS Path Suffix for Duplicate Routes

	DuplicateRoutesAsPathSuffix *string `json:"duplicateRoutesAsPathSuffix,omitempty"`
	// DuplicateRoutesPerDevicePercent: Percentage to Duplicate Primary Routes per Device.

	DuplicateRoutesPerDevicePercent *float32 `json:"duplicateRoutesPerDevicePercent,omitempty"`
	// NetworkAddressStart: Network Address Start Value.

	NetworkAddressStart *string `json:"networkAddressStart,omitempty"`
	// NetworkAddressStep: Network Address Step Value.

	NetworkAddressStep *string `json:"networkAddressStep,omitempty"`
	// PrefixLengthDistributionScope: Prefix Length Distribution Scope.

	PrefixLengthDistributionScope *string `json:"prefixLengthDistributionScope,omitempty"`
	// PrefixLengthDistributionType: Prefix Length Distribution Type.

	PrefixLengthDistributionType *string `json:"prefixLengthDistributionType,omitempty"`
	// PrefixLengthEnd: Prefix Length End Value. Applicable only for Even and Exponential distribution type.

	PrefixLengthEnd *float32 `json:"prefixLengthEnd,omitempty"`
	// PrefixLengthStart: Prefix Length Start Value. Applicable only for Fixed, Even and Exponential distribution type.

	PrefixLengthStart *float32 `json:"prefixLengthStart,omitempty"`
	// PrimaryRoutesAsPathSuffix: AS Path Suffix for Primary Routes

	PrimaryRoutesAsPathSuffix *string `json:"primaryRoutesAsPathSuffix,omitempty"`
	// PrimaryRoutesPerDevice: Number of Primary Routes per Device.

	PrimaryRoutesPerDevice *float32 `json:"primaryRoutesPerDevice,omitempty"`
	// PrimaryRoutesPerRange: Number of Routes per Route Range.

	PrimaryRoutesPerRange *float32 `json:"primaryRoutesPerRange,omitempty"`
	// SkipLoopback: Do not include Loopback Address in the generated Address Range

	SkipLoopback *bool `json:"skipLoopback,omitempty"`
	// SkipMcast: Do not include Multicast Address in the generated Address Range

	SkipMcast *bool `json:"skipMcast,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyGenerateIpv6RoutesParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyGenerateIpv6RoutesParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyGenerateIpv6RoutesParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyGenerateIpv6RoutesParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyGenerateRoutesParams: Generate Primary and Duplicate Routes with advanced prefix length distribution options.
type TopologyGenerateRoutesParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AddressRangesToSkip: Address Ranges that will be skipped. You can provide multiple ranges separated by ','. Example: 192.0.0.0 - 192.255.255.255, 201.0.0.0. - 201.255.255.255

	AddressRangesToSkip *string `json:"addressRangesToSkip,omitempty"`
	// CustomDistributionFile: Source file having custom distribution information.

	CustomDistributionFile *string `json:"customDistributionFile,omitempty"`
	// DuplicateRoutesAsPathSuffix: AS Path Suffix for Duplicate Routes

	DuplicateRoutesAsPathSuffix *string `json:"duplicateRoutesAsPathSuffix,omitempty"`
	// DuplicateRoutesPerDevicePercent: Percentage to Duplicate Primary Routes per Device.

	DuplicateRoutesPerDevicePercent *float32 `json:"duplicateRoutesPerDevicePercent,omitempty"`
	// EnableRandomASPath: If selected, Random AS Path is turned on for the route range. Only available, when Route Replication is selected as Per Device.

	EnableRandomASPath *bool `json:"enableRandomASPath,omitempty"`
	// IncludeDefaultRoute: Include the default route address, 0.0.0.0, in the generated Address Range.

	IncludeDefaultRoute *bool `json:"includeDefaultRoute,omitempty"`
	// NetworkAddressStart: Network Address Start Value.

	NetworkAddressStart *string `json:"networkAddressStart,omitempty"`
	// NetworkAddressStep: Network Address Step Value.

	NetworkAddressStep *string `json:"networkAddressStep,omitempty"`
	// PrefixLengthDistributionScope: Prefix Length Distribution Scope.

	PrefixLengthDistributionScope *string `json:"prefixLengthDistributionScope,omitempty"`
	// PrefixLengthDistributionType: Prefix Length Distribution Type.

	PrefixLengthDistributionType *string `json:"prefixLengthDistributionType,omitempty"`
	// PrefixLengthEnd: Prefix Length End Value. Applicable only for Even and Exponential distribution type.

	PrefixLengthEnd *float32 `json:"prefixLengthEnd,omitempty"`
	// PrefixLengthMix: The prefix lengths are assigned to the routes in accordance with Internet Prefix Profile.

	PrefixLengthMix *string `json:"prefixLengthMix,omitempty"`
	// PrefixLengthStart: Prefix Length Start Value. Applicable only for Fixed, Even and Exponential distribution type.

	PrefixLengthStart *float32 `json:"prefixLengthStart,omitempty"`
	// PrimaryRoutesAsPathSuffix: AS Path Suffix for Primary Routes

	PrimaryRoutesAsPathSuffix *string `json:"primaryRoutesAsPathSuffix,omitempty"`
	// PrimaryRoutesPerDevice: Number of Primary Routes per Device.

	PrimaryRoutesPerDevice *float32 `json:"primaryRoutesPerDevice,omitempty"`
	// PrimaryRoutesPerRange: Number of Routes per Route Range.

	PrimaryRoutesPerRange *float32 `json:"primaryRoutesPerRange,omitempty"`
	// RouteCount: The number of routes you want to generate. Only available, when Route Replication is selected as Per Device.

	RouteCount *float32 `json:"routeCount,omitempty"`
	// RouteReplicationType: The replication type of the routes.

	RouteReplicationType *string `json:"routeReplicationType,omitempty"`
	// SkipClassEAddresses: DO not include Class E Addresses (240.0.0.0 - 255.255.255.254) in the generated Address Range.

	SkipClassEAddresses *bool `json:"skipClassEAddresses,omitempty"`
	// SkipLoopback: Do not include Loopback Address in the generated Address Range

	SkipLoopback *bool `json:"skipLoopback,omitempty"`
	// SkipMcast: Do not include Multicast Address in the generated Address Range

	SkipMcast *bool `json:"skipMcast,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyGenerateRoutesParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyGenerateRoutesParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyGenerateRoutesParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyGenerateRoutesParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyGeneve: Geneve protocol.
type TopologyGeneve struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableUdpCsum: Enable UDP checksum for outgoing packets
	EnableUdpCsum *Multivalue `json:"enableUdpCsum,omitempty"`
	// Ipv4Remote: The IPv4 address of the remote tunnel endpoint
	Ipv4Remote *Multivalue `json:"ipv4Remote,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UdpDestPort: The UDP port used for GENEVE communication
	UdpDestPort *Multivalue `json:"udpDestPort,omitempty"`
	// Vni: The virtual network identifier for this tunnel endpoint
	Vni *Multivalue `json:"vni,omitempty"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	Ethernet            []*TopologyEthernet            `json:"ethernet"`
	Ipv4Loopback        []*TopologyIpv4Loopback        `json:"ipv4Loopback"`
	Ipv6Loopback        []*TopologyIpv6Loopback        `json:"ipv6Loopback"`
	LdpBasicRouter      []*TopologyLdpBasicRouter      `json:"ldpBasicRouter"`
	LdpBasicRouterV6    []*TopologyLdpBasicRouterV6    `json:"ldpBasicRouterV6"`
	LdpTargetedRouter   []*TopologyLdpTargetedRouter   `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6 []*TopologyLdpTargetedRouterV6 `json:"ldpTargetedRouterV6"`
	TlvProfile          []*TopologyTlvProfile          `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyGeneve) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyGeneve) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyGeneve) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyGeneve) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableUdpCsum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableUdpCsum",
		isMultivalue: true,
	})
	n.Ipv4Remote.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Remote",
		isMultivalue: true,
	})
	n.UdpDestPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpDestPort",
		isMultivalue: true,
	})
	n.Vni.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vni",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyGreoipv4: GRE IPv4 protocol.
type TopologyGreoipv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DestIp: Destination IPv4 address
	DestIp *Multivalue `json:"destIp,omitempty"`
	// EnableChecksum: Enable Checksum.
	EnableChecksum *Multivalue `json:"enableChecksum,omitempty"`
	// EnableKey: Enable Key.
	EnableKey *Multivalue `json:"enableKey,omitempty"`
	// EnableSequenceNumber: Enable Sequence Number.
	EnableSequenceNumber *Multivalue `json:"enableSequenceNumber,omitempty"`
	// InKey: In Key.
	InKey *Multivalue `json:"inKey,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OutKey: Out Key.
	OutKey *Multivalue `json:"outKey,omitempty"`
	// SrcIp: Source IPv4 address
	SrcIp *Multivalue `json:"srcIp,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href               `json:"-"`
	BondedGRE         []*TopologyBondedGre `json:"bondedGRE"`
	CfmBridge         []*TopologyCfmBridge `json:"cfmBridge"`

	Connector             *TopologyConnector               `json:"connector,omitempty"`
	Dhcpv4client          []*TopologyDhcpv4client          `json:"dhcpv4client"`
	Dhcpv6client          []*TopologyDhcpv6client          `json:"dhcpv6client"`
	ECpriRe               []*TopologyECpriRe               `json:"eCpriRe"`
	ECpriRec              []*TopologyECpriRec              `json:"eCpriRec"`
	Ethernet              []*TopologyEthernet              `json:"ethernet"`
	Ipv4                  []*TopologyIpv4                  `json:"ipv4"`
	Ipv6                  []*TopologyIpv6                  `json:"ipv6"`
	Ipv6Autoconfiguration []*TopologyIpv6Autoconfiguration `json:"ipv6Autoconfiguration"`
	IsisDceSimRouter      []*TopologyIsisDceSimRouter      `json:"isisDceSimRouter"`
	IsisFabricPath        []*TopologyIsisFabricPath        `json:"isisFabricPath"`
	IsisL3                []*TopologyIsisL3                `json:"isisL3"`
	IsisSpbBcb            []*TopologyIsisSpbBcb            `json:"isisSpbBcb"`
	IsisSpbBeb            []*TopologyIsisSpbBeb            `json:"isisSpbBeb"`
	IsisSpbSimRouter      []*TopologyIsisSpbSimRouter      `json:"isisSpbSimRouter"`
	IsisTrill             []*TopologyIsisTrill             `json:"isisTrill"`
	IsisTrillSimRouter    []*TopologyIsisTrillSimRouter    `json:"isisTrillSimRouter"`
	Lacp                  []*TopologyLacp                  `json:"lacp"`
	Lagportlacp           []*TopologyLagportlacp           `json:"lagportlacp"`
	Lagportstaticlag      []*TopologyLagportstaticlag      `json:"lagportstaticlag"`
	Mka                   []*TopologyMka                   `json:"mka"`
	MsrpListener          []*TopologyMsrpListener          `json:"msrpListener"`
	MsrpTalker            []*TopologyMsrpTalker            `json:"msrpTalker"`
	StaticLag             []*TopologyStaticLag             `json:"staticLag"`

	Streams *TopologyStreams `json:"streams,omitempty"`
	Tag     []*TopologyTag   `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyGreoipv4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyGreoipv4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyGreoipv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyGreoipv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DestIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destIp",
		isMultivalue: true,
	})
	n.EnableChecksum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableChecksum",
		isMultivalue: true,
	})
	n.EnableKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableKey",
		isMultivalue: true,
	})
	n.EnableSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSequenceNumber",
		isMultivalue: true,
	})
	n.InKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "inKey",
		isMultivalue: true,
	})
	n.OutKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outKey",
		isMultivalue: true,
	})
	n.SrcIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcIp",
		isMultivalue: true,
	})
	for i, o := range n.BondedGRE {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bondedGRE",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CfmBridge {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmBridge",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Dhcpv4client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Autoconfiguration {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Autoconfiguration",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDceSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDceSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisFabricPath {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisFabricPath",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBcb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBcb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBeb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBeb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrill {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrill",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportlacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportlacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportstaticlag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportstaticlag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mka {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mka",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpListener {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpListener",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpTalker {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpTalker",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StaticLag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "staticLag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Streams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "streams",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyGreoipv6: GRE IPv6 protocol.
type TopologyGreoipv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DestIp: Destination IPv6 address
	DestIp *Multivalue `json:"destIp,omitempty"`
	// EnableChecksum: Enable Checksum.
	EnableChecksum *Multivalue `json:"enableChecksum,omitempty"`
	// EnableKey: Enable Key.
	EnableKey *Multivalue `json:"enableKey,omitempty"`
	// EnableSequenceNumber: Enable Sequence Number.
	EnableSequenceNumber *Multivalue `json:"enableSequenceNumber,omitempty"`
	// InKey: In Key.
	InKey *Multivalue `json:"inKey,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OutKey: Out Key.
	OutKey *Multivalue `json:"outKey,omitempty"`
	// SrcIp: Source IPv6 address
	SrcIp *Multivalue `json:"srcIp,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href               `json:"-"`
	BondedGRE         []*TopologyBondedGre `json:"bondedGRE"`
	CfmBridge         []*TopologyCfmBridge `json:"cfmBridge"`

	Connector             *TopologyConnector               `json:"connector,omitempty"`
	Dhcpv4client          []*TopologyDhcpv4client          `json:"dhcpv4client"`
	Dhcpv6client          []*TopologyDhcpv6client          `json:"dhcpv6client"`
	ECpriRe               []*TopologyECpriRe               `json:"eCpriRe"`
	ECpriRec              []*TopologyECpriRec              `json:"eCpriRec"`
	Ethernet              []*TopologyEthernet              `json:"ethernet"`
	Ipv4                  []*TopologyIpv4                  `json:"ipv4"`
	Ipv6                  []*TopologyIpv6                  `json:"ipv6"`
	Ipv6Autoconfiguration []*TopologyIpv6Autoconfiguration `json:"ipv6Autoconfiguration"`
	IsisDceSimRouter      []*TopologyIsisDceSimRouter      `json:"isisDceSimRouter"`
	IsisFabricPath        []*TopologyIsisFabricPath        `json:"isisFabricPath"`
	IsisL3                []*TopologyIsisL3                `json:"isisL3"`
	IsisSpbBcb            []*TopologyIsisSpbBcb            `json:"isisSpbBcb"`
	IsisSpbBeb            []*TopologyIsisSpbBeb            `json:"isisSpbBeb"`
	IsisSpbSimRouter      []*TopologyIsisSpbSimRouter      `json:"isisSpbSimRouter"`
	IsisTrill             []*TopologyIsisTrill             `json:"isisTrill"`
	IsisTrillSimRouter    []*TopologyIsisTrillSimRouter    `json:"isisTrillSimRouter"`
	Lacp                  []*TopologyLacp                  `json:"lacp"`
	Lagportlacp           []*TopologyLagportlacp           `json:"lagportlacp"`
	Lagportstaticlag      []*TopologyLagportstaticlag      `json:"lagportstaticlag"`
	Mka                   []*TopologyMka                   `json:"mka"`
	MsrpListener          []*TopologyMsrpListener          `json:"msrpListener"`
	MsrpTalker            []*TopologyMsrpTalker            `json:"msrpTalker"`
	StaticLag             []*TopologyStaticLag             `json:"staticLag"`

	Streams *TopologyStreams `json:"streams,omitempty"`
	Tag     []*TopologyTag   `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyGreoipv6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyGreoipv6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyGreoipv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyGreoipv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DestIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destIp",
		isMultivalue: true,
	})
	n.EnableChecksum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableChecksum",
		isMultivalue: true,
	})
	n.EnableKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableKey",
		isMultivalue: true,
	})
	n.EnableSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSequenceNumber",
		isMultivalue: true,
	})
	n.InKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "inKey",
		isMultivalue: true,
	})
	n.OutKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outKey",
		isMultivalue: true,
	})
	n.SrcIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcIp",
		isMultivalue: true,
	})
	for i, o := range n.BondedGRE {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bondedGRE",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CfmBridge {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmBridge",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Dhcpv4client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Autoconfiguration {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Autoconfiguration",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDceSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDceSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisFabricPath {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisFabricPath",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBcb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBcb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBeb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBeb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrill {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrill",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportlacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportlacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportstaticlag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportstaticlag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mka {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mka",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpListener {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpListener",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpTalker {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpTalker",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StaticLag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "staticLag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Streams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "streams",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyGroups: Openflow Groups Configuration
type TopologyGroups struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// GroupAdvertise: If selected, group is advertised when the OpenFlow channel comes up.
	GroupAdvertise *Multivalue `json:"groupAdvertise,omitempty"`
	// GroupDescription: A description of the group.
	GroupDescription *Multivalue `json:"groupDescription,omitempty"`
	// GroupId: A 32-bit integer uniquely identifying the group.
	GroupId *Multivalue `json:"groupId,omitempty"`
	// GroupType: Select the type of group to determine the group semantics.
	GroupType *Multivalue `json:"groupType,omitempty"`
	// Multiplier: Number of instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfBuckets: Specify the number of Buckets.

	NumberOfBuckets *float32 `json:"numberOfBuckets,omitempty"`
	// OfChannel: The OF Channel to which the group belongs.
	OfChannel *Multivalue        `json:"ofChannel,omitempty"`
	Buckets   []*TopologyBuckets `json:"buckets"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyGroups) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyGroups) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyGroups) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyGroups) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.GroupAdvertise.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAdvertise",
		isMultivalue: true,
	})
	n.GroupDescription.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupDescription",
		isMultivalue: true,
	})
	n.GroupId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupId",
		isMultivalue: true,
	})
	n.GroupType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupType",
		isMultivalue: true,
	})
	n.OfChannel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ofChannel",
		isMultivalue: true,
	})
	for i, o := range n.Buckets {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "buckets",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIPv4PseudoNodeRoutes: Isis IPv4 pseudo node routes
type TopologyIPv4PseudoNodeRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// IPv6SourceRouterID: This takes the value of the ipv6 source router id.
	IPv6SourceRouterID *Multivalue `json:"iPv6SourceRouterID,omitempty"`
	// IncludePrefixAttrFlags: Select this check box to include the prefix attribute flags.
	IncludePrefixAttrFlags *Multivalue `json:"includePrefixAttrFlags,omitempty"`
	// IncludeSourceRouterID: This drop box is provided to select ipv4 or ipv6 source id or none of them.
	IncludeSourceRouterID *Multivalue `json:"includeSourceRouterID,omitempty"`
	// Ipv4EFlag: Explicit NULL flag
	Ipv4EFlag *Multivalue `json:"ipv4EFlag,omitempty"`
	// Ipv4LFlag: Local Flag
	Ipv4LFlag *Multivalue `json:"ipv4LFlag,omitempty"`
	// Ipv4Metric: Route Metric
	Ipv4Metric *Multivalue `json:"ipv4Metric,omitempty"`
	// Ipv4NFlag: Nodal prefix flag
	Ipv4NFlag *Multivalue `json:"ipv4NFlag,omitempty"`
	// Ipv4PFlag: No-PHP flag. If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID.
	Ipv4PFlag *Multivalue `json:"ipv4PFlag,omitempty"`
	// Ipv4RFlag: Redistribution flag
	Ipv4RFlag *Multivalue `json:"ipv4RFlag,omitempty"`
	// Ipv4Redistribution: Redistribution
	Ipv4Redistribution *Multivalue `json:"ipv4Redistribution,omitempty"`
	// Ipv4RouteOrigin: Route Origin
	Ipv4RouteOrigin *Multivalue `json:"ipv4RouteOrigin,omitempty"`
	// Ipv4SourceRouterID: This takes the value of the ipv4 source router id.
	Ipv4SourceRouterID *Multivalue `json:"ipv4SourceRouterID,omitempty"`
	// Ipv4VFlag: Value Flag
	Ipv4VFlag *Multivalue `json:"ipv4VFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Network addresses of the simulated IPv4 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// PrefixLength: Prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SIDIndexLabel: SID/Index/Label
	SIDIndexLabel *Multivalue    `json:"sIDIndexLabel,omitempty"`
	Tag           []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIPv4PseudoNodeRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIPv4PseudoNodeRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIPv4PseudoNodeRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIPv4PseudoNodeRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.IPv6SourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iPv6SourceRouterID",
		isMultivalue: true,
	})
	n.IncludePrefixAttrFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePrefixAttrFlags",
		isMultivalue: true,
	})
	n.IncludeSourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSourceRouterID",
		isMultivalue: true,
	})
	n.Ipv4EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4EFlag",
		isMultivalue: true,
	})
	n.Ipv4LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4LFlag",
		isMultivalue: true,
	})
	n.Ipv4Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Metric",
		isMultivalue: true,
	})
	n.Ipv4NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NFlag",
		isMultivalue: true,
	})
	n.Ipv4PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4PFlag",
		isMultivalue: true,
	})
	n.Ipv4RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4RFlag",
		isMultivalue: true,
	})
	n.Ipv4Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Redistribution",
		isMultivalue: true,
	})
	n.Ipv4RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4RouteOrigin",
		isMultivalue: true,
	})
	n.Ipv4SourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4SourceRouterID",
		isMultivalue: true,
	})
	n.Ipv4VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4VFlag",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDIndexLabel",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIPv6PseudoNodeRoutes: Isis IPv6 pseudo node routes
type TopologyIPv6PseudoNodeRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseForAllMts: Advertise for all MTs configured in router
	AdvertiseForAllMts *Multivalue `json:"advertiseForAllMts,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// IPv6SourceRouterID: This takes the value of the ipv6 source router id.
	IPv6SourceRouterID *Multivalue `json:"iPv6SourceRouterID,omitempty"`
	// IncludePrefixAttrFlags: Select this check box to include the prefix attribute flags.
	IncludePrefixAttrFlags *Multivalue `json:"includePrefixAttrFlags,omitempty"`
	// IncludeSourceRouterID: This drop box is provided to select ipv4 or ipv6 source id or none of them.
	IncludeSourceRouterID *Multivalue `json:"includeSourceRouterID,omitempty"`
	// Ipv4SourceRouterID: This takes the value of the ipv4 source router id.
	Ipv4SourceRouterID *Multivalue `json:"ipv4SourceRouterID,omitempty"`
	// Ipv6EFlag: Explicit NULL flag
	Ipv6EFlag *Multivalue `json:"ipv6EFlag,omitempty"`
	// Ipv6LFlag: Local Flag
	Ipv6LFlag *Multivalue `json:"ipv6LFlag,omitempty"`
	// Ipv6Metric: Route Metric
	Ipv6Metric *Multivalue `json:"ipv6Metric,omitempty"`
	// Ipv6NFlag: Nodal prefix flag
	Ipv6NFlag *Multivalue `json:"ipv6NFlag,omitempty"`
	// Ipv6PFlag: No-PHP flag. If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID.
	Ipv6PFlag *Multivalue `json:"ipv6PFlag,omitempty"`
	// Ipv6RFlag: Redistribution flag
	Ipv6RFlag *Multivalue `json:"ipv6RFlag,omitempty"`
	// Ipv6Redistribution: Redistribution
	Ipv6Redistribution *Multivalue `json:"ipv6Redistribution,omitempty"`
	// Ipv6RouteOrigin: Route Origin
	Ipv6RouteOrigin *Multivalue `json:"ipv6RouteOrigin,omitempty"`
	// Ipv6Srh: Advertise IPv6 SID
	Ipv6Srh *Multivalue `json:"ipv6Srh,omitempty"`
	// Ipv6VFlag: Value Flag
	Ipv6VFlag *Multivalue `json:"ipv6VFlag,omitempty"`
	// MtId: MT Id for which this route would be advertised
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Prefixes of the simulated IPv6 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// Prefix: Prefix Length
	Prefix *Multivalue `json:"prefix,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SIDIndexLabel: SID/Index/Label
	SIDIndexLabel *Multivalue    `json:"sIDIndexLabel,omitempty"`
	Tag           []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIPv6PseudoNodeRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIPv6PseudoNodeRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIPv6PseudoNodeRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIPv6PseudoNodeRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseForAllMts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseForAllMts",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.IPv6SourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iPv6SourceRouterID",
		isMultivalue: true,
	})
	n.IncludePrefixAttrFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePrefixAttrFlags",
		isMultivalue: true,
	})
	n.IncludeSourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSourceRouterID",
		isMultivalue: true,
	})
	n.Ipv4SourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4SourceRouterID",
		isMultivalue: true,
	})
	n.Ipv6EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6EFlag",
		isMultivalue: true,
	})
	n.Ipv6LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6LFlag",
		isMultivalue: true,
	})
	n.Ipv6Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Metric",
		isMultivalue: true,
	})
	n.Ipv6NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NFlag",
		isMultivalue: true,
	})
	n.Ipv6PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6PFlag",
		isMultivalue: true,
	})
	n.Ipv6RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6RFlag",
		isMultivalue: true,
	})
	n.Ipv6Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Redistribution",
		isMultivalue: true,
	})
	n.Ipv6RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6RouteOrigin",
		isMultivalue: true,
	})
	n.Ipv6Srh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Srh",
		isMultivalue: true,
	})
	n.Ipv6VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6VFlag",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDIndexLabel",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIPv6SegmentsList: IPv6 Segments List
type TopologyIPv6SegmentsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SID: Segment Item Address
	SID *Multivalue `json:"sID,omitempty"`
	// SIDEnable: Enable This Segment
	SIDEnable *Multivalue `json:"sIDEnable,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIPv6SegmentsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIPv6SegmentsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIPv6SegmentsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIPv6SegmentsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sID",
		isMultivalue: true,
	})
	n.SIDEnable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDEnable",
		isMultivalue: true,
	})
}

// TopologyIgmpHost: IGMP Host
type TopologyIgmpHost struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableIptv: Enable IPTV
	EnableIptv *Multivalue `json:"enableIptv,omitempty"`
	// EnableProxyReporting: Enable Proxy Reporting
	EnableProxyReporting *Multivalue `json:"enableProxyReporting,omitempty"`
	// GQResponseMode: General Query Response Mode
	GQResponseMode *Multivalue `json:"gQResponseMode,omitempty"`
	// GSResponseMode: Group Specific Response Mode
	GSResponseMode *Multivalue `json:"gSResponseMode,omitempty"`
	// ImResponse: Immediate Response
	ImResponse *Multivalue `json:"imResponse,omitempty"`
	// JlMultiplier: No. of Join/Leave messages to send per opertation

	JlMultiplier *float32 `json:"jlMultiplier,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfGrpRanges: Defines the number of group range per host required

	NoOfGrpRanges *float32 `json:"noOfGrpRanges,omitempty"`
	// ReportFreq: Report Frequency measured in seconds
	ReportFreq *Multivalue `json:"reportFreq,omitempty"`
	// RouterAlert: Enables Router Alert option of IPv4 Packet
	RouterAlert *Multivalue `json:"routerAlert,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// USResponseMode: Unsolicited Response Mode
	USResponseMode *Multivalue `json:"uSResponseMode,omitempty"`
	// VersionType: Specifies the IGMP Version Type
	VersionType *Multivalue `json:"versionType,omitempty"`

	IgmpMcastIPv4GroupList *TopologyIgmpMcastIPv4GroupList `json:"igmpMcastIPv4GroupList,omitempty"`

	Iptv *TopologyIptv  `json:"iptv,omitempty"`
	Tag  []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIgmpHost) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIgmpHost) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIgmpHost) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIgmpHost) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableIptv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIptv",
		isMultivalue: true,
	})
	n.EnableProxyReporting.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableProxyReporting",
		isMultivalue: true,
	})
	n.GQResponseMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gQResponseMode",
		isMultivalue: true,
	})
	n.GSResponseMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gSResponseMode",
		isMultivalue: true,
	})
	n.ImResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "imResponse",
		isMultivalue: true,
	})
	n.ReportFreq.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reportFreq",
		isMultivalue: true,
	})
	n.RouterAlert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerAlert",
		isMultivalue: true,
	})
	n.USResponseMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uSResponseMode",
		isMultivalue: true,
	})
	n.VersionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "versionType",
		isMultivalue: true,
	})
	n.IgmpMcastIPv4GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "igmpMcastIPv4GroupList",
	})
	n.Iptv.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "iptv",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIgmpMcastIPv4GroupList: IGMP Multicast IPv4 Groups
type TopologyIgmpMcastIPv4GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfSrcRanges: Sources per Multicast Group (multiplier)

	NoOfSrcRanges *float32 `json:"noOfSrcRanges,omitempty"`
	// SourceMode: Specifies the IGMP/MLD Source Type
	SourceMode *Multivalue `json:"sourceMode,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`

	IgmpUcastIPv4SourceList *TopologyIgmpUcastIPv4SourceList `json:"igmpUcastIPv4SourceList,omitempty"`
	Tag                     []*TopologyTag                   `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIgmpMcastIPv4GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIgmpMcastIPv4GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIgmpMcastIPv4GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIgmpMcastIPv4GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SourceMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMode",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.IgmpUcastIPv4SourceList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "igmpUcastIPv4SourceList",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIgmpQuerier: IGMP Querier Configuration
type TopologyIgmpQuerier struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DiscardLearntInfo: Discard Learned Info
	DiscardLearntInfo *Multivalue `json:"discardLearntInfo,omitempty"`
	// GeneralQueryInterval: General Query Interval in seconds
	GeneralQueryInterval *Multivalue `json:"generalQueryInterval,omitempty"`
	// GeneralQueryResponseInterval: General Query Response Interval in milliseconds
	GeneralQueryResponseInterval *Multivalue `json:"generalQueryResponseInterval,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ProxyQuerier: Enable Proxy Querier
	ProxyQuerier *Multivalue `json:"proxyQuerier,omitempty"`
	// RobustnessVariable: Robustness Variable
	RobustnessVariable *Multivalue `json:"robustnessVariable,omitempty"`
	// RouterAlert: Router Alert
	RouterAlert *Multivalue `json:"routerAlert,omitempty"`
	// SpecificQueryResponseInterval: Specific Query Response Interval in milliseconds
	SpecificQueryResponseInterval *Multivalue `json:"specificQueryResponseInterval,omitempty"`
	// SpecificQueryTransmissionCount: Specific Query Transmission Count
	SpecificQueryTransmissionCount *Multivalue `json:"specificQueryTransmissionCount,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartupQueryCount: Startup Query Count
	StartupQueryCount *Multivalue `json:"startupQueryCount,omitempty"`
	// SupportElection: Support Election
	SupportElection *Multivalue `json:"supportElection,omitempty"`
	// SupportOlderVersionHost: Support Older Version Host
	SupportOlderVersionHost *Multivalue `json:"supportOlderVersionHost,omitempty"`
	// SupportOlderVersionQuerier: Support Older Version Querier
	SupportOlderVersionQuerier *Multivalue `json:"supportOlderVersionQuerier,omitempty"`
	// VersionType: Version
	VersionType *Multivalue            `json:"versionType,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIgmpQuerier) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIgmpQuerier) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIgmpQuerier) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIgmpQuerier) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DiscardLearntInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLearntInfo",
		isMultivalue: true,
	})
	n.GeneralQueryInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "generalQueryInterval",
		isMultivalue: true,
	})
	n.GeneralQueryResponseInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "generalQueryResponseInterval",
		isMultivalue: true,
	})
	n.ProxyQuerier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "proxyQuerier",
		isMultivalue: true,
	})
	n.RobustnessVariable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "robustnessVariable",
		isMultivalue: true,
	})
	n.RouterAlert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerAlert",
		isMultivalue: true,
	})
	n.SpecificQueryResponseInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "specificQueryResponseInterval",
		isMultivalue: true,
	})
	n.SpecificQueryTransmissionCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "specificQueryTransmissionCount",
		isMultivalue: true,
	})
	n.StartupQueryCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startupQueryCount",
		isMultivalue: true,
	})
	n.SupportElection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportElection",
		isMultivalue: true,
	})
	n.SupportOlderVersionHost.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportOlderVersionHost",
		isMultivalue: true,
	})
	n.SupportOlderVersionQuerier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportOlderVersionQuerier",
		isMultivalue: true,
	})
	n.VersionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "versionType",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIgmpUcastIPv4SourceList: IGMP Unicast IPv4 Source
type TopologyIgmpUcastIPv4SourceList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StartUcastAddr: Start Multicast Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcAddrCnt: Source Address Count
	UcastSrcAddrCnt *Multivalue `json:"ucastSrcAddrCnt,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIgmpUcastIPv4SourceList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIgmpUcastIPv4SourceList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIgmpUcastIPv4SourceList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIgmpUcastIPv4SourceList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcAddrCnt",
		isMultivalue: true,
	})
}

// TopologyImportBgpRoutesParams: Import IPv4 routes from standard route file. Supported format - Cisco IOS, Juniper JUNOS, Classis Ixia (.csv) and standard CSV.
type TopologyImportBgpRoutesParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BestRoutes: Import only the best routes (provided route file has this information).

	BestRoutes *bool `json:"bestRoutes,omitempty"`
	// DataFile: Select source file having route information.

	DataFile *string `json:"dataFile,omitempty"`
	// FileType: Import routes file type. Route import may fail in file type is not matching with the file being imported.

	FileType *string `json:"fileType,omitempty"`
	// NextHop: Option for setting Next Hop modification type.

	NextHop *string `json:"nextHop,omitempty"`
	// RouteDistributionType: Option to specify distribution type, for distributing imported routes across all BGP Peer. Options: Round-Robin, for allocating routes sequentially, and Replicate, for allocating all routes to each Peer.

	RouteDistributionType *string `json:"routeDistributionType,omitempty"`
	// RouteLimit: Specify maximum routes(per port) that you want to import. Based on Card Memory, the Max Route Limit Per Port are: - 4GB or more => 2.0 million 2GB => 1.6 million 1GB => 0.8 million Less than 1GB => 0.5 million

	RouteLimit *float32 `json:"routeLimit,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyImportBgpRoutesParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyImportBgpRoutesParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyImportBgpRoutesParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyImportBgpRoutesParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyInnerVlanList: Inner VLAN
type TopologyInnerVlanList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Priority: 3-bit user priority field in the VLAN tag.
	Priority *Multivalue `json:"priority,omitempty"`
	// Tpid: 16-bit Tag Protocol Identifier (TPID) or EtherType in the VLAN tag.
	Tpid *Multivalue `json:"tpid,omitempty"`
	// VlanId: 12-bit VLAN ID in the VLAN tag.
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyInnerVlanList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyInnerVlanList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyInnerVlanList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyInnerVlanList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.Tpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tpid",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyInstruction: Instruction
type TopologyInstruction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name    *string                     `json:"name,omitempty"`
	Actions []*TopologyActions          `json:"actions"`
	Field   []*TopologyInstructionField `json:"field"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyInstruction) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyInstruction) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyInstruction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyInstruction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Actions {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "actions",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyInstructionField: Fixed size field.
type TopologyInstructionField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// Encoding: The encoding of the field in bytes.

	Encoding *string `json:"encoding,omitempty"`
	// Enum: Internal enumeration type used to restrict possible field values.

	Enum *string `json:"enum,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name *string `json:"name,omitempty"`
	// SingleValue: If true the field can only be configured with a single value pattern.

	SingleValue *bool `json:"singleValue,omitempty"`
	// Size: The size of the field in bytes.

	Size *float32 `json:"size,omitempty"`
	// SizeType: The size types/data unit of the field.

	SizeType *string `json:"sizeType,omitempty"`
	// Value: The string value of the field.
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyInstructionField) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyInstructionField) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyInstructionField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyInstructionField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyInstructions: Instruction
type TopologyInstructions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name        *string                `json:"name,omitempty"`
	Instruction []*TopologyInstruction `json:"instruction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyInstructions) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyInstructions) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyInstructions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyInstructions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Instruction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "instruction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyInterAreaPrefix: Simulated Router Information
type TopologyInterAreaPrefix struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6) before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LABit: Options-LA Bit(Local Address)
	LABit *Multivalue `json:"lABit,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LinkStateId: Link State Id of the simulated IPv6 network
	LinkStateId *Multivalue `json:"linkStateId,omitempty"`
	// LinkStateIdStep: Link State Id Step for the LSAs to be generated for this set of IPv6 Inter-Area networks.
	LinkStateIdStep *Multivalue `json:"linkStateIdStep,omitempty"`
	// MCBit: Options-MC Bit(Multicast)
	MCBit *Multivalue `json:"mCBit,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised by a Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// NUBit: Options-NU Bit(No Unicast)
	NUBit *Multivalue `json:"nUBit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Prefixes of the simulated IPv6 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PBit: Options-P Bit(Propagate)
	PBit *Multivalue `json:"pBit,omitempty"`
	// Prefix: Prefix Length
	Prefix *Multivalue `json:"prefix,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// UnusedBit4: Options-(4)Unused
	UnusedBit4 *Multivalue `json:"unusedBit4,omitempty"`
	// UnusedBit5: Options-(5)Unused
	UnusedBit5 *Multivalue `json:"unusedBit5,omitempty"`
	// UnusedBit6: Options-(6)Unused
	UnusedBit6 *Multivalue `json:"unusedBit6,omitempty"`
	// UnusedBit7: Options-(7)Unused
	UnusedBit7 *Multivalue `json:"unusedBit7,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyInterAreaPrefix) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyInterAreaPrefix) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyInterAreaPrefix) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyInterAreaPrefix) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lABit",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateId",
		isMultivalue: true,
	})
	n.LinkStateIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateIdStep",
		isMultivalue: true,
	})
	n.MCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mCBit",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NUBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nUBit",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pBit",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.UnusedBit4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit4",
		isMultivalue: true,
	})
	n.UnusedBit5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit5",
		isMultivalue: true,
	})
	n.UnusedBit6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit6",
		isMultivalue: true,
	})
	n.UnusedBit7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit7",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyInterAreaRouter: External routes without external metric
type TopologyInterAreaRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// DCBit: Demand Circuit bit
	DCBit *Multivalue `json:"dCBit,omitempty"`
	// DestRouterId: Destination Router Id
	DestRouterId *Multivalue `json:"destRouterId,omitempty"`
	// DestRouterIdPrefix: Destination Router Id Step
	DestRouterIdPrefix *Multivalue `json:"destRouterIdPrefix,omitempty"`
	// EBit: bit describing how AS-external-LSAs are flooded
	EBit *Multivalue `json:"eBit,omitempty"`
	// LinkStateId: Link State Id of the simulated IPv6 network
	LinkStateId *Multivalue `json:"linkStateId,omitempty"`
	// LinkStateIdStep: Link State Id Step for the LSAs to be generated for this set of IPv6 Inter-Area networks.
	LinkStateIdStep *Multivalue `json:"linkStateIdStep,omitempty"`
	// MCBit: bit for forwarding of IP multicast datagrams
	MCBit *Multivalue `json:"mCBit,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// NBit: bit for handling Type 7 LSAs
	NBit *Multivalue `json:"nBit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RBit: Router bit
	RBit *Multivalue `json:"rBit,omitempty"`
	// RangeSize: Count
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// ReservedBit6: (6) Reserved Bit
	ReservedBit6 *Multivalue `json:"reservedBit6,omitempty"`
	// ReservedBit7: (7) Reserved Bit
	ReservedBit7 *Multivalue `json:"reservedBit7,omitempty"`
	// V6Bit: bit for excluding the router/link from IPv6 routing calculations. If clear, router/link is excluded
	V6Bit *Multivalue `json:"v6Bit,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyInterAreaRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyInterAreaRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyInterAreaRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyInterAreaRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dCBit",
		isMultivalue: true,
	})
	n.DestRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destRouterId",
		isMultivalue: true,
	})
	n.DestRouterIdPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destRouterIdPrefix",
		isMultivalue: true,
	})
	n.EBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eBit",
		isMultivalue: true,
	})
	n.LinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateId",
		isMultivalue: true,
	})
	n.LinkStateIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateIdStep",
		isMultivalue: true,
	})
	n.MCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mCBit",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nBit",
		isMultivalue: true,
	})
	n.RBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rBit",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.ReservedBit6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedBit6",
		isMultivalue: true,
	})
	n.ReservedBit7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedBit7",
		isMultivalue: true,
	})
	n.V6Bit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "v6Bit",
		isMultivalue: true,
	})
}

// TopologyInterestedVlanList: Fabric-Path Interested Vlans
type TopologyInterestedVlanList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// IncludeInLSP: Include in LSP
	IncludeInLSP *Multivalue `json:"includeInLSP,omitempty"`
	// IncludeInMGroupPDU: Include in MGROUP-PDU
	IncludeInMGroupPDU *Multivalue `json:"includeInMGroupPDU,omitempty"`
	// M4BitEnabled: M4 Bit Enabled
	M4BitEnabled *Multivalue `json:"m4BitEnabled,omitempty"`
	// M6BitEnabled: M6 Bit Enabled
	M6BitEnabled *Multivalue `json:"m6BitEnabled,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// NoOfSpanningTreeRoots: No. of Spanning Tree Roots
	NoOfSpanningTreeRoots *Multivalue `json:"noOfSpanningTreeRoots,omitempty"`
	// StartSpanningTreeRootBridgeId: Start Spanning Tree Root Bridge ID
	StartSpanningTreeRootBridgeId *Multivalue `json:"startSpanningTreeRootBridgeId,omitempty"`
	// StartVlanId: Start Vlan Id
	StartVlanId *Multivalue `json:"startVlanId,omitempty"`
	// VlanCount: Vlan Count
	VlanCount *Multivalue `json:"vlanCount,omitempty"`
	// VlanIdIncr: Vlan Id Increment
	VlanIdIncr *Multivalue `json:"vlanIdIncr,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyInterestedVlanList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyInterestedVlanList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyInterestedVlanList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyInterestedVlanList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.IncludeInLSP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeInLSP",
		isMultivalue: true,
	})
	n.IncludeInMGroupPDU.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeInMGroupPDU",
		isMultivalue: true,
	})
	n.M4BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m4BitEnabled",
		isMultivalue: true,
	})
	n.M6BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m6BitEnabled",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.NoOfSpanningTreeRoots.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfSpanningTreeRoots",
		isMultivalue: true,
	})
	n.StartSpanningTreeRootBridgeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSpanningTreeRootBridgeId",
		isMultivalue: true,
	})
	n.StartVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startVlanId",
		isMultivalue: true,
	})
	n.VlanCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanCount",
		isMultivalue: true,
	})
	n.VlanIdIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdIncr",
		isMultivalue: true,
	})
}

// TopologyIntraAreaPrefix: Simulated Router Information
type TopologyIntraAreaPrefix struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6) before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LABit: Options-LA Bit(Local Address)
	LABit *Multivalue `json:"lABit,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LinkStateId: Link State Id of the simulated IPv6 network
	LinkStateId *Multivalue `json:"linkStateId,omitempty"`
	// LinkStateIdStep: Link State Id Step for the LSAs to be generated for this set of IPv6 Inter-Area networks.
	LinkStateIdStep *Multivalue `json:"linkStateIdStep,omitempty"`
	// MCBit: Options-MC Bit(Multicast)
	MCBit *Multivalue `json:"mCBit,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised by a Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// NUBit: Options-NU Bit(No Unicast)
	NUBit *Multivalue `json:"nUBit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Prefixes of the simulated IPv6 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PBit: Options-P Bit(Propagate)
	PBit *Multivalue `json:"pBit,omitempty"`
	// Prefix: Prefix Length
	Prefix *Multivalue `json:"prefix,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// RefLSType: Reference LS Type
	RefLSType *Multivalue `json:"refLSType,omitempty"`
	// ReferencedLinkStateId: Referenced Link State Id
	ReferencedLinkStateId *Multivalue `json:"referencedLinkStateId,omitempty"`
	// ReferencedRouterId: Referenced Advertising Router Id
	ReferencedRouterId *Multivalue `json:"referencedRouterId,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// UnusedBit4: Options-(4)Unused
	UnusedBit4 *Multivalue `json:"unusedBit4,omitempty"`
	// UnusedBit5: Options-(5)Unused
	UnusedBit5 *Multivalue `json:"unusedBit5,omitempty"`
	// UnusedBit6: Options-(6)Unused
	UnusedBit6 *Multivalue `json:"unusedBit6,omitempty"`
	// UnusedBit7: Options-(7)Unused
	UnusedBit7 *Multivalue `json:"unusedBit7,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIntraAreaPrefix) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIntraAreaPrefix) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIntraAreaPrefix) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIntraAreaPrefix) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lABit",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateId",
		isMultivalue: true,
	})
	n.LinkStateIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateIdStep",
		isMultivalue: true,
	})
	n.MCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mCBit",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NUBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nUBit",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pBit",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.RefLSType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "refLSType",
		isMultivalue: true,
	})
	n.ReferencedLinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "referencedLinkStateId",
		isMultivalue: true,
	})
	n.ReferencedRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "referencedRouterId",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.UnusedBit4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit4",
		isMultivalue: true,
	})
	n.UnusedBit5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit5",
		isMultivalue: true,
	})
	n.UnusedBit6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit6",
		isMultivalue: true,
	})
	n.UnusedBit7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit7",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyIpVersion: TBD
type TopologyIpVersion struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpVersion) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpVersion) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpVersion) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpVersion) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyIptv: IGMP/MLD IPTV Configuration
type TopologyIptv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CombinedLeaveJoin: If enabled, Leave for current group and join for next group gets merged in a single multicast packet
	CombinedLeaveJoin *Multivalue `json:"combinedLeaveJoin,omitempty"`
	// EnableGeneralQueryResponse: If enabled, General Query Response is send.
	EnableGeneralQueryResponse *Multivalue `json:"enableGeneralQueryResponse,omitempty"`
	// EnableGroupSpecificQueryResponse: If enabled, Group Specific Response is sent
	EnableGroupSpecificQueryResponse *Multivalue `json:"enableGroupSpecificQueryResponse,omitempty"`
	// JoinLatencyThreshold: The maximum time that is allowed for a multicast stream to arrive for channel for which a Join has been sent.
	JoinLatencyThreshold *Multivalue `json:"joinLatencyThreshold,omitempty"`
	// LeaveLatencyThreshold: The maximum time allowed for a multicast stream to stop for a channel for which a Leave has been sent.
	LeaveLatencyThreshold *Multivalue `json:"leaveLatencyThreshold,omitempty"`
	// LogAllTimestamps: If enabled, all the captured timestamps for Join and Leave are saved to a log file.
	LogAllTimestamps *Multivalue `json:"logAllTimestamps,omitempty"`
	// LogFailureTimestamps: If enabled, the timestamps for Join and Leave failures are saved to a log file.
	LogFailureTimestamps *Multivalue `json:"logFailureTimestamps,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumChannelChangesBeforeView: Number of channels to change before stopping on a channel and watching it for View Duration.
	NumChannelChangesBeforeView *Multivalue `json:"numChannelChangesBeforeView,omitempty"`
	// StbLeaveJoinDelay: Time in milliseconds between sending a Leave for the current channel and Join for the next channel.
	StbLeaveJoinDelay *Multivalue `json:"stbLeaveJoinDelay,omitempty"`
	// ViewDuration: Specifies the time in milliseconds to view the last channel.
	ViewDuration *Multivalue `json:"viewDuration,omitempty"`
	// ZapBehavior: Use Zap Only to change channels without viewing the channel or Zap and View to change traffic and receive traffic for the last channel.
	ZapBehavior *Multivalue `json:"zapBehavior,omitempty"`
	// ZapDirection: Specifies the direction of changing channels.
	ZapDirection *Multivalue `json:"zapDirection,omitempty"`
	// ZapInterval: Interval in milliseconds between channel changes based on the selected type.
	ZapInterval *Multivalue `json:"zapInterval,omitempty"`
	// ZapIntervalType: Specifies the wait interval type before changing the channels.
	ZapIntervalType *Multivalue `json:"zapIntervalType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIptv) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIptv) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIptv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIptv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.CombinedLeaveJoin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "combinedLeaveJoin",
		isMultivalue: true,
	})
	n.EnableGeneralQueryResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGeneralQueryResponse",
		isMultivalue: true,
	})
	n.EnableGroupSpecificQueryResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGroupSpecificQueryResponse",
		isMultivalue: true,
	})
	n.JoinLatencyThreshold.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "joinLatencyThreshold",
		isMultivalue: true,
	})
	n.LeaveLatencyThreshold.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leaveLatencyThreshold",
		isMultivalue: true,
	})
	n.LogAllTimestamps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logAllTimestamps",
		isMultivalue: true,
	})
	n.LogFailureTimestamps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logFailureTimestamps",
		isMultivalue: true,
	})
	n.NumChannelChangesBeforeView.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numChannelChangesBeforeView",
		isMultivalue: true,
	})
	n.StbLeaveJoinDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stbLeaveJoinDelay",
		isMultivalue: true,
	})
	n.ViewDuration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "viewDuration",
		isMultivalue: true,
	})
	n.ZapBehavior.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "zapBehavior",
		isMultivalue: true,
	})
	n.ZapDirection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "zapDirection",
		isMultivalue: true,
	})
	n.ZapInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "zapInterval",
		isMultivalue: true,
	})
	n.ZapIntervalType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "zapIntervalType",
		isMultivalue: true,
	})
}

// TopologyIpv4: Static IPV4
type TopologyIpv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Address: IPv4 addresses of the devices
	Address *Multivalue `json:"address,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableGratarpRarp: Enables GRATARP or RARP packet transmission.
	EnableGratarpRarp *Multivalue `json:"enableGratarpRarp,omitempty"`
	// GatewayIp: IPv4 addresses of the Gateways for the devices
	GatewayIp *Multivalue `json:"gatewayIp,omitempty"`
	// Ipv4GratarpRarp: Sends GRATARP or RARP packet.
	Ipv4GratarpRarp *Multivalue `json:"ipv4GratarpRarp,omitempty"`
	// ManualGatewayMac: User specified Gateway MAC addresses
	ManualGatewayMac *Multivalue `json:"manualGatewayMac,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Prefix: The length (in bits) of the mask to be used in conjunction with all the addresses created in the range
	Prefix *Multivalue `json:"prefix,omitempty"`
	// ResolveGateway: Enables the gateway MAC address discovery.
	ResolveGateway *Multivalue `json:"resolveGateway,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs     []Href                           `json:"-"`
	Ancp                  []*TopologyAncp                  `json:"ancp"`
	Bfdv4Interface        []*TopologyBfdv4Interface        `json:"bfdv4Interface"`
	BgpIpv4Peer           []*TopologyBgpIpv4Peer           `json:"bgpIpv4Peer"`
	Dhcpv4relayAgent      []*TopologyDhcpv4relayAgent      `json:"dhcpv4relayAgent"`
	Dhcpv4server          []*TopologyDhcpv4server          `json:"dhcpv4server"`
	ECpriRe               []*TopologyECpriRe               `json:"eCpriRe"`
	ECpriRec              []*TopologyECpriRec              `json:"eCpriRec"`
	Geneve                []*TopologyGeneve                `json:"geneve"`
	Greoipv4              []*TopologyGreoipv4              `json:"greoipv4"`
	IgmpHost              []*TopologyIgmpHost              `json:"igmpHost"`
	IgmpQuerier           []*TopologyIgmpQuerier           `json:"igmpQuerier"`
	Lac                   []*TopologyLac                   `json:"lac"`
	LdpBasicRouter        []*TopologyLdpBasicRouter        `json:"ldpBasicRouter"`
	LdpConnectedInterface []*TopologyLdpConnectedInterface `json:"ldpConnectedInterface"`
	LdpTargetedRouter     []*TopologyLdpTargetedRouter     `json:"ldpTargetedRouter"`
	Lns                   []*TopologyLns                   `json:"lns"`
	MplsOam               []*TopologyMplsOam               `json:"mplsOam"`
	NetconfClient         []*TopologyNetconfClient         `json:"netconfClient"`
	NetconfServer         []*TopologyNetconfServer         `json:"netconfServer"`
	Ntpclock              []*TopologyNtpclock              `json:"ntpclock"`
	OpenFlowController    []*TopologyOpenFlowController    `json:"openFlowController"`
	OpenFlowSwitch        []*TopologyOpenFlowSwitch        `json:"openFlowSwitch"`
	Ospfv2                []*TopologyOspfv2                `json:"ospfv2"`
	Ovsdbcontroller       []*TopologyOvsdbcontroller       `json:"ovsdbcontroller"`
	Ovsdbserver           []*TopologyOvsdbserver           `json:"ovsdbserver"`
	Pcc                   []*TopologyPcc                   `json:"pcc"`
	Pce                   []*TopologyPce                   `json:"pce"`
	PimV4Interface        []*TopologyPimV4Interface        `json:"pimV4Interface"`
	Ptp                   []*TopologyPtp                   `json:"ptp"`
	RsvpteIf              []*TopologyRsvpteIf              `json:"rsvpteIf"`
	RsvpteLsps            []*TopologyRsvpteLsps            `json:"rsvpteLsps"`
	Tag                   []*TopologyTag                   `json:"tag"`
	Vxlan                 []*TopologyVxlan                 `json:"vxlan"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "address",
		isMultivalue: true,
	})
	n.EnableGratarpRarp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGratarpRarp",
		isMultivalue: true,
	})
	n.GatewayIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gatewayIp",
		isMultivalue: true,
	})
	n.Ipv4GratarpRarp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4GratarpRarp",
		isMultivalue: true,
	})
	n.ManualGatewayMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "manualGatewayMac",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.ResolveGateway.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "resolveGateway",
		isMultivalue: true,
	})
	for i, o := range n.Ancp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ancp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Bfdv4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv4relayAgent {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4relayAgent",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv4server {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4server",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Geneve {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "geneve",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Greoipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "greoipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lac {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lac",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpConnectedInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpConnectedInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lns {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lns",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MplsOam {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsOam",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfClient {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfClient",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfServer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfServer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ntpclock {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ntpclock",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OpenFlowController {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "openFlowController",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OpenFlowSwitch {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "openFlowSwitch",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv2 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv2",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ovsdbcontroller {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ovsdbcontroller",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ovsdbserver {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ovsdbserver",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pcc {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcc",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pce {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pce",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ptp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ptp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpteIf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpteIf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpteLsps {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpteLsps",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIpv4Loopback: IPv4 Loopback
type TopologyIpv4Loopback struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Address: IPv4 addresses of the devices
	Address *Multivalue `json:"address,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Prefix: The length (in bits) of the mask to be used in conjunction with all the addresses created in the range
	Prefix *Multivalue `json:"prefix,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href                    `json:"-"`
	Bfdv4Interface    []*TopologyBfdv4Interface `json:"bfdv4Interface"`
	BgpIpv4Peer       []*TopologyBgpIpv4Peer    `json:"bgpIpv4Peer"`

	Connector         *TopologyConnector           `json:"connector,omitempty"`
	ECpriRe           []*TopologyECpriRe           `json:"eCpriRe"`
	ECpriRec          []*TopologyECpriRec          `json:"eCpriRec"`
	Geneve            []*TopologyGeneve            `json:"geneve"`
	Greoipv4          []*TopologyGreoipv4          `json:"greoipv4"`
	IgmpHost          []*TopologyIgmpHost          `json:"igmpHost"`
	IgmpQuerier       []*TopologyIgmpQuerier       `json:"igmpQuerier"`
	LdpTargetedRouter []*TopologyLdpTargetedRouter `json:"ldpTargetedRouter"`
	MplsOam           []*TopologyMplsOam           `json:"mplsOam"`
	NetconfClient     []*TopologyNetconfClient     `json:"netconfClient"`
	NetconfServer     []*TopologyNetconfServer     `json:"netconfServer"`
	Ntpclock          []*TopologyNtpclock          `json:"ntpclock"`
	Ospfv2            []*TopologyOspfv2            `json:"ospfv2"`
	Pcc               []*TopologyPcc               `json:"pcc"`
	Pce               []*TopologyPce               `json:"pce"`
	PimV4Interface    []*TopologyPimV4Interface    `json:"pimV4Interface"`
	RsvpteLsps        []*TopologyRsvpteLsps        `json:"rsvpteLsps"`
	Tag               []*TopologyTag               `json:"tag"`
	Vxlan             []*TopologyVxlan             `json:"vxlan"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv4Loopback) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv4Loopback) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv4Loopback) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv4Loopback) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "address",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Geneve {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "geneve",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Greoipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "greoipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MplsOam {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsOam",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfClient {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfClient",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfServer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfServer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ntpclock {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ntpclock",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv2 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv2",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pcc {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcc",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pce {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pce",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpteLsps {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpteLsps",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIpv4NodeId: TBD
type TopologyIpv4NodeId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv4NodeId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv4NodeId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv4NodeId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv4NodeId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyIpv4PrefixPools: Represents an IPv4 address
type TopologyIpv4PrefixPools struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AddrStepSupported: Indicates whether the Route Range provider allows route range address increment step of more than one

	AddrStepSupported *bool `json:"addrStepSupported,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: First address of host/network address pool in the simulated IPv4 host/network range
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NumberOfAddresses: Number of host/network addresses in the simulated IPv4 host/network range

	NumberOfAddresses *float32 `json:"numberOfAddresses,omitempty"`
	// NumberOfAddressesAsy: Number of host/network addresses in the simulated IPv4 host/network range
	NumberOfAddressesAsy *Multivalue `json:"numberOfAddressesAsy,omitempty"`
	// PrefixAddrStep: The difference between each address, and its next, in the IPv4 host/network range.
	PrefixAddrStep *Multivalue `json:"prefixAddrStep,omitempty"`
	// PrefixLength: The length (in bits) of the mask to be used in conjunction with all the addresses created in the range
	PrefixLength             *Multivalue                         `json:"prefixLength,omitempty"`
	BgpIPRouteProperty       []*TopologyBgpIpRouteProperty       `json:"bgpIPRouteProperty"`
	BgpL3VpnRouteProperty    []*TopologyBgpL3VpnRouteProperty    `json:"bgpL3VpnRouteProperty"`
	BgpMVpnReceiverSitesIpv4 []*TopologyBgpMVpnReceiverSitesIpv4 `json:"bgpMVpnReceiverSitesIpv4"`
	BgpMVpnReceiverSitesIpv6 []*TopologyBgpMVpnReceiverSitesIpv6 `json:"bgpMVpnReceiverSitesIpv6"`
	BgpMVpnSenderSitesIpv4   []*TopologyBgpMVpnSenderSitesIpv4   `json:"bgpMVpnSenderSitesIpv4"`
	BgpMVpnSenderSitesIpv6   []*TopologyBgpMVpnSenderSitesIpv6   `json:"bgpMVpnSenderSitesIpv6"`
	BgpV6IPRouteProperty     []*TopologyBgpV6IpRouteProperty     `json:"bgpV6IPRouteProperty"`
	BgpV6L3VpnRouteProperty  []*TopologyBgpV6L3VpnRouteProperty  `json:"bgpV6L3VpnRouteProperty"`
	CMacProperties           []*TopologyCMacProperties           `json:"cMacProperties"`

	Connector                    *TopologyConnector                      `json:"connector,omitempty"`
	ECpriReRadioChannelsOrUsers  []*TopologyECpriReRadioChannelsOrUsers  `json:"eCpriReRadioChannelsOrUsers"`
	ECpriRecRadioChannelsOrUsers []*TopologyECpriRecRadioChannelsOrUsers `json:"eCpriRecRadioChannelsOrUsers"`
	EvpnIPv4PrefixRange          []*TopologyEvpnIPv4PrefixRange          `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange          []*TopologyEvpnIPv6PrefixRange          `json:"evpnIPv6PrefixRange"`
	IsisL3RouteProperty          []*TopologyIsisL3RouteProperty          `json:"isisL3RouteProperty"`
	LdpFECProperty               []*TopologyLdpFecProperty               `json:"ldpFECProperty"`
	OspfRouteProperty            []*TopologyOspfRouteProperty            `json:"ospfRouteProperty"`
	Tag                          []*TopologyTag                          `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv4PrefixPools) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv4PrefixPools) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv4PrefixPools) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv4PrefixPools) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NumberOfAddressesAsy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfAddressesAsy",
		isMultivalue: true,
	})
	n.PrefixAddrStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixAddrStep",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	for i, o := range n.BgpIPRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VpnRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VpnRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnReceiverSitesIpv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnReceiverSitesIpv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnReceiverSitesIpv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnReceiverSitesIpv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnSenderSitesIpv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnSenderSitesIpv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnSenderSitesIpv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnSenderSitesIpv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpV6IPRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpV6IPRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpV6L3VpnRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpV6L3VpnRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.ECpriReRadioChannelsOrUsers {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriReRadioChannelsOrUsers",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRecRadioChannelsOrUsers {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRecRadioChannelsOrUsers",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3RouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3RouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpFECProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpFECProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIpv6: Static IPV6
type TopologyIpv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Address: IPv6 addresses of the devices
	Address *Multivalue `json:"address,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DiscoverGatewayIp: Enables gateway Link-local IP address discovery.
	DiscoverGatewayIp *Multivalue `json:"discoverGatewayIp,omitempty"`
	// GatewayIp: Gateways of the layer
	GatewayIp *Multivalue `json:"gatewayIp,omitempty"`
	// IncludeRaPrefix: When enabled, prefix will be added in RA option.
	IncludeRaPrefix *Multivalue `json:"includeRaPrefix,omitempty"`
	// ManualGatewayMac: User specified Gateway MAC addresses
	ManualGatewayMac *Multivalue `json:"manualGatewayMac,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Prefix: The length (in bits) of the mask to be used in conjunction with all the addresses created in the range
	Prefix *Multivalue `json:"prefix,omitempty"`
	// ResolveGateway: Enables the gateway MAC address discovery.
	ResolveGateway *Multivalue `json:"resolveGateway,omitempty"`
	// SendRa: Enables sending RA.
	SendRa *Multivalue `json:"sendRa,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs       []Href                             `json:"-"`
	Bfdv6Interface          []*TopologyBfdv6Interface          `json:"bfdv6Interface"`
	BgpIpv6Peer             []*TopologyBgpIpv6Peer             `json:"bgpIpv6Peer"`
	Dhcpv6relayAgent        []*TopologyDhcpv6relayAgent        `json:"dhcpv6relayAgent"`
	Dhcpv6server            []*TopologyDhcpv6server            `json:"dhcpv6server"`
	Greoipv6                []*TopologyGreoipv6                `json:"greoipv6"`
	Ipv6sr                  []*TopologyIpv6sr                  `json:"ipv6sr"`
	LdpBasicRouterV6        []*TopologyLdpBasicRouterV6        `json:"ldpBasicRouterV6"`
	LdpTargetedRouterV6     []*TopologyLdpTargetedRouterV6     `json:"ldpTargetedRouterV6"`
	Ldpv6ConnectedInterface []*TopologyLdpv6ConnectedInterface `json:"ldpv6ConnectedInterface"`
	MldHost                 []*TopologyMldHost                 `json:"mldHost"`
	MldQuerier              []*TopologyMldQuerier              `json:"mldQuerier"`
	Ntpclock                []*TopologyNtpclock                `json:"ntpclock"`
	Ospfv3                  []*TopologyOspfv3                  `json:"ospfv3"`
	PimV6Interface          []*TopologyPimV6Interface          `json:"pimV6Interface"`
	Ptp                     []*TopologyPtp                     `json:"ptp"`
	Tag                     []*TopologyTag                     `json:"tag"`
	Vxlanv6                 []*TopologyVxlanv6                 `json:"vxlanv6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "address",
		isMultivalue: true,
	})
	n.DiscoverGatewayIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discoverGatewayIp",
		isMultivalue: true,
	})
	n.GatewayIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gatewayIp",
		isMultivalue: true,
	})
	n.IncludeRaPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeRaPrefix",
		isMultivalue: true,
	})
	n.ManualGatewayMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "manualGatewayMac",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.ResolveGateway.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "resolveGateway",
		isMultivalue: true,
	})
	n.SendRa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendRa",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6relayAgent {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6relayAgent",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6server {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6server",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Greoipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "greoipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6sr {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6sr",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldpv6ConnectedInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpv6ConnectedInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ntpclock {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ntpclock",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ptp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ptp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlanv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlanv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIpv6Autoconfiguration: IPv6 Autoconfiguration protocol
type TopologyIpv6Autoconfiguration struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href                    `json:"-"`
	Bfdv6Interface    []*TopologyBfdv6Interface `json:"bfdv6Interface"`
	BgpIpv6Peer       []*TopologyBgpIpv6Peer    `json:"bgpIpv6Peer"`
	MldHost           []*TopologyMldHost        `json:"mldHost"`
	MldQuerier        []*TopologyMldQuerier     `json:"mldQuerier"`
	Ospfv3            []*TopologyOspfv3         `json:"ospfv3"`
	PimV6Interface    []*TopologyPimV6Interface `json:"pimV6Interface"`
	Tag               []*TopologyTag            `json:"tag"`
	Vxlanv6           []*TopologyVxlanv6        `json:"vxlanv6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv6Autoconfiguration) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv6Autoconfiguration) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv6Autoconfiguration) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv6Autoconfiguration) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Bfdv6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlanv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlanv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIpv6Loopback: IPV6 Loopback
type TopologyIpv6Loopback struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Address: IPv6 addresses of the devices
	Address *Multivalue `json:"address,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Prefix: The length (in bits) of the mask to be used in conjunction with all the addresses created in the range
	Prefix *Multivalue `json:"prefix,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href                    `json:"-"`
	Bfdv6Interface    []*TopologyBfdv6Interface `json:"bfdv6Interface"`
	BgpIpv6Peer       []*TopologyBgpIpv6Peer    `json:"bgpIpv6Peer"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	Greoipv6            []*TopologyGreoipv6            `json:"greoipv6"`
	LdpTargetedRouterV6 []*TopologyLdpTargetedRouterV6 `json:"ldpTargetedRouterV6"`
	MldHost             []*TopologyMldHost             `json:"mldHost"`
	MldQuerier          []*TopologyMldQuerier          `json:"mldQuerier"`
	Ntpclock            []*TopologyNtpclock            `json:"ntpclock"`
	Ospfv3              []*TopologyOspfv3              `json:"ospfv3"`
	PimV6Interface      []*TopologyPimV6Interface      `json:"pimV6Interface"`
	Tag                 []*TopologyTag                 `json:"tag"`
	Vxlanv6             []*TopologyVxlanv6             `json:"vxlanv6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv6Loopback) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv6Loopback) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv6Loopback) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv6Loopback) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "address",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Greoipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "greoipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ntpclock {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ntpclock",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlanv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlanv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIpv6NodeId: TBD
type TopologyIpv6NodeId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv6NodeId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv6NodeId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv6NodeId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv6NodeId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyIpv6PrefixPools: Represents an IPv6 address
type TopologyIpv6PrefixPools struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AddrStepSupported: Indicates whether the Route Range provider allows address increment step of more than one

	AddrStepSupported *bool `json:"addrStepSupported,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: First address of host/network address pool in the simulated IPv6 host/network range
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NumberOfAddresses: Number of host/network addresses in the simulated IPv6 host/network range

	NumberOfAddresses *float32 `json:"numberOfAddresses,omitempty"`
	// NumberOfAddressesAsy: Number of host/network addresses in the simulated IPv6 host/network range
	NumberOfAddressesAsy *Multivalue `json:"numberOfAddressesAsy,omitempty"`
	// PrefixAddrStep: The difference between each address, and its next, in the IPv6 host/network range.
	PrefixAddrStep *Multivalue `json:"prefixAddrStep,omitempty"`
	// PrefixLength: The length (in bits) of the mask to be used in conjunction with all the addresses created in the range
	PrefixLength             *Multivalue                         `json:"prefixLength,omitempty"`
	BgpIPRouteProperty       []*TopologyBgpIpRouteProperty       `json:"bgpIPRouteProperty"`
	BgpL3VpnRouteProperty    []*TopologyBgpL3VpnRouteProperty    `json:"bgpL3VpnRouteProperty"`
	BgpMVpnReceiverSitesIpv4 []*TopologyBgpMVpnReceiverSitesIpv4 `json:"bgpMVpnReceiverSitesIpv4"`
	BgpMVpnReceiverSitesIpv6 []*TopologyBgpMVpnReceiverSitesIpv6 `json:"bgpMVpnReceiverSitesIpv6"`
	BgpMVpnSenderSitesIpv4   []*TopologyBgpMVpnSenderSitesIpv4   `json:"bgpMVpnSenderSitesIpv4"`
	BgpMVpnSenderSitesIpv6   []*TopologyBgpMVpnSenderSitesIpv6   `json:"bgpMVpnSenderSitesIpv6"`
	BgpV6IPRouteProperty     []*TopologyBgpV6IpRouteProperty     `json:"bgpV6IPRouteProperty"`
	BgpV6L3VpnRouteProperty  []*TopologyBgpV6L3VpnRouteProperty  `json:"bgpV6L3VpnRouteProperty"`
	CMacProperties           []*TopologyCMacProperties           `json:"cMacProperties"`

	Connector                    *TopologyConnector                      `json:"connector,omitempty"`
	ECpriReRadioChannelsOrUsers  []*TopologyECpriReRadioChannelsOrUsers  `json:"eCpriReRadioChannelsOrUsers"`
	ECpriRecRadioChannelsOrUsers []*TopologyECpriRecRadioChannelsOrUsers `json:"eCpriRecRadioChannelsOrUsers"`
	EvpnIPv4PrefixRange          []*TopologyEvpnIPv4PrefixRange          `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange          []*TopologyEvpnIPv6PrefixRange          `json:"evpnIPv6PrefixRange"`
	IsisL3RouteProperty          []*TopologyIsisL3RouteProperty          `json:"isisL3RouteProperty"`
	LdpIpv6FECProperty           []*TopologyLdpIpv6FecProperty           `json:"ldpIpv6FECProperty"`
	OspfRouteProperty            []*TopologyOspfRouteProperty            `json:"ospfRouteProperty"`
	Ospfv3RouteProperty          []*TopologyOspfv3RouteProperty          `json:"ospfv3RouteProperty"`
	Tag                          []*TopologyTag                          `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv6PrefixPools) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv6PrefixPools) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv6PrefixPools) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv6PrefixPools) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NumberOfAddressesAsy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfAddressesAsy",
		isMultivalue: true,
	})
	n.PrefixAddrStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixAddrStep",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	for i, o := range n.BgpIPRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VpnRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VpnRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnReceiverSitesIpv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnReceiverSitesIpv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnReceiverSitesIpv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnReceiverSitesIpv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnSenderSitesIpv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnSenderSitesIpv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnSenderSitesIpv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnSenderSitesIpv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpV6IPRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpV6IPRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpV6L3VpnRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpV6L3VpnRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.ECpriReRadioChannelsOrUsers {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriReRadioChannelsOrUsers",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRecRadioChannelsOrUsers {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRecRadioChannelsOrUsers",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3RouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3RouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpIpv6FECProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpIpv6FECProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3RouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3RouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIpv6sr: IPv6 SR Configuration
type TopologyIpv6sr struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CleanupFlag: Set when the SRH has to be removed from the packet when the packet reaches the last segment
	CleanupFlag *Multivalue `json:"cleanupFlag,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// FirstSegment: Count of enabled SID List -1
	FirstSegment *Multivalue `json:"firstSegment,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberSegments: Maximum available index of the Segments List in SRH header (0 Based Index)

	NumberSegments *float32 `json:"numberSegments,omitempty"`
	// OamFlag: Indicates that this packet will be Operations And Management
	OamFlag *Multivalue `json:"oamFlag,omitempty"`
	// OuterDestAddr: Controlled by Segments Left, index from enabled SID List
	OuterDestAddr *Multivalue `json:"outerDestAddr,omitempty"`
	// OuterSrcAddr: Outer IPv6 Source Address
	OuterSrcAddr *Multivalue `json:"outerSrcAddr,omitempty"`
	// ProtectedFlag: Set when the packet has been rerouted through FRR mechanism by an SR endpoint node
	ProtectedFlag *Multivalue `json:"protectedFlag,omitempty"`
	// SID0: Segment Item Address
	SID0 *Multivalue `json:"sID0,omitempty"`
	// SIDEnable0: Enable This Segment
	SIDEnable0 *Multivalue `json:"sIDEnable0,omitempty"`
	// SegmentsLeft: Segments Left (0 Based Index)
	SegmentsLeft *Multivalue `json:"segmentsLeft,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TunnelDescription: Tunnel Description
	TunnelDescription *Multivalue `json:"tunnelDescription,omitempty"`
	// UseAsIngress: Use This Device As Ingress
	UseAsIngress     *Multivalue                 `json:"useAsIngress,omitempty"`
	IPv6SegmentsList []*TopologyIPv6SegmentsList `json:"IPv6SegmentsList"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIpv6sr) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIpv6sr) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIpv6sr) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIpv6sr) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CleanupFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cleanupFlag",
		isMultivalue: true,
	})
	n.FirstSegment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "firstSegment",
		isMultivalue: true,
	})
	n.OamFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oamFlag",
		isMultivalue: true,
	})
	n.OuterDestAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outerDestAddr",
		isMultivalue: true,
	})
	n.OuterSrcAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outerSrcAddr",
		isMultivalue: true,
	})
	n.ProtectedFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectedFlag",
		isMultivalue: true,
	})
	n.SID0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sID0",
		isMultivalue: true,
	})
	n.SIDEnable0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDEnable0",
		isMultivalue: true,
	})
	n.SegmentsLeft.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentsLeft",
		isMultivalue: true,
	})
	n.TunnelDescription.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelDescription",
		isMultivalue: true,
	})
	n.UseAsIngress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useAsIngress",
		isMultivalue: true,
	})
	for i, o := range n.IPv6SegmentsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "IPv6SegmentsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
}

// TopologyIsidList: ISIS SPB ISID Configuration
type TopologyIsidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BaseVid: Base VID
	BaseVid *Multivalue `json:"baseVid,omitempty"`
	// Isid: I-SID
	Isid *Multivalue `json:"isid,omitempty"`
	// ItagEthernetType: I-Tag Ethernet Type
	ItagEthernetType *Multivalue `json:"itagEthernetType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Rbit: R Bit
	Rbit *Multivalue `json:"rbit,omitempty"`
	// Tbit: T Bit
	Tbit *Multivalue `json:"tbit,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// TransmissionType: Transmission Type
	TransmissionType *Multivalue `json:"transmissionType,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BaseVid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseVid",
		isMultivalue: true,
	})
	n.Isid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "isid",
		isMultivalue: true,
	})
	n.ItagEthernetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "itagEthernetType",
		isMultivalue: true,
	})
	n.Rbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rbit",
		isMultivalue: true,
	})
	n.Tbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tbit",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.TransmissionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transmissionType",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
}

// TopologyIsisAppSpecSrlgList: ISIS Application Specific SRLG
type TopologyIsisAppSpecSrlgList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// IpV4InterfaceAddr: IPv4 Interface Address
	IpV4InterfaceAddr *Multivalue `json:"ipV4InterfaceAddr,omitempty"`
	// IpV4NeighborAddr: IPv4 Neighbor Address
	IpV4NeighborAddr *Multivalue `json:"ipV4NeighborAddr,omitempty"`
	// IpV6InterfaceAddr: IPv6 Interface Address
	IpV6InterfaceAddr *Multivalue `json:"ipV6InterfaceAddr,omitempty"`
	// IpV6NeighborAddr: IPv6 Neighbor Address
	IpV6NeighborAddr *Multivalue `json:"ipV6NeighborAddr,omitempty"`
	// LFlag: If set to False, all link attributes will be advertised as sub-sub-tlv of sub tlv Application Specific Link Attributes sub-TLV (Type 16) of TLV 22,23,141,222 and 223 If true, then all link attributes will be advertised as sub-TLV of TLV 22,23,141,222 and 223.
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StdAppType: Standard Appplication Type
	StdAppType *Multivalue `json:"stdAppType,omitempty"`
	// UserDefAppBm: User Defined Application BM
	UserDefAppBm *Multivalue `json:"userDefAppBm,omitempty"`
	// UserDefAppBmLen: User Defined Application BM Length
	UserDefAppBmLen *Multivalue `json:"userDefAppBmLen,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisAppSpecSrlgList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisAppSpecSrlgList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisAppSpecSrlgList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisAppSpecSrlgList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.IpV4InterfaceAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV4InterfaceAddr",
		isMultivalue: true,
	})
	n.IpV4NeighborAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV4NeighborAddr",
		isMultivalue: true,
	})
	n.IpV6InterfaceAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV6InterfaceAddr",
		isMultivalue: true,
	})
	n.IpV6NeighborAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV6NeighborAddr",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.StdAppType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stdAppType",
		isMultivalue: true,
	})
	n.UserDefAppBm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBm",
		isMultivalue: true,
	})
	n.UserDefAppBmLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBmLen",
		isMultivalue: true,
	})
}

// TopologyIsisBierBsObjectList: Isis BIER Bit String Details
type TopologyIsisBierBsObjectList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BIERBitStringLength: Bit String Length
	BIERBitStringLength *Multivalue `json:"BIERBitStringLength,omitempty"`
	// LabelRangeSize: Maximum Set Identifier
	LabelRangeSize *Multivalue `json:"labelRangeSize,omitempty"`
	// LabelStart: Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisBierBsObjectList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisBierBsObjectList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisBierBsObjectList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisBierBsObjectList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BIERBitStringLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERBitStringLength",
		isMultivalue: true,
	})
	n.LabelRangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelRangeSize",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
}

// TopologyIsisBierSubDomainList: ISIS BIER Sub Domain
type TopologyIsisBierSubDomainList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BAR: BIER Algorithm
	BAR *Multivalue `json:"BAR,omitempty"`
	// BFRId: BFR Id
	BFRId *Multivalue `json:"BFRId,omitempty"`
	// IPA: IGP Algorithm
	IPA *Multivalue `json:"IPA,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfBSLen: Number of Supported BSL

	NumberOfBSLen *float32 `json:"numberOfBSLen,omitempty"`
	// SubDomainId: Sub Domain Id
	SubDomainId          *Multivalue                     `json:"subDomainId,omitempty"`
	IsisBierBSObjectList []*TopologyIsisBierBsObjectList `json:"isisBierBSObjectList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisBierSubDomainList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisBierSubDomainList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisBierSubDomainList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisBierSubDomainList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BAR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BAR",
		isMultivalue: true,
	})
	n.BFRId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRId",
		isMultivalue: true,
	})
	n.IPA.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "IPA",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.SubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subDomainId",
		isMultivalue: true,
	})
	for i, o := range n.IsisBierBSObjectList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisBierBSObjectList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisDcePseudoIfaceAttPoint1Config: Fabric-Path Pseudo Interaface Attribute Configuration
type TopologyIsisDcePseudoIfaceAttPoint1Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisDcePseudoIfaceAttPoint1Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisDcePseudoIfaceAttPoint1Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisDcePseudoIfaceAttPoint1Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisDcePseudoIfaceAttPoint1Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisDcePseudoIfaceAttPoint2Config: Fabric-Path Pseudo Interaface Attribute Configuration
type TopologyIsisDcePseudoIfaceAttPoint2Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisDcePseudoIfaceAttPoint2Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisDcePseudoIfaceAttPoint2Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisDcePseudoIfaceAttPoint2Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisDcePseudoIfaceAttPoint2Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisDcePseudoNode: Fabric-Path Pseudo Node Configuration
type TopologyIsisDcePseudoNode struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BroadcastRootPriority: Broadcast Root Priority
	BroadcastRootPriority *Multivalue `json:"broadcastRootPriority,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisDcePseudoNode) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisDcePseudoNode) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisDcePseudoNode) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisDcePseudoNode) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BroadcastRootPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "broadcastRootPriority",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
}

// TopologyIsisDceSimRouter: Fabric Path Simulated Router Edge
type TopologyIsisDceSimRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BroadcastRootPriority: Broadcast Root Priority
	BroadcastRootPriority *Multivalue `json:"broadcastRootPriority,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DceMCastIpv4GroupCount: # Multicast IPv4 Groups(multiplier)

	DceMCastIpv4GroupCount *float32 `json:"dceMCastIpv4GroupCount,omitempty"`
	// DceMCastIpv6GroupCount: # Multicast IPv6 Groups(multiplier)

	DceMCastIpv6GroupCount *float32 `json:"dceMCastIpv6GroupCount,omitempty"`
	// DceMCastMacGroupCount: MAC Group Count(multiplier)

	DceMCastMacGroupCount *float32 `json:"dceMCastMacGroupCount,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Switch Id
	Nickname *Multivalue `json:"nickname,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SystemId: System Id
	SystemId *Multivalue `json:"systemId,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	DceSimulatedMCastIpv4GroupList *TopologyDceSimulatedMCastIpv4GroupList `json:"dceSimulatedMCastIpv4GroupList,omitempty"`

	DceSimulatedMCastIpv6GroupList *TopologyDceSimulatedMCastIpv6GroupList `json:"dceSimulatedMCastIpv6GroupList,omitempty"`

	DceSimulatedMCastMacGroupList *TopologyDceSimulatedMCastMacGroupList `json:"dceSimulatedMCastMacGroupList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisDceSimRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisDceSimRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisDceSimRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisDceSimRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BroadcastRootPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "broadcastRootPriority",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.DceSimulatedMCastIpv4GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceSimulatedMCastIpv4GroupList",
	})
	n.DceSimulatedMCastIpv6GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceSimulatedMCastIpv6GroupList",
	})
	n.DceSimulatedMCastMacGroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceSimulatedMCastMacGroupList",
	})
}

// TopologyIsisDceSimulatedTopologyConfig: Fabric-Path Simulated Topology Configuration
type TopologyIsisDceSimulatedTopologyConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// DceNodeTopologyCount: Node Topology Count(multiplier)

	DceNodeTopologyCount *float32 `json:"dceNodeTopologyCount,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	DceNodeTopologyList *TopologyDceNodeTopologyList `json:"dceNodeTopologyList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisDceSimulatedTopologyConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisDceSimulatedTopologyConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisDceSimulatedTopologyConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisDceSimulatedTopologyConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.DceNodeTopologyList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceNodeTopologyList",
	})
}

// TopologyIsisFabricPath: ISIS Interface level Configuration
type TopologyIsisFabricPath struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuthType: Authentication Type
	AuthType *Multivalue `json:"authType,omitempty"`
	// AutoAdjustArea: Auto Adjust Area
	AutoAdjustArea *Multivalue `json:"autoAdjustArea,omitempty"`
	// AutoAdjustMTU: Auto Adjust MTU
	AutoAdjustMTU *Multivalue `json:"autoAdjustMTU,omitempty"`
	// AutoAdjustSupportedProtocols: Auto Adjust Supported Protocols
	AutoAdjustSupportedProtocols *Multivalue `json:"autoAdjustSupportedProtocols,omitempty"`
	// CircuitTranmitPasswordOrMD5Key: Circuit Transmit Password / MD5-Key
	CircuitTranmitPasswordOrMD5Key *Multivalue `json:"circuitTranmitPasswordOrMD5Key,omitempty"`
	// ConfiguredHoldTime: Configured Hold Time
	ConfiguredHoldTime *Multivalue `json:"configuredHoldTime,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Enable3WayHandshake: Enable 3-way Handshake
	Enable3WayHandshake *Multivalue `json:"enable3WayHandshake,omitempty"`
	// EnableConfiguredHoldTime: Enable Configured Hold Time
	EnableConfiguredHoldTime *Multivalue `json:"enableConfiguredHoldTime,omitempty"`
	// ExtendedLocalCircuitId: Extended Local Circuit Id
	ExtendedLocalCircuitId *Multivalue `json:"extendedLocalCircuitId,omitempty"`
	// InterfaceMetric: Interface Metric
	InterfaceMetric *Multivalue `json:"interfaceMetric,omitempty"`
	// Level1DeadInterval: Level 1 Dead Interval (sec)
	Level1DeadInterval *Multivalue `json:"level1DeadInterval,omitempty"`
	// Level1HelloInterval: Level 1 Hello Interval (sec)
	Level1HelloInterval *Multivalue `json:"level1HelloInterval,omitempty"`
	// LevelType: Level Type
	LevelType *Multivalue `json:"levelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkType: Network Type
	NetworkType *Multivalue `json:"networkType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Connector   *TopologyConnector     `json:"connector,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisFabricPath) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisFabricPath) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisFabricPath) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisFabricPath) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuthType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authType",
		isMultivalue: true,
	})
	n.AutoAdjustArea.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustArea",
		isMultivalue: true,
	})
	n.AutoAdjustMTU.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustMTU",
		isMultivalue: true,
	})
	n.AutoAdjustSupportedProtocols.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustSupportedProtocols",
		isMultivalue: true,
	})
	n.CircuitTranmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "circuitTranmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.ConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredHoldTime",
		isMultivalue: true,
	})
	n.Enable3WayHandshake.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable3WayHandshake",
		isMultivalue: true,
	})
	n.EnableConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableConfiguredHoldTime",
		isMultivalue: true,
	})
	n.ExtendedLocalCircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extendedLocalCircuitId",
		isMultivalue: true,
	})
	n.InterfaceMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceMetric",
		isMultivalue: true,
	})
	n.Level1DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1DeadInterval",
		isMultivalue: true,
	})
	n.Level1HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1HelloInterval",
		isMultivalue: true,
	})
	n.LevelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "levelType",
		isMultivalue: true,
	})
	n.NetworkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkType",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisFabricPathRouter: Fabric Path Configuration
type TopologyIsisFabricPathRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AreaAddresses: Area Addresses
	AreaAddresses *Multivalue `json:"areaAddresses,omitempty"`
	// AreaAuthenticationType: Area Authentication Type
	AreaAuthenticationType *Multivalue `json:"areaAuthenticationType,omitempty"`
	// AreaTransmitPasswordOrMD5Key: Area Transmit Password / MD5-Key
	AreaTransmitPasswordOrMD5Key *Multivalue `json:"areaTransmitPasswordOrMD5Key,omitempty"`
	// Attached: Attached
	Attached *Multivalue `json:"attached,omitempty"`
	// CSNPInterval: CSNP Interval (ms)
	CSNPInterval *Multivalue `json:"cSNPInterval,omitempty"`
	// CapabilityRouterId: Capability Router Id
	CapabilityRouterId *Multivalue `json:"capabilityRouterId,omitempty"`
	// DceMCastIpv4GroupCount: # Multicast IPv4 Groups(multiplier)

	DceMCastIpv4GroupCount *float32 `json:"dceMCastIpv4GroupCount,omitempty"`
	// DceMCastIpv6GroupCount: # Multicast IPv6 Groups(multiplier)

	DceMCastIpv6GroupCount *float32 `json:"dceMCastIpv6GroupCount,omitempty"`
	// DceMCastMacGroupCount: MAC Group Count(multiplier)

	DceMCastMacGroupCount *float32 `json:"dceMCastMacGroupCount,omitempty"`
	// DceTopologyCount: Topology Count(multiplier)

	DceTopologyCount *float32 `json:"dceTopologyCount,omitempty"`
	// DiscardLSPs: Discard LSPs
	DiscardLSPs *Multivalue `json:"discardLSPs,omitempty"`
	// EnableHelloPadding: Enable Hello Padding
	EnableHelloPadding *Multivalue `json:"enableHelloPadding,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// EnableWideMetric: Enable Wide Metric
	EnableWideMetric *Multivalue `json:"enableWideMetric,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// IgnoreReceiveMD5: Ignore Receive MD5
	IgnoreReceiveMD5 *Multivalue `json:"ignoreReceiveMD5,omitempty"`
	// InterLSPsOrMGroupPDUBurstGap: Inter LSPs/MGROUP-PDUs Burst Gap (ms)
	InterLSPsOrMGroupPDUBurstGap *Multivalue `json:"interLSPsOrMGroupPDUBurstGap,omitempty"`
	// LSPLifetime: LSP Rifetime (sec)
	LSPLifetime *Multivalue `json:"lSPLifetime,omitempty"`
	// LSPRefreshRate: LSP Refresh Rate (sec)
	LSPRefreshRate *Multivalue `json:"lSPRefreshRate,omitempty"`
	// LSPorMGroupPDUMinTransmissionInterval: LSP/MGROUP-PDU Min Transmission Interval (ms)
	LSPorMGroupPDUMinTransmissionInterval *Multivalue `json:"lSPorMGroupPDUMinTransmissionInterval,omitempty"`
	// MaxAreaAddresses: Maximum Area Addresses
	MaxAreaAddresses *Multivalue `json:"maxAreaAddresses,omitempty"`
	// MaxLSPSize: Max LSP Size
	MaxLSPSize *Multivalue `json:"maxLSPSize,omitempty"`
	// MaxLSPsOrMGroupPDUsPerBurst: Max LSPs/MGROUP-PDUs Per Burst
	MaxLSPsOrMGroupPDUsPerBurst *Multivalue `json:"maxLSPsOrMGroupPDUsPerBurst,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Overloaded: Overloaded
	Overloaded *Multivalue `json:"overloaded,omitempty"`
	// PSNPInterval: PSNP Interval (ms)
	PSNPInterval *Multivalue `json:"pSNPInterval,omitempty"`
	// PartitionRepair: Partition Repair
	PartitionRepair *Multivalue `json:"partitionRepair,omitempty"`

	DceMCastIpv4GroupList *TopologyDceMCastIpv4GroupList `json:"dceMCastIpv4GroupList,omitempty"`

	DceMCastIpv6GroupList *TopologyDceMCastIpv6GroupList `json:"dceMCastIpv6GroupList,omitempty"`

	DceMCastMacGroupList *TopologyDceMCastMacGroupList `json:"dceMCastMacGroupList,omitempty"`

	DceTopologyList *TopologyDceTopologyList `json:"dceTopologyList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisFabricPathRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisFabricPathRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisFabricPathRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisFabricPathRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAddresses",
		isMultivalue: true,
	})
	n.AreaAuthenticationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAuthenticationType",
		isMultivalue: true,
	})
	n.AreaTransmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaTransmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.Attached.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attached",
		isMultivalue: true,
	})
	n.CSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cSNPInterval",
		isMultivalue: true,
	})
	n.CapabilityRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityRouterId",
		isMultivalue: true,
	})
	n.DiscardLSPs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLSPs",
		isMultivalue: true,
	})
	n.EnableHelloPadding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloPadding",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.EnableWideMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWideMetric",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.IgnoreReceiveMD5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreReceiveMD5",
		isMultivalue: true,
	})
	n.InterLSPsOrMGroupPDUBurstGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interLSPsOrMGroupPDUBurstGap",
		isMultivalue: true,
	})
	n.LSPLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPLifetime",
		isMultivalue: true,
	})
	n.LSPRefreshRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPRefreshRate",
		isMultivalue: true,
	})
	n.LSPorMGroupPDUMinTransmissionInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPorMGroupPDUMinTransmissionInterval",
		isMultivalue: true,
	})
	n.MaxAreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxAreaAddresses",
		isMultivalue: true,
	})
	n.MaxLSPSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPSize",
		isMultivalue: true,
	})
	n.MaxLSPsOrMGroupPDUsPerBurst.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPsOrMGroupPDUsPerBurst",
		isMultivalue: true,
	})
	n.Overloaded.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overloaded",
		isMultivalue: true,
	})
	n.PSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pSNPInterval",
		isMultivalue: true,
	})
	n.PartitionRepair.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partitionRepair",
		isMultivalue: true,
	})
	n.DceMCastIpv4GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceMCastIpv4GroupList",
	})
	n.DceMCastIpv6GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceMCastIpv6GroupList",
	})
	n.DceMCastMacGroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceMCastMacGroupList",
	})
	n.DceTopologyList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dceTopologyList",
	})
}

// TopologyIsisFlexAlgorithmList: ISIS Flex Algorithm
type TopologyIsisFlexAlgorithmList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvTwiceExcludeAg: Advertise Twice Exclude AG
	AdvTwiceExcludeAg *Multivalue `json:"advTwiceExcludeAg,omitempty"`
	// AdvTwiceIncludeAllAg: Advertise Twice Include-All AG
	AdvTwiceIncludeAllAg *Multivalue `json:"advTwiceIncludeAllAg,omitempty"`
	// AdvTwiceIncludeAnyAg: Advertise Twice Include-Any AG
	AdvTwiceIncludeAnyAg *Multivalue `json:"advTwiceIncludeAnyAg,omitempty"`
	// CalcType: Calc Type
	CalcType *Multivalue `json:"calcType,omitempty"`
	// DontAdvInSrAlgo: Don't Adv. in SR Algorithm
	DontAdvInSrAlgo *Multivalue `json:"dontAdvInSrAlgo,omitempty"`
	// EnableExcludeAg: If this is enabled, Flexible Algorithm Exclude Admin Group Sub-Sub TLV will be advertised with FAD sub-TLV.
	EnableExcludeAg *Multivalue `json:"enableExcludeAg,omitempty"`
	// EnableFadfTlv: If enabled then following attributes will get enabled and ISIS Flexible Algorithm Definition Flags Sub-TLV or FADF sub-sub-TLV will be advertised with FAD Sub-TLV
	EnableFadfTlv *Multivalue `json:"enableFadfTlv,omitempty"`
	// EnableIncludeAllAg: If this is enabled, Flexible Algorithm Include-All Admin Group Sub-Sub TLV will be advertised with FAD sub-TLV.
	EnableIncludeAllAg *Multivalue `json:"enableIncludeAllAg,omitempty"`
	// EnableIncludeAnyAg: If this is enabled, Flexible Algorithm Include-Any Admin Group Sub-Sub TLV will be advertised with FAD sub-TLV.
	EnableIncludeAnyAg *Multivalue `json:"enableIncludeAnyAg,omitempty"`
	// ExcludeAgExtAg: Ext Admin Group
	ExcludeAgExtAg *Multivalue `json:"excludeAgExtAg,omitempty"`
	// ExcludeAgExtAgLen: Ext AG Length
	ExcludeAgExtAgLen *Multivalue `json:"excludeAgExtAgLen,omitempty"`
	// FadfLen: FADF AG Length
	FadfLen *Multivalue `json:"fadfLen,omitempty"`
	// FlexAlgo: Flex Algo
	FlexAlgo *Multivalue `json:"flexAlgo,omitempty"`
	// IncludeAllAgExtAg: Ext Include-All AG
	IncludeAllAgExtAg *Multivalue `json:"includeAllAgExtAg,omitempty"`
	// IncludeAllAgExtAgLen: Ext AG Length
	IncludeAllAgExtAgLen *Multivalue `json:"includeAllAgExtAgLen,omitempty"`
	// IncludeAnyAgExtAg: Ext Include-Any AG
	IncludeAnyAgExtAg *Multivalue `json:"includeAnyAgExtAg,omitempty"`
	// IncludeAnyAgExtAgLen: Ext AG Length
	IncludeAnyAgExtAgLen *Multivalue `json:"includeAnyAgExtAgLen,omitempty"`
	// MFlag: M-Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// MetricType: Metric Type
	MetricType *Multivalue `json:"metricType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Priority: Priority
	Priority *Multivalue `json:"priority,omitempty"`
	// ReservedBits: Reserved Bits
	ReservedBits *Multivalue `json:"reservedBits,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisFlexAlgorithmList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisFlexAlgorithmList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisFlexAlgorithmList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisFlexAlgorithmList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvTwiceExcludeAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advTwiceExcludeAg",
		isMultivalue: true,
	})
	n.AdvTwiceIncludeAllAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advTwiceIncludeAllAg",
		isMultivalue: true,
	})
	n.AdvTwiceIncludeAnyAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advTwiceIncludeAnyAg",
		isMultivalue: true,
	})
	n.CalcType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "calcType",
		isMultivalue: true,
	})
	n.DontAdvInSrAlgo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dontAdvInSrAlgo",
		isMultivalue: true,
	})
	n.EnableExcludeAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExcludeAg",
		isMultivalue: true,
	})
	n.EnableFadfTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFadfTlv",
		isMultivalue: true,
	})
	n.EnableIncludeAllAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIncludeAllAg",
		isMultivalue: true,
	})
	n.EnableIncludeAnyAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIncludeAnyAg",
		isMultivalue: true,
	})
	n.ExcludeAgExtAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAgExtAg",
		isMultivalue: true,
	})
	n.ExcludeAgExtAgLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAgExtAgLen",
		isMultivalue: true,
	})
	n.FadfLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fadfLen",
		isMultivalue: true,
	})
	n.FlexAlgo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flexAlgo",
		isMultivalue: true,
	})
	n.IncludeAllAgExtAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAllAgExtAg",
		isMultivalue: true,
	})
	n.IncludeAllAgExtAgLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAllAgExtAgLen",
		isMultivalue: true,
	})
	n.IncludeAnyAgExtAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAnyAgExtAg",
		isMultivalue: true,
	})
	n.IncludeAnyAgExtAgLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAnyAgExtAgLen",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.MetricType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricType",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.ReservedBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedBits",
		isMultivalue: true,
	})
}

// TopologyIsisL3: ISIS Interface level Configuration
type TopologyIsisL3 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdjSID: AdjSID
	AdjSID *Multivalue `json:"adjSID,omitempty"`
	// AdjSidCount: Adj SID Count

	AdjSidCount *float32 `json:"adjSidCount,omitempty"`
	// AdvertiseLinkMsd: Advertise Link MSD
	AdvertiseLinkMsd *Multivalue `json:"advertiseLinkMsd,omitempty"`
	// AuthType: Authentication Type
	AuthType *Multivalue `json:"authType,omitempty"`
	// AutoAdjustArea: Auto Adjust Area
	AutoAdjustArea *Multivalue `json:"autoAdjustArea,omitempty"`
	// AutoAdjustMTU: Auto Adjust MTU
	AutoAdjustMTU *Multivalue `json:"autoAdjustMTU,omitempty"`
	// AutoAdjustSupportedProtocols: Auto Adjust Supported Protocols
	AutoAdjustSupportedProtocols *Multivalue `json:"autoAdjustSupportedProtocols,omitempty"`
	// BFlag: Backup Flag, if set, the Adj-SID is eligible for protection
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// CircuitTranmitPasswordOrMD5Key: Circuit Transmit Password / MD5-Key
	CircuitTranmitPasswordOrMD5Key *Multivalue `json:"circuitTranmitPasswordOrMD5Key,omitempty"`
	// ConfiguredHoldTime: Configured Hold Time
	ConfiguredHoldTime *Multivalue `json:"configuredHoldTime,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DedicatedOnePlusOne: This is a Protection Scheme with value 0x10. It means that a dedicated disjoint link is protecting this link. However, the protecting link is not advertised in the link state database and is therefore not available for the routing of LSPs.
	DedicatedOnePlusOne *Multivalue `json:"dedicatedOnePlusOne,omitempty"`
	// DedicatedOneToOne: This is a Protection Scheme with value 0x08. It means that there is one dedicated disjoint link of type Extra Traffic that is protecting this link.
	DedicatedOneToOne *Multivalue `json:"dedicatedOneToOne,omitempty"`
	// Enable3WayHandshake: Enable 3-way Handshake
	Enable3WayHandshake *Multivalue `json:"enable3WayHandshake,omitempty"`
	// EnableAdjSID: Enable Adj SID
	EnableAdjSID *Multivalue `json:"enableAdjSID,omitempty"`
	// EnableAppSpecSrlg: This enables Application Specific SRLG on the ISIS link between two mentioned interfaces.
	EnableAppSpecSrlg *Multivalue `json:"enableAppSpecSrlg,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableConfiguredHoldTime: Enable Configured Hold Time
	EnableConfiguredHoldTime *Multivalue `json:"enableConfiguredHoldTime,omitempty"`
	// EnableIPv6SID: Enable IPv6 SID
	EnableIPv6SID *Multivalue `json:"enableIPv6SID,omitempty"`
	// EnableLinkProtection: This enables the link protection on the ISIS link between two mentioned interfaces.
	EnableLinkProtection *Multivalue `json:"enableLinkProtection,omitempty"`
	// EnableMT: Enable MT
	EnableMT *Multivalue `json:"enableMT,omitempty"`
	// EnableSRLG: This enables the SRLG on the ISIS link between two mentioned interfaces.
	EnableSRLG *Multivalue `json:"enableSRLG,omitempty"`
	// Enhanced: This is a Protection Scheme with value 0x20. It means that a protection scheme that is more reliable than Dedicated 1+1, e.g., 4 fiber BLSR/MS-SPRING, is being used to protect this link.
	Enhanced *Multivalue `json:"enhanced,omitempty"`
	// ExtendedLocalCircuitId: Extended Local Circuit Id
	ExtendedLocalCircuitId *Multivalue `json:"extendedLocalCircuitId,omitempty"`
	// ExtraTraffic: This is a Protection Scheme with value 0x01. It means that the link is protecting another link or links. The LSPs on a link of this type will be lost if any of the links it is protecting fail.
	ExtraTraffic *Multivalue `json:"extraTraffic,omitempty"`
	// FFlag: Address Family Flag,False value refers to an adjacency with outgoing IPv4 encapsulationTrue value refers to an adjacency with outgoing IPv6 encapsulation
	FFlag *Multivalue `json:"fFlag,omitempty"`
	// Funcflags: This is the function flags
	Funcflags *Multivalue `json:"funcflags,omitempty"`
	// Function: This specifies endpoint function codes
	Function *Multivalue `json:"function,omitempty"`
	// IncludeMaxSlMsd: If set, then Include Maximum Segment Left MSD in SRv6 capability
	IncludeMaxSlMsd *Multivalue `json:"includeMaxSlMsd,omitempty"`
	// IncludeMaximumEndDMsd: If set, then include Maximum End D MSD in SRv6 capability
	IncludeMaximumEndDMsd *Multivalue `json:"includeMaximumEndDMsd,omitempty"`
	// IncludeMaximumEndPopMsd: If set, then include Max-End-Pop-MSD n SRv6 capability
	IncludeMaximumEndPopMsd *Multivalue `json:"includeMaximumEndPopMsd,omitempty"`
	// IncludeMaximumTEncapMsd: If set, then include Maximum T.Encap MSD in SRv6 capability
	IncludeMaximumTEncapMsd *Multivalue `json:"includeMaximumTEncapMsd,omitempty"`
	// IncludeMaximumTInsertMsd: If set, then include Maximum T.Insert MSDin SRv6 capability
	IncludeMaximumTInsertMsd *Multivalue `json:"includeMaximumTInsertMsd,omitempty"`
	// InterfaceMetric: Interface Metric
	InterfaceMetric *Multivalue `json:"interfaceMetric,omitempty"`
	// Ipv6MTMetric: IPv6 MT Metric
	Ipv6MTMetric *Multivalue `json:"ipv6MTMetric,omitempty"`
	// Ipv6SidValue: IPv6 Adj SID
	Ipv6SidValue *Multivalue `json:"ipv6SidValue,omitempty"`
	// LFlag: Local Flag, if set, then the value/index carried by the Adj-SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// Level1DeadInterval: Level 1 Dead Interval (sec)
	Level1DeadInterval *Multivalue `json:"level1DeadInterval,omitempty"`
	// Level1HelloInterval: Level 1 Hello Interval (sec)
	Level1HelloInterval *Multivalue `json:"level1HelloInterval,omitempty"`
	// Level1Priority: Level 1 Priority
	Level1Priority *Multivalue `json:"level1Priority,omitempty"`
	// Level2DeadInterval: Level 2 Dead Interval (sec)
	Level2DeadInterval *Multivalue `json:"level2DeadInterval,omitempty"`
	// Level2HelloInterval: Level 2 Hello Interval (sec)
	Level2HelloInterval *Multivalue `json:"level2HelloInterval,omitempty"`
	// Level2Priority: Level 2 Priority
	Level2Priority *Multivalue `json:"level2Priority,omitempty"`
	// LevelType: Level Type
	LevelType *Multivalue `json:"levelType,omitempty"`
	// MaxEndDMsd: This field specifies the maximum number of SIDs in an SRH when applying End.DX6 and End.DT6 functions. If this field is zero, then the router cannot apply End.DX6 or End.DT6 functions. If the extension header is right underneath the outer IPv6, header is an SRH.
	MaxEndDMsd *Multivalue `json:"maxEndDMsd,omitempty"`
	// MaxEndPopMsd: This field specifies the maximum number of SIDs in the top MSD in an MSD stack that the router can apply PSP or USP flavors to. If the value of this field is zero, then the router cannot apply PSP or USP flavors.
	MaxEndPopMsd *Multivalue `json:"maxEndPopMsd,omitempty"`
	// MaxSlMsd: This field specifies the maximum value of the Segments Left (SL) MSD field in the SRH of a received packet before applying the function associated with a SID.
	MaxSlMsd *Multivalue `json:"maxSlMsd,omitempty"`
	// MaxTEncap: This field specifies the maximum number of SIDs that can be included as part of the T.Encap behavior. If this field is zero and the E flag is set, then the router can apply T.Encap by encapsulating the incoming packet in another IPv6 header without SRH, it is the same way IPinIP encapsulation is performed. If the E flag is clear, then this field SHOULD be transmitted as zero and MUST be ignored on receipt.
	MaxTEncap *Multivalue `json:"maxTEncap,omitempty"`
	// MaxTInsertMsd: This field specifies the maximum number of SIDs that can be inserted as part of the T.insert behavior. If the value of this field is zero, then the router cannot apply any variation of the T.insert behavior.
	MaxTInsertMsd *Multivalue `json:"maxTInsertMsd,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkType: Network Type
	NetworkType *Multivalue `json:"networkType,omitempty"`
	// NoOfAppSpecSrlg: This field value shows how many SRLG Value columns would be there in the GUI.

	NoOfAppSpecSrlg *float32 `json:"noOfAppSpecSrlg,omitempty"`
	// NoOfTeProfile: Number of TE Profile

	NoOfTeProfile *float32 `json:"noOfTeProfile,omitempty"`
	// OverrideFFlag: When false, then F flag value in the packet will be set TRUE/ FALSE depending on whether IPv6/ IPv4 stack is present beside ISIS respectively. When true, then F flag value will be the one as configured.
	OverrideFFlag *Multivalue `json:"overrideFFlag,omitempty"`
	// PFlag: Persistent flag: when set, this indicates that the Adj-SID value remains persistent across router restart and/or interface flap.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// Reserved0x40: This is a Protection Scheme with value 0x40.
	Reserved0x40 *Multivalue `json:"reserved0x40,omitempty"`
	// Reserved0x80: This is a Protection Scheme with value 0x80.
	Reserved0x80 *Multivalue `json:"reserved0x80,omitempty"`
	// SFlag: Set flag: when set, this indicates that the Adj-SID refers to a set of adjacencies
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// Shared: This is a Protection Scheme with value 0x04. It means that there are one or more disjoint links of type Extra Traffic that are protecting this link. These Extra Traffic links are shared between one or more links of type Shared.
	Shared *Multivalue `json:"shared,omitempty"`
	// SrlgCount: This field value shows how many SRLG Value columns would be there in the GUI.

	SrlgCount *float32 `json:"srlgCount,omitempty"`
	// Srv6SidFlags: This specifies the value of the SRv6 SID Flags
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SuppressHello: Hello suppression
	SuppressHello *Multivalue `json:"suppressHello,omitempty"`
	// Unprotected: This is a Protection Scheme with value 0x02. It means that there is no other link protecting this link. The LSPs on a link of this type will be lost if the link fails.
	Unprotected *Multivalue `json:"unprotected,omitempty"`
	// VFlag: Value Flag, if set, the Adjacency SID carries a value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// Weight: Weight
	Weight *Multivalue `json:"weight,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	IsisAppSpecSrlgList *TopologyIsisAppSpecSrlgList `json:"isisAppSpecSrlgList,omitempty"`

	IsisSRv6AdjSIDList *TopologyIsisSRv6AdjSidList `json:"isisSRv6AdjSIDList,omitempty"`

	IsisTrafficEngineering *TopologyIsisTrafficEngineering `json:"isisTrafficEngineering,omitempty"`

	IsisTrafficEngineeringProfileList *TopologyIsisTrafficEngineeringProfileList `json:"isisTrafficEngineeringProfileList,omitempty"`
	LearnedInfo                       []*TopologyLearnedInfo                     `json:"learnedInfo"`
	SrlgValueList                     []*TopologySrlgValueList                   `json:"srlgValueList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adjSID",
		isMultivalue: true,
	})
	n.AdvertiseLinkMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseLinkMsd",
		isMultivalue: true,
	})
	n.AuthType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authType",
		isMultivalue: true,
	})
	n.AutoAdjustArea.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustArea",
		isMultivalue: true,
	})
	n.AutoAdjustMTU.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustMTU",
		isMultivalue: true,
	})
	n.AutoAdjustSupportedProtocols.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustSupportedProtocols",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.CircuitTranmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "circuitTranmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.ConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredHoldTime",
		isMultivalue: true,
	})
	n.DedicatedOnePlusOne.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicatedOnePlusOne",
		isMultivalue: true,
	})
	n.DedicatedOneToOne.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicatedOneToOne",
		isMultivalue: true,
	})
	n.Enable3WayHandshake.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable3WayHandshake",
		isMultivalue: true,
	})
	n.EnableAdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdjSID",
		isMultivalue: true,
	})
	n.EnableAppSpecSrlg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAppSpecSrlg",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableConfiguredHoldTime",
		isMultivalue: true,
	})
	n.EnableIPv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIPv6SID",
		isMultivalue: true,
	})
	n.EnableLinkProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLinkProtection",
		isMultivalue: true,
	})
	n.EnableMT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMT",
		isMultivalue: true,
	})
	n.EnableSRLG.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSRLG",
		isMultivalue: true,
	})
	n.Enhanced.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enhanced",
		isMultivalue: true,
	})
	n.ExtendedLocalCircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extendedLocalCircuitId",
		isMultivalue: true,
	})
	n.ExtraTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extraTraffic",
		isMultivalue: true,
	})
	n.FFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fFlag",
		isMultivalue: true,
	})
	n.Funcflags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "funcflags",
		isMultivalue: true,
	})
	n.Function.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "function",
		isMultivalue: true,
	})
	n.IncludeMaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaxSlMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndDMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndPopMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTEncapMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTEncapMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTInsertMsd",
		isMultivalue: true,
	})
	n.InterfaceMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceMetric",
		isMultivalue: true,
	})
	n.Ipv6MTMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6MTMetric",
		isMultivalue: true,
	})
	n.Ipv6SidValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6SidValue",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.Level1DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1DeadInterval",
		isMultivalue: true,
	})
	n.Level1HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1HelloInterval",
		isMultivalue: true,
	})
	n.Level1Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1Priority",
		isMultivalue: true,
	})
	n.Level2DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level2DeadInterval",
		isMultivalue: true,
	})
	n.Level2HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level2HelloInterval",
		isMultivalue: true,
	})
	n.Level2Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level2Priority",
		isMultivalue: true,
	})
	n.LevelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "levelType",
		isMultivalue: true,
	})
	n.MaxEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndDMsd",
		isMultivalue: true,
	})
	n.MaxEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndPopMsd",
		isMultivalue: true,
	})
	n.MaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSlMsd",
		isMultivalue: true,
	})
	n.MaxTEncap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTEncap",
		isMultivalue: true,
	})
	n.MaxTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTInsertMsd",
		isMultivalue: true,
	})
	n.NetworkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkType",
		isMultivalue: true,
	})
	n.OverrideFFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideFFlag",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.Reserved0x40.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved0x40",
		isMultivalue: true,
	})
	n.Reserved0x80.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved0x80",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.Shared.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shared",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.SuppressHello.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "suppressHello",
		isMultivalue: true,
	})
	n.Unprotected.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unprotected",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.IsisAppSpecSrlgList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisAppSpecSrlgList",
	})
	n.IsisSRv6AdjSIDList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisSRv6AdjSIDList",
	})
	n.IsisTrafficEngineering.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisTrafficEngineering",
	})
	n.IsisTrafficEngineeringProfileList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisTrafficEngineeringProfileList",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SrlgValueList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "srlgValueList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisL3PrefixesSrSid: ISIS L3 Prefix SID's
type TopologyIsisL3PrefixesSrSid struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: Explicit NULL flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// EnableFapm: Advertise FAPM
	EnableFapm *Multivalue `json:"enableFapm,omitempty"`
	// FapmMetric: FAPM Metric
	FapmMetric *Multivalue `json:"fapmMetric,omitempty"`
	// LFlag: Local Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// NFlag: Nodal prefix flag
	NFlag *Multivalue `json:"nFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlag: No-PHP flag. If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// RFlag: Redistribution flag
	RFlag *Multivalue `json:"rFlag,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: Value Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3PrefixesSrSid) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3PrefixesSrSid) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3PrefixesSrSid) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3PrefixesSrSid) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.EnableFapm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFapm",
		isMultivalue: true,
	})
	n.FapmMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fapmMetric",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nFlag",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rFlag",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyIsisL3PseudoIfaceAttPoint1Config: ISIS-L3 Pseudo Interafce Attribute Configuration
type TopologyIsisL3PseudoIfaceAttPoint1Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3PseudoIfaceAttPoint1Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3PseudoIfaceAttPoint1Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3PseudoIfaceAttPoint1Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3PseudoIfaceAttPoint1Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisL3PseudoIfaceAttPoint2Config: ISIS-L3 Pseudo Interafce Attribute Configuration
type TopologyIsisL3PseudoIfaceAttPoint2Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3PseudoIfaceAttPoint2Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3PseudoIfaceAttPoint2Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3PseudoIfaceAttPoint2Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3PseudoIfaceAttPoint2Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisL3PseudoInterface: ISIS-L3 Pseudo Interafce Configuration
type TopologyIsisL3PseudoInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdjSID: AdjSID
	AdjSID *Multivalue `json:"adjSID,omitempty"`
	// AdjSidCount: Adj SID Count

	AdjSidCount *float32 `json:"adjSidCount,omitempty"`
	// AdministratorGroup: Administrator Group
	AdministratorGroup *Multivalue `json:"administratorGroup,omitempty"`
	// AdvertiseLinkMsd: Advertise Link MSD
	AdvertiseLinkMsd *Multivalue `json:"advertiseLinkMsd,omitempty"`
	// BFlag: Backup Flag, if set, the Adj-SID is eligible for protection
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// BandwidthPriority0Bps: Bandwidth for Priority 0 (B/sec)
	BandwidthPriority0Bps *Multivalue `json:"bandwidthPriority0_Bps,omitempty"`
	// BandwidthPriority1Bps: Bandwidth for Priority 1 (B/sec)
	BandwidthPriority1Bps *Multivalue `json:"bandwidthPriority1_Bps,omitempty"`
	// BandwidthPriority2Bps: Bandwidth for Priority 2 (B/sec)
	BandwidthPriority2Bps *Multivalue `json:"bandwidthPriority2_Bps,omitempty"`
	// BandwidthPriority3Bps: Bandwidth for Priority 3 (B/sec)
	BandwidthPriority3Bps *Multivalue `json:"bandwidthPriority3_Bps,omitempty"`
	// BandwidthPriority4Bps: Bandwidth for Priority 4 (B/sec)
	BandwidthPriority4Bps *Multivalue `json:"bandwidthPriority4_Bps,omitempty"`
	// BandwidthPriority5Bps: Bandwidth for Priority 5 (B/sec)
	BandwidthPriority5Bps *Multivalue `json:"bandwidthPriority5_Bps,omitempty"`
	// BandwidthPriority6Bps: Bandwidth for Priority 6 (B/sec)
	BandwidthPriority6Bps *Multivalue `json:"bandwidthPriority6_Bps,omitempty"`
	// BandwidthPriority7Bps: Bandwidth for Priority 7 (B/sec)
	BandwidthPriority7Bps *Multivalue `json:"bandwidthPriority7_Bps,omitempty"`
	// DedicatedOnePlusOne: This is a Protection Scheme with value 0x10. It means that a dedicated disjoint link is protecting this link. However, the protecting link is not advertised in the link state database and is therefore not available for the routing of LSPs.
	DedicatedOnePlusOne *Multivalue `json:"dedicatedOnePlusOne,omitempty"`
	// DedicatedOneToOne: This is a Protection Scheme with value 0x08. It means that there is one dedicated disjoint link of type Extra Traffic that is protecting this link.
	DedicatedOneToOne *Multivalue `json:"dedicatedOneToOne,omitempty"`
	// EnableAdjSID: Enable Adj SID
	EnableAdjSID *Multivalue `json:"enableAdjSID,omitempty"`
	// EnableAppSpecSrlg: This enables Application Specific SRLG on the ISIS link between two mentioned interfaces.
	EnableAppSpecSrlg *Multivalue `json:"enableAppSpecSrlg,omitempty"`
	// EnableIPv6SID: Enable IPv6 SID
	EnableIPv6SID *Multivalue `json:"enableIPv6SID,omitempty"`
	// EnableLinkProtection: This enables the link protection on the ISIS link between two mentioned interfaces.
	EnableLinkProtection *Multivalue `json:"enableLinkProtection,omitempty"`
	// EnableMT: Enable MT
	EnableMT *Multivalue `json:"enableMT,omitempty"`
	// EnableSRLG: This enables the SRLG on the ISIS link between two mentioned interfaces.
	EnableSRLG *Multivalue `json:"enableSRLG,omitempty"`
	// Enhanced: This is a Protection Scheme with value 0x20. It means that a protection scheme that is more reliable than Dedicated 1+1, e.g., 4 fiber BLSR/MS-SPRING, is being used to protect this link.
	Enhanced *Multivalue `json:"enhanced,omitempty"`
	// ExtraTraffic: This is a Protection Scheme with value 0x01. It means that the link is protecting another link or links. The LSPs on a link of this type will be lost if any of the links it is protecting fail.
	ExtraTraffic *Multivalue `json:"extraTraffic,omitempty"`
	// FFlag: Address Family Flag,False value refers to an adjacency with outgoing IPv4 encapsulationTrue value refers to an adjacency with outgoing IPv6 encapsulation
	FFlag *Multivalue `json:"fFlag,omitempty"`
	// Funcflags: This is the function flags
	Funcflags *Multivalue `json:"funcflags,omitempty"`
	// Function: This specifies endpoint function codes
	Function *Multivalue `json:"function,omitempty"`
	// IncludeMaxSlMsd: If set, then Include Maximum Segment Left MSD in SRv6 capability
	IncludeMaxSlMsd *Multivalue `json:"includeMaxSlMsd,omitempty"`
	// IncludeMaximumEndDMsd: If set, then include Maximum End D MSD in SRv6 capability
	IncludeMaximumEndDMsd *Multivalue `json:"includeMaximumEndDMsd,omitempty"`
	// IncludeMaximumEndPopMsd: If set, then include Max-End-Pop-MSD n SRv6 capability
	IncludeMaximumEndPopMsd *Multivalue `json:"includeMaximumEndPopMsd,omitempty"`
	// IncludeMaximumTEncapMsd: If set, then include Maximum T.Encap MSD in SRv6 capability
	IncludeMaximumTEncapMsd *Multivalue `json:"includeMaximumTEncapMsd,omitempty"`
	// IncludeMaximumTInsertMsd: If set, then include Maximum T.Insert MSDin SRv6 capability
	IncludeMaximumTInsertMsd *Multivalue `json:"includeMaximumTInsertMsd,omitempty"`
	// Ipv6SidValue: IPv6 Adj SID
	Ipv6SidValue *Multivalue `json:"ipv6SidValue,omitempty"`
	// LFlag: Local Flag, if set, then the value/index carried by the Adj-SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LinkType: Link Type
	LinkType *Multivalue `json:"linkType,omitempty"`
	// MaxBandwidthBps: Maximum Bandwidth (B/sec)
	MaxBandwidthBps *Multivalue `json:"maxBandwidth_Bps,omitempty"`
	// MaxEndDMsd: This field specifies the maximum number of SIDs in an SRH when applying End.DX6 and End.DT6 functions. If this field is zero, then the router cannot apply End.DX6 or End.DT6 functions. If the extension header is right underneath the outer IPv6, header is an SRH.
	MaxEndDMsd *Multivalue `json:"maxEndDMsd,omitempty"`
	// MaxEndPopMsd: This field specifies the maximum number of SIDs in the top MSD in an MSD stack that the router can apply PSP or USP flavors to. If the value of this field is zero, then the router cannot apply PSP or USP flavors.
	MaxEndPopMsd *Multivalue `json:"maxEndPopMsd,omitempty"`
	// MaxReservableBandwidthBps: Maximum Reservable Bandwidth (B/sec)
	MaxReservableBandwidthBps *Multivalue `json:"maxReservableBandwidth_Bps,omitempty"`
	// MaxSlMsd: This field specifies the maximum value of the Segments Left (SL) MSD field in the SRH of a received packet before applying the function associated with a SID.
	MaxSlMsd *Multivalue `json:"maxSlMsd,omitempty"`
	// MaxTEncap: This field specifies the maximum number of SIDs that can be included as part of the T.Encap behavior. If this field is zero and the E flag is set, then the router can apply T.Encap by encapsulating the incoming packet in another IPv6 header without SRH, it is the same way IPinIP encapsulation is performed. If the E flag is clear, then this field SHOULD be transmitted as zero and MUST be ignored on receipt
	MaxTEncap *Multivalue `json:"maxTEncap,omitempty"`
	// MaxTInsertMsd: This field specifies the maximum number of SIDs that can be inserted as part of the T.insert behavior. If the value of this field is zero, then the router cannot apply any variation of the T.insert behavior.
	MaxTInsertMsd *Multivalue `json:"maxTInsertMsd,omitempty"`
	// MetricLevel: Metric Level
	MetricLevel *Multivalue `json:"metricLevel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfAppSpecSrlg: This field value shows how many SRLG Value columns would be there in the GUI.

	NoOfAppSpecSrlg *float32 `json:"noOfAppSpecSrlg,omitempty"`
	// NoOfTeProfile: Number of TE Profile

	NoOfTeProfile *float32 `json:"noOfTeProfile,omitempty"`
	// OverrideFFlag: When false, then F flag value in the packet will be set TRUE/ FALSE depending on whether IPv6/ IPv4 stack is present beside ISIS respectively. When true, then F flag value will be the one as configured.
	OverrideFFlag *Multivalue `json:"overrideFFlag,omitempty"`
	// PFlag: Persistent flag: when set, this indicates that the Adj-SID value remains persistent across router restart and/or interface flap.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// Reserved0x40: This is a Protection Scheme with value 0x40.
	Reserved0x40 *Multivalue `json:"reserved0x40,omitempty"`
	// Reserved0x80: This is a Protection Scheme with value 0x80.
	Reserved0x80 *Multivalue `json:"reserved0x80,omitempty"`
	// SFlag: Set flag: when set, this indicates that the Adj-SID refers to a set of adjacencies
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// Shared: This is a Protection Scheme with value 0x04. It means that there are one or more disjoint links of type Extra Traffic that are protecting this link. These Extra Traffic links are shared between one or more links of type Shared.
	Shared *Multivalue `json:"shared,omitempty"`
	// SrlgCount: This field value shows how many SRLG Value columns would be there in the GUI.

	SrlgCount *float32 `json:"srlgCount,omitempty"`
	// Srv6SidFlags: This specifies the value of the SRv6 SID Flags
	Srv6SidFlags *Multivalue `json:"srv6SidFlags,omitempty"`
	// Unprotected: This is a Protection Scheme with value 0x02. It means that there is no other link protecting this link. The LSPs on a link of this type will be lost if the link fails.
	Unprotected *Multivalue `json:"unprotected,omitempty"`
	// VFlag: Value Flag, if set, the Adjacency SID carries a value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// Weight: Weight
	Weight                            *Multivalue                                  `json:"weight,omitempty"`
	IsisPseudoMultiTopologyValuesList []*TopologyIsisPseudoMultiTopologyValuesList `json:"IsisPseudoMultiTopologyValuesList"`
	IsisDcePseudoIfaceAttPoint1Config []*TopologyIsisDcePseudoIfaceAttPoint1Config `json:"isisDcePseudoIfaceAttPoint1Config"`
	IsisDcePseudoIfaceAttPoint2Config []*TopologyIsisDcePseudoIfaceAttPoint2Config `json:"isisDcePseudoIfaceAttPoint2Config"`
	IsisL3PseudoIfaceAttPoint1Config  []*TopologyIsisL3PseudoIfaceAttPoint1Config  `json:"isisL3PseudoIfaceAttPoint1Config"`
	IsisL3PseudoIfaceAttPoint2Config  []*TopologyIsisL3PseudoIfaceAttPoint2Config  `json:"isisL3PseudoIfaceAttPoint2Config"`

	IsisPseudoAppSpecSrlgList *TopologyIsisPseudoAppSpecSrlgList `json:"isisPseudoAppSpecSrlgList,omitempty"`

	IsisPseudoSRv6AdjSIDList *TopologyIsisPseudoSRv6AdjSidList `json:"isisPseudoSRv6AdjSIDList,omitempty"`

	IsisPseudoTraffEngProfile           *TopologyIsisPseudoTraffEngProfile             `json:"isisPseudoTraffEngProfile,omitempty"`
	IsisSpbPseudoIfaceAttPoint1Config   []*TopologyIsisSpbPseudoIfaceAttPoint1Config   `json:"isisSpbPseudoIfaceAttPoint1Config"`
	IsisSpbPseudoIfaceAttPoint2Config   []*TopologyIsisSpbPseudoIfaceAttPoint2Config   `json:"isisSpbPseudoIfaceAttPoint2Config"`
	IsisTrillPseudoIfaceAttPoint1Config []*TopologyIsisTrillPseudoIfaceAttPoint1Config `json:"isisTrillPseudoIfaceAttPoint1Config"`
	IsisTrillPseudoIfaceAttPoint2Config []*TopologyIsisTrillPseudoIfaceAttPoint2Config `json:"isisTrillPseudoIfaceAttPoint2Config"`
	SrlgValueList                       []*TopologySrlgValueList                       `json:"srlgValueList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3PseudoInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3PseudoInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3PseudoInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3PseudoInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adjSID",
		isMultivalue: true,
	})
	n.AdministratorGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administratorGroup",
		isMultivalue: true,
	})
	n.AdvertiseLinkMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseLinkMsd",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.BandwidthPriority0Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority0_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority1Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority1_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority2Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority2_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority3Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority3_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority4Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority4_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority5Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority5_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority6Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority6_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority7Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority7_Bps",
		isMultivalue: true,
	})
	n.DedicatedOnePlusOne.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicatedOnePlusOne",
		isMultivalue: true,
	})
	n.DedicatedOneToOne.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicatedOneToOne",
		isMultivalue: true,
	})
	n.EnableAdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdjSID",
		isMultivalue: true,
	})
	n.EnableAppSpecSrlg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAppSpecSrlg",
		isMultivalue: true,
	})
	n.EnableIPv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIPv6SID",
		isMultivalue: true,
	})
	n.EnableLinkProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLinkProtection",
		isMultivalue: true,
	})
	n.EnableMT.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMT",
		isMultivalue: true,
	})
	n.EnableSRLG.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSRLG",
		isMultivalue: true,
	})
	n.Enhanced.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enhanced",
		isMultivalue: true,
	})
	n.ExtraTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extraTraffic",
		isMultivalue: true,
	})
	n.FFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fFlag",
		isMultivalue: true,
	})
	n.Funcflags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "funcflags",
		isMultivalue: true,
	})
	n.Function.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "function",
		isMultivalue: true,
	})
	n.IncludeMaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaxSlMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndDMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndPopMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTEncapMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTEncapMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTInsertMsd",
		isMultivalue: true,
	})
	n.Ipv6SidValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6SidValue",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LinkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkType",
		isMultivalue: true,
	})
	n.MaxBandwidthBps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxBandwidth_Bps",
		isMultivalue: true,
	})
	n.MaxEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndDMsd",
		isMultivalue: true,
	})
	n.MaxEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndPopMsd",
		isMultivalue: true,
	})
	n.MaxReservableBandwidthBps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxReservableBandwidth_Bps",
		isMultivalue: true,
	})
	n.MaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSlMsd",
		isMultivalue: true,
	})
	n.MaxTEncap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTEncap",
		isMultivalue: true,
	})
	n.MaxTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTInsertMsd",
		isMultivalue: true,
	})
	n.MetricLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricLevel",
		isMultivalue: true,
	})
	n.OverrideFFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideFFlag",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.Reserved0x40.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved0x40",
		isMultivalue: true,
	})
	n.Reserved0x80.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved0x80",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.Shared.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shared",
		isMultivalue: true,
	})
	n.Srv6SidFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SidFlags",
		isMultivalue: true,
	})
	n.Unprotected.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unprotected",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	for i, o := range n.IsisPseudoMultiTopologyValuesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "IsisPseudoMultiTopologyValuesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDcePseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDcePseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDcePseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDcePseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3PseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3PseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3PseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3PseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.IsisPseudoAppSpecSrlgList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisPseudoAppSpecSrlgList",
	})
	n.IsisPseudoSRv6AdjSIDList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisPseudoSRv6AdjSIDList",
	})
	n.IsisPseudoTraffEngProfile.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisPseudoTraffEngProfile",
	})
	for i, o := range n.IsisSpbPseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbPseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbPseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbPseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillPseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillPseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillPseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillPseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SrlgValueList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "srlgValueList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisL3PseudoRouter: ISIS-L3 Pseudo Node Configuration
type TopologyIsisL3PseudoRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseNodeMsd: Advertise Node MSD
	AdvertiseNodeMsd *Multivalue `json:"advertiseNodeMsd,omitempty"`
	// AdvertiseSRLB: Enables advertisement of Segment Routing Local Block (SRLB) Sub-Tlv in Router Capability Tlv
	AdvertiseSRLB *Multivalue `json:"advertiseSRLB,omitempty"`
	// AdvertiseSidAsLocator: If enabled, then the configured IPv6 Node SID gets advertised as a reachable IPv6 prefix
	AdvertiseSidAsLocator *Multivalue `json:"advertiseSidAsLocator,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// DBit: When the IS-IS Router CAPABILITY TLV is leaked from level-2 to level-1, the D bit MUST be set, else it should be clear
	DBit *Multivalue `json:"dBit,omitempty"`
	// DBitForSRv6Cap: When the IS-IS Router CAPABILITY TLV is leaked from level-2 to level-1, the D bit MUST be set, else it should be clear
	DBitForSRv6Cap *Multivalue `json:"dBitForSRv6Cap,omitempty"`
	// DBitInsideSRv6SidTLV: When the SID is leaked from level-2 to level-1, the D bit MUST be set. Otherwise, this bit MUST be clear.
	DBitInsideSRv6SidTLV *Multivalue `json:"dBitInsideSRv6SidTLV,omitempty"`
	// EFlag: Explicit NULL flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// EFlagOfSRv6CapTlv: If set, then router is able to apply T.Encap operation
	EFlagOfSRv6CapTlv *Multivalue `json:"eFlagOfSRv6CapTlv,omitempty"`
	// Enable: Enable IPv4 TE
	Enable *Multivalue `json:"enable,omitempty"`
	// EnableIpV6TE: If it is enabled, the ISIS Traffic Engineering Profiles will be available. If not enabled, then no TE fields will be sent out in TLV 222.
	EnableIpV6TE *Multivalue `json:"enableIpV6TE,omitempty"`
	// EnableMTIPv6: Enable MT for IPv6
	EnableMTIPv6 *Multivalue `json:"enableMTIPv6,omitempty"`
	// EnableSR: This enables SR MPLS on all the simulated ISIS router(s)

	EnableSR *bool `json:"enableSR,omitempty"`
	// EnableWMforTEinNetworkGroup: Hidden field is to disable wide Metric, when user disable TE Router in Network Group
	EnableWMforTEinNetworkGroup *Multivalue `json:"enableWMforTEinNetworkGroup,omitempty"`
	// EnableWideMetric: Enable Wide Metric
	EnableWideMetric *Multivalue `json:"enableWideMetric,omitempty"`
	// FlexAlgoCount: If the count is greater than 0, then the Flex Algo tab will appear. Default is 0. Range is 0-128.

	FlexAlgoCount *float32 `json:"flexAlgoCount,omitempty"`
	// Funcflags: This is the function flags
	Funcflags *Multivalue `json:"funcflags,omitempty"`
	// Function: This specifies endpoint function codes
	Function *Multivalue `json:"function,omitempty"`
	// IncludeMaxSlMsd: If set, then Include Maximum Segment Left MSD in SRv6 capability
	IncludeMaxSlMsd *Multivalue `json:"includeMaxSlMsd,omitempty"`
	// IncludeMaximumEndDMsd: If set, then include Maximum End D MSD in SRv6 capability
	IncludeMaximumEndDMsd *Multivalue `json:"includeMaximumEndDMsd,omitempty"`
	// IncludeMaximumEndDSrhTLV: If set, then include Maximum End D SRH TLV in SRv6 capability
	IncludeMaximumEndDSrhTLV *Multivalue `json:"includeMaximumEndDSrhTLV,omitempty"`
	// IncludeMaximumEndPopMsd: If set, then include Max-End-Pop-MSD in SRv6 capability
	IncludeMaximumEndPopMsd *Multivalue `json:"includeMaximumEndPopMsd,omitempty"`
	// IncludeMaximumEndPopSrhTLV: If set, then include Max-End-Pop-SRH TLV in SRv6 capability
	IncludeMaximumEndPopSrhTLV *Multivalue `json:"includeMaximumEndPopSrhTLV,omitempty"`
	// IncludeMaximumSLTLV: If set, then include Maximum SL TLV in SRv6 capability
	IncludeMaximumSLTLV *Multivalue `json:"includeMaximumSLTLV,omitempty"`
	// IncludeMaximumTEncapMsd: If set, then include Maximum T.Encap MSD in SRv6 capability
	IncludeMaximumTEncapMsd *Multivalue `json:"includeMaximumTEncapMsd,omitempty"`
	// IncludeMaximumTEncapSrhTLV: If set, then include Maximum T.Encap SRH TLV in SRv6 capability
	IncludeMaximumTEncapSrhTLV *Multivalue `json:"includeMaximumTEncapSrhTLV,omitempty"`
	// IncludeMaximumTInsertMsd: If set, then include Maximum T.Insert MSD in SRv6 capability
	IncludeMaximumTInsertMsd *Multivalue `json:"includeMaximumTInsertMsd,omitempty"`
	// IncludeMaximumTInsertSrhTLV: If set, then include Maximum T.Insert SRH TLV in SRv6 capability
	IncludeMaximumTInsertSrhTLV *Multivalue `json:"includeMaximumTInsertSrhTLV,omitempty"`
	// IpV6TERouterId: It is a unique ID including emulated and simulated routers. It should match IPv6 Node Prefix in SRv6 by default. It will send out the TLV 140 in ISIS.
	IpV6TERouterId *Multivalue `json:"ipV6TERouterId,omitempty"`
	// Ipv4Flag: MPLS IPv4 Flag
	Ipv4Flag *Multivalue `json:"ipv4Flag,omitempty"`
	// Ipv6Flag: MPLS IPv6 Flag
	Ipv6Flag *Multivalue `json:"ipv6Flag,omitempty"`
	// Ipv6MTMetric: IPv6 MT Metric
	Ipv6MTMetric *Multivalue `json:"ipv6MTMetric,omitempty"`
	// Ipv6NodePrefix: IPv6 Node Prefix
	Ipv6NodePrefix *Multivalue `json:"ipv6NodePrefix,omitempty"`
	// Ipv6Srh: Router will advertise and process IPv6 SR related TLVs
	Ipv6Srh *Multivalue `json:"ipv6Srh,omitempty"`
	// LFlag: Local Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LocatorCount: Locator Count

	LocatorCount *float32 `json:"locatorCount,omitempty"`
	// LocatorPrefixLength: Locator Prefix Length
	LocatorPrefixLength *Multivalue `json:"locatorPrefixLength,omitempty"`
	// Mask: Mask
	Mask *Multivalue `json:"mask,omitempty"`
	// MaxEndD: This field specifies the maximum number of SIDs in an SRH when applying End.DX6 and End.DT6 functions. If this field is zero, then the router cannot apply End.DX6 or End.DT6 functions if the extension header right underneath the outer IPv6 header is an SRH.
	MaxEndD *Multivalue `json:"maxEndD,omitempty"`
	// MaxEndDMsd: This field specifies the maximum number of SIDs in an SRH when applying End.DX6 and End.DT6 functions. If this field is zero, then the router cannot apply End.DX6 or End.DT6 functions. If the extension header is right underneath the outer IPv6, header is an SRH.
	MaxEndDMsd *Multivalue `json:"maxEndDMsd,omitempty"`
	// MaxEndPopMsd: This field specifies the maximum number of SIDs in the top MSD in an MSD stack that the router can apply PSP or USP flavors to. If the value of this field is zero, then the router cannot apply PSP or USP flavors.
	MaxEndPopMsd *Multivalue `json:"maxEndPopMsd,omitempty"`
	// MaxEndPopSrh: This field specifies the maximum number of SIDs in the top SRH in an SRH stack that the router can apply PSP or USP flavors to. If the value of this field is zero, then the router cannot apply PSP or USP flavors.
	MaxEndPopSrh *Multivalue `json:"maxEndPopSrh,omitempty"`
	// MaxSL: This field specifies the maximum value of the Segments Left (SL) field in the SRH of a received packet before applying the function associated with a SID.
	MaxSL *Multivalue `json:"maxSL,omitempty"`
	// MaxSlMsd: This field specifies the maximum value of the Segments Left (SL) MSD field in the SRH of a received packet before applying the function associated with a SID.
	MaxSlMsd *Multivalue `json:"maxSlMsd,omitempty"`
	// MaxTEncap: This field specifies the maximum number of SIDs that can be included as part of the T.Encap behavior. If this field is zero and the E flag is set, then the router can apply T.Encap by encapsulating the incoming packet in another IPv6 header without SRH, it is the same way IPinIP encapsulation is performed. If the E flag is clear, then this field SHOULD be transmitted as zero and MUST be ignored on receipt
	MaxTEncap *Multivalue `json:"maxTEncap,omitempty"`
	// MaxTEncapMsd: This field specifies the maximum number of SIDs that can be included as part of the T.Encap behavior. If this field is zero and the E flag is set, then the router can apply T.Encap by encapsulating the incoming packet in another IPv6 header without SRH, it is the same way IPinIP encapsulation is performed. If the E flag is clear, then this field SHOULD be transmitted as zero and MUST be ignored on receipt
	MaxTEncapMsd *Multivalue `json:"maxTEncapMsd,omitempty"`
	// MaxTInsert: This field specifies the maximum number of SIDs that can be inserted as part of the T.insert behavior. If the value of this field is zero, then the router cannot apply any variation of the T.insert behavior.
	MaxTInsert *Multivalue `json:"maxTInsert,omitempty"`
	// MaxTInsertMsd: This field specifies the maximum number of SIDs that can be inserted as part of the T.insert behavior. If the value of this field is zero, then the router cannot apply any variation of the T.insert behavior.
	MaxTInsertMsd *Multivalue `json:"maxTInsertMsd,omitempty"`
	// MtCount: MT Count

	MtCount *float32 `json:"mtCount,omitempty"`
	// NFlag: Nodal prefix flag
	NFlag *Multivalue `json:"nFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NodePrefix: Node Prefix
	NodePrefix *Multivalue `json:"nodePrefix,omitempty"`
	// OFlagOfSRv6Cap: If set, it indicates that this packet is an operations and management (OAM) packet.
	OFlagOfSRv6Cap *Multivalue `json:"oFlagOfSRv6Cap,omitempty"`
	// PFlag: No-PHP flag. If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RFlag: Redistribution flag
	RFlag *Multivalue `json:"rFlag,omitempty"`
	// Redistribution: Redistribution
	Redistribution *Multivalue `json:"redistribution,omitempty"`
	// RedistributionForSRv6: Redistribution
	RedistributionForSRv6 *Multivalue `json:"redistributionForSRv6,omitempty"`
	// ReservedInsideFlagsOfSRv6SidTLV: This is the reserved field (part of flags field of SRv6 SID TLV)
	ReservedInsideFlagsOfSRv6SidTLV *Multivalue `json:"reservedInsideFlagsOfSRv6SidTLV,omitempty"`
	// ReservedInsideSRv6CapFlag: This is the reserved field (as part of Flags field of SRv6 Capability TLV)
	ReservedInsideSRv6CapFlag *Multivalue `json:"reservedInsideSRv6CapFlag,omitempty"`
	// RouteMetric: Route Metric
	RouteMetric *Multivalue `json:"routeMetric,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// RtrcapId: Router Capability Id
	RtrcapId *Multivalue `json:"rtrcapId,omitempty"`
	// RtrcapIdForSrv6: Router Capability Id
	RtrcapIdForSrv6 *Multivalue `json:"rtrcapIdForSrv6,omitempty"`
	// SBit: Enabling S bit lets the IS-IS Router CAPABILITY TLV to get flooded across the entire routing domain, otherwise the TLV not be leaked between levels
	SBit *Multivalue `json:"sBit,omitempty"`
	// SBitForSRv6Cap: Enabling S bit lets the IS-IS Router CAPABILITY TLV to get flooded across the entire routing domain, otherwise the TLV not be leaked between levels
	SBitForSRv6Cap *Multivalue `json:"sBitForSRv6Cap,omitempty"`
	// SIDIndexLabel: SID/Index/Label
	SIDIndexLabel *Multivalue `json:"sIDIndexLabel,omitempty"`
	// SRAlgorithmCount: SR Algorithm Count

	SRAlgorithmCount *float32 `json:"sRAlgorithmCount,omitempty"`
	// SRGBRangeCount: SRGB Range Count

	SRGBRangeCount *float32 `json:"sRGBRangeCount,omitempty"`
	// SRv6NodePrefix: This is an IPv6 Node prefix for the SRv6 router
	SRv6NodePrefix *Multivalue `json:"sRv6NodePrefix,omitempty"`
	// SRv6NodePrefixLength: This is the prefix length of the SRv6 node prefix
	SRv6NodePrefixLength *Multivalue `json:"sRv6NodePrefixLength,omitempty"`
	// SrlbDescriptorCount: Count of the SRLB descriptor entries, each being a tuple having format {Start SID/Label, SID Count}

	SrlbDescriptorCount *float32 `json:"srlbDescriptorCount,omitempty"`
	// SrlbFlags: This specifies the value of the SRLB flags field
	SrlbFlags *Multivalue `json:"srlbFlags,omitempty"`
	// TERouterId: TE Router ID
	TERouterId *Multivalue `json:"tERouterId,omitempty"`
	// VFlag: Value Flag
	VFlag                             *Multivalue                                  `json:"vFlag,omitempty"`
	IPv4PseudoNodeRoutes              []*TopologyIPv4PseudoNodeRoutes              `json:"IPv4PseudoNodeRoutes"`
	IPv6PseudoNodeRoutes              []*TopologyIPv6PseudoNodeRoutes              `json:"IPv6PseudoNodeRoutes"`
	IsisPseudoMultiTopologyValuesList []*TopologyIsisPseudoMultiTopologyValuesList `json:"IsisPseudoMultiTopologyValuesList"`

	IsisPseudoFlexAlgorithm *TopologyIsisPseudoFlexAlgorithm `json:"isisPseudoFlexAlgorithm,omitempty"`

	IsisPseudoSRv6LocatorEntryList *TopologyIsisPseudoSRv6LocatorEntryList `json:"isisPseudoSRv6LocatorEntryList,omitempty"`
	IsisSRAlgorithmList            []*TopologyIsisSrAlgorithmList          `json:"isisSRAlgorithmList"`
	IsisSRGBRangeSubObjectsList    []*TopologyIsisSrgbRangeSubObjectsList  `json:"isisSRGBRangeSubObjectsList"`
	IsisSRLBDescriptorList         []*TopologyIsisSrlbDescriptorList       `json:"isisSRLBDescriptorList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3PseudoRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3PseudoRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3PseudoRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3PseudoRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseNodeMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseNodeMsd",
		isMultivalue: true,
	})
	n.AdvertiseSRLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRLB",
		isMultivalue: true,
	})
	n.AdvertiseSidAsLocator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSidAsLocator",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.DBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBit",
		isMultivalue: true,
	})
	n.DBitForSRv6Cap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBitForSRv6Cap",
		isMultivalue: true,
	})
	n.DBitInsideSRv6SidTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBitInsideSRv6SidTLV",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.EFlagOfSRv6CapTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlagOfSRv6CapTlv",
		isMultivalue: true,
	})
	n.Enable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable",
		isMultivalue: true,
	})
	n.EnableIpV6TE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpV6TE",
		isMultivalue: true,
	})
	n.EnableMTIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMTIPv6",
		isMultivalue: true,
	})
	n.EnableWMforTEinNetworkGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWMforTEinNetworkGroup",
		isMultivalue: true,
	})
	n.EnableWideMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWideMetric",
		isMultivalue: true,
	})
	n.Funcflags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "funcflags",
		isMultivalue: true,
	})
	n.Function.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "function",
		isMultivalue: true,
	})
	n.IncludeMaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaxSlMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndDMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndDSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndDSrhTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndPopMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndPopSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndPopSrhTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumSLTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumSLTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumTEncapMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTEncapMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTEncapSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTEncapSrhTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTInsertMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTInsertSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTInsertSrhTLV",
		isMultivalue: true,
	})
	n.IpV6TERouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV6TERouterId",
		isMultivalue: true,
	})
	n.Ipv4Flag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Flag",
		isMultivalue: true,
	})
	n.Ipv6Flag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Flag",
		isMultivalue: true,
	})
	n.Ipv6MTMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6MTMetric",
		isMultivalue: true,
	})
	n.Ipv6NodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NodePrefix",
		isMultivalue: true,
	})
	n.Ipv6Srh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Srh",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LocatorPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorPrefixLength",
		isMultivalue: true,
	})
	n.Mask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mask",
		isMultivalue: true,
	})
	n.MaxEndD.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndD",
		isMultivalue: true,
	})
	n.MaxEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndDMsd",
		isMultivalue: true,
	})
	n.MaxEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndPopMsd",
		isMultivalue: true,
	})
	n.MaxEndPopSrh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndPopSrh",
		isMultivalue: true,
	})
	n.MaxSL.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSL",
		isMultivalue: true,
	})
	n.MaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSlMsd",
		isMultivalue: true,
	})
	n.MaxTEncap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTEncap",
		isMultivalue: true,
	})
	n.MaxTEncapMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTEncapMsd",
		isMultivalue: true,
	})
	n.MaxTInsert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTInsert",
		isMultivalue: true,
	})
	n.MaxTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTInsertMsd",
		isMultivalue: true,
	})
	n.NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nFlag",
		isMultivalue: true,
	})
	n.NodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodePrefix",
		isMultivalue: true,
	})
	n.OFlagOfSRv6Cap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oFlagOfSRv6Cap",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rFlag",
		isMultivalue: true,
	})
	n.Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistribution",
		isMultivalue: true,
	})
	n.RedistributionForSRv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistributionForSRv6",
		isMultivalue: true,
	})
	n.ReservedInsideFlagsOfSRv6SidTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedInsideFlagsOfSRv6SidTLV",
		isMultivalue: true,
	})
	n.ReservedInsideSRv6CapFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedInsideSRv6CapFlag",
		isMultivalue: true,
	})
	n.RouteMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeMetric",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.RtrcapId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rtrcapId",
		isMultivalue: true,
	})
	n.RtrcapIdForSrv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rtrcapIdForSrv6",
		isMultivalue: true,
	})
	n.SBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sBit",
		isMultivalue: true,
	})
	n.SBitForSRv6Cap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sBitForSRv6Cap",
		isMultivalue: true,
	})
	n.SIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDIndexLabel",
		isMultivalue: true,
	})
	n.SRv6NodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sRv6NodePrefix",
		isMultivalue: true,
	})
	n.SRv6NodePrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sRv6NodePrefixLength",
		isMultivalue: true,
	})
	n.SrlbFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlbFlags",
		isMultivalue: true,
	})
	n.TERouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tERouterId",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	for i, o := range n.IPv4PseudoNodeRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "IPv4PseudoNodeRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IPv6PseudoNodeRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "IPv6PseudoNodeRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisPseudoMultiTopologyValuesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "IsisPseudoMultiTopologyValuesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.IsisPseudoFlexAlgorithm.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisPseudoFlexAlgorithm",
	})
	n.IsisPseudoSRv6LocatorEntryList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisPseudoSRv6LocatorEntryList",
	})
	for i, o := range n.IsisSRAlgorithmList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSRAlgorithmList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSRLBDescriptorList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSRLBDescriptorList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisL3RouteProperty: ISIS L3 Route Range Table
type TopologyIsisL3RouteProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BAR: BIER Algorithm
	BAR *Multivalue `json:"BAR,omitempty"`
	// BFRId: BFR Id
	BFRId *Multivalue `json:"BFRId,omitempty"`
	// BFRIdStep: BFR Id Step
	BFRIdStep *Multivalue `json:"BFRIdStep,omitempty"`
	// BIERBitStringLength: Bit String Length
	BIERBitStringLength *Multivalue `json:"BIERBitStringLength,omitempty"`
	// IPA: IGP Algorithm
	IPA *Multivalue `json:"IPA,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvIPv6Prefix: Advertise IPv6 Prefix
	AdvIPv6Prefix *Multivalue `json:"advIPv6Prefix,omitempty"`
	// AdvertiseForAllMts: Advertise for all MTs configured in router
	AdvertiseForAllMts *Multivalue `json:"advertiseForAllMts,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// DBitInsideSRv6SidTLV: When the SID is leaked from level-2 to level-1, the D bit MUST be set. Otherwise, this bit MUST be clear.
	DBitInsideSRv6SidTLV *Multivalue `json:"dBitInsideSRv6SidTLV,omitempty"`
	// EFlag: Explicit NULL flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// Funcflags: This is the function flags
	Funcflags *Multivalue `json:"funcflags,omitempty"`
	// Function: This specifies endpoint function codes
	Function *Multivalue `json:"function,omitempty"`
	// IPv6SourceRouterID: This takes the value of the ipv6 source router id.
	IPv6SourceRouterID *Multivalue `json:"iPv6SourceRouterID,omitempty"`
	// IncludeBIERInfo: Include BIER Info

	IncludeBIERInfo *bool `json:"includeBIERInfo,omitempty"`
	// IncludeBSLObject: If set, MPLS encapsulation sub-sub-Tlv will be advertised under Bier Info Sub-Tlv
	IncludeBSLObject *Multivalue `json:"includeBSLObject,omitempty"`
	// IncludePrefixAttrFlags: Select this check box to include the prefix attribute flags.
	IncludePrefixAttrFlags *Multivalue `json:"includePrefixAttrFlags,omitempty"`
	// IncludeSourceRouterID: This drop box is provided to select ipv4 or ipv6 source id or none of them.
	IncludeSourceRouterID *Multivalue `json:"includeSourceRouterID,omitempty"`
	// Ipv4SourceRouterID: This takes the value of the ipv4 source router id.
	Ipv4SourceRouterID *Multivalue `json:"ipv4SourceRouterID,omitempty"`
	// Ipv6SID: This refers to the IPv6 SID that is being used to reach the advertised IPv6 Prefix
	Ipv6SID *Multivalue `json:"ipv6SID,omitempty"`
	// Ipv6Srh: Advertise IPv6 SID
	Ipv6Srh *Multivalue `json:"ipv6Srh,omitempty"`
	// LFlag: Local Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LabelRangeSize: Maximum Set Identifier
	LabelRangeSize *Multivalue `json:"labelRangeSize,omitempty"`
	// LabelStart: Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// Metric: Route Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// MtId: MT Id for which this route would be advertised
	MtId *Multivalue `json:"mtId,omitempty"`
	// NFlag: Nodal prefix flag
	NFlag *Multivalue `json:"nFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfSidperPrefix: Number of SID's per prefix

	NoOfSidperPrefix *float32 `json:"noOfSidperPrefix,omitempty"`
	// PFlag: No-PHP flag. If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// RFlag: Redistribution flag
	RFlag *Multivalue `json:"rFlag,omitempty"`
	// Redistribution: Redistribution
	Redistribution *Multivalue `json:"redistribution,omitempty"`
	// ReservedInsideFlagsOfSRv6SidTLV: This is the reserved field (part of Flags field of SRv6 SID TLV)
	ReservedInsideFlagsOfSRv6SidTLV *Multivalue `json:"reservedInsideFlagsOfSRv6SidTLV,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// SIDIndexLabel: SID/Index/Label
	SIDIndexLabel *Multivalue `json:"sIDIndexLabel,omitempty"`
	// SubDomainId: Sub Domain Id
	SubDomainId *Multivalue `json:"subDomainId,omitempty"`
	// VFlag: Value Flag
	VFlag               *Multivalue                    `json:"vFlag,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`

	IsisL3PrefixesSrSid *TopologyIsisL3PrefixesSrSid `json:"isisL3PrefixesSrSid,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3RouteProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3RouteProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3RouteProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3RouteProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BAR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BAR",
		isMultivalue: true,
	})
	n.BFRId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRId",
		isMultivalue: true,
	})
	n.BFRIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIdStep",
		isMultivalue: true,
	})
	n.BIERBitStringLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERBitStringLength",
		isMultivalue: true,
	})
	n.IPA.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "IPA",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvIPv6Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advIPv6Prefix",
		isMultivalue: true,
	})
	n.AdvertiseForAllMts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseForAllMts",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.DBitInsideSRv6SidTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBitInsideSRv6SidTLV",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.Funcflags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "funcflags",
		isMultivalue: true,
	})
	n.Function.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "function",
		isMultivalue: true,
	})
	n.IPv6SourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iPv6SourceRouterID",
		isMultivalue: true,
	})
	n.IncludeBSLObject.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeBSLObject",
		isMultivalue: true,
	})
	n.IncludePrefixAttrFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePrefixAttrFlags",
		isMultivalue: true,
	})
	n.IncludeSourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSourceRouterID",
		isMultivalue: true,
	})
	n.Ipv4SourceRouterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4SourceRouterID",
		isMultivalue: true,
	})
	n.Ipv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6SID",
		isMultivalue: true,
	})
	n.Ipv6Srh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Srh",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LabelRangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelRangeSize",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nFlag",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rFlag",
		isMultivalue: true,
	})
	n.Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistribution",
		isMultivalue: true,
	})
	n.ReservedInsideFlagsOfSRv6SidTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedInsideFlagsOfSRv6SidTLV",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.SIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDIndexLabel",
		isMultivalue: true,
	})
	n.SubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subDomainId",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.IsisL3PrefixesSrSid.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisL3PrefixesSrSid",
	})
}

// TopologyIsisL3Router: ISIS-L3 Router configuration
type TopologyIsisL3Router struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BIERNodePrefix: Node Prefix
	BIERNodePrefix *Multivalue `json:"BIERNodePrefix,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseNodeMsd: Advertise Node MSD
	AdvertiseNodeMsd *Multivalue `json:"advertiseNodeMsd,omitempty"`
	// AdvertiseSRLB: Enables advertisement of Segment Routing Local Block (SRLB) Sub-Tlv in Router Capability Tlv
	AdvertiseSRLB *Multivalue `json:"advertiseSRLB,omitempty"`
	// AdvertiseSRMSPreference: Advertise SRMS Preference sub-TLV in Router capability TLV
	AdvertiseSRMSPreference *Multivalue `json:"advertiseSRMSPreference,omitempty"`
	// AdvertiseSidAsLocator: If enabled, then the configured IPv6 Node SID gets advertised as a reachable IPv6 prefix
	AdvertiseSidAsLocator *Multivalue `json:"advertiseSidAsLocator,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// AreaAddresses: Area Addresses
	AreaAddresses *Multivalue `json:"areaAddresses,omitempty"`
	// AreaAuthenticationType: Area Authentication Type
	AreaAuthenticationType *Multivalue `json:"areaAuthenticationType,omitempty"`
	// AreaTransmitPasswordOrMD5Key: Area Transmit Password / MD5-Key
	AreaTransmitPasswordOrMD5Key *Multivalue `json:"areaTransmitPasswordOrMD5Key,omitempty"`
	// Attached: Attached
	Attached *Multivalue `json:"attached,omitempty"`
	// BIERIPv6NodePrefix: IPv6 Node Prefix
	BIERIPv6NodePrefix *Multivalue `json:"bIERIPv6NodePrefix,omitempty"`
	// BierNFlag: Nodal prefix flag
	BierNFlag *Multivalue `json:"bierNFlag,omitempty"`
	// BierRFlag: Redistribution flag
	BierRFlag *Multivalue `json:"bierRFlag,omitempty"`
	// CSNPInterval: CSNP Interval (ms)
	CSNPInterval *Multivalue `json:"cSNPInterval,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// DBit: When the IS-IS Router CAPABILITY TLV is leaked from level-2 to level-1, the D bit MUST be set, else it should be clear
	DBit *Multivalue `json:"dBit,omitempty"`
	// DBitForSRv6Cap: When the IS-IS Router CAPABILITY TLV is leaked from level-2 to level-1, the D bit MUST be set, else it should be clear
	DBitForSRv6Cap *Multivalue `json:"dBitForSRv6Cap,omitempty"`
	// DBitInsideSRv6SidTLV: When the SID is leaked from level-2 to level-1, the D bit MUST be set. Otherwise, this bit MUST be clear.
	DBitInsideSRv6SidTLV *Multivalue `json:"dBitInsideSRv6SidTLV,omitempty"`
	// DiscardLSPs: Discard LSPs
	DiscardLSPs *Multivalue `json:"discardLSPs,omitempty"`
	// Distribution: Distribution
	Distribution *Multivalue `json:"distribution,omitempty"`
	// DomainAuthenticationType: Domain Authentication Type
	DomainAuthenticationType *Multivalue `json:"domainAuthenticationType,omitempty"`
	// DomainTransmitPasswordOrMD5Key: Domain Transmit Password / MD5-Key
	DomainTransmitPasswordOrMD5Key *Multivalue `json:"domainTransmitPasswordOrMD5Key,omitempty"`
	// EFlag: Explicit NULL flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// EFlagOfSRv6CapTlv: If set, then router is able to apply T.Encap operation
	EFlagOfSRv6CapTlv *Multivalue `json:"eFlagOfSRv6CapTlv,omitempty"`
	// EnableBIER: Enable BIER

	EnableBIER *bool `json:"enableBIER,omitempty"`
	// EnableHelloPadding: Enable Hello Padding
	EnableHelloPadding *Multivalue `json:"enableHelloPadding,omitempty"`
	// EnableHitlessRestart: Enable Hitless Restart
	EnableHitlessRestart *Multivalue `json:"enableHitlessRestart,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// EnableITID: Select this checkbox to enable Instance-specific topology identifier. Once it is enabled, it allows to configure ITID value.
	EnableITID *Multivalue `json:"enableITID,omitempty"`
	// EnableIpV6TE: If it is enabled, the ISIS Traffic Engineering Profiles will be available. If not enabled, then no TE fields will be sent out in TLV 222.
	EnableIpV6TE *Multivalue `json:"enableIpV6TE,omitempty"`
	// EnableMI: Select this checkbox to configure the Router as Multi Instance. Once it is enabled, it allows to configure IID and ITID details.
	EnableMI *Multivalue `json:"enableMI,omitempty"`
	// EnableMTIPv6: Enable MT for IPv6
	EnableMTIPv6 *Multivalue `json:"enableMTIPv6,omitempty"`
	// EnableMappingServer: This ensures whether the ISIS router will behave as a Segment Routing Mapping Server (SRMS) or not.
	EnableMappingServer *Multivalue `json:"enableMappingServer,omitempty"`
	// EnableSR: This enables SR MPLS on all the emulated ISIS router(s)

	EnableSR *bool `json:"enableSR,omitempty"`
	// EnableTE: Enable IPv4 TE
	EnableTE *Multivalue `json:"enableTE,omitempty"`
	// EnableWMforTE: Hidden field is to disable wide Metric, when user disable TE Router conditionally
	EnableWMforTE *Multivalue `json:"enableWMforTE,omitempty"`
	// EnableWideMetric: Enable Wide Metric
	EnableWideMetric *Multivalue `json:"enableWideMetric,omitempty"`
	// FlexAlgoCount: If the count is greater than 0, then the Flex Algo tab will appear after ISIS-L3 RTR tab. Default is 0. Range is 0-128.

	FlexAlgoCount *float32 `json:"flexAlgoCount,omitempty"`
	// Funcflags: This is the function flags
	Funcflags *Multivalue `json:"funcflags,omitempty"`
	// Function: This specifies endpoint function codes
	Function *Multivalue `json:"function,omitempty"`
	// HitlessRestartMode: Restart Mode
	HitlessRestartMode *Multivalue `json:"hitlessRestartMode,omitempty"`
	// HitlessRestartTime: Restart Time
	HitlessRestartTime *Multivalue `json:"hitlessRestartTime,omitempty"`
	// HitlessRestartVersion: Restart Version
	HitlessRestartVersion *Multivalue `json:"hitlessRestartVersion,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// IgnoreReceiveMD5: Ignore Receive MD5
	IgnoreReceiveMD5 *Multivalue `json:"ignoreReceiveMD5,omitempty"`
	// Iid: Instance Identifier. Configure any number within the range of 0-65535.
	Iid *Multivalue `json:"iid,omitempty"`
	// IncludeMaxSlMsd: If set, then Include Maximum Segment Left MSD in SRv6 capability
	IncludeMaxSlMsd *Multivalue `json:"includeMaxSlMsd,omitempty"`
	// IncludeMaximumEndDMsd: If set, then include Maximum End D MSD in SRv6 capability
	IncludeMaximumEndDMsd *Multivalue `json:"includeMaximumEndDMsd,omitempty"`
	// IncludeMaximumEndDSrhTLV: If set, then include Maximum End D SRH TLV in SRv6 capability
	IncludeMaximumEndDSrhTLV *Multivalue `json:"includeMaximumEndDSrhTLV,omitempty"`
	// IncludeMaximumEndPopMsd: If set, then include Max-End-Pop-MSD in SRv6 capability
	IncludeMaximumEndPopMsd *Multivalue `json:"includeMaximumEndPopMsd,omitempty"`
	// IncludeMaximumEndPopSrhTLV: If set, then include Max-End-Pop-SRH TLV in SRv6 capability
	IncludeMaximumEndPopSrhTLV *Multivalue `json:"includeMaximumEndPopSrhTLV,omitempty"`
	// IncludeMaximumSLTLV: If set, then include Maximum SL TLV in SRv6 capability
	IncludeMaximumSLTLV *Multivalue `json:"includeMaximumSLTLV,omitempty"`
	// IncludeMaximumTEncapMsd: If set, then include Maximum T.Encap MSD in SRv6 capability
	IncludeMaximumTEncapMsd *Multivalue `json:"includeMaximumTEncapMsd,omitempty"`
	// IncludeMaximumTEncapSrhTLV: If set, then include Maximum T.Encap SRH TLV in SRv6 capability
	IncludeMaximumTEncapSrhTLV *Multivalue `json:"includeMaximumTEncapSrhTLV,omitempty"`
	// IncludeMaximumTInsertMsd: If set, then include Maximum T.Insert MSD in SRv6 capability
	IncludeMaximumTInsertMsd *Multivalue `json:"includeMaximumTInsertMsd,omitempty"`
	// IncludeMaximumTInsertSrhTLV: If set, then include Maximum T.Insert SRH TLV in SRv6 capability
	IncludeMaximumTInsertSrhTLV *Multivalue `json:"includeMaximumTInsertSrhTLV,omitempty"`
	// IncludePrefixAttrFlags: Include Prefix Attributes Flags
	IncludePrefixAttrFlags *Multivalue `json:"includePrefixAttrFlags,omitempty"`
	// InterLSPsOrMGroupPDUBurstGap: Inter LSPs/MGROUP-PDUs Burst Gap (ms)
	InterLSPsOrMGroupPDUBurstGap *Multivalue `json:"interLSPsOrMGroupPDUBurstGap,omitempty"`
	// IpV6TERouterId: It is a unique ID including emulated and simulated routers. It should match IPv6 Node Prefix in SRv6 by default. It will send out the TLV 140 in ISIS.
	IpV6TERouterId *Multivalue `json:"ipV6TERouterId,omitempty"`
	// Ipv4Flag: If set, then the router is capable of processing SR MPLS encapsulated IPv4 packets on all interfaces.
	Ipv4Flag *Multivalue `json:"ipv4Flag,omitempty"`
	// Ipv6Flag: If set, then the router is capable of processing SR MPLS encapsulated IPv6 packets on all interfaces.
	Ipv6Flag *Multivalue `json:"ipv6Flag,omitempty"`
	// Ipv6NodePrefix: IPv6 Node SID
	Ipv6NodePrefix *Multivalue `json:"ipv6NodePrefix,omitempty"`
	// Ipv6Srh: This is the SR-IPv6 flag. If set to true, then this enables the SRv6 capability on the router If set to false, then this enables the MPLS SR capability on the router
	Ipv6Srh *Multivalue `json:"ipv6Srh,omitempty"`
	// Itid: Instance-specific topology identifier. Configure any number within the range of 0-65535.
	Itid *Multivalue `json:"itid,omitempty"`
	// LFlag: Local Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LSPLifetime: LSP Rifetime (sec)
	LSPLifetime *Multivalue `json:"lSPLifetime,omitempty"`
	// LSPRefreshRate: LSP Refresh Rate (sec)
	LSPRefreshRate *Multivalue `json:"lSPRefreshRate,omitempty"`
	// LSPorMGroupPDUMinTransmissionInterval: LSP/MGROUP-PDU Min Transmission Interval (ms)
	LSPorMGroupPDUMinTransmissionInterval *Multivalue `json:"lSPorMGroupPDUMinTransmissionInterval,omitempty"`
	// LocatorCount: Locator Count

	LocatorCount *float32 `json:"locatorCount,omitempty"`
	// LocatorPrefixLength: Locator Prefix Length
	LocatorPrefixLength *Multivalue `json:"locatorPrefixLength,omitempty"`
	// Mask: Mask
	Mask *Multivalue `json:"mask,omitempty"`
	// MaxAreaAddresses: Maximum Area Addresses
	MaxAreaAddresses *Multivalue `json:"maxAreaAddresses,omitempty"`
	// MaxEndD: This field specifies the maximum number of SIDs in an SRH when applying End.DX6 and End.DT6 functions. If this field is zero, then the router cannot apply End.DX6 or End.DT6 functions if the extension header right underneath the outer IPv6 header is an SRH.
	MaxEndD *Multivalue `json:"maxEndD,omitempty"`
	// MaxEndDMsd: This field specifies the maximum number of SIDs in an SRH when applying End.DX6 and End.DT6 functions. If this field is zero, then the router cannot apply End.DX6 or End.DT6 functions. If the extension header is right underneath the outer IPv6, header is an SRH.
	MaxEndDMsd *Multivalue `json:"maxEndDMsd,omitempty"`
	// MaxEndPopMsd: This field specifies the maximum number of SIDs in the top MSD in an MSD stack that the router can apply PSP or USP flavors to. If the value of this field is zero, then the router cannot apply PSP or USP flavors.
	MaxEndPopMsd *Multivalue `json:"maxEndPopMsd,omitempty"`
	// MaxEndPopSrh: This field specifies the maximum number of SIDs in the top SRH in an SRH stack that the router can apply PSP or USP flavors to. If the value of this field is zero, then the router cannot apply PSP or USP flavors.
	MaxEndPopSrh *Multivalue `json:"maxEndPopSrh,omitempty"`
	// MaxLSPSize: Max LSP Size
	MaxLSPSize *Multivalue `json:"maxLSPSize,omitempty"`
	// MaxLSPsOrMGroupPDUsPerBurst: Max LSPs/MGROUP-PDUs Per Burst
	MaxLSPsOrMGroupPDUsPerBurst *Multivalue `json:"maxLSPsOrMGroupPDUsPerBurst,omitempty"`
	// MaxSL: This field specifies the maximum value of the Segments Left (SL) field in the SRH of a received packet before applying the function associated with a SID.
	MaxSL *Multivalue `json:"maxSL,omitempty"`
	// MaxSlMsd: This field specifies the maximum value of the Segments Left (SL) MSD field in the SRH of a received packet before applying the function associated with a SID.
	MaxSlMsd *Multivalue `json:"maxSlMsd,omitempty"`
	// MaxTEncap: This field specifies the maximum number of SIDs that can be included as part of the T.Encap behavior. If this field is zero and the E flag is set, then the router can apply T.Encap by encapsulating the incoming packet in another IPv6 header without SRH the same way IPinIP encapsulation is performed. If the E flag is clear, then this field SHOULD be transmitted as zero and MUST be ignored on receipt.
	MaxTEncap *Multivalue `json:"maxTEncap,omitempty"`
	// MaxTEncapMsd: This field specifies the maximum number of SIDs that can be included as part of the T.Encap behavior. If this field is zero and the E flag is set, then the router can apply T.Encap by encapsulating the incoming packet in another IPv6 header without SRH, it is the same way IPinIP encapsulation is performed. If the E flag is clear, then this field SHOULD be transmitted as zero and MUST be ignored on receipt.
	MaxTEncapMsd *Multivalue `json:"maxTEncapMsd,omitempty"`
	// MaxTInsert: This field specifies the maximum number of SIDs that can be inserted as part of the T.insert behavior. If the value of this field is zero, then the router cannot apply any variation of the T.insert behavior.
	MaxTInsert *Multivalue `json:"maxTInsert,omitempty"`
	// MaxTInsertMsd: This field specifies the maximum number of SIDs that can be inserted as part of the T.insert behavior. If the value of this field is zero, then the router cannot apply any variation of the T.insert behavior.
	MaxTInsertMsd *Multivalue `json:"maxTInsertMsd,omitempty"`
	// MtCount: MT Count

	MtCount *float32 `json:"mtCount,omitempty"`
	// NFlag: Nodal prefix flag
	NFlag *Multivalue `json:"nFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfBIERSubDomains: Number of BIER Sub Domains

	NoOfBIERSubDomains *float32 `json:"noOfBIERSubDomains,omitempty"`
	// NoOfSRTunnels: Number of MPLS SR Tunnels

	NoOfSRTunnels *float32 `json:"noOfSRTunnels,omitempty"`
	// NodePrefix: Node Prefix
	NodePrefix *Multivalue `json:"nodePrefix,omitempty"`
	// NumberOfMappingIPV4Ranges: Specifies the number of IPv4 mappings or range TLVs that each router in a DG can advertise.

	NumberOfMappingIPV4Ranges *float32 `json:"numberOfMappingIPV4Ranges,omitempty"`
	// NumberOfMappingIPV6Ranges: Specifies the number of IPv6 mappings or range TLVs that each router in a DG can advertise.

	NumberOfMappingIPV6Ranges *float32 `json:"numberOfMappingIPV6Ranges,omitempty"`
	// OFlagOfSRv6Cap: If set, it indicates that this packet is an operations and management (OAM) packet.
	OFlagOfSRv6Cap *Multivalue `json:"oFlagOfSRv6Cap,omitempty"`
	// OFlagOfSRv6CapTlv: If set, it indicates that this packet is an operations and management (OAM) packet.
	OFlagOfSRv6CapTlv *Multivalue `json:"oFlagOfSRv6CapTlv,omitempty"`
	// Overloaded: Overloaded
	Overloaded *Multivalue `json:"overloaded,omitempty"`
	// PFlag: No-PHP flag. If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// PSNPInterval: PSNP Interval (ms)
	PSNPInterval *Multivalue `json:"pSNPInterval,omitempty"`
	// PartitionRepair: Partition Repair
	PartitionRepair *Multivalue `json:"partitionRepair,omitempty"`
	// PrefixAdvertisementType: Prefix Advertisement Type
	PrefixAdvertisementType *Multivalue `json:"prefixAdvertisementType,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RFlag: Redistribution flag
	RFlag *Multivalue `json:"rFlag,omitempty"`
	// Redistribution: Redistribution
	Redistribution *Multivalue `json:"redistribution,omitempty"`
	// RedistributionForSRv6: Redistribution
	RedistributionForSRv6 *Multivalue `json:"redistributionForSRv6,omitempty"`
	// ReservedInsideFlagsOfSRv6SidTLV: This is the reserved field (part of flags field of SRv6 SID TLV)
	ReservedInsideFlagsOfSRv6SidTLV *Multivalue `json:"reservedInsideFlagsOfSRv6SidTLV,omitempty"`
	// ReservedInsideSRv6CapFlag: This is the reserved field (as part of Flags field of SRv6 Capability TLV)
	ReservedInsideSRv6CapFlag *Multivalue `json:"reservedInsideSRv6CapFlag,omitempty"`
	// RouteMetric: Route Metric
	RouteMetric *Multivalue `json:"routeMetric,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// RtrcapId: Router Capability Id
	RtrcapId *Multivalue `json:"rtrcapId,omitempty"`
	// RtrcapIdForSrv6: Router Capability Id
	RtrcapIdForSrv6 *Multivalue `json:"rtrcapIdForSrv6,omitempty"`
	// SBit: Enabling S bit lets the IS-IS Router CAPABILITY TLV to get flooded across the entire routing domain, otherwise the TLV not be leaked between levels
	SBit *Multivalue `json:"sBit,omitempty"`
	// SBitForSRv6Cap: Enabling S bit lets the IS-IS Router CAPABILITY TLV to get flooded across the entire routing domain, otherwise the TLV not be leaked between levels
	SBitForSRv6Cap *Multivalue `json:"sBitForSRv6Cap,omitempty"`
	// SIDIndexLabel: SID/Index/Label
	SIDIndexLabel *Multivalue `json:"sIDIndexLabel,omitempty"`
	// SRAlgorithmCount: SR Algorithm Count

	SRAlgorithmCount *float32 `json:"sRAlgorithmCount,omitempty"`
	// SRGBRangeCount: SRGB Range Count

	SRGBRangeCount *float32 `json:"sRGBRangeCount,omitempty"`
	// SRv6NodePrefix: This is an IPv6 Node prefix for the SRv6 router
	SRv6NodePrefix *Multivalue `json:"sRv6NodePrefix,omitempty"`
	// SRv6NodePrefixLength: This is the prefix length of the SRv6 node prefix
	SRv6NodePrefixLength *Multivalue `json:"sRv6NodePrefixLength,omitempty"`
	// SrlbDescriptorCount: Count of the SRLB descriptor entries, each being a tuple having format {Start SID/Label, SID Count}

	SrlbDescriptorCount *float32 `json:"srlbDescriptorCount,omitempty"`
	// SrlbFlags: This specifies the value of the SRLB flags field
	SrlbFlags *Multivalue `json:"srlbFlags,omitempty"`
	// SrmsPreference: This is used to associate a preference with SRMS advertisements and is being advertised as a sub-TLV in Router Capability TLV
	SrmsPreference *Multivalue `json:"srmsPreference,omitempty"`
	// TERouterId: TE Router ID
	TERouterId *Multivalue `json:"tERouterId,omitempty"`
	// VFlag: Value Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`

	IsisBierSubDomainList *TopologyIsisBierSubDomainList `json:"isisBierSubDomainList,omitempty"`

	IsisFlexAlgorithmList *TopologyIsisFlexAlgorithmList `json:"isisFlexAlgorithmList,omitempty"`

	IsisMappingServerIPV4List *TopologyIsisMappingServerIpv4List `json:"isisMappingServerIPV4List,omitempty"`

	IsisMappingServerIPV6List   *TopologyIsisMappingServerIpv6List     `json:"isisMappingServerIPV6List,omitempty"`
	IsisMultiTopologyValuesList []*TopologyIsisMultiTopologyValuesList `json:"isisMultiTopologyValuesList"`
	IsisSRAlgorithmList         []*TopologyIsisSrAlgorithmList         `json:"isisSRAlgorithmList"`
	IsisSRGBRangeSubObjectsList []*TopologyIsisSrgbRangeSubObjectsList `json:"isisSRGBRangeSubObjectsList"`
	IsisSRLBDescriptorList      []*TopologyIsisSrlbDescriptorList      `json:"isisSRLBDescriptorList"`

	IsisSRTunnelList *TopologyIsisSrTunnelList `json:"isisSRTunnelList,omitempty"`

	IsisSRv6LocatorEntryList *TopologyIsisSRv6LocatorEntryList `json:"isisSRv6LocatorEntryList,omitempty"`
	Tag                      []*TopologyTag                    `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3Router) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3Router) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3Router) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3Router) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BIERNodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERNodePrefix",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseNodeMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseNodeMsd",
		isMultivalue: true,
	})
	n.AdvertiseSRLB.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRLB",
		isMultivalue: true,
	})
	n.AdvertiseSRMSPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSRMSPreference",
		isMultivalue: true,
	})
	n.AdvertiseSidAsLocator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSidAsLocator",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.AreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAddresses",
		isMultivalue: true,
	})
	n.AreaAuthenticationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAuthenticationType",
		isMultivalue: true,
	})
	n.AreaTransmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaTransmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.Attached.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attached",
		isMultivalue: true,
	})
	n.BIERIPv6NodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bIERIPv6NodePrefix",
		isMultivalue: true,
	})
	n.BierNFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierNFlag",
		isMultivalue: true,
	})
	n.BierRFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierRFlag",
		isMultivalue: true,
	})
	n.CSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cSNPInterval",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.DBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBit",
		isMultivalue: true,
	})
	n.DBitForSRv6Cap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBitForSRv6Cap",
		isMultivalue: true,
	})
	n.DBitInsideSRv6SidTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBitInsideSRv6SidTLV",
		isMultivalue: true,
	})
	n.DiscardLSPs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLSPs",
		isMultivalue: true,
	})
	n.Distribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distribution",
		isMultivalue: true,
	})
	n.DomainAuthenticationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "domainAuthenticationType",
		isMultivalue: true,
	})
	n.DomainTransmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "domainTransmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.EFlagOfSRv6CapTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlagOfSRv6CapTlv",
		isMultivalue: true,
	})
	n.EnableHelloPadding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloPadding",
		isMultivalue: true,
	})
	n.EnableHitlessRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHitlessRestart",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.EnableITID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableITID",
		isMultivalue: true,
	})
	n.EnableIpV6TE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpV6TE",
		isMultivalue: true,
	})
	n.EnableMI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMI",
		isMultivalue: true,
	})
	n.EnableMTIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMTIPv6",
		isMultivalue: true,
	})
	n.EnableMappingServer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMappingServer",
		isMultivalue: true,
	})
	n.EnableTE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableTE",
		isMultivalue: true,
	})
	n.EnableWMforTE.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWMforTE",
		isMultivalue: true,
	})
	n.EnableWideMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWideMetric",
		isMultivalue: true,
	})
	n.Funcflags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "funcflags",
		isMultivalue: true,
	})
	n.Function.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "function",
		isMultivalue: true,
	})
	n.HitlessRestartMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hitlessRestartMode",
		isMultivalue: true,
	})
	n.HitlessRestartTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hitlessRestartTime",
		isMultivalue: true,
	})
	n.HitlessRestartVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hitlessRestartVersion",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.IgnoreReceiveMD5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreReceiveMD5",
		isMultivalue: true,
	})
	n.Iid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iid",
		isMultivalue: true,
	})
	n.IncludeMaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaxSlMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndDMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndDSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndDSrhTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndPopMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumEndPopSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumEndPopSrhTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumSLTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumSLTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumTEncapMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTEncapMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTEncapSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTEncapSrhTLV",
		isMultivalue: true,
	})
	n.IncludeMaximumTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTInsertMsd",
		isMultivalue: true,
	})
	n.IncludeMaximumTInsertSrhTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMaximumTInsertSrhTLV",
		isMultivalue: true,
	})
	n.IncludePrefixAttrFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePrefixAttrFlags",
		isMultivalue: true,
	})
	n.InterLSPsOrMGroupPDUBurstGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interLSPsOrMGroupPDUBurstGap",
		isMultivalue: true,
	})
	n.IpV6TERouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV6TERouterId",
		isMultivalue: true,
	})
	n.Ipv4Flag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Flag",
		isMultivalue: true,
	})
	n.Ipv6Flag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Flag",
		isMultivalue: true,
	})
	n.Ipv6NodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NodePrefix",
		isMultivalue: true,
	})
	n.Ipv6Srh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Srh",
		isMultivalue: true,
	})
	n.Itid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "itid",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LSPLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPLifetime",
		isMultivalue: true,
	})
	n.LSPRefreshRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPRefreshRate",
		isMultivalue: true,
	})
	n.LSPorMGroupPDUMinTransmissionInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPorMGroupPDUMinTransmissionInterval",
		isMultivalue: true,
	})
	n.LocatorPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorPrefixLength",
		isMultivalue: true,
	})
	n.Mask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mask",
		isMultivalue: true,
	})
	n.MaxAreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxAreaAddresses",
		isMultivalue: true,
	})
	n.MaxEndD.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndD",
		isMultivalue: true,
	})
	n.MaxEndDMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndDMsd",
		isMultivalue: true,
	})
	n.MaxEndPopMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndPopMsd",
		isMultivalue: true,
	})
	n.MaxEndPopSrh.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxEndPopSrh",
		isMultivalue: true,
	})
	n.MaxLSPSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPSize",
		isMultivalue: true,
	})
	n.MaxLSPsOrMGroupPDUsPerBurst.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPsOrMGroupPDUsPerBurst",
		isMultivalue: true,
	})
	n.MaxSL.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSL",
		isMultivalue: true,
	})
	n.MaxSlMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSlMsd",
		isMultivalue: true,
	})
	n.MaxTEncap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTEncap",
		isMultivalue: true,
	})
	n.MaxTEncapMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTEncapMsd",
		isMultivalue: true,
	})
	n.MaxTInsert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTInsert",
		isMultivalue: true,
	})
	n.MaxTInsertMsd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTInsertMsd",
		isMultivalue: true,
	})
	n.NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nFlag",
		isMultivalue: true,
	})
	n.NodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodePrefix",
		isMultivalue: true,
	})
	n.OFlagOfSRv6Cap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oFlagOfSRv6Cap",
		isMultivalue: true,
	})
	n.OFlagOfSRv6CapTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oFlagOfSRv6CapTlv",
		isMultivalue: true,
	})
	n.Overloaded.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overloaded",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.PSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pSNPInterval",
		isMultivalue: true,
	})
	n.PartitionRepair.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partitionRepair",
		isMultivalue: true,
	})
	n.PrefixAdvertisementType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixAdvertisementType",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rFlag",
		isMultivalue: true,
	})
	n.Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistribution",
		isMultivalue: true,
	})
	n.RedistributionForSRv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistributionForSRv6",
		isMultivalue: true,
	})
	n.ReservedInsideFlagsOfSRv6SidTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedInsideFlagsOfSRv6SidTLV",
		isMultivalue: true,
	})
	n.ReservedInsideSRv6CapFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedInsideSRv6CapFlag",
		isMultivalue: true,
	})
	n.RouteMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeMetric",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.RtrcapId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rtrcapId",
		isMultivalue: true,
	})
	n.RtrcapIdForSrv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rtrcapIdForSrv6",
		isMultivalue: true,
	})
	n.SBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sBit",
		isMultivalue: true,
	})
	n.SBitForSRv6Cap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sBitForSRv6Cap",
		isMultivalue: true,
	})
	n.SIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDIndexLabel",
		isMultivalue: true,
	})
	n.SRv6NodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sRv6NodePrefix",
		isMultivalue: true,
	})
	n.SRv6NodePrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sRv6NodePrefixLength",
		isMultivalue: true,
	})
	n.SrlbFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlbFlags",
		isMultivalue: true,
	})
	n.SrmsPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srmsPreference",
		isMultivalue: true,
	})
	n.TERouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tERouterId",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.IsisBierSubDomainList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisBierSubDomainList",
	})
	n.IsisFlexAlgorithmList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisFlexAlgorithmList",
	})
	n.IsisMappingServerIPV4List.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisMappingServerIPV4List",
	})
	n.IsisMappingServerIPV6List.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisMappingServerIPV6List",
	})
	for i, o := range n.IsisMultiTopologyValuesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisMultiTopologyValuesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSRAlgorithmList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSRAlgorithmList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSRLBDescriptorList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSRLBDescriptorList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.IsisSRTunnelList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisSRTunnelList",
	})
	n.IsisSRv6LocatorEntryList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisSRv6LocatorEntryList",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisL3SimulatedTopologyConfig: ISIS-L3 Simulated Topology Configuration
type TopologyIsisL3SimulatedTopologyConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// IsisL3Ipv4NodeRouteCount: Node Route Range Count(multiplier)

	IsisL3Ipv4NodeRouteCount *float32 `json:"isisL3Ipv4NodeRouteCount,omitempty"`
	// IsisL3Ipv6NodeRouteCount: Node Route Range Count(multiplier)

	IsisL3Ipv6NodeRouteCount *float32 `json:"isisL3Ipv6NodeRouteCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	IsisL3ipv4NodeRouteList *TopologyIsisL3ipv4NodeRouteList `json:"isisL3ipv4NodeRouteList,omitempty"`

	IsisL3ipv6NodeRouteList *TopologyIsisL3ipv6NodeRouteList `json:"isisL3ipv6NodeRouteList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3SimulatedTopologyConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3SimulatedTopologyConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3SimulatedTopologyConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3SimulatedTopologyConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.IsisL3ipv4NodeRouteList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisL3ipv4NodeRouteList",
	})
	n.IsisL3ipv6NodeRouteList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisL3ipv6NodeRouteList",
	})
}

// TopologyIsisL3ipv4NodeRouteList: ISIS-L3 IPv4 Node Route Configuration
type TopologyIsisL3ipv4NodeRouteList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// FirstIpv4Route: First IPv4 Route
	FirstIpv4Route *Multivalue `json:"firstIpv4Route,omitempty"`
	// MaskWidth: Mask Width for IPv4
	MaskWidth *Multivalue `json:"maskWidth,omitempty"`
	// Metric: Route Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfRoutes: No. of Routes
	NoOfRoutes *Multivalue `json:"noOfRoutes,omitempty"`
	// NodeStep: Node Step
	NodeStep *Multivalue `json:"nodeStep,omitempty"`
	// Redistribution: Redistribution
	Redistribution *Multivalue `json:"redistribution,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// RouteStep: RouteStep
	RouteStep *Multivalue `json:"routeStep,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3ipv4NodeRouteList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3ipv4NodeRouteList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3ipv4NodeRouteList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3ipv4NodeRouteList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.FirstIpv4Route.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "firstIpv4Route",
		isMultivalue: true,
	})
	n.MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maskWidth",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NoOfRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfRoutes",
		isMultivalue: true,
	})
	n.NodeStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeStep",
		isMultivalue: true,
	})
	n.Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistribution",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.RouteStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeStep",
		isMultivalue: true,
	})
}

// TopologyIsisL3ipv6NodeRouteList: ISIS-L3 IPv6 Node Route Configuration
type TopologyIsisL3ipv6NodeRouteList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// FirstIpv6Route: First IPv6 Route
	FirstIpv6Route *Multivalue `json:"firstIpv6Route,omitempty"`
	// MaskWidth: Mask Width for IPv6
	MaskWidth *Multivalue `json:"maskWidth,omitempty"`
	// Metric: Route Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfRoutes: No. of Routes
	NoOfRoutes *Multivalue `json:"noOfRoutes,omitempty"`
	// NodeStep: Node Step
	NodeStep *Multivalue `json:"nodeStep,omitempty"`
	// Redistribution: Redistribution
	Redistribution *Multivalue `json:"redistribution,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// RouteStep: RouteStep
	RouteStep *Multivalue `json:"routeStep,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisL3ipv6NodeRouteList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisL3ipv6NodeRouteList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisL3ipv6NodeRouteList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisL3ipv6NodeRouteList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.FirstIpv6Route.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "firstIpv6Route",
		isMultivalue: true,
	})
	n.MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maskWidth",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NoOfRoutes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfRoutes",
		isMultivalue: true,
	})
	n.NodeStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeStep",
		isMultivalue: true,
	})
	n.Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistribution",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.RouteStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeStep",
		isMultivalue: true,
	})
}

// TopologyIsisMappingServerIpv4List: ISIS Mapping Server IPV4
type TopologyIsisMappingServerIpv4List struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AFlag: Attached flag
	AFlag *Multivalue `json:"aFlag,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// DFlag: When the SID/Label Binding TLV is leaked from level-2 to level-1, this flag MUST be set, else it should be clear
	DFlag *Multivalue `json:"dFlag,omitempty"`
	// EFlag: Explicit NULL flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// FECPrefix: IPv4 FEC Prefix
	FECPrefix *Multivalue `json:"fECPrefix,omitempty"`
	// LFlag: Local Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mirror Context flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// NFlag: N Flag: Indicates the nodal prefix
	NFlag *Multivalue `json:"nFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlag: P Flag: Indicates that to reach to a prefix, this router would be penultimate hop.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// PrefixLength: Length of the IPv4 FEC prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RFlag: Redistribution flag
	RFlag *Multivalue `json:"rFlag,omitempty"`
	// Range_: This the count of continuous IPv4 address prefixes and their respective continuous SID/labels
	Range_ *Multivalue `json:"range,omitempty"`
	// SFlag: Enabling this flag lets the SID/Label Binding TLV to get flooded across the entire routing domain, else this TLV should not be leaked between levels
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// StartSIDLabel: Starting value of SID/ Label
	StartSIDLabel *Multivalue `json:"startSIDLabel,omitempty"`
	// VFlag: Value Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// Weight: Weight
	Weight *Multivalue `json:"weight,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisMappingServerIpv4List) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisMappingServerIpv4List) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisMappingServerIpv4List) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisMappingServerIpv4List) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aFlag",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.DFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dFlag",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.FECPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fECPrefix",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nFlag",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rFlag",
		isMultivalue: true,
	})
	n.Range_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "range",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.StartSIDLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSIDLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
}

// TopologyIsisMappingServerIpv6List: ISIS Mapping Server IPV6
type TopologyIsisMappingServerIpv6List struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AFlag: Attached flag
	AFlag *Multivalue `json:"aFlag,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// DFlag: When the SID/Label Binding TLV is leaked from level-2 to level-1, this flag MUST be set, else it should be clear
	DFlag *Multivalue `json:"dFlag,omitempty"`
	// EFlag: Explicit NULL flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// FECPrefix: IPv6 FEC Prefix
	FECPrefix *Multivalue `json:"fECPrefix,omitempty"`
	// LFlag: Local Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mirror Context flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// NFlag: N Flag: Indicates the nodal prefix
	NFlag *Multivalue `json:"nFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlag: P Flag: Indicates that to reach to a prefix, this router would be penultimate hop.
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// PrefixLength: Length of the IPv4 FEC prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RFlag: Redistribution flag
	RFlag *Multivalue `json:"rFlag,omitempty"`
	// Range_: This the count of continuous FEC IPv6 prefixes and their respective continuous SID/labels
	Range_ *Multivalue `json:"range,omitempty"`
	// SFlag: Enabling this flag lets the SID/Label Binding TLV to get flooded across the entire routing domain, else this TLV should not be leaked between levels
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// StartSIDLabel: Starting value of SID/ Label
	StartSIDLabel *Multivalue `json:"startSIDLabel,omitempty"`
	// VFlag: Value Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// Weight: Weight
	Weight *Multivalue `json:"weight,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisMappingServerIpv6List) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisMappingServerIpv6List) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisMappingServerIpv6List) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisMappingServerIpv6List) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aFlag",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.DFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dFlag",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.FECPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fECPrefix",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.NFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nFlag",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rFlag",
		isMultivalue: true,
	})
	n.Range_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "range",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.StartSIDLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSIDLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
}

// TopologyIsisMultiTopologyValuesList: ISIS MT Values
type TopologyIsisMultiTopologyValuesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableMtId: Enable MT-Id
	EnableMtId *Multivalue `json:"enableMtId,omitempty"`
	// MtId: MT Id
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisMultiTopologyValuesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisMultiTopologyValuesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisMultiTopologyValuesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisMultiTopologyValuesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableMtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMtId",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
}

// TopologyIsisPseudoAppSpecSrlgList: ISIS Pseudo Application Specific SRLG
type TopologyIsisPseudoAppSpecSrlgList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// IpV4InterfaceAddr: IPv4 Interface Address
	IpV4InterfaceAddr *Multivalue `json:"ipV4InterfaceAddr,omitempty"`
	// IpV4NeighborAddr: IPv4 Neighbor Address
	IpV4NeighborAddr *Multivalue `json:"ipV4NeighborAddr,omitempty"`
	// IpV6InterfaceAddr: IPv6 Interface Address
	IpV6InterfaceAddr *Multivalue `json:"ipV6InterfaceAddr,omitempty"`
	// IpV6NeighborAddr: IPv6 Neighbor Address
	IpV6NeighborAddr *Multivalue `json:"ipV6NeighborAddr,omitempty"`
	// LFlag: If set to False, all link attributes will be advertised as sub-sub-tlv of sub tlv Application Specific Link Attributes sub-TLV (Type 16) of TLV 22,23,141,222 and 223 If true, then all link attributes will be advertised as sub-TLV of TLV 22,23,141,222 and 223.
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StdAppType: Standard Appplication Type
	StdAppType *Multivalue `json:"stdAppType,omitempty"`
	// UserDefAppBm: User Defined Application BM
	UserDefAppBm *Multivalue `json:"userDefAppBm,omitempty"`
	// UserDefAppBmLen: User Defined Application BM Length
	UserDefAppBmLen *Multivalue `json:"userDefAppBmLen,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoAppSpecSrlgList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoAppSpecSrlgList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoAppSpecSrlgList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoAppSpecSrlgList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.IpV4InterfaceAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV4InterfaceAddr",
		isMultivalue: true,
	})
	n.IpV4NeighborAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV4NeighborAddr",
		isMultivalue: true,
	})
	n.IpV6InterfaceAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV6InterfaceAddr",
		isMultivalue: true,
	})
	n.IpV6NeighborAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipV6NeighborAddr",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.StdAppType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stdAppType",
		isMultivalue: true,
	})
	n.UserDefAppBm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBm",
		isMultivalue: true,
	})
	n.UserDefAppBmLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBmLen",
		isMultivalue: true,
	})
}

// TopologyIsisPseudoFlexAlgorithm: ISIS Pseudo Flex Algorithm
type TopologyIsisPseudoFlexAlgorithm struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvTwiceExcludeAg: Advertise Twice Exclude AG
	AdvTwiceExcludeAg *Multivalue `json:"advTwiceExcludeAg,omitempty"`
	// AdvTwiceIncludeAllAg: Advertise Twice Include-All AG
	AdvTwiceIncludeAllAg *Multivalue `json:"advTwiceIncludeAllAg,omitempty"`
	// AdvTwiceIncludeAnyAg: Advertise Twice Include-Any AG
	AdvTwiceIncludeAnyAg *Multivalue `json:"advTwiceIncludeAnyAg,omitempty"`
	// CalcType: Calc Type
	CalcType *Multivalue `json:"calcType,omitempty"`
	// DontAdvInSrAlgo: Don't Adv. in SR Algorithm
	DontAdvInSrAlgo *Multivalue `json:"dontAdvInSrAlgo,omitempty"`
	// EnableExcludeAg: If this is enabled, Flexible Algorithm Exclude Admin Group Sub-Sub TLV will be advertised with FAD sub-TLV.
	EnableExcludeAg *Multivalue `json:"enableExcludeAg,omitempty"`
	// EnableFadfTlv: If enabled then following attributes will get enabled and ISIS Flexible Algorithm Definition Flags Sub-TLV or FADF sub-sub-TLV will be advertised with FAD Sub-TLV
	EnableFadfTlv *Multivalue `json:"enableFadfTlv,omitempty"`
	// EnableIncludeAllAg: If this is enabled, Flexible Algorithm Include-All Admin Group Sub-Sub TLV will be advertised with FAD sub-TLV.
	EnableIncludeAllAg *Multivalue `json:"enableIncludeAllAg,omitempty"`
	// EnableIncludeAnyAg: If this is enabled, Flexible Algorithm Include-Any Admin Group Sub-Sub TLV will be advertised with FAD sub-TLV.
	EnableIncludeAnyAg *Multivalue `json:"enableIncludeAnyAg,omitempty"`
	// ExcludeAgExtAg: Ext Admin Group
	ExcludeAgExtAg *Multivalue `json:"excludeAgExtAg,omitempty"`
	// ExcludeAgExtAgLen: Ext AG Length
	ExcludeAgExtAgLen *Multivalue `json:"excludeAgExtAgLen,omitempty"`
	// FadfLen: FADF AG Length
	FadfLen *Multivalue `json:"fadfLen,omitempty"`
	// FlexAlgo: Flex Algo
	FlexAlgo *Multivalue `json:"flexAlgo,omitempty"`
	// IncludeAllAgExtAg: Ext Include-All AG
	IncludeAllAgExtAg *Multivalue `json:"includeAllAgExtAg,omitempty"`
	// IncludeAllAgExtAgLen: Ext AG Length
	IncludeAllAgExtAgLen *Multivalue `json:"includeAllAgExtAgLen,omitempty"`
	// IncludeAnyAgExtAg: Ext Include-Any AG
	IncludeAnyAgExtAg *Multivalue `json:"includeAnyAgExtAg,omitempty"`
	// IncludeAnyAgExtAgLen: Ext AG Length
	IncludeAnyAgExtAgLen *Multivalue `json:"includeAnyAgExtAgLen,omitempty"`
	// MFlag: M-Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// MetricType: Metric Type
	MetricType *Multivalue `json:"metricType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Priority: Priority
	Priority *Multivalue `json:"priority,omitempty"`
	// ReservedBits: Reserved Bits
	ReservedBits *Multivalue `json:"reservedBits,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoFlexAlgorithm) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoFlexAlgorithm) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoFlexAlgorithm) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoFlexAlgorithm) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvTwiceExcludeAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advTwiceExcludeAg",
		isMultivalue: true,
	})
	n.AdvTwiceIncludeAllAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advTwiceIncludeAllAg",
		isMultivalue: true,
	})
	n.AdvTwiceIncludeAnyAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advTwiceIncludeAnyAg",
		isMultivalue: true,
	})
	n.CalcType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "calcType",
		isMultivalue: true,
	})
	n.DontAdvInSrAlgo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dontAdvInSrAlgo",
		isMultivalue: true,
	})
	n.EnableExcludeAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableExcludeAg",
		isMultivalue: true,
	})
	n.EnableFadfTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFadfTlv",
		isMultivalue: true,
	})
	n.EnableIncludeAllAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIncludeAllAg",
		isMultivalue: true,
	})
	n.EnableIncludeAnyAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIncludeAnyAg",
		isMultivalue: true,
	})
	n.ExcludeAgExtAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAgExtAg",
		isMultivalue: true,
	})
	n.ExcludeAgExtAgLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAgExtAgLen",
		isMultivalue: true,
	})
	n.FadfLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fadfLen",
		isMultivalue: true,
	})
	n.FlexAlgo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flexAlgo",
		isMultivalue: true,
	})
	n.IncludeAllAgExtAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAllAgExtAg",
		isMultivalue: true,
	})
	n.IncludeAllAgExtAgLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAllAgExtAgLen",
		isMultivalue: true,
	})
	n.IncludeAnyAgExtAg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAnyAgExtAg",
		isMultivalue: true,
	})
	n.IncludeAnyAgExtAgLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAnyAgExtAgLen",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.MetricType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricType",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.ReservedBits.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedBits",
		isMultivalue: true,
	})
}

// TopologyIsisPseudoInterface: Information for Simulated Router Interfaces
type TopologyIsisPseudoInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// LinkType: Link Type
	LinkType *Multivalue `json:"linkType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name                                *string                                        `json:"name,omitempty"`
	IsisDcePseudoIfaceAttPoint1Config   []*TopologyIsisDcePseudoIfaceAttPoint1Config   `json:"isisDcePseudoIfaceAttPoint1Config"`
	IsisDcePseudoIfaceAttPoint2Config   []*TopologyIsisDcePseudoIfaceAttPoint2Config   `json:"isisDcePseudoIfaceAttPoint2Config"`
	IsisL3PseudoIfaceAttPoint1Config    []*TopologyIsisL3PseudoIfaceAttPoint1Config    `json:"isisL3PseudoIfaceAttPoint1Config"`
	IsisL3PseudoIfaceAttPoint2Config    []*TopologyIsisL3PseudoIfaceAttPoint2Config    `json:"isisL3PseudoIfaceAttPoint2Config"`
	IsisSpbPseudoIfaceAttPoint1Config   []*TopologyIsisSpbPseudoIfaceAttPoint1Config   `json:"isisSpbPseudoIfaceAttPoint1Config"`
	IsisSpbPseudoIfaceAttPoint2Config   []*TopologyIsisSpbPseudoIfaceAttPoint2Config   `json:"isisSpbPseudoIfaceAttPoint2Config"`
	IsisTrillPseudoIfaceAttPoint1Config []*TopologyIsisTrillPseudoIfaceAttPoint1Config `json:"isisTrillPseudoIfaceAttPoint1Config"`
	IsisTrillPseudoIfaceAttPoint2Config []*TopologyIsisTrillPseudoIfaceAttPoint2Config `json:"isisTrillPseudoIfaceAttPoint2Config"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LinkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkType",
		isMultivalue: true,
	})
	for i, o := range n.IsisDcePseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDcePseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDcePseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDcePseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3PseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3PseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3PseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3PseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbPseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbPseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbPseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbPseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillPseudoIfaceAttPoint1Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillPseudoIfaceAttPoint1Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillPseudoIfaceAttPoint2Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillPseudoIfaceAttPoint2Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisPseudoMultiTopologyValuesList: ISIS MT Values
type TopologyIsisPseudoMultiTopologyValuesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableMtId: Enable MT-Id
	EnableMtId *Multivalue `json:"enableMtId,omitempty"`
	// MtId: MT Id
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoMultiTopologyValuesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoMultiTopologyValuesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoMultiTopologyValuesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoMultiTopologyValuesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableMtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMtId",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
}

// TopologyIsisPseudoSRv6AdjSidList: ISIS SRv6 Adj SID
type TopologyIsisPseudoSRv6AdjSidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ActiveTo: Flag.
	ActiveTo *Multivalue `json:"activeTo,omitempty"`
	// AdvertiseCustomSubTLV: Advertise Custom Sub-TLV
	AdvertiseCustomSubTLV *Multivalue `json:"advertiseCustomSubTLV,omitempty"`
	// AdvertiseCustomSubTLVTo: Advertise Custom Sub-TLV
	AdvertiseCustomSubTLVTo *Multivalue `json:"advertiseCustomSubTLVTo,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// AlgorithmTo: Algorithm
	AlgorithmTo *Multivalue `json:"algorithmTo,omitempty"`
	// ArgumentLength: Argument Length in Bits
	ArgumentLength *Multivalue `json:"argumentLength,omitempty"`
	// ArgumentLengthTo: Argument Length in Bits
	ArgumentLengthTo *Multivalue `json:"argumentLengthTo,omitempty"`
	// BFlag: B-Flag
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// BFlagTo: B-Flag
	BFlagTo *Multivalue `json:"bFlagTo,omitempty"`
	// CustomEndPointFunction: Custom End-Point Function
	CustomEndPointFunction *Multivalue `json:"customEndPointFunction,omitempty"`
	// CustomEndPointFunctionTo: Custom End-Point Function
	CustomEndPointFunctionTo *Multivalue `json:"customEndPointFunctionTo,omitempty"`
	// CustomSubTlv: Custom Sub-TLV
	CustomSubTlv *Multivalue `json:"customSubTlv,omitempty"`
	// CustomSubTlvTo: Custom Sub-TLV
	CustomSubTlvTo *Multivalue `json:"customSubTlvTo,omitempty"`
	// EndPointFunction: End-Point Function
	EndPointFunction *Multivalue `json:"endPointFunction,omitempty"`
	// EndPointFunctionTo: End-Point Function
	EndPointFunctionTo *Multivalue `json:"endPointFunctionTo,omitempty"`
	// FunctionLength: Function Length in Bits
	FunctionLength *Multivalue `json:"functionLength,omitempty"`
	// FunctionLengthTo: Function Length in Bits
	FunctionLengthTo *Multivalue `json:"functionLengthTo,omitempty"`
	// IncludeSRv6SIDStructureSubSubTlv: Include SRv6 SID Structure Sub-Sub-TLV
	IncludeSRv6SIDStructureSubSubTlv *Multivalue `json:"includeSRv6SIDStructureSubSubTlv,omitempty"`
	// IncludeSRv6SIDStructureSubSubTlvTo: Include SRv6 SID Structure Sub-Sub-TLV
	IncludeSRv6SIDStructureSubSubTlvTo *Multivalue `json:"includeSRv6SIDStructureSubSubTlvTo,omitempty"`
	// Ipv6AdjSid: IPv6 Adj SID
	Ipv6AdjSid *Multivalue `json:"ipv6AdjSid,omitempty"`
	// Ipv6AdjSidTo: IPv6 Adj SID
	Ipv6AdjSidTo *Multivalue `json:"ipv6AdjSidTo,omitempty"`
	// LocatorBlockLength: Locator Block Length in Bits
	LocatorBlockLength *Multivalue `json:"locatorBlockLength,omitempty"`
	// LocatorBlockLengthTo: Locator Block Length in Bits
	LocatorBlockLengthTo *Multivalue `json:"locatorBlockLengthTo,omitempty"`
	// LocatorNodeLength: Locator Node Length in Bits
	LocatorNodeLength *Multivalue `json:"locatorNodeLength,omitempty"`
	// LocatorNodeLengthTo: Locator Node Length in Bits
	LocatorNodeLengthTo *Multivalue `json:"locatorNodeLengthTo,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlag: P-Flag
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// PFlagTo: P-Flag
	PFlagTo *Multivalue `json:"pFlagTo,omitempty"`
	// Reserved: Reserved
	Reserved *Multivalue `json:"reserved,omitempty"`
	// ReservedTo: Reserved
	ReservedTo *Multivalue `json:"reservedTo,omitempty"`
	// SFlag: S-Flag
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// SFlagTo: S-Flag
	SFlagTo *Multivalue `json:"sFlagTo,omitempty"`
	// Weight: Weight
	Weight *Multivalue `json:"weight,omitempty"`
	// WeightTo: Weight
	WeightTo *Multivalue `json:"weightTo,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoSRv6AdjSidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoSRv6AdjSidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoSRv6AdjSidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoSRv6AdjSidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActiveTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeTo",
		isMultivalue: true,
	})
	n.AdvertiseCustomSubTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseCustomSubTLV",
		isMultivalue: true,
	})
	n.AdvertiseCustomSubTLVTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseCustomSubTLVTo",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.AlgorithmTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithmTo",
		isMultivalue: true,
	})
	n.ArgumentLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLength",
		isMultivalue: true,
	})
	n.ArgumentLengthTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLengthTo",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.BFlagTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlagTo",
		isMultivalue: true,
	})
	n.CustomEndPointFunction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customEndPointFunction",
		isMultivalue: true,
	})
	n.CustomEndPointFunctionTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customEndPointFunctionTo",
		isMultivalue: true,
	})
	n.CustomSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSubTlv",
		isMultivalue: true,
	})
	n.CustomSubTlvTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSubTlvTo",
		isMultivalue: true,
	})
	n.EndPointFunction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointFunction",
		isMultivalue: true,
	})
	n.EndPointFunctionTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointFunctionTo",
		isMultivalue: true,
	})
	n.FunctionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLength",
		isMultivalue: true,
	})
	n.FunctionLengthTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLengthTo",
		isMultivalue: true,
	})
	n.IncludeSRv6SIDStructureSubSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSRv6SIDStructureSubSubTlv",
		isMultivalue: true,
	})
	n.IncludeSRv6SIDStructureSubSubTlvTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSRv6SIDStructureSubSubTlvTo",
		isMultivalue: true,
	})
	n.Ipv6AdjSid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6AdjSid",
		isMultivalue: true,
	})
	n.Ipv6AdjSidTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6AdjSidTo",
		isMultivalue: true,
	})
	n.LocatorBlockLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorBlockLength",
		isMultivalue: true,
	})
	n.LocatorBlockLengthTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorBlockLengthTo",
		isMultivalue: true,
	})
	n.LocatorNodeLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorNodeLength",
		isMultivalue: true,
	})
	n.LocatorNodeLengthTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorNodeLengthTo",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.PFlagTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagTo",
		isMultivalue: true,
	})
	n.Reserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved",
		isMultivalue: true,
	})
	n.ReservedTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedTo",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.SFlagTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlagTo",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.WeightTo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weightTo",
		isMultivalue: true,
	})
}

// TopologyIsisPseudoSRv6EndSidList: ISIS SRv6 End SID
type TopologyIsisPseudoSRv6EndSidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseCustomSubTLV: Advertise Custom Sub-TLV
	AdvertiseCustomSubTLV *Multivalue `json:"advertiseCustomSubTLV,omitempty"`
	// ArgumentLength: Argument Length in Bits
	ArgumentLength *Multivalue `json:"argumentLength,omitempty"`
	// CustomEndPointFunction: Custom End-Point Function
	CustomEndPointFunction *Multivalue `json:"customEndPointFunction,omitempty"`
	// CustomSubTlv: Custom Sub-TLV
	CustomSubTlv *Multivalue `json:"customSubTlv,omitempty"`
	// EndPointFunction: End-Point Function
	EndPointFunction *Multivalue `json:"endPointFunction,omitempty"`
	// Flags: Flags
	Flags *Multivalue `json:"flags,omitempty"`
	// FunctionLength: Function Length in Bits
	FunctionLength *Multivalue `json:"functionLength,omitempty"`
	// IncludeSRv6SIDStructureSubSubTlv: Include SRv6 SID Structure Sub-Sub-TLV
	IncludeSRv6SIDStructureSubSubTlv *Multivalue `json:"includeSRv6SIDStructureSubSubTlv,omitempty"`
	// LocatorBlockLength: Locator Block Length in Bits
	LocatorBlockLength *Multivalue `json:"locatorBlockLength,omitempty"`
	// LocatorNodeLength: Locator Node Length in Bits
	LocatorNodeLength *Multivalue `json:"locatorNodeLength,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Sid: SID
	Sid *Multivalue `json:"sid,omitempty"`
	// SidName: SID Name
	SidName *Multivalue `json:"sidName,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoSRv6EndSidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoSRv6EndSidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoSRv6EndSidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoSRv6EndSidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseCustomSubTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseCustomSubTLV",
		isMultivalue: true,
	})
	n.ArgumentLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLength",
		isMultivalue: true,
	})
	n.CustomEndPointFunction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customEndPointFunction",
		isMultivalue: true,
	})
	n.CustomSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSubTlv",
		isMultivalue: true,
	})
	n.EndPointFunction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointFunction",
		isMultivalue: true,
	})
	n.Flags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flags",
		isMultivalue: true,
	})
	n.FunctionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLength",
		isMultivalue: true,
	})
	n.IncludeSRv6SIDStructureSubSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSRv6SIDStructureSubSubTlv",
		isMultivalue: true,
	})
	n.LocatorBlockLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorBlockLength",
		isMultivalue: true,
	})
	n.LocatorNodeLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorNodeLength",
		isMultivalue: true,
	})
	n.Sid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sid",
		isMultivalue: true,
	})
	n.SidName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidName",
		isMultivalue: true,
	})
}

// TopologyIsisPseudoSRv6LocatorEntryList: ISIS SRv6 Locator Entry
type TopologyIsisPseudoSRv6LocatorEntryList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseLocatorAsPrefix: Advertise Locator as Prefix
	AdvertiseLocatorAsPrefix *Multivalue `json:"advertiseLocatorAsPrefix,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// DBit: D Bit
	DBit *Multivalue `json:"dBit,omitempty"`
	// Locator: Locator
	Locator *Multivalue `json:"locator,omitempty"`
	// LocatorName: Locator Name
	LocatorName *Multivalue `json:"locatorName,omitempty"`
	// LocatorSize: Locator Size
	LocatorSize *Multivalue `json:"locatorSize,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// MtApplicabilityForIPv6Locator: Multi-Topology Applicability for IPv6
	MtApplicabilityForIPv6Locator *Multivalue `json:"mtApplicabilityForIPv6Locator,omitempty"`
	// MtId: MTID
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// Redistribution: Redistribution
	Redistribution *Multivalue `json:"redistribution,omitempty"`
	// ReservedFlags: Reserved (Flags)
	ReservedFlags *Multivalue `json:"reservedFlags,omitempty"`
	// RouteMetric: Route Metric
	RouteMetric *Multivalue `json:"routeMetric,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// SidCount: SID Count

	SidCount *float32 `json:"sidCount,omitempty"`

	IsisPseudoSRv6EndSIDList *TopologyIsisPseudoSRv6EndSidList `json:"isisPseudoSRv6EndSIDList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoSRv6LocatorEntryList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoSRv6LocatorEntryList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoSRv6LocatorEntryList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoSRv6LocatorEntryList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseLocatorAsPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseLocatorAsPrefix",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.DBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBit",
		isMultivalue: true,
	})
	n.Locator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locator",
		isMultivalue: true,
	})
	n.LocatorName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorName",
		isMultivalue: true,
	})
	n.LocatorSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorSize",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.MtApplicabilityForIPv6Locator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtApplicabilityForIPv6Locator",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistribution",
		isMultivalue: true,
	})
	n.ReservedFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedFlags",
		isMultivalue: true,
	})
	n.RouteMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeMetric",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.IsisPseudoSRv6EndSIDList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisPseudoSRv6EndSIDList",
	})
}

// TopologyIsisPseudoTraffEngProfile: ISIS Pseudo Node Traffic Engineering Profiles
type TopologyIsisPseudoTraffEngProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdministratorGroup: Administrator Group
	AdministratorGroup *Multivalue `json:"administratorGroup,omitempty"`
	// AdvAppSpecificTraffic: If this is set to True, link attributes will be advertised as sub-TLV of TLVs 22,23,141,222 and 223 If set to False, the link atrributes will be advertised as wither sub-sub-tlv of Application Specific Link Attributes sub-TLV (Type 26) or sub-tlv of TLVs 22,23,141,222 and 223 depending upon the configuration of L flag
	AdvAppSpecificTraffic *Multivalue `json:"advAppSpecificTraffic,omitempty"`
	// AdvMinMaxUniDiLinkDelay: Advertise Min/Max Uni-Directional Link Delay
	AdvMinMaxUniDiLinkDelay *Multivalue `json:"advMinMaxUniDiLinkDelay,omitempty"`
	// AdvUniDirAvailableBw: Advertise Uni-Directional Available BW
	AdvUniDirAvailableBw *Multivalue `json:"advUniDirAvailableBw,omitempty"`
	// AdvUniDirDelayVariation: Advertise Uni-Directional Delay Variation
	AdvUniDirDelayVariation *Multivalue `json:"advUniDirDelayVariation,omitempty"`
	// AdvUniDirLinkLoss: Advertise Uni-Directional Link Loss
	AdvUniDirLinkLoss *Multivalue `json:"advUniDirLinkLoss,omitempty"`
	// AdvUniDirResidualBw: Advertise Uni-Directional Residual BW
	AdvUniDirResidualBw *Multivalue `json:"advUniDirResidualBw,omitempty"`
	// AdvUniDirUtilizedBw: Advertise Uni-Directional Utilized BW
	AdvUniDirUtilizedBw *Multivalue `json:"advUniDirUtilizedBw,omitempty"`
	// AdvertiseExtAdminGroup: Advertise Ext Admin Group
	AdvertiseExtAdminGroup *Multivalue `json:"advertiseExtAdminGroup,omitempty"`
	// AdvertiseUniDiLinkDelay: Advertise Uni-Directional Link Delay
	AdvertiseUniDiLinkDelay *Multivalue `json:"advertiseUniDiLinkDelay,omitempty"`
	// BandwidthPriority0Bps: Bandwidth for Priority 0 (B/sec)
	BandwidthPriority0Bps *Multivalue `json:"bandwidthPriority0_Bps,omitempty"`
	// BandwidthPriority1Bps: Bandwidth for Priority 1 (B/sec)
	BandwidthPriority1Bps *Multivalue `json:"bandwidthPriority1_Bps,omitempty"`
	// BandwidthPriority2Bps: Bandwidth for Priority 2 (B/sec)
	BandwidthPriority2Bps *Multivalue `json:"bandwidthPriority2_Bps,omitempty"`
	// BandwidthPriority3Bps: Bandwidth for Priority 3 (B/sec)
	BandwidthPriority3Bps *Multivalue `json:"bandwidthPriority3_Bps,omitempty"`
	// BandwidthPriority4Bps: Bandwidth for Priority 4 (B/sec)
	BandwidthPriority4Bps *Multivalue `json:"bandwidthPriority4_Bps,omitempty"`
	// BandwidthPriority5Bps: Bandwidth for Priority 5 (B/sec)
	BandwidthPriority5Bps *Multivalue `json:"bandwidthPriority5_Bps,omitempty"`
	// BandwidthPriority6Bps: Bandwidth for Priority 6 (B/sec)
	BandwidthPriority6Bps *Multivalue `json:"bandwidthPriority6_Bps,omitempty"`
	// BandwidthPriority7Bps: Bandwidth for Priority 7 (B/sec)
	BandwidthPriority7Bps *Multivalue `json:"bandwidthPriority7_Bps,omitempty"`
	// ExtAdminGroup: Ext Admin Group
	ExtAdminGroup *Multivalue `json:"extAdminGroup,omitempty"`
	// ExtAdminGroupLength: Ext Admin Group Length
	ExtAdminGroupLength *Multivalue `json:"extAdminGroupLength,omitempty"`
	// LFlag: If set to False, all link attributes will be advertised as sub-sub-tlv of sub tlv Application Specific Link Attributes sub-TLV (Type 16) of TLV 22,23,141,222 and 223 If true, then all link attributes will be advertised as sub-TLV of TLV 22,23,141,222 and 223.
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MaxBandwidthBps: Maximum Bandwidth (B/sec)
	MaxBandwidthBps *Multivalue `json:"maxBandwidth_Bps,omitempty"`
	// MaxReservableBandwidthBps: Maximum Reservable Bandwidth (B/sec)
	MaxReservableBandwidthBps *Multivalue `json:"maxReservableBandwidth_Bps,omitempty"`
	// MetricLevel: Metric Level
	MetricLevel *Multivalue `json:"metricLevel,omitempty"`
	// MinMaxUniDirLinkDelayABit: A Bit
	MinMaxUniDirLinkDelayABit *Multivalue `json:"minMaxUniDirLinkDelayABit,omitempty"`
	// MtApplicabilityForIPv6: Multi-Topology Applicability for IPv6
	MtApplicabilityForIPv6 *Multivalue `json:"mtApplicabilityForIPv6,omitempty"`
	// MtId: MTID
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StdAppType: Standard Appplication Type
	StdAppType *Multivalue `json:"stdAppType,omitempty"`
	// UniDirAvailableBw: Available BW (B/sec)
	UniDirAvailableBw *Multivalue `json:"uniDirAvailableBw,omitempty"`
	// UniDirLinkDelay: Delay (us)
	UniDirLinkDelay *Multivalue `json:"uniDirLinkDelay,omitempty"`
	// UniDirLinkDelayABit: A Bit
	UniDirLinkDelayABit *Multivalue `json:"uniDirLinkDelayABit,omitempty"`
	// UniDirLinkDelayVariation: Delay Variation(us)
	UniDirLinkDelayVariation *Multivalue `json:"uniDirLinkDelayVariation,omitempty"`
	// UniDirLinkLoss: Link Loss(%)
	UniDirLinkLoss *Multivalue `json:"uniDirLinkLoss,omitempty"`
	// UniDirLinkLossABit: A Bit
	UniDirLinkLossABit *Multivalue `json:"uniDirLinkLossABit,omitempty"`
	// UniDirLinkMaxDelay: Delay(us)
	UniDirLinkMaxDelay *Multivalue `json:"uniDirLinkMaxDelay,omitempty"`
	// UniDirLinkMinDelay: Minimum Delay (us)
	UniDirLinkMinDelay *Multivalue `json:"uniDirLinkMinDelay,omitempty"`
	// UniDirResidualBw: Residual BW (B/sec)
	UniDirResidualBw *Multivalue `json:"uniDirResidualBw,omitempty"`
	// UniDirUtilizedBw: Utilized BW (Bytes/sec)
	UniDirUtilizedBw *Multivalue `json:"uniDirUtilizedBw,omitempty"`
	// UserDefAppBm: User Defined Application BM
	UserDefAppBm *Multivalue `json:"userDefAppBm,omitempty"`
	// UserDefAppBmLen: User Defined Application BM Length
	UserDefAppBmLen *Multivalue `json:"userDefAppBmLen,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisPseudoTraffEngProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisPseudoTraffEngProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisPseudoTraffEngProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisPseudoTraffEngProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdministratorGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administratorGroup",
		isMultivalue: true,
	})
	n.AdvAppSpecificTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advAppSpecificTraffic",
		isMultivalue: true,
	})
	n.AdvMinMaxUniDiLinkDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advMinMaxUniDiLinkDelay",
		isMultivalue: true,
	})
	n.AdvUniDirAvailableBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirAvailableBw",
		isMultivalue: true,
	})
	n.AdvUniDirDelayVariation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirDelayVariation",
		isMultivalue: true,
	})
	n.AdvUniDirLinkLoss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirLinkLoss",
		isMultivalue: true,
	})
	n.AdvUniDirResidualBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirResidualBw",
		isMultivalue: true,
	})
	n.AdvUniDirUtilizedBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirUtilizedBw",
		isMultivalue: true,
	})
	n.AdvertiseExtAdminGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseExtAdminGroup",
		isMultivalue: true,
	})
	n.AdvertiseUniDiLinkDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseUniDiLinkDelay",
		isMultivalue: true,
	})
	n.BandwidthPriority0Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority0_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority1Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority1_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority2Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority2_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority3Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority3_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority4Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority4_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority5Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority5_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority6Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority6_Bps",
		isMultivalue: true,
	})
	n.BandwidthPriority7Bps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority7_Bps",
		isMultivalue: true,
	})
	n.ExtAdminGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extAdminGroup",
		isMultivalue: true,
	})
	n.ExtAdminGroupLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extAdminGroupLength",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MaxBandwidthBps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxBandwidth_Bps",
		isMultivalue: true,
	})
	n.MaxReservableBandwidthBps.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxReservableBandwidth_Bps",
		isMultivalue: true,
	})
	n.MetricLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricLevel",
		isMultivalue: true,
	})
	n.MinMaxUniDirLinkDelayABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minMaxUniDirLinkDelayABit",
		isMultivalue: true,
	})
	n.MtApplicabilityForIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtApplicabilityForIPv6",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.StdAppType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stdAppType",
		isMultivalue: true,
	})
	n.UniDirAvailableBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirAvailableBw",
		isMultivalue: true,
	})
	n.UniDirLinkDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkDelay",
		isMultivalue: true,
	})
	n.UniDirLinkDelayABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkDelayABit",
		isMultivalue: true,
	})
	n.UniDirLinkDelayVariation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkDelayVariation",
		isMultivalue: true,
	})
	n.UniDirLinkLoss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkLoss",
		isMultivalue: true,
	})
	n.UniDirLinkLossABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkLossABit",
		isMultivalue: true,
	})
	n.UniDirLinkMaxDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkMaxDelay",
		isMultivalue: true,
	})
	n.UniDirLinkMinDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkMinDelay",
		isMultivalue: true,
	})
	n.UniDirResidualBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirResidualBw",
		isMultivalue: true,
	})
	n.UniDirUtilizedBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirUtilizedBw",
		isMultivalue: true,
	})
	n.UserDefAppBm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBm",
		isMultivalue: true,
	})
	n.UserDefAppBmLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBmLen",
		isMultivalue: true,
	})
}

// TopologyIsisSRv6AdjSidList: ISIS SRv6 Adj SID
type TopologyIsisSRv6AdjSidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseCustomSubTLV: Advertise Custom Sub-TLV
	AdvertiseCustomSubTLV *Multivalue `json:"advertiseCustomSubTLV,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ArgumentLength: Argument Length in Bits
	ArgumentLength *Multivalue `json:"argumentLength,omitempty"`
	// BFlag: B-Flag
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// CustomSubTlv: Custom Sub-TLV
	CustomSubTlv *Multivalue `json:"customSubTlv,omitempty"`
	// EndPointFunction: End-Point Function
	EndPointFunction *Multivalue `json:"endPointFunction,omitempty"`
	// FunctionLength: Function Length in Bits
	FunctionLength *Multivalue `json:"functionLength,omitempty"`
	// IncludeSRv6SIDStructureSubSubTlv: Include SRv6 SID Structure Sub-Sub-TLV
	IncludeSRv6SIDStructureSubSubTlv *Multivalue `json:"includeSRv6SIDStructureSubSubTlv,omitempty"`
	// Ipv6AdjSid: IPv6 Adj SID
	Ipv6AdjSid *Multivalue `json:"ipv6AdjSid,omitempty"`
	// LocatorBlockLength: Locator Block Length in Bits
	LocatorBlockLength *Multivalue `json:"locatorBlockLength,omitempty"`
	// LocatorNodeLength: Locator Node Length in Bits
	LocatorNodeLength *Multivalue `json:"locatorNodeLength,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlag: P-Flag
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// Reserved: Reserved
	Reserved *Multivalue `json:"reserved,omitempty"`
	// SFlag: S-Flag
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// Weight: Weight
	Weight *Multivalue `json:"weight,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSRv6AdjSidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSRv6AdjSidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSRv6AdjSidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSRv6AdjSidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseCustomSubTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseCustomSubTLV",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ArgumentLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLength",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.CustomSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSubTlv",
		isMultivalue: true,
	})
	n.EndPointFunction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointFunction",
		isMultivalue: true,
	})
	n.FunctionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLength",
		isMultivalue: true,
	})
	n.IncludeSRv6SIDStructureSubSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSRv6SIDStructureSubSubTlv",
		isMultivalue: true,
	})
	n.Ipv6AdjSid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6AdjSid",
		isMultivalue: true,
	})
	n.LocatorBlockLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorBlockLength",
		isMultivalue: true,
	})
	n.LocatorNodeLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorNodeLength",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.Reserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
}

// TopologyIsisSRv6EndSidList: ISIS SRv6 End SID
type TopologyIsisSRv6EndSidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseCustomSubTLV: Advertise Custom Sub-TLV
	AdvertiseCustomSubTLV *Multivalue `json:"advertiseCustomSubTLV,omitempty"`
	// ArgumentLength: Argument Length in Bits
	ArgumentLength *Multivalue `json:"argumentLength,omitempty"`
	// CustomSubTlv: Custom Sub-TLV
	CustomSubTlv *Multivalue `json:"customSubTlv,omitempty"`
	// EndPointFunction: End-Point Function
	EndPointFunction *Multivalue `json:"endPointFunction,omitempty"`
	// Flags: Flags
	Flags *Multivalue `json:"flags,omitempty"`
	// FunctionLength: Function Length in Bits
	FunctionLength *Multivalue `json:"functionLength,omitempty"`
	// IncludeSRv6SIDStructureSubSubTlv: Include SRv6 SID Structure Sub-Sub-TLV
	IncludeSRv6SIDStructureSubSubTlv *Multivalue `json:"includeSRv6SIDStructureSubSubTlv,omitempty"`
	// LocatorBlockLength: Locator Block Length in Bits
	LocatorBlockLength *Multivalue `json:"locatorBlockLength,omitempty"`
	// LocatorNodeLength: Locator Node Length in Bits
	LocatorNodeLength *Multivalue `json:"locatorNodeLength,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Sid: SID
	Sid *Multivalue `json:"sid,omitempty"`
	// SidName: SID Name
	SidName *Multivalue `json:"sidName,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSRv6EndSidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSRv6EndSidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSRv6EndSidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSRv6EndSidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseCustomSubTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseCustomSubTLV",
		isMultivalue: true,
	})
	n.ArgumentLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "argumentLength",
		isMultivalue: true,
	})
	n.CustomSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customSubTlv",
		isMultivalue: true,
	})
	n.EndPointFunction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointFunction",
		isMultivalue: true,
	})
	n.Flags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flags",
		isMultivalue: true,
	})
	n.FunctionLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "functionLength",
		isMultivalue: true,
	})
	n.IncludeSRv6SIDStructureSubSubTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSRv6SIDStructureSubSubTlv",
		isMultivalue: true,
	})
	n.LocatorBlockLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorBlockLength",
		isMultivalue: true,
	})
	n.LocatorNodeLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorNodeLength",
		isMultivalue: true,
	})
	n.Sid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sid",
		isMultivalue: true,
	})
	n.SidName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidName",
		isMultivalue: true,
	})
}

// TopologyIsisSRv6LocatorEntryList: ISIS SRv6 Locator Entry
type TopologyIsisSRv6LocatorEntryList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseLocatorAsPrefix: Advertise Locator as Prefix
	AdvertiseLocatorAsPrefix *Multivalue `json:"advertiseLocatorAsPrefix,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// DBit: D Bit
	DBit *Multivalue `json:"dBit,omitempty"`
	// Locator: Locator
	Locator *Multivalue `json:"locator,omitempty"`
	// LocatorName: Locator Name
	LocatorName *Multivalue `json:"locatorName,omitempty"`
	// LocatorSize: Locator Size
	LocatorSize *Multivalue `json:"locatorSize,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// MtApplicabilityForIPv6Locator: Multi-Topology Applicability for IPv6
	MtApplicabilityForIPv6Locator *Multivalue `json:"mtApplicabilityForIPv6Locator,omitempty"`
	// MtId: MTID
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// Redistribution: Redistribution
	Redistribution *Multivalue `json:"redistribution,omitempty"`
	// ReservedFlags: Reserved (Flags)
	ReservedFlags *Multivalue `json:"reservedFlags,omitempty"`
	// RouteMetric: Route Metric
	RouteMetric *Multivalue `json:"routeMetric,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// SidCount: SID Count

	SidCount *float32 `json:"sidCount,omitempty"`

	IsisSRv6EndSIDList *TopologyIsisSRv6EndSidList `json:"isisSRv6EndSIDList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSRv6LocatorEntryList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSRv6LocatorEntryList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSRv6LocatorEntryList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSRv6LocatorEntryList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseLocatorAsPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseLocatorAsPrefix",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.DBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dBit",
		isMultivalue: true,
	})
	n.Locator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locator",
		isMultivalue: true,
	})
	n.LocatorName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorName",
		isMultivalue: true,
	})
	n.LocatorSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "locatorSize",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.MtApplicabilityForIPv6Locator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtApplicabilityForIPv6Locator",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.Redistribution.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redistribution",
		isMultivalue: true,
	})
	n.ReservedFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedFlags",
		isMultivalue: true,
	})
	n.RouteMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeMetric",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.IsisSRv6EndSIDList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "isisSRv6EndSIDList",
	})
}

// TopologyIsisSegmentList: ISIS MPLS SR Tunnel Segments
type TopologyIsisSegmentList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enable: Enable
	Enable *Multivalue `json:"enable,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NeighbournodeSystemID: Neighbour Node System ID
	NeighbournodeSystemID *Multivalue `json:"neighbournodeSystemID,omitempty"`
	// NodeSystemID: Node System ID
	NodeSystemID *Multivalue `json:"nodeSystemID,omitempty"`
	// SegmentType: Segment Type
	SegmentType *Multivalue `json:"segmentType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSegmentList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSegmentList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSegmentList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSegmentList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable",
		isMultivalue: true,
	})
	n.NeighbournodeSystemID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "neighbournodeSystemID",
		isMultivalue: true,
	})
	n.NodeSystemID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeSystemID",
		isMultivalue: true,
	})
	n.SegmentType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "segmentType",
		isMultivalue: true,
	})
}

// TopologyIsisSpbBcb: ISIS Interface level Configuration
type TopologyIsisSpbBcb struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuthType: Authentication Type
	AuthType *Multivalue `json:"authType,omitempty"`
	// AutoAdjustArea: Auto Adjust Area
	AutoAdjustArea *Multivalue `json:"autoAdjustArea,omitempty"`
	// AutoAdjustMTU: Auto Adjust MTU
	AutoAdjustMTU *Multivalue `json:"autoAdjustMTU,omitempty"`
	// AutoAdjustSupportedProtocols: Auto Adjust Supported Protocols
	AutoAdjustSupportedProtocols *Multivalue `json:"autoAdjustSupportedProtocols,omitempty"`
	// CircuitTranmitPasswordOrMD5Key: Circuit Transmit Password / MD5-Key
	CircuitTranmitPasswordOrMD5Key *Multivalue `json:"circuitTranmitPasswordOrMD5Key,omitempty"`
	// ConfiguredHoldTime: Configured Hold Time
	ConfiguredHoldTime *Multivalue `json:"configuredHoldTime,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DeadInterval: Dead Interval (sec)
	DeadInterval *Multivalue `json:"deadInterval,omitempty"`
	// Enable3WayHandshake: Enable 3-way Handshake
	Enable3WayHandshake *Multivalue `json:"enable3WayHandshake,omitempty"`
	// EnableConfiguredHoldTime: Enable Configured Hold Time
	EnableConfiguredHoldTime *Multivalue `json:"enableConfiguredHoldTime,omitempty"`
	// ExtendedLocalCircuitId: Extended Local Circuit Id
	ExtendedLocalCircuitId *Multivalue `json:"extendedLocalCircuitId,omitempty"`
	// HelloInterval: Hello Interval (sec)
	HelloInterval *Multivalue `json:"helloInterval,omitempty"`
	// InterfaceMetric: Interface Metric
	InterfaceMetric *Multivalue `json:"interfaceMetric,omitempty"`
	// LevelType: Level Type
	LevelType *Multivalue `json:"levelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkType: Network Type
	NetworkType *Multivalue `json:"networkType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href                 `json:"-"`
	LearnedInfo       []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbBcb) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbBcb) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbBcb) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbBcb) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuthType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authType",
		isMultivalue: true,
	})
	n.AutoAdjustArea.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustArea",
		isMultivalue: true,
	})
	n.AutoAdjustMTU.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustMTU",
		isMultivalue: true,
	})
	n.AutoAdjustSupportedProtocols.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustSupportedProtocols",
		isMultivalue: true,
	})
	n.CircuitTranmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "circuitTranmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.ConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredHoldTime",
		isMultivalue: true,
	})
	n.DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "deadInterval",
		isMultivalue: true,
	})
	n.Enable3WayHandshake.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable3WayHandshake",
		isMultivalue: true,
	})
	n.EnableConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableConfiguredHoldTime",
		isMultivalue: true,
	})
	n.ExtendedLocalCircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extendedLocalCircuitId",
		isMultivalue: true,
	})
	n.HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloInterval",
		isMultivalue: true,
	})
	n.InterfaceMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceMetric",
		isMultivalue: true,
	})
	n.LevelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "levelType",
		isMultivalue: true,
	})
	n.NetworkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkType",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisSpbBeb: ISIS Interface level Configuration
type TopologyIsisSpbBeb struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuthType: Authentication Type
	AuthType *Multivalue `json:"authType,omitempty"`
	// AutoAdjustArea: Auto Adjust Area
	AutoAdjustArea *Multivalue `json:"autoAdjustArea,omitempty"`
	// AutoAdjustMTU: Auto Adjust MTU
	AutoAdjustMTU *Multivalue `json:"autoAdjustMTU,omitempty"`
	// AutoAdjustSupportedProtocols: Auto Adjust Supported Protocols
	AutoAdjustSupportedProtocols *Multivalue `json:"autoAdjustSupportedProtocols,omitempty"`
	// CircuitTranmitPasswordOrMD5Key: Circuit Transmit Password / MD5-Key
	CircuitTranmitPasswordOrMD5Key *Multivalue `json:"circuitTranmitPasswordOrMD5Key,omitempty"`
	// ConfiguredHoldTime: Configured Hold Time
	ConfiguredHoldTime *Multivalue `json:"configuredHoldTime,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DeadInterval: Dead Interval (sec)
	DeadInterval *Multivalue `json:"deadInterval,omitempty"`
	// Enable3WayHandshake: Enable 3-way Handshake
	Enable3WayHandshake *Multivalue `json:"enable3WayHandshake,omitempty"`
	// EnableConfiguredHoldTime: Enable Configured Hold Time
	EnableConfiguredHoldTime *Multivalue `json:"enableConfiguredHoldTime,omitempty"`
	// ExtendedLocalCircuitId: Extended Local Circuit Id
	ExtendedLocalCircuitId *Multivalue `json:"extendedLocalCircuitId,omitempty"`
	// HelloInterval: Hello Interval (sec)
	HelloInterval *Multivalue `json:"helloInterval,omitempty"`
	// InterfaceMetric: Interface Metric
	InterfaceMetric *Multivalue `json:"interfaceMetric,omitempty"`
	// LevelType: Level Type
	LevelType *Multivalue `json:"levelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkType: Network Type
	NetworkType *Multivalue `json:"networkType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href                 `json:"-"`
	LearnedInfo       []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbBeb) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbBeb) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbBeb) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbBeb) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuthType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authType",
		isMultivalue: true,
	})
	n.AutoAdjustArea.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustArea",
		isMultivalue: true,
	})
	n.AutoAdjustMTU.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustMTU",
		isMultivalue: true,
	})
	n.AutoAdjustSupportedProtocols.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustSupportedProtocols",
		isMultivalue: true,
	})
	n.CircuitTranmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "circuitTranmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.ConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredHoldTime",
		isMultivalue: true,
	})
	n.DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "deadInterval",
		isMultivalue: true,
	})
	n.Enable3WayHandshake.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable3WayHandshake",
		isMultivalue: true,
	})
	n.EnableConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableConfiguredHoldTime",
		isMultivalue: true,
	})
	n.ExtendedLocalCircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extendedLocalCircuitId",
		isMultivalue: true,
	})
	n.HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloInterval",
		isMultivalue: true,
	})
	n.InterfaceMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceMetric",
		isMultivalue: true,
	})
	n.LevelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "levelType",
		isMultivalue: true,
	})
	n.NetworkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkType",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisSpbMacCloudConfig: Isis Spb MAC Cloud specific configuration
type TopologyIsisSpbMacCloudConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Isid: ISID
	Isid *Multivalue `json:"isid,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name                *string                        `json:"name,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbMacCloudConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbMacCloudConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbMacCloudConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbMacCloudConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Isid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "isid",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisSpbPseudoIfaceAttPoint1Config: ISIS-SPB Pseudo Interface Attribute Configuration
type TopologyIsisSpbPseudoIfaceAttPoint1Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbPseudoIfaceAttPoint1Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbPseudoIfaceAttPoint1Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbPseudoIfaceAttPoint1Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbPseudoIfaceAttPoint1Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisSpbPseudoIfaceAttPoint2Config: ISIS-SPB Pseudo Interface Attribute Configuration
type TopologyIsisSpbPseudoIfaceAttPoint2Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbPseudoIfaceAttPoint2Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbPseudoIfaceAttPoint2Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbPseudoIfaceAttPoint2Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbPseudoIfaceAttPoint2Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisSpbPseudoNode: SPB Pseudo Node Configuration
type TopologyIsisSpbPseudoNode struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BridgePriority: Bridge Priority
	BridgePriority *Multivalue `json:"bridgePriority,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SpSourceId: SP Source Id
	SpSourceId *Multivalue `json:"spSourceId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbPseudoNode) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbPseudoNode) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbPseudoNode) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbPseudoNode) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BridgePriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bridgePriority",
		isMultivalue: true,
	})
	n.SpSourceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "spSourceId",
		isMultivalue: true,
	})
}

// TopologyIsisSpbRouter: SPB Configuration
type TopologyIsisSpbRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AreaAddresses: Area Addresses
	AreaAddresses *Multivalue `json:"areaAddresses,omitempty"`
	// AreaAuthenticationType: Area Authentication Type
	AreaAuthenticationType *Multivalue `json:"areaAuthenticationType,omitempty"`
	// AreaTransmitPasswordOrMD5Key: Area Transmit Password / MD5-Key
	AreaTransmitPasswordOrMD5Key *Multivalue `json:"areaTransmitPasswordOrMD5Key,omitempty"`
	// Attached: Attached
	Attached *Multivalue `json:"attached,omitempty"`
	// CSNPInterval: CSNP Interval (ms)
	CSNPInterval *Multivalue `json:"cSNPInterval,omitempty"`
	// DiscardLSPs: Discard LSPs
	DiscardLSPs *Multivalue `json:"discardLSPs,omitempty"`
	// EnableHelloPadding: Enable Hello Padding
	EnableHelloPadding *Multivalue `json:"enableHelloPadding,omitempty"`
	// EnableHitlessRestart: Enable Hitless Restart
	EnableHitlessRestart *Multivalue `json:"enableHitlessRestart,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// EnableWideMetric: Enable Wide Metric
	EnableWideMetric *Multivalue `json:"enableWideMetric,omitempty"`
	// HitlessRestartMode: Restart Mode
	HitlessRestartMode *Multivalue `json:"hitlessRestartMode,omitempty"`
	// HitlessRestartTime: Restart Time
	HitlessRestartTime *Multivalue `json:"hitlessRestartTime,omitempty"`
	// HitlessRestartVersion: Restart Version
	HitlessRestartVersion *Multivalue `json:"hitlessRestartVersion,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// IgnoreMTPortCapability: Ignore MT Port Capability
	IgnoreMTPortCapability *Multivalue `json:"ignoreMTPortCapability,omitempty"`
	// IgnoreReceiveMD5: Ignore Receive MD5
	IgnoreReceiveMD5 *Multivalue `json:"ignoreReceiveMD5,omitempty"`
	// InterLSPsOrMGroupPDUBurstGap: Inter LSPs/MGROUP-PDUs Burst Gap (ms)
	InterLSPsOrMGroupPDUBurstGap *Multivalue `json:"interLSPsOrMGroupPDUBurstGap,omitempty"`
	// LSPLifetime: LSP Rifetime (sec)
	LSPLifetime *Multivalue `json:"lSPLifetime,omitempty"`
	// LSPRefreshRate: LSP Refresh Rate (sec)
	LSPRefreshRate *Multivalue `json:"lSPRefreshRate,omitempty"`
	// LSPorMGroupPDUMinTransmissionInterval: LSP/MGROUP-PDU Min Transmission Interval (ms)
	LSPorMGroupPDUMinTransmissionInterval *Multivalue `json:"lSPorMGroupPDUMinTransmissionInterval,omitempty"`
	// MaxAreaAddresses: Maximum Area Addresses
	MaxAreaAddresses *Multivalue `json:"maxAreaAddresses,omitempty"`
	// MaxLSPSize: Max LSP Size
	MaxLSPSize *Multivalue `json:"maxLSPSize,omitempty"`
	// MaxLSPsOrMGroupPDUsPerBurst: Max LSPs/MGROUP-PDUs Per Burst
	MaxLSPsOrMGroupPDUsPerBurst *Multivalue `json:"maxLSPsOrMGroupPDUsPerBurst,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Overloaded: Overloaded
	Overloaded *Multivalue `json:"overloaded,omitempty"`
	// PSNPInterval: PSNP Interval (ms)
	PSNPInterval *Multivalue `json:"pSNPInterval,omitempty"`
	// PartitionRepair: Partition Repair
	PartitionRepair *Multivalue `json:"partitionRepair,omitempty"`
	// SpbTopologyCount: Topology Count(multiplier)

	SpbTopologyCount *float32 `json:"spbTopologyCount,omitempty"`

	SpbTopologyList *TopologySpbTopologyList `json:"spbTopologyList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAddresses",
		isMultivalue: true,
	})
	n.AreaAuthenticationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAuthenticationType",
		isMultivalue: true,
	})
	n.AreaTransmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaTransmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.Attached.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attached",
		isMultivalue: true,
	})
	n.CSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cSNPInterval",
		isMultivalue: true,
	})
	n.DiscardLSPs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLSPs",
		isMultivalue: true,
	})
	n.EnableHelloPadding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloPadding",
		isMultivalue: true,
	})
	n.EnableHitlessRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHitlessRestart",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.EnableWideMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWideMetric",
		isMultivalue: true,
	})
	n.HitlessRestartMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hitlessRestartMode",
		isMultivalue: true,
	})
	n.HitlessRestartTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hitlessRestartTime",
		isMultivalue: true,
	})
	n.HitlessRestartVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hitlessRestartVersion",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.IgnoreMTPortCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreMTPortCapability",
		isMultivalue: true,
	})
	n.IgnoreReceiveMD5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreReceiveMD5",
		isMultivalue: true,
	})
	n.InterLSPsOrMGroupPDUBurstGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interLSPsOrMGroupPDUBurstGap",
		isMultivalue: true,
	})
	n.LSPLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPLifetime",
		isMultivalue: true,
	})
	n.LSPRefreshRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPRefreshRate",
		isMultivalue: true,
	})
	n.LSPorMGroupPDUMinTransmissionInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPorMGroupPDUMinTransmissionInterval",
		isMultivalue: true,
	})
	n.MaxAreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxAreaAddresses",
		isMultivalue: true,
	})
	n.MaxLSPSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPSize",
		isMultivalue: true,
	})
	n.MaxLSPsOrMGroupPDUsPerBurst.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPsOrMGroupPDUsPerBurst",
		isMultivalue: true,
	})
	n.Overloaded.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overloaded",
		isMultivalue: true,
	})
	n.PSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pSNPInterval",
		isMultivalue: true,
	})
	n.PartitionRepair.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partitionRepair",
		isMultivalue: true,
	})
	n.SpbTopologyList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "spbTopologyList",
	})
}

// TopologyIsisSpbSimRouter: SPB Simulated Router Edge
type TopologyIsisSpbSimRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BridgePriority: Bridge Priority
	BridgePriority *Multivalue `json:"bridgePriority,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SpSourceId: SP Source Id
	SpSourceId *Multivalue `json:"spSourceId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SystemId: System Id
	SystemId *Multivalue `json:"systemId,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	SpbSimEdgeTopologyList *TopologySpbSimEdgeTopologyList `json:"spbSimEdgeTopologyList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbSimRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbSimRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbSimRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbSimRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BridgePriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bridgePriority",
		isMultivalue: true,
	})
	n.SpSourceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "spSourceId",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.SpbSimEdgeTopologyList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "spbSimEdgeTopologyList",
	})
}

// TopologyIsisSpbSimulatedTopologyConfig: SPB Simulated Edge Topology Configuration
type TopologyIsisSpbSimulatedTopologyConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// InterfaceMetric: Interface Metric
	InterfaceMetric *Multivalue `json:"interfaceMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SpbNodeTopologyCount: Node Topology Count(multiplier)

	SpbNodeTopologyCount *float32 `json:"spbNodeTopologyCount,omitempty"`

	SpbNodeTopologyList *TopologySpbNodeTopologyList `json:"spbNodeTopologyList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSpbSimulatedTopologyConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSpbSimulatedTopologyConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSpbSimulatedTopologyConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSpbSimulatedTopologyConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.InterfaceMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceMetric",
		isMultivalue: true,
	})
	n.SpbNodeTopologyList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "spbNodeTopologyList",
	})
}

// TopologyIsisSrAlgorithmList: Isis SR Algorithms
type TopologyIsisSrAlgorithmList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsisSrAlgorithm: SR Algorithm
	IsisSrAlgorithm *Multivalue `json:"isisSrAlgorithm,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSrAlgorithmList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSrAlgorithmList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSrAlgorithmList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSrAlgorithmList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.IsisSrAlgorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "isisSrAlgorithm",
		isMultivalue: true,
	})
}

// TopologyIsisSrTunnelList: ISIS MPLS SR Tunnel
type TopologyIsisSrTunnelList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfSegments: Number of Segments

	NumberOfSegments *float32 `json:"numberOfSegments,omitempty"`
	// SourceIpv4: Source IPv4
	SourceIpv4 *Multivalue `json:"sourceIpv4,omitempty"`
	// SourceIpv6: Source IPv6
	SourceIpv6 *Multivalue `json:"sourceIpv6,omitempty"`
	// TunnelDescription: Tunnel Description
	TunnelDescription *Multivalue `json:"tunnelDescription,omitempty"`
	// UsingHeadEndNodePrefix: Using head end Node prefix
	UsingHeadEndNodePrefix *Multivalue                `json:"usingHeadEndNodePrefix,omitempty"`
	IsisSegmentList        []*TopologyIsisSegmentList `json:"isisSegmentList"`
	Tag                    []*TopologyTag             `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSrTunnelList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSrTunnelList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSrTunnelList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSrTunnelList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.SourceIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv4",
		isMultivalue: true,
	})
	n.SourceIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv6",
		isMultivalue: true,
	})
	n.TunnelDescription.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelDescription",
		isMultivalue: true,
	})
	n.UsingHeadEndNodePrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "usingHeadEndNodePrefix",
		isMultivalue: true,
	})
	for i, o := range n.IsisSegmentList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSegmentList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisSrgbRangeSubObjectsList: Isis SRGB Range Sub Objects
type TopologyIsisSrgbRangeSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SIDCount: SID Count
	SIDCount *Multivalue `json:"sIDCount,omitempty"`
	// StartSIDLabel: Start SID/Label
	StartSIDLabel *Multivalue `json:"startSIDLabel,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSrgbRangeSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSrgbRangeSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSrgbRangeSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSrgbRangeSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SIDCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDCount",
		isMultivalue: true,
	})
	n.StartSIDLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSIDLabel",
		isMultivalue: true,
	})
}

// TopologyIsisSrlbDescriptorList: Isis SRLB Descriptor Entries
type TopologyIsisSrlbDescriptorList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SIDCount: SID Count
	SIDCount *Multivalue `json:"sIDCount,omitempty"`
	// StartSIDLabel: Start SID/Label
	StartSIDLabel *Multivalue `json:"startSIDLabel,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisSrlbDescriptorList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisSrlbDescriptorList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisSrlbDescriptorList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisSrlbDescriptorList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SIDCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sIDCount",
		isMultivalue: true,
	})
	n.StartSIDLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSIDLabel",
		isMultivalue: true,
	})
}

// TopologyIsisTrafficEngineering: Isis Traffic Engineering Configuration
type TopologyIsisTrafficEngineering struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdministratorGroup: Administrator Group
	AdministratorGroup *Multivalue `json:"administratorGroup,omitempty"`
	// BandwidthPriority0: Bandwidth for Priority 0 (B/sec)
	BandwidthPriority0 *Multivalue `json:"bandwidthPriority0,omitempty"`
	// BandwidthPriority1: Bandwidth for Priority 1 (B/sec)
	BandwidthPriority1 *Multivalue `json:"bandwidthPriority1,omitempty"`
	// BandwidthPriority2: Bandwidth for Priority 2 (B/sec)
	BandwidthPriority2 *Multivalue `json:"bandwidthPriority2,omitempty"`
	// BandwidthPriority3: Bandwidth for Priority 3 (B/sec)
	BandwidthPriority3 *Multivalue `json:"bandwidthPriority3,omitempty"`
	// BandwidthPriority4: Bandwidth for Priority 4 (B/sec)
	BandwidthPriority4 *Multivalue `json:"bandwidthPriority4,omitempty"`
	// BandwidthPriority5: Bandwidth for Priority 5 (B/sec)
	BandwidthPriority5 *Multivalue `json:"bandwidthPriority5,omitempty"`
	// BandwidthPriority6: Bandwidth for Priority 6 (B/sec)
	BandwidthPriority6 *Multivalue `json:"bandwidthPriority6,omitempty"`
	// BandwidthPriority7: Bandwidth for Priority 7 (B/sec)
	BandwidthPriority7 *Multivalue `json:"bandwidthPriority7,omitempty"`
	// MaxBandwidth: Maximum Bandwidth (B/sec)
	MaxBandwidth *Multivalue `json:"maxBandwidth,omitempty"`
	// MaxReservableBandwidth: Maximum Reservable Bandwidth (B/sec)
	MaxReservableBandwidth *Multivalue `json:"maxReservableBandwidth,omitempty"`
	// MetricLevel: TE Metric Level
	MetricLevel *Multivalue `json:"metricLevel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrafficEngineering) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrafficEngineering) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrafficEngineering) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrafficEngineering) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdministratorGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administratorGroup",
		isMultivalue: true,
	})
	n.BandwidthPriority0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority0",
		isMultivalue: true,
	})
	n.BandwidthPriority1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority1",
		isMultivalue: true,
	})
	n.BandwidthPriority2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority2",
		isMultivalue: true,
	})
	n.BandwidthPriority3.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority3",
		isMultivalue: true,
	})
	n.BandwidthPriority4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority4",
		isMultivalue: true,
	})
	n.BandwidthPriority5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority5",
		isMultivalue: true,
	})
	n.BandwidthPriority6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority6",
		isMultivalue: true,
	})
	n.BandwidthPriority7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority7",
		isMultivalue: true,
	})
	n.MaxBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxBandwidth",
		isMultivalue: true,
	})
	n.MaxReservableBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxReservableBandwidth",
		isMultivalue: true,
	})
	n.MetricLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricLevel",
		isMultivalue: true,
	})
}

// TopologyIsisTrafficEngineeringProfileList: ISIS Traffic Engineering Profiles
type TopologyIsisTrafficEngineeringProfileList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdministratorGroup: Administrator Group
	AdministratorGroup *Multivalue `json:"administratorGroup,omitempty"`
	// AdvAppSpecificTraffic: If this is set to True, link attributes will be advertised as sub-TLV of TLVs 22,23,141,222 and 223 If set to False, the link atrributes will be advertised as wither sub-sub-tlv of Application Specific Link Attributes sub-TLV (Type 26) or sub-tlv of TLVs 22,23,141,222 and 223 depending upon the configuration of L flag
	AdvAppSpecificTraffic *Multivalue `json:"advAppSpecificTraffic,omitempty"`
	// AdvMinMaxUniDiLinkDelay: Advertise Min/Max Uni-Directional Link Delay
	AdvMinMaxUniDiLinkDelay *Multivalue `json:"advMinMaxUniDiLinkDelay,omitempty"`
	// AdvUniDirAvailableBw: Advertise Uni-Directional Available BW
	AdvUniDirAvailableBw *Multivalue `json:"advUniDirAvailableBw,omitempty"`
	// AdvUniDirDelayVariation: Advertise Uni-Directional Delay Variation
	AdvUniDirDelayVariation *Multivalue `json:"advUniDirDelayVariation,omitempty"`
	// AdvUniDirLinkLoss: Advertise Uni-Directional Link Loss
	AdvUniDirLinkLoss *Multivalue `json:"advUniDirLinkLoss,omitempty"`
	// AdvUniDirResidualBw: Advertise Uni-Directional Residual BW
	AdvUniDirResidualBw *Multivalue `json:"advUniDirResidualBw,omitempty"`
	// AdvUniDirUtilizedBw: Advertise Uni-Directional Utilized BW
	AdvUniDirUtilizedBw *Multivalue `json:"advUniDirUtilizedBw,omitempty"`
	// AdvertiseExtAdminGroup: Advertise Ext Admin Group
	AdvertiseExtAdminGroup *Multivalue `json:"advertiseExtAdminGroup,omitempty"`
	// AdvertiseUniDiLinkDelay: Advertise Uni-Directional Link Delay
	AdvertiseUniDiLinkDelay *Multivalue `json:"advertiseUniDiLinkDelay,omitempty"`
	// BandwidthPriority0: Bandwidth for Priority 0 (B/sec)
	BandwidthPriority0 *Multivalue `json:"bandwidthPriority0,omitempty"`
	// BandwidthPriority1: Bandwidth for Priority 1 (B/sec)
	BandwidthPriority1 *Multivalue `json:"bandwidthPriority1,omitempty"`
	// BandwidthPriority2: Bandwidth for Priority 2 (B/sec)
	BandwidthPriority2 *Multivalue `json:"bandwidthPriority2,omitempty"`
	// BandwidthPriority3: Bandwidth for Priority 3 (B/sec)
	BandwidthPriority3 *Multivalue `json:"bandwidthPriority3,omitempty"`
	// BandwidthPriority4: Bandwidth for Priority 4 (B/sec)
	BandwidthPriority4 *Multivalue `json:"bandwidthPriority4,omitempty"`
	// BandwidthPriority5: Bandwidth for Priority 5 (B/sec)
	BandwidthPriority5 *Multivalue `json:"bandwidthPriority5,omitempty"`
	// BandwidthPriority6: Bandwidth for Priority 6 (B/sec)
	BandwidthPriority6 *Multivalue `json:"bandwidthPriority6,omitempty"`
	// BandwidthPriority7: Bandwidth for Priority 7 (B/sec)
	BandwidthPriority7 *Multivalue `json:"bandwidthPriority7,omitempty"`
	// ExtAdminGroup: Ext Admin Group
	ExtAdminGroup *Multivalue `json:"extAdminGroup,omitempty"`
	// ExtAdminGroupLength: Ext Admin Group Length
	ExtAdminGroupLength *Multivalue `json:"extAdminGroupLength,omitempty"`
	// LFlag: If set to False, all link attributes will be advertised as sub-sub-tlv of sub tlv Application Specific Link Attributes sub-TLV (Type 16) of TLV 22,23,141,222 and 223 If true, then all link attributes will be advertised as sub-TLV of TLV 22,23,141,222 and 223.
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MaxBandwidth: Maximum Bandwidth (B/sec)
	MaxBandwidth *Multivalue `json:"maxBandwidth,omitempty"`
	// MaxReservableBandwidth: Maximum Reservable Bandwidth (B/sec)
	MaxReservableBandwidth *Multivalue `json:"maxReservableBandwidth,omitempty"`
	// MetricLevel: TE Metric Level
	MetricLevel *Multivalue `json:"metricLevel,omitempty"`
	// MinMaxUniDirLinkDelayABit: A Bit
	MinMaxUniDirLinkDelayABit *Multivalue `json:"minMaxUniDirLinkDelayABit,omitempty"`
	// MtApplicabilityForIPv6: Multi-Topology Applicability for IPv6
	MtApplicabilityForIPv6 *Multivalue `json:"mtApplicabilityForIPv6,omitempty"`
	// MtId: MTID
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StdAppType: Standard Appplication Type
	StdAppType *Multivalue `json:"stdAppType,omitempty"`
	// UniDirAvailableBw: Available BW (B/sec)
	UniDirAvailableBw *Multivalue `json:"uniDirAvailableBw,omitempty"`
	// UniDirLinkDelay: Delay (us)
	UniDirLinkDelay *Multivalue `json:"uniDirLinkDelay,omitempty"`
	// UniDirLinkDelayABit: A Bit
	UniDirLinkDelayABit *Multivalue `json:"uniDirLinkDelayABit,omitempty"`
	// UniDirLinkDelayVariation: Delay Variation(us)
	UniDirLinkDelayVariation *Multivalue `json:"uniDirLinkDelayVariation,omitempty"`
	// UniDirLinkLoss: Link Loss(%)
	UniDirLinkLoss *Multivalue `json:"uniDirLinkLoss,omitempty"`
	// UniDirLinkLossABit: A Bit
	UniDirLinkLossABit *Multivalue `json:"uniDirLinkLossABit,omitempty"`
	// UniDirLinkMaxDelay: Delay(us)
	UniDirLinkMaxDelay *Multivalue `json:"uniDirLinkMaxDelay,omitempty"`
	// UniDirLinkMinDelay: Minimum Delay (us)
	UniDirLinkMinDelay *Multivalue `json:"uniDirLinkMinDelay,omitempty"`
	// UniDirResidualBw: Residual BW (B/sec)
	UniDirResidualBw *Multivalue `json:"uniDirResidualBw,omitempty"`
	// UniDirUtilizedBw: Utilized BW (B/sec)
	UniDirUtilizedBw *Multivalue `json:"uniDirUtilizedBw,omitempty"`
	// UserDefAppBm: User Defined Application BM
	UserDefAppBm *Multivalue `json:"userDefAppBm,omitempty"`
	// UserDefAppBmLen: User Defined Application BM Length
	UserDefAppBmLen *Multivalue `json:"userDefAppBmLen,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrafficEngineeringProfileList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrafficEngineeringProfileList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrafficEngineeringProfileList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrafficEngineeringProfileList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdministratorGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administratorGroup",
		isMultivalue: true,
	})
	n.AdvAppSpecificTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advAppSpecificTraffic",
		isMultivalue: true,
	})
	n.AdvMinMaxUniDiLinkDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advMinMaxUniDiLinkDelay",
		isMultivalue: true,
	})
	n.AdvUniDirAvailableBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirAvailableBw",
		isMultivalue: true,
	})
	n.AdvUniDirDelayVariation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirDelayVariation",
		isMultivalue: true,
	})
	n.AdvUniDirLinkLoss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirLinkLoss",
		isMultivalue: true,
	})
	n.AdvUniDirResidualBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirResidualBw",
		isMultivalue: true,
	})
	n.AdvUniDirUtilizedBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advUniDirUtilizedBw",
		isMultivalue: true,
	})
	n.AdvertiseExtAdminGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseExtAdminGroup",
		isMultivalue: true,
	})
	n.AdvertiseUniDiLinkDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseUniDiLinkDelay",
		isMultivalue: true,
	})
	n.BandwidthPriority0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority0",
		isMultivalue: true,
	})
	n.BandwidthPriority1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority1",
		isMultivalue: true,
	})
	n.BandwidthPriority2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority2",
		isMultivalue: true,
	})
	n.BandwidthPriority3.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority3",
		isMultivalue: true,
	})
	n.BandwidthPriority4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority4",
		isMultivalue: true,
	})
	n.BandwidthPriority5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority5",
		isMultivalue: true,
	})
	n.BandwidthPriority6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority6",
		isMultivalue: true,
	})
	n.BandwidthPriority7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority7",
		isMultivalue: true,
	})
	n.ExtAdminGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extAdminGroup",
		isMultivalue: true,
	})
	n.ExtAdminGroupLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extAdminGroupLength",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MaxBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxBandwidth",
		isMultivalue: true,
	})
	n.MaxReservableBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxReservableBandwidth",
		isMultivalue: true,
	})
	n.MetricLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricLevel",
		isMultivalue: true,
	})
	n.MinMaxUniDirLinkDelayABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minMaxUniDirLinkDelayABit",
		isMultivalue: true,
	})
	n.MtApplicabilityForIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtApplicabilityForIPv6",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.StdAppType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stdAppType",
		isMultivalue: true,
	})
	n.UniDirAvailableBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirAvailableBw",
		isMultivalue: true,
	})
	n.UniDirLinkDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkDelay",
		isMultivalue: true,
	})
	n.UniDirLinkDelayABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkDelayABit",
		isMultivalue: true,
	})
	n.UniDirLinkDelayVariation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkDelayVariation",
		isMultivalue: true,
	})
	n.UniDirLinkLoss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkLoss",
		isMultivalue: true,
	})
	n.UniDirLinkLossABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkLossABit",
		isMultivalue: true,
	})
	n.UniDirLinkMaxDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkMaxDelay",
		isMultivalue: true,
	})
	n.UniDirLinkMinDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirLinkMinDelay",
		isMultivalue: true,
	})
	n.UniDirResidualBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirResidualBw",
		isMultivalue: true,
	})
	n.UniDirUtilizedBw.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniDirUtilizedBw",
		isMultivalue: true,
	})
	n.UserDefAppBm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBm",
		isMultivalue: true,
	})
	n.UserDefAppBmLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefAppBmLen",
		isMultivalue: true,
	})
}

// TopologyIsisTrill: ISIS Interface level Configuration
type TopologyIsisTrill struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuthType: Authentication Type
	AuthType *Multivalue `json:"authType,omitempty"`
	// AutoAdjustArea: Auto Adjust Area
	AutoAdjustArea *Multivalue `json:"autoAdjustArea,omitempty"`
	// AutoAdjustMTU: Auto Adjust MTU
	AutoAdjustMTU *Multivalue `json:"autoAdjustMTU,omitempty"`
	// AutoAdjustSupportedProtocols: Auto Adjust Supported Protocols
	AutoAdjustSupportedProtocols *Multivalue `json:"autoAdjustSupportedProtocols,omitempty"`
	// CircuitTranmitPasswordOrMD5Key: Circuit Transmit Password / MD5-Key
	CircuitTranmitPasswordOrMD5Key *Multivalue `json:"circuitTranmitPasswordOrMD5Key,omitempty"`
	// ConfiguredHoldTime: Configured Hold Time
	ConfiguredHoldTime *Multivalue `json:"configuredHoldTime,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Enable3WayHandshake: Enable 3-way Handshake
	Enable3WayHandshake *Multivalue `json:"enable3WayHandshake,omitempty"`
	// EnableConfiguredHoldTime: Enable Configured Hold Time
	EnableConfiguredHoldTime *Multivalue `json:"enableConfiguredHoldTime,omitempty"`
	// ExtendedLocalCircuitId: Extended Local Circuit Id
	ExtendedLocalCircuitId *Multivalue `json:"extendedLocalCircuitId,omitempty"`
	// InterfaceMetric: Interface Metric
	InterfaceMetric *Multivalue `json:"interfaceMetric,omitempty"`
	// Level1DeadInterval: Level 1 Dead Interval (sec)
	Level1DeadInterval *Multivalue `json:"level1DeadInterval,omitempty"`
	// Level1HelloInterval: Level 1 Hello Interval (sec)
	Level1HelloInterval *Multivalue `json:"level1HelloInterval,omitempty"`
	// Level1Priority: Level 1 Priority
	Level1Priority *Multivalue `json:"level1Priority,omitempty"`
	// LevelType: Level Type
	LevelType *Multivalue `json:"levelType,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkType: Network Type
	NetworkType *Multivalue `json:"networkType,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Connector   *TopologyConnector     `json:"connector,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrill) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrill) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrill) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrill) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuthType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authType",
		isMultivalue: true,
	})
	n.AutoAdjustArea.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustArea",
		isMultivalue: true,
	})
	n.AutoAdjustMTU.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustMTU",
		isMultivalue: true,
	})
	n.AutoAdjustSupportedProtocols.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoAdjustSupportedProtocols",
		isMultivalue: true,
	})
	n.CircuitTranmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "circuitTranmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.ConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configuredHoldTime",
		isMultivalue: true,
	})
	n.Enable3WayHandshake.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable3WayHandshake",
		isMultivalue: true,
	})
	n.EnableConfiguredHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableConfiguredHoldTime",
		isMultivalue: true,
	})
	n.ExtendedLocalCircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extendedLocalCircuitId",
		isMultivalue: true,
	})
	n.InterfaceMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceMetric",
		isMultivalue: true,
	})
	n.Level1DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1DeadInterval",
		isMultivalue: true,
	})
	n.Level1HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1HelloInterval",
		isMultivalue: true,
	})
	n.Level1Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "level1Priority",
		isMultivalue: true,
	})
	n.LevelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "levelType",
		isMultivalue: true,
	})
	n.NetworkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkType",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyIsisTrillPseudoIfaceAttPoint1Config: TRILL Pseudo Interface Attribute Configuration
type TopologyIsisTrillPseudoIfaceAttPoint1Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrillPseudoIfaceAttPoint1Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrillPseudoIfaceAttPoint1Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrillPseudoIfaceAttPoint1Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrillPseudoIfaceAttPoint1Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisTrillPseudoIfaceAttPoint2Config: TRILL Pseudo Interface Attribute Configuration
type TopologyIsisTrillPseudoIfaceAttPoint2Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrillPseudoIfaceAttPoint2Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrillPseudoIfaceAttPoint2Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrillPseudoIfaceAttPoint2Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrillPseudoIfaceAttPoint2Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
}

// TopologyIsisTrillPseudoNode: TRILL Pseudo Node Configuration
type TopologyIsisTrillPseudoNode struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BroadcastRootPriority: Broadcast Root Priority
	BroadcastRootPriority *Multivalue `json:"broadcastRootPriority,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrillPseudoNode) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrillPseudoNode) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrillPseudoNode) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrillPseudoNode) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BroadcastRootPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "broadcastRootPriority",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
}

// TopologyIsisTrillRouter: TRILL Configuration
type TopologyIsisTrillRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AreaAddresses: Area Addresses
	AreaAddresses *Multivalue `json:"areaAddresses,omitempty"`
	// AreaAuthenticationType: Area Authentication Type
	AreaAuthenticationType *Multivalue `json:"areaAuthenticationType,omitempty"`
	// AreaTransmitPasswordOrMD5Key: Area Transmit Password / MD5-Key
	AreaTransmitPasswordOrMD5Key *Multivalue `json:"areaTransmitPasswordOrMD5Key,omitempty"`
	// Attached: Attached
	Attached *Multivalue `json:"attached,omitempty"`
	// CSNPInterval: CSNP Interval (ms)
	CSNPInterval *Multivalue `json:"cSNPInterval,omitempty"`
	// CapabilityRouterId: Capability Router Id
	CapabilityRouterId *Multivalue `json:"capabilityRouterId,omitempty"`
	// DiscardLSPs: Discard LSPs
	DiscardLSPs *Multivalue `json:"discardLSPs,omitempty"`
	// EnableHelloPadding: Enable Hello Padding
	EnableHelloPadding *Multivalue `json:"enableHelloPadding,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// EnableMtuProbe: Enable MTU Probe
	EnableMtuProbe *Multivalue `json:"enableMtuProbe,omitempty"`
	// EnableWideMetric: Enable Wide Metric
	EnableWideMetric *Multivalue `json:"enableWideMetric,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// IgnoreReceiveMD5: Ignore Receive MD5
	IgnoreReceiveMD5 *Multivalue `json:"ignoreReceiveMD5,omitempty"`
	// InterLSPsOrMGroupPDUBurstGap: Inter LSPs/MGROUP-PDUs Burst Gap (ms)
	InterLSPsOrMGroupPDUBurstGap *Multivalue `json:"interLSPsOrMGroupPDUBurstGap,omitempty"`
	// LSPLifetime: LSP Rifetime (sec)
	LSPLifetime *Multivalue `json:"lSPLifetime,omitempty"`
	// LSPRefreshRate: LSP Refresh Rate (sec)
	LSPRefreshRate *Multivalue `json:"lSPRefreshRate,omitempty"`
	// LSPorMGroupPDUMinTransmissionInterval: LSP/MGROUP-PDU Min Transmission Interval (ms)
	LSPorMGroupPDUMinTransmissionInterval *Multivalue `json:"lSPorMGroupPDUMinTransmissionInterval,omitempty"`
	// MaxAreaAddresses: Maximum Area Addresses
	MaxAreaAddresses *Multivalue `json:"maxAreaAddresses,omitempty"`
	// MaxLSPSize: Max LSP Size
	MaxLSPSize *Multivalue `json:"maxLSPSize,omitempty"`
	// MaxLSPsOrMGroupPDUsPerBurst: Max LSPs/MGROUP-PDUs Per Burst
	MaxLSPsOrMGroupPDUsPerBurst *Multivalue `json:"maxLSPsOrMGroupPDUsPerBurst,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfMtuProbes: No. of MTU Probes
	NoOfMtuProbes *Multivalue `json:"noOfMtuProbes,omitempty"`
	// OrigLspBufSize: Originating LSP Buf Size(Sz)
	OrigLspBufSize *Multivalue `json:"origLspBufSize,omitempty"`
	// Overloaded: Overloaded
	Overloaded *Multivalue `json:"overloaded,omitempty"`
	// PSNPInterval: PSNP Interval (ms)
	PSNPInterval *Multivalue `json:"pSNPInterval,omitempty"`
	// PartitionRepair: Partition Repair
	PartitionRepair *Multivalue `json:"partitionRepair,omitempty"`
	// TrillMCastIpv4GroupCount: # Multicast IPv4 Groups(multiplier)

	TrillMCastIpv4GroupCount *float32 `json:"trillMCastIpv4GroupCount,omitempty"`
	// TrillMCastIpv6GroupCount: # Multicast IPv6 Groups(multiplier)

	TrillMCastIpv6GroupCount *float32 `json:"trillMCastIpv6GroupCount,omitempty"`
	// TrillMCastMacGroupCount: MAC Group Count(multiplier)

	TrillMCastMacGroupCount *float32 `json:"trillMCastMacGroupCount,omitempty"`

	TrillMCastIpv4GroupList *TopologyTrillMCastIpv4GroupList `json:"trillMCastIpv4GroupList,omitempty"`

	TrillMCastIpv6GroupList *TopologyTrillMCastIpv6GroupList `json:"trillMCastIpv6GroupList,omitempty"`

	TrillMCastMacGroupList *TopologyTrillMCastMacGroupList `json:"trillMCastMacGroupList,omitempty"`

	TrillTopologyList *TopologyTrillTopologyList `json:"trillTopologyList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrillRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrillRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrillRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrillRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAddresses",
		isMultivalue: true,
	})
	n.AreaAuthenticationType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaAuthenticationType",
		isMultivalue: true,
	})
	n.AreaTransmitPasswordOrMD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaTransmitPasswordOrMD5Key",
		isMultivalue: true,
	})
	n.Attached.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attached",
		isMultivalue: true,
	})
	n.CSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cSNPInterval",
		isMultivalue: true,
	})
	n.CapabilityRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilityRouterId",
		isMultivalue: true,
	})
	n.DiscardLSPs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLSPs",
		isMultivalue: true,
	})
	n.EnableHelloPadding.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloPadding",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.EnableMtuProbe.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMtuProbe",
		isMultivalue: true,
	})
	n.EnableWideMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableWideMetric",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.IgnoreReceiveMD5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreReceiveMD5",
		isMultivalue: true,
	})
	n.InterLSPsOrMGroupPDUBurstGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interLSPsOrMGroupPDUBurstGap",
		isMultivalue: true,
	})
	n.LSPLifetime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPLifetime",
		isMultivalue: true,
	})
	n.LSPRefreshRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPRefreshRate",
		isMultivalue: true,
	})
	n.LSPorMGroupPDUMinTransmissionInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPorMGroupPDUMinTransmissionInterval",
		isMultivalue: true,
	})
	n.MaxAreaAddresses.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxAreaAddresses",
		isMultivalue: true,
	})
	n.MaxLSPSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPSize",
		isMultivalue: true,
	})
	n.MaxLSPsOrMGroupPDUsPerBurst.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLSPsOrMGroupPDUsPerBurst",
		isMultivalue: true,
	})
	n.NoOfMtuProbes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfMtuProbes",
		isMultivalue: true,
	})
	n.OrigLspBufSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "origLspBufSize",
		isMultivalue: true,
	})
	n.Overloaded.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overloaded",
		isMultivalue: true,
	})
	n.PSNPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pSNPInterval",
		isMultivalue: true,
	})
	n.PartitionRepair.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "partitionRepair",
		isMultivalue: true,
	})
	n.TrillMCastIpv4GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillMCastIpv4GroupList",
	})
	n.TrillMCastIpv6GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillMCastIpv6GroupList",
	})
	n.TrillMCastMacGroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillMCastMacGroupList",
	})
	n.TrillTopologyList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillTopologyList",
	})
}

// TopologyIsisTrillSimRouter: TRILL Simulated Edge
type TopologyIsisTrillSimRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BroadcastRootPriority: Broadcast Root Priority
	BroadcastRootPriority *Multivalue `json:"broadcastRootPriority,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SystemId: System Id
	SystemId *Multivalue `json:"systemId,omitempty"`
	// TrillMCastIpv4GroupCount: # Multicast IPv4 Groups(multiplier)

	TrillMCastIpv4GroupCount *float32 `json:"trillMCastIpv4GroupCount,omitempty"`
	// TrillMCastIpv6GroupCount: # Multicast IPv6 Groups(multiplier)

	TrillMCastIpv6GroupCount *float32 `json:"trillMCastIpv6GroupCount,omitempty"`
	// TrillMCastMacGroupCount: MAC Group Count(multiplier)

	TrillMCastMacGroupCount *float32 `json:"trillMCastMacGroupCount,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	TrillSimulatedMCastIpv4GroupList *TopologyTrillSimulatedMCastIpv4GroupList `json:"trillSimulatedMCastIpv4GroupList,omitempty"`

	TrillSimulatedMCastIpv6GroupList *TopologyTrillSimulatedMCastIpv6GroupList `json:"trillSimulatedMCastIpv6GroupList,omitempty"`

	TrillSimulatedMCastMacGroupList *TopologyTrillSimulatedMCastMacGroupList `json:"trillSimulatedMCastMacGroupList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrillSimRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrillSimRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrillSimRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrillSimRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BroadcastRootPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "broadcastRootPriority",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.TrillSimulatedMCastIpv4GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillSimulatedMCastIpv4GroupList",
	})
	n.TrillSimulatedMCastIpv6GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillSimulatedMCastIpv6GroupList",
	})
	n.TrillSimulatedMCastMacGroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillSimulatedMCastMacGroupList",
	})
}

// TopologyIsisTrillSimulatedTopologyConfig: TRILL Simulated Topology Configuration
type TopologyIsisTrillSimulatedTopologyConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnableHostName: Enable Host Name
	EnableHostName *Multivalue `json:"enableHostName,omitempty"`
	// HostName: Host Name
	HostName *Multivalue `json:"hostName,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TrillNodeTopologyCount: Node Topology Count(multiplier)

	TrillNodeTopologyCount *float32 `json:"trillNodeTopologyCount,omitempty"`

	TrillNodeTopologyList *TopologyTrillNodeTopologyList `json:"trillNodeTopologyList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrillSimulatedTopologyConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrillSimulatedTopologyConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrillSimulatedTopologyConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrillSimulatedTopologyConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostName",
		isMultivalue: true,
	})
	n.HostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostName",
		isMultivalue: true,
	})
	n.TrillNodeTopologyList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trillNodeTopologyList",
	})
}

// TopologyIsisTrillUCastMacConfig: Isis TRILL Unicast MAC specific configuration
type TopologyIsisTrillUCastMacConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name                *string                        `json:"name,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyIsisTrillUCastMacConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyIsisTrillUCastMacConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyIsisTrillUCastMacConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyIsisTrillUCastMacConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLabelBlockList: Bgp Label Block
type TopologyLabelBlockList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvLblBlock: Advertise Label Block
	AdvLblBlock *Multivalue `json:"advLblBlock,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumLabels: Number Of Labels
	NumLabels *Multivalue `json:"numLabels,omitempty"`
	// OffsetLabelBlock: Label Block Offset
	OffsetLabelBlock *Multivalue `json:"offsetLabelBlock,omitempty"`
	// StartLabel: Label Start
	StartLabel *Multivalue `json:"startLabel,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLabelBlockList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLabelBlockList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLabelBlockList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLabelBlockList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdvLblBlock.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advLblBlock",
		isMultivalue: true,
	})
	n.NumLabels.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numLabels",
		isMultivalue: true,
	})
	n.OffsetLabelBlock.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetLabelBlock",
		isMultivalue: true,
	})
	n.StartLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startLabel",
		isMultivalue: true,
	})
}

// TopologyLac: L2TP Access Concentrator protocol.
type TopologyLac struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// BaseLnsIp: Defines the base address to be used by the L2TP tunnel
	BaseLnsIp *Multivalue `json:"baseLnsIp,omitempty"`
	// BearerCapability: Indicates to the DUT the bearer device types from which incoming calls will be accepted.
	BearerCapability *Multivalue `json:"bearerCapability,omitempty"`
	// BearerType: The bearer type.
	BearerType *Multivalue `json:"bearerType,omitempty"`
	// Callingnum: Calling Number AVP in ICRQ
	Callingnum *Multivalue `json:"callingnum,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ControlMsgsRetryCounter: Number of L2TP retries
	ControlMsgsRetryCounter *Multivalue `json:"controlMsgsRetryCounter,omitempty"`
	// EnableControlChecksum: If checked, UDP checksum is enabled on control plane packets
	EnableControlChecksum *Multivalue `json:"enableControlChecksum,omitempty"`
	// EnableDataChecksum: If checked, UDP checksum is enabled on data plane packets
	EnableDataChecksum *Multivalue `json:"enableDataChecksum,omitempty"`
	// EnableExcludeHdlc: If checked, HDLC header is not encoded in the L2TP packets.

	EnableExcludeHdlc *bool `json:"enableExcludeHdlc,omitempty"`
	// EnableHelloRequest: If checked, L2TP hello request is enabled
	EnableHelloRequest *Multivalue `json:"enableHelloRequest,omitempty"`
	// EnableRedial: If checked, L2TP redial is enabled
	EnableRedial *Multivalue `json:"enableRedial,omitempty"`
	// FramingCapability: Designates sync or async framing
	FramingCapability *Multivalue `json:"framingCapability,omitempty"`
	// HelloRequestInterval: Timeout for L2TP hello request, in seconds
	HelloRequestInterval *Multivalue `json:"helloRequestInterval,omitempty"`
	// InitRetransmitInterval: The initial amount of time that can elapse before an unacknowledged control message is retransmitted.
	InitRetransmitInterval *Multivalue `json:"initRetransmitInterval,omitempty"`
	// LacHostName: LAC Hostname used for tunnel authentication.
	LacHostName *Multivalue `json:"lacHostName,omitempty"`
	// LacSecret: Secret value used for tunnel authentication.
	LacSecret *Multivalue `json:"lacSecret,omitempty"`
	// MaxRedialAttempts: Maximum number of L2TP redial attempts
	MaxRedialAttempts *Multivalue `json:"maxRedialAttempts,omitempty"`
	// MaxRetransmitInterval: The maximum amount of time that can elapse for receiving a reply for a control message.
	MaxRetransmitInterval *Multivalue `json:"maxRetransmitInterval,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OffsetByte: L2TP offset byte. Applicable only if offset bit is set.
	OffsetByte *Multivalue `json:"offsetByte,omitempty"`
	// OffsetLength: L2TP offset length in bytes. Applicable only if offset bit set.
	OffsetLength *Multivalue `json:"offsetLength,omitempty"`
	// ReceiveWindowSize: L2TP Receive Window Size
	ReceiveWindowSize *Multivalue `json:"receiveWindowSize,omitempty"`
	// RedialInterval: L2TP redial timeout, in seconds
	RedialInterval *Multivalue `json:"redialInterval,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TunnelAuthentication: Enables or disables L2TP tunnel authentication
	TunnelAuthentication *Multivalue `json:"tunnelAuthentication,omitempty"`
	// TunnelsPerInterfaceMultiplier: Number of tunnels per interface (multiplier).

	TunnelsPerInterfaceMultiplier *float32 `json:"tunnelsPerInterfaceMultiplier,omitempty"`
	// UdpDestinationPort: UDP port to employ for tunneling destinations
	UdpDestinationPort *Multivalue `json:"udpDestinationPort,omitempty"`
	// UdpSourcePort: UDP port to employ for tunneling sources
	UdpSourcePort *Multivalue `json:"udpSourcePort,omitempty"`
	// UseHiddenAVPs: If checked, Attribute Value Pair hiding is enabled
	UseHiddenAVPs *Multivalue `json:"useHiddenAVPs,omitempty"`
	// UseLengthBitInPayload: If checked, length bit is set in L2TP data packets.
	UseLengthBitInPayload *Multivalue `json:"useLengthBitInPayload,omitempty"`
	// UseOffsetBitInPayload: If checked, offset bit is enabled in L2TP data packets
	UseOffsetBitInPayload *Multivalue `json:"useOffsetBitInPayload,omitempty"`
	// UseSequenceNoInPayload: If checked, sequence bit is set in L2TP data packets.
	UseSequenceNoInPayload *Multivalue `json:"useSequenceNoInPayload,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	Tag       []*TopologyTag     `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLac) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLac) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLac) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLac) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BaseLnsIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseLnsIp",
		isMultivalue: true,
	})
	n.BearerCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bearerCapability",
		isMultivalue: true,
	})
	n.BearerType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bearerType",
		isMultivalue: true,
	})
	n.Callingnum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "callingnum",
		isMultivalue: true,
	})
	n.ControlMsgsRetryCounter.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "controlMsgsRetryCounter",
		isMultivalue: true,
	})
	n.EnableControlChecksum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableControlChecksum",
		isMultivalue: true,
	})
	n.EnableDataChecksum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDataChecksum",
		isMultivalue: true,
	})
	n.EnableHelloRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloRequest",
		isMultivalue: true,
	})
	n.EnableRedial.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRedial",
		isMultivalue: true,
	})
	n.FramingCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "framingCapability",
		isMultivalue: true,
	})
	n.HelloRequestInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloRequestInterval",
		isMultivalue: true,
	})
	n.InitRetransmitInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initRetransmitInterval",
		isMultivalue: true,
	})
	n.LacHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacHostName",
		isMultivalue: true,
	})
	n.LacSecret.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacSecret",
		isMultivalue: true,
	})
	n.MaxRedialAttempts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRedialAttempts",
		isMultivalue: true,
	})
	n.MaxRetransmitInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRetransmitInterval",
		isMultivalue: true,
	})
	n.OffsetByte.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetByte",
		isMultivalue: true,
	})
	n.OffsetLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetLength",
		isMultivalue: true,
	})
	n.ReceiveWindowSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "receiveWindowSize",
		isMultivalue: true,
	})
	n.RedialInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redialInterval",
		isMultivalue: true,
	})
	n.TunnelAuthentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelAuthentication",
		isMultivalue: true,
	})
	n.UdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpDestinationPort",
		isMultivalue: true,
	})
	n.UdpSourcePort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpSourcePort",
		isMultivalue: true,
	})
	n.UseHiddenAVPs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useHiddenAVPs",
		isMultivalue: true,
	})
	n.UseLengthBitInPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useLengthBitInPayload",
		isMultivalue: true,
	})
	n.UseOffsetBitInPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useOffsetBitInPayload",
		isMultivalue: true,
	})
	n.UseSequenceNoInPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useSequenceNoInPayload",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLacp: TBD
type TopologyLacp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ActorKey: Actor Key
	ActorKey *Multivalue `json:"actorKey,omitempty"`
	// ActorPortNumber: Actor Port Number
	ActorPortNumber *Multivalue `json:"actorPortNumber,omitempty"`
	// ActorPortPriority: Actor Port Priority
	ActorPortPriority *Multivalue `json:"actorPortPriority,omitempty"`
	// ActorSystemId: Actor System Id
	ActorSystemId *Multivalue `json:"actorSystemId,omitempty"`
	// ActorSystemPriority: Actor System Priority
	ActorSystemPriority *Multivalue `json:"actorSystemPriority,omitempty"`
	// AdministrativeKey: Administrative Key
	AdministrativeKey *Multivalue `json:"administrativeKey,omitempty"`
	// AggregationFlagState: Aggregation Flag State
	AggregationFlagState *Multivalue `json:"aggregationFlagState,omitempty"`
	// CollectingFlag: Collecting Flag
	CollectingFlag *Multivalue `json:"collectingFlag,omitempty"`
	// CollectorsMaxdelay: Collectors Maximum Delay
	CollectorsMaxdelay *Multivalue `json:"collectorsMaxdelay,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DistributingFlag: Distributing Flag
	DistributingFlag *Multivalue `json:"distributingFlag,omitempty"`
	// InterMarkerPDUDelay: Inter Marker PDU Delay (sec)
	InterMarkerPDUDelay *Multivalue `json:"interMarkerPDUDelay,omitempty"`
	// InterMarkerPDUDelayRandomMax: Inter Marker PDU Delay Random Max (sec)
	InterMarkerPDUDelayRandomMax *Multivalue `json:"interMarkerPDUDelayRandomMax,omitempty"`
	// InterMarkerPDUDelayRandomMin: Inter Marker PDU Delay Random Min (sec)
	InterMarkerPDUDelayRandomMin *Multivalue `json:"interMarkerPDUDelayRandomMin,omitempty"`
	// LacpActivity: LACP Actvity
	LacpActivity *Multivalue `json:"lacpActivity,omitempty"`
	// LacpduPeriodicTimeInterval: Lacp PDU Periodic Time Interval
	LacpduPeriodicTimeInterval *Multivalue `json:"lacpduPeriodicTimeInterval,omitempty"`
	// LacpduTimeout: Lacp PDU Timeout
	LacpduTimeout *Multivalue `json:"lacpduTimeout,omitempty"`
	// MarkerRequestMode: Marker Request Mode
	MarkerRequestMode *Multivalue `json:"markerRequestMode,omitempty"`
	// MarkerResponseWaitTime: Marker Response Wait Time (sec)
	MarkerResponseWaitTime *Multivalue `json:"markerResponseWaitTime,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeriodicSendingOfMarkerRequest: Periodic Sending Of Marker Request
	PeriodicSendingOfMarkerRequest *Multivalue `json:"periodicSendingOfMarkerRequest,omitempty"`
	// SendMarkerRequestOnLagChange: Send Marker Request On Lag Change
	SendMarkerRequestOnLagChange *Multivalue `json:"sendMarkerRequestOnLagChange,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SupportRespondingToMarker: Support Responding To Marker
	SupportRespondingToMarker *Multivalue `json:"supportRespondingToMarker,omitempty"`
	// SynchronizationFlag: Synchronization Flag
	SynchronizationFlag *Multivalue `json:"synchronizationFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLacp) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLacp) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLacp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLacp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActorKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorKey",
		isMultivalue: true,
	})
	n.ActorPortNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorPortNumber",
		isMultivalue: true,
	})
	n.ActorPortPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorPortPriority",
		isMultivalue: true,
	})
	n.ActorSystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorSystemId",
		isMultivalue: true,
	})
	n.ActorSystemPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorSystemPriority",
		isMultivalue: true,
	})
	n.AdministrativeKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administrativeKey",
		isMultivalue: true,
	})
	n.AggregationFlagState.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregationFlagState",
		isMultivalue: true,
	})
	n.CollectingFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "collectingFlag",
		isMultivalue: true,
	})
	n.CollectorsMaxdelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "collectorsMaxdelay",
		isMultivalue: true,
	})
	n.DistributingFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distributingFlag",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelay",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelayRandomMax.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelayRandomMax",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelayRandomMin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelayRandomMin",
		isMultivalue: true,
	})
	n.LacpActivity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpActivity",
		isMultivalue: true,
	})
	n.LacpduPeriodicTimeInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpduPeriodicTimeInterval",
		isMultivalue: true,
	})
	n.LacpduTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpduTimeout",
		isMultivalue: true,
	})
	n.MarkerRequestMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "markerRequestMode",
		isMultivalue: true,
	})
	n.MarkerResponseWaitTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "markerResponseWaitTime",
		isMultivalue: true,
	})
	n.PeriodicSendingOfMarkerRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicSendingOfMarkerRequest",
		isMultivalue: true,
	})
	n.SendMarkerRequestOnLagChange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendMarkerRequestOnLagChange",
		isMultivalue: true,
	})
	n.SupportRespondingToMarker.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportRespondingToMarker",
		isMultivalue: true,
	})
	n.SynchronizationFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "synchronizationFlag",
		isMultivalue: true,
	})
}

// TopologyLagportlacp: TBD
type TopologyLagportlacp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ActorKey: Actor Key
	ActorKey *Multivalue `json:"actorKey,omitempty"`
	// ActorPortNumber: Actor Port Number
	ActorPortNumber *Multivalue `json:"actorPortNumber,omitempty"`
	// ActorPortPriority: Actor Port Priority
	ActorPortPriority *Multivalue `json:"actorPortPriority,omitempty"`
	// ActorSystemId: Actor System Id
	ActorSystemId *Multivalue `json:"actorSystemId,omitempty"`
	// ActorSystemPriority: Actor System Priority
	ActorSystemPriority *Multivalue `json:"actorSystemPriority,omitempty"`
	// AdministrativeKey: Administrative Key
	AdministrativeKey *Multivalue `json:"administrativeKey,omitempty"`
	// AggregationFlagState: Aggregation Flag State
	AggregationFlagState *Multivalue `json:"aggregationFlagState,omitempty"`
	// CollectingFlag: Collecting Flag
	CollectingFlag *Multivalue `json:"collectingFlag,omitempty"`
	// CollectorsMaxdelay: Collectors Maximum Delay
	CollectorsMaxdelay *Multivalue `json:"collectorsMaxdelay,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DistributingFlag: Distributing Flag
	DistributingFlag *Multivalue `json:"distributingFlag,omitempty"`
	// InterMarkerPDUDelay: Inter Marker PDU Delay (sec)
	InterMarkerPDUDelay *Multivalue `json:"interMarkerPDUDelay,omitempty"`
	// InterMarkerPDUDelayRandomMax: Inter Marker PDU Delay Random Max (sec)
	InterMarkerPDUDelayRandomMax *Multivalue `json:"interMarkerPDUDelayRandomMax,omitempty"`
	// InterMarkerPDUDelayRandomMin: Inter Marker PDU Delay Random Min (sec)
	InterMarkerPDUDelayRandomMin *Multivalue `json:"interMarkerPDUDelayRandomMin,omitempty"`
	// LacpActivity: LACP Actvity
	LacpActivity *Multivalue `json:"lacpActivity,omitempty"`
	// LacpduPeriodicTimeInterval: Lacp PDU Periodic Time Interval
	LacpduPeriodicTimeInterval *Multivalue `json:"lacpduPeriodicTimeInterval,omitempty"`
	// LacpduTimeout: Lacp PDU Timeout
	LacpduTimeout *Multivalue `json:"lacpduTimeout,omitempty"`
	// MarkerRequestMode: Marker Request Mode
	MarkerRequestMode *Multivalue `json:"markerRequestMode,omitempty"`
	// MarkerResponseWaitTime: Marker Response Wait Time (sec)
	MarkerResponseWaitTime *Multivalue `json:"markerResponseWaitTime,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeriodicSendingOfMarkerRequest: Periodic Sending Of Marker Request
	PeriodicSendingOfMarkerRequest *Multivalue `json:"periodicSendingOfMarkerRequest,omitempty"`
	// SendMarkerRequestOnLagChange: Send Marker Request On Lag Change
	SendMarkerRequestOnLagChange *Multivalue `json:"sendMarkerRequestOnLagChange,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SupportRespondingToMarker: Support Responding To Marker
	SupportRespondingToMarker *Multivalue `json:"supportRespondingToMarker,omitempty"`
	// SynchronizationFlag: Synchronization Flag
	SynchronizationFlag *Multivalue `json:"synchronizationFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLagportlacp) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLagportlacp) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLagportlacp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLagportlacp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActorKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorKey",
		isMultivalue: true,
	})
	n.ActorPortNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorPortNumber",
		isMultivalue: true,
	})
	n.ActorPortPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorPortPriority",
		isMultivalue: true,
	})
	n.ActorSystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorSystemId",
		isMultivalue: true,
	})
	n.ActorSystemPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actorSystemPriority",
		isMultivalue: true,
	})
	n.AdministrativeKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administrativeKey",
		isMultivalue: true,
	})
	n.AggregationFlagState.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aggregationFlagState",
		isMultivalue: true,
	})
	n.CollectingFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "collectingFlag",
		isMultivalue: true,
	})
	n.CollectorsMaxdelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "collectorsMaxdelay",
		isMultivalue: true,
	})
	n.DistributingFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "distributingFlag",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelay",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelayRandomMax.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelayRandomMax",
		isMultivalue: true,
	})
	n.InterMarkerPDUDelayRandomMin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interMarkerPDUDelayRandomMin",
		isMultivalue: true,
	})
	n.LacpActivity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpActivity",
		isMultivalue: true,
	})
	n.LacpduPeriodicTimeInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpduPeriodicTimeInterval",
		isMultivalue: true,
	})
	n.LacpduTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacpduTimeout",
		isMultivalue: true,
	})
	n.MarkerRequestMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "markerRequestMode",
		isMultivalue: true,
	})
	n.MarkerResponseWaitTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "markerResponseWaitTime",
		isMultivalue: true,
	})
	n.PeriodicSendingOfMarkerRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicSendingOfMarkerRequest",
		isMultivalue: true,
	})
	n.SendMarkerRequestOnLagChange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendMarkerRequestOnLagChange",
		isMultivalue: true,
	})
	n.SupportRespondingToMarker.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportRespondingToMarker",
		isMultivalue: true,
	})
	n.SynchronizationFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "synchronizationFlag",
		isMultivalue: true,
	})
}

// TopologyLagportstaticlag: TBD
type TopologyLagportstaticlag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// LagId: LAG ID
	LagId *Multivalue `json:"lagId,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLagportstaticlag) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLagportstaticlag) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLagportstaticlag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLagportstaticlag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lagId",
		isMultivalue: true,
	})
}

// TopologyLdpBasicRouter: Ldp V4 Device level Configuration
type TopologyLdpBasicRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableBfdMplsLearnedLsp: If selected, BFD MPLS is enabled.
	EnableBfdMplsLearnedLsp *Multivalue `json:"enableBfdMplsLearnedLsp,omitempty"`
	// EnableFec128Advertisement: If selected, FEC128 P2P-PW app type is enabled in SAC TLV.
	EnableFec128Advertisement *Multivalue `json:"enableFec128Advertisement,omitempty"`
	// EnableFec129Advertisement: If selected, FEC129 P2P-PW app type is enabled in SAC TLV.
	EnableFec129Advertisement *Multivalue `json:"enableFec129Advertisement,omitempty"`
	// EnableGracefulRestart: If selected, LDP Graceful Restart is enabled on this Ixia-emulated LDP Router.
	EnableGracefulRestart *Multivalue `json:"enableGracefulRestart,omitempty"`
	// EnableIpv4Advertisement: If selected, IPv4-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv4Advertisement *Multivalue `json:"enableIpv4Advertisement,omitempty"`
	// EnableIpv6Advertisement: If selected, IPv6-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv6Advertisement *Multivalue `json:"enableIpv6Advertisement,omitempty"`
	// EnableLspPingLearnedLsp: If selected, LSP Ping is enabled for learned LSPs.
	EnableLspPingLearnedLsp *Multivalue `json:"enableLspPingLearnedLsp,omitempty"`
	// EnableP2MPCapability: If selected, LDP Router is P2MP capable.
	EnableP2MPCapability *Multivalue `json:"enableP2MPCapability,omitempty"`
	// IgnoreStateAdvertisementControlCapability: If selected, LDP Router ignores SAC TLV it receives.
	IgnoreStateAdvertisementControlCapability *Multivalue `json:"ignoreStateAdvertisementControlCapability,omitempty"`
	// IncludeSac: Select to include 'State Advertisement Control Capability' TLV in Initialization message and Capability message
	IncludeSac *Multivalue `json:"includeSac,omitempty"`
	// KeepAliveHoldTime: The period of time, in seconds, between KEEP-ALIVE messages sent to the DUT.
	KeepAliveHoldTime *Multivalue `json:"keepAliveHoldTime,omitempty"`
	// KeepAliveInterval: The frequency, in seconds, at which IxNetwork sends KEEP-ALIVE requests.
	KeepAliveInterval *Multivalue `json:"keepAliveInterval,omitempty"`
	// LdpVersion: Version of LDP. When RFC 5036 is chosen, LDP version is version 1. When draft-pdutta-mpls-ldp-adj-capability-00 is chosen, LDP version is version 2

	LdpVersion *string `json:"ldpVersion,omitempty"`
	// LeafRangesCountV4: The number of Leaf Ranges configured for this LDP router

	LeafRangesCountV4 *float32 `json:"leafRangesCountV4,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ReconnectTime: Reconnect Time ms
	ReconnectTime *Multivalue `json:"reconnectTime,omitempty"`
	// RecoveryTime: The restarting LSR advertises the amount of time that it will retain its MPLS forwarding state.
	RecoveryTime *Multivalue `json:"recoveryTime,omitempty"`
	// RootRangesCountV4: The number of Root Ranges configured for this LDP router

	RootRangesCountV4 *float32 `json:"rootRangesCountV4,omitempty"`
	// SessionPreference: The transport connection preference of the LDP router that is conveyed in Dual-stack capability TLV included in LDP Hello message.
	SessionPreference *Multivalue `json:"sessionPreference,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	LdpLeafRangeV4 *TopologyLdpLeafRangeV4 `json:"ldpLeafRangeV4,omitempty"`

	LdpRootRangeV4 *TopologyLdpRootRangeV4 `json:"ldpRootRangeV4,omitempty"`
	Ldpotherpws    []*TopologyLdpotherpws  `json:"ldpotherpws"`
	Ldppwvpls      []*TopologyLdppwvpls    `json:"ldppwvpls"`
	Ldpvplsbgpad   []*TopologyLdpvplsbgpad `json:"ldpvplsbgpad"`
	LearnedInfo    []*TopologyLearnedInfo  `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpBasicRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpBasicRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpBasicRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpBasicRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableBfdMplsLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdMplsLearnedLsp",
		isMultivalue: true,
	})
	n.EnableFec128Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec128Advertisement",
		isMultivalue: true,
	})
	n.EnableFec129Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec129Advertisement",
		isMultivalue: true,
	})
	n.EnableGracefulRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestart",
		isMultivalue: true,
	})
	n.EnableIpv4Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv4Advertisement",
		isMultivalue: true,
	})
	n.EnableIpv6Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv6Advertisement",
		isMultivalue: true,
	})
	n.EnableLspPingLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLspPingLearnedLsp",
		isMultivalue: true,
	})
	n.EnableP2MPCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableP2MPCapability",
		isMultivalue: true,
	})
	n.IgnoreStateAdvertisementControlCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreStateAdvertisementControlCapability",
		isMultivalue: true,
	})
	n.IncludeSac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSac",
		isMultivalue: true,
	})
	n.KeepAliveHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveHoldTime",
		isMultivalue: true,
	})
	n.KeepAliveInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveInterval",
		isMultivalue: true,
	})
	n.ReconnectTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconnectTime",
		isMultivalue: true,
	})
	n.RecoveryTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "recoveryTime",
		isMultivalue: true,
	})
	n.SessionPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionPreference",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.LdpLeafRangeV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpLeafRangeV4",
	})
	n.LdpRootRangeV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpRootRangeV4",
	})
	for i, o := range n.Ldpotherpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpotherpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldppwvpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldppwvpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldpvplsbgpad {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpvplsbgpad",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpBasicRouterV6: Ldpv6 Device level Configuration
type TopologyLdpBasicRouterV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableBfdMplsLearnedLsp: If selected, BFD MPLS is enabled.
	EnableBfdMplsLearnedLsp *Multivalue `json:"enableBfdMplsLearnedLsp,omitempty"`
	// EnableFec128Advertisement: If selected, FEC128 P2P-PW app type is enabled in SAC TLV.
	EnableFec128Advertisement *Multivalue `json:"enableFec128Advertisement,omitempty"`
	// EnableFec129Advertisement: If selected, FEC129 P2P-PW app type is enabled in SAC TLV.
	EnableFec129Advertisement *Multivalue `json:"enableFec129Advertisement,omitempty"`
	// EnableGracefulRestart: If selected, LDP Graceful Restart is enabled on this Ixia-emulated LDP Router.
	EnableGracefulRestart *Multivalue `json:"enableGracefulRestart,omitempty"`
	// EnableIpv4Advertisement: If selected, IPv4-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv4Advertisement *Multivalue `json:"enableIpv4Advertisement,omitempty"`
	// EnableIpv6Advertisement: If selected, IPv6-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv6Advertisement *Multivalue `json:"enableIpv6Advertisement,omitempty"`
	// EnableLspPingLearnedLsp: If selected, LSP Ping is enabled for learned LSPs.
	EnableLspPingLearnedLsp *Multivalue `json:"enableLspPingLearnedLsp,omitempty"`
	// EnableP2MPCapability: If selected, LDP Router is P2MP capable.
	EnableP2MPCapability *Multivalue `json:"enableP2MPCapability,omitempty"`
	// IgnoreStateAdvertisementControlCapability: If selected, LDP Router ignores SAC TLV it receives.
	IgnoreStateAdvertisementControlCapability *Multivalue `json:"ignoreStateAdvertisementControlCapability,omitempty"`
	// IncludeSac: Select to include 'State Advertisement Control Capability' TLV in Initialization message and Capability message
	IncludeSac *Multivalue `json:"includeSac,omitempty"`
	// KeepAliveHoldTime: The period of time, in seconds, between KEEP-ALIVE messages sent to the DUT.
	KeepAliveHoldTime *Multivalue `json:"keepAliveHoldTime,omitempty"`
	// KeepAliveInterval: The frequency, in seconds, at which IxNetwork sends KEEP-ALIVE requests.
	KeepAliveInterval *Multivalue `json:"keepAliveInterval,omitempty"`
	// LdpVersion: Version of LDP. When RFC 5036 is chosen, LDP version is version 1. When draft-pdutta-mpls-ldp-adj-capability-00 is chosen, LDP version is version 2

	LdpVersion *string `json:"ldpVersion,omitempty"`
	// LeafRangesCountV6: The number of Leaf Ranges configured for this LDP router

	LeafRangesCountV6 *float32 `json:"leafRangesCountV6,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ReconnectTime: Reconnect Time ms
	ReconnectTime *Multivalue `json:"reconnectTime,omitempty"`
	// RecoveryTime: The restarting LSR advertises the amount of time that it will retain its MPLS forwarding state.
	RecoveryTime *Multivalue `json:"recoveryTime,omitempty"`
	// RootRangesCountV6: The number of Root Ranges configured for this LDP router

	RootRangesCountV6 *float32 `json:"rootRangesCountV6,omitempty"`
	// SessionPreference: The transport connection preference of the LDP router that is conveyed in Dual-stack capability TLV included in LDP Hello message.
	SessionPreference *Multivalue `json:"sessionPreference,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	LdpLeafRangeV6 *TopologyLdpLeafRangeV6 `json:"ldpLeafRangeV6,omitempty"`

	LdpRootRangeV6 *TopologyLdpRootRangeV6 `json:"ldpRootRangeV6,omitempty"`
	Ldpotherpws    []*TopologyLdpotherpws  `json:"ldpotherpws"`
	Ldppwvpls      []*TopologyLdppwvpls    `json:"ldppwvpls"`
	Ldpvplsbgpad   []*TopologyLdpvplsbgpad `json:"ldpvplsbgpad"`
	LearnedInfo    []*TopologyLearnedInfo  `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpBasicRouterV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpBasicRouterV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpBasicRouterV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpBasicRouterV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableBfdMplsLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdMplsLearnedLsp",
		isMultivalue: true,
	})
	n.EnableFec128Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec128Advertisement",
		isMultivalue: true,
	})
	n.EnableFec129Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec129Advertisement",
		isMultivalue: true,
	})
	n.EnableGracefulRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestart",
		isMultivalue: true,
	})
	n.EnableIpv4Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv4Advertisement",
		isMultivalue: true,
	})
	n.EnableIpv6Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv6Advertisement",
		isMultivalue: true,
	})
	n.EnableLspPingLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLspPingLearnedLsp",
		isMultivalue: true,
	})
	n.EnableP2MPCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableP2MPCapability",
		isMultivalue: true,
	})
	n.IgnoreStateAdvertisementControlCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreStateAdvertisementControlCapability",
		isMultivalue: true,
	})
	n.IncludeSac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSac",
		isMultivalue: true,
	})
	n.KeepAliveHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveHoldTime",
		isMultivalue: true,
	})
	n.KeepAliveInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveInterval",
		isMultivalue: true,
	})
	n.ReconnectTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconnectTime",
		isMultivalue: true,
	})
	n.RecoveryTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "recoveryTime",
		isMultivalue: true,
	})
	n.SessionPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionPreference",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.LdpLeafRangeV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpLeafRangeV6",
	})
	n.LdpRootRangeV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpRootRangeV6",
	})
	for i, o := range n.Ldpotherpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpotherpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldppwvpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldppwvpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldpvplsbgpad {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpvplsbgpad",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpConnectedInterface: LDP Interface level Configuration
type TopologyLdpConnectedInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Authentication: The type of cryptographic authentication to be used on this link interface
	Authentication *Multivalue `json:"authentication,omitempty"`
	// BasicHelloInterval: The number of seconds between this router's Hello packets.
	BasicHelloInterval *Multivalue `json:"basicHelloInterval,omitempty"`
	// BasicHoldTime: Maximum length of time that a sending LSR will retain the record of Hellos sent by the receiving LSR, without receiving another Hello message.
	BasicHoldTime *Multivalue `json:"basicHoldTime,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// LabelSpaceID: Identifies the set of labels that will be used. Part of the LDP Identifier.
	LabelSpaceID *Multivalue `json:"labelSpaceID,omitempty"`
	// MD5Key: A value to be used as the secret MD5 Key.
	MD5Key *Multivalue `json:"mD5Key,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OperationMode: The type of LDP Label Advertisement.
	OperationMode *Multivalue `json:"operationMode,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpConnectedInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpConnectedInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpConnectedInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpConnectedInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.BasicHelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "basicHelloInterval",
		isMultivalue: true,
	})
	n.BasicHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "basicHoldTime",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.LabelSpaceID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceID",
		isMultivalue: true,
	})
	n.MD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mD5Key",
		isMultivalue: true,
	})
	n.OperationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "operationMode",
		isMultivalue: true,
	})
}

// TopologyLdpFecProperty: LDP FEC Range
type TopologyLdpFecProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnablePacking: If selected, FEC ranges are aggregated within a single LDP PDU to conserve bandwidth and processing.
	EnablePacking *Multivalue `json:"enablePacking,omitempty"`
	// EnableReplyingLspPing: If selected, LSP Ping reply is enabled.
	EnableReplyingLspPing *Multivalue `json:"enableReplyingLspPing,omitempty"`
	// LabelIncrementMode: Label Increment Mode
	LabelIncrementMode *Multivalue `json:"labelIncrementMode,omitempty"`
	// LabelValue: The first label in the range of labels
	LabelValue *Multivalue `json:"labelValue,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name                *string                        `json:"name,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpFecProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpFecProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpFecProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpFecProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnablePacking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePacking",
		isMultivalue: true,
	})
	n.EnableReplyingLspPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableReplyingLspPing",
		isMultivalue: true,
	})
	n.LabelIncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelIncrementMode",
		isMultivalue: true,
	})
	n.LabelValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValue",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpIpv6FecProperty: LDP FEC Range V6
type TopologyLdpIpv6FecProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// EnablePacking: If selected, FEC ranges are aggregated within a single LDP PDU to conserve bandwidth and processing.
	EnablePacking *Multivalue `json:"enablePacking,omitempty"`
	// EnableReplyingLspPing: If selected, LSP Ping reply is enabled.
	EnableReplyingLspPing *Multivalue `json:"enableReplyingLspPing,omitempty"`
	// LabelIncrementMode: Label Increment Mode
	LabelIncrementMode *Multivalue `json:"labelIncrementMode,omitempty"`
	// LabelValue: The first label in the range of labels
	LabelValue *Multivalue `json:"labelValue,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name                *string                        `json:"name,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpIpv6FecProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpIpv6FecProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpIpv6FecProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpIpv6FecProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnablePacking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePacking",
		isMultivalue: true,
	})
	n.EnableReplyingLspPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableReplyingLspPing",
		isMultivalue: true,
	})
	n.LabelIncrementMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelIncrementMode",
		isMultivalue: true,
	})
	n.LabelValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValue",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpLeafRangeV4: LDP Basic LeafRange V4 Configuration
type TopologyLdpLeafRangeV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// ContinuousIncrementOVAcrossRoot: Continuous Increment Opaque Value Across Root
	ContinuousIncrementOVAcrossRoot *Multivalue `json:"continuousIncrementOVAcrossRoot,omitempty"`
	// GroupAddressV4: IPv4 Group Address
	GroupAddressV4 *Multivalue `json:"groupAddressV4,omitempty"`
	// GroupAddressV6: IPv6 Group Address
	GroupAddressV6 *Multivalue `json:"groupAddressV6,omitempty"`
	// GroupCountPerLsp: Group Count per LSP
	GroupCountPerLsp *Multivalue `json:"groupCountPerLsp,omitempty"`
	// LSPType: LSP Type

	LSPType *string `json:"lSPType,omitempty"`
	// LabelValueStart: Label Value Start
	LabelValueStart *Multivalue `json:"labelValueStart,omitempty"`
	// LabelValueStep: Label Value Step
	LabelValueStep *Multivalue `json:"labelValueStep,omitempty"`
	// LspCountPerRoot: LSP Count Per Root
	LspCountPerRoot *Multivalue `json:"lspCountPerRoot,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfTLVs: Number Of TLVs

	NumberOfTLVs *float32 `json:"numberOfTLVs,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RootAddressCount: Root Address Count
	RootAddressCount *Multivalue `json:"rootAddressCount,omitempty"`
	// RootAddressStep: Root Address Step
	RootAddressStep *Multivalue           `json:"rootAddressStep,omitempty"`
	LdpTLVList      []*TopologyLdpTlvList `json:"ldpTLVList"`
	Tag             []*TopologyTag        `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpLeafRangeV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpLeafRangeV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpLeafRangeV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpLeafRangeV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ContinuousIncrementOVAcrossRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "continuousIncrementOVAcrossRoot",
		isMultivalue: true,
	})
	n.GroupAddressV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressV4",
		isMultivalue: true,
	})
	n.GroupAddressV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressV6",
		isMultivalue: true,
	})
	n.GroupCountPerLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCountPerLsp",
		isMultivalue: true,
	})
	n.LabelValueStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValueStart",
		isMultivalue: true,
	})
	n.LabelValueStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValueStep",
		isMultivalue: true,
	})
	n.LspCountPerRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspCountPerRoot",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RootAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressCount",
		isMultivalue: true,
	})
	n.RootAddressStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressStep",
		isMultivalue: true,
	})
	for i, o := range n.LdpTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpLeafRangeV6: LDP Basic LeafRange V6 Configuration
type TopologyLdpLeafRangeV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// ContinuousIncrementOVAcrossRoot: Continuous Increment Opaque Value Across Root
	ContinuousIncrementOVAcrossRoot *Multivalue `json:"continuousIncrementOVAcrossRoot,omitempty"`
	// GroupAddressV4: IPv4 Group Address
	GroupAddressV4 *Multivalue `json:"groupAddressV4,omitempty"`
	// GroupAddressV6: IPv6 Group Address
	GroupAddressV6 *Multivalue `json:"groupAddressV6,omitempty"`
	// GroupCountPerLsp: Group Count per LSP
	GroupCountPerLsp *Multivalue `json:"groupCountPerLsp,omitempty"`
	// LSPType: LSP Type

	LSPType *string `json:"lSPType,omitempty"`
	// LabelValueStart: Label Value Start
	LabelValueStart *Multivalue `json:"labelValueStart,omitempty"`
	// LabelValueStep: Label Value Step
	LabelValueStep *Multivalue `json:"labelValueStep,omitempty"`
	// LspCountPerRoot: LSP Count Per Root
	LspCountPerRoot *Multivalue `json:"lspCountPerRoot,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfTLVs: Number Of TLVs

	NumberOfTLVs *float32 `json:"numberOfTLVs,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RootAddressCount: Root Address Count
	RootAddressCount *Multivalue `json:"rootAddressCount,omitempty"`
	// RootAddressStep: Root Address Step
	RootAddressStep *Multivalue           `json:"rootAddressStep,omitempty"`
	LdpTLVList      []*TopologyLdpTlvList `json:"ldpTLVList"`
	Tag             []*TopologyTag        `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpLeafRangeV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpLeafRangeV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpLeafRangeV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpLeafRangeV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ContinuousIncrementOVAcrossRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "continuousIncrementOVAcrossRoot",
		isMultivalue: true,
	})
	n.GroupAddressV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressV4",
		isMultivalue: true,
	})
	n.GroupAddressV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressV6",
		isMultivalue: true,
	})
	n.GroupCountPerLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCountPerLsp",
		isMultivalue: true,
	})
	n.LabelValueStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValueStart",
		isMultivalue: true,
	})
	n.LabelValueStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValueStep",
		isMultivalue: true,
	})
	n.LspCountPerRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspCountPerRoot",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RootAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressCount",
		isMultivalue: true,
	})
	n.RootAddressStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressStep",
		isMultivalue: true,
	})
	for i, o := range n.LdpTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpLpbInterface: LDP Interface level Configuration
type TopologyLdpLpbInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpLpbInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpLpbInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpLpbInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpLpbInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyLdpPseudoRouter: Simulated Router Information
type TopologyLdpPseudoRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// LabelValue: Label Value Start
	LabelValue *Multivalue `json:"labelValue,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpPseudoRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpPseudoRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpPseudoRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpPseudoRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LabelValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValue",
		isMultivalue: true,
	})
}

// TopologyLdpRootRangeV4: LDP Basic RootRange V4 Configuration
type TopologyLdpRootRangeV4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ContinuousIncrementOVAcrossRoot: Continuous Increment Opaque Value Across Root
	ContinuousIncrementOVAcrossRoot *Multivalue `json:"continuousIncrementOVAcrossRoot,omitempty"`
	// FilterOnGroupAddress: If selected, all the LSPs will belong to the same set of groups
	FilterOnGroupAddress *Multivalue `json:"filterOnGroupAddress,omitempty"`
	// GroupCountPerLSP: Group Count Per LSP
	GroupCountPerLSP *Multivalue `json:"groupCountPerLSP,omitempty"`
	// LspCountPerRoot: LSP Count Per Root
	LspCountPerRoot *Multivalue `json:"lspCountPerRoot,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfTLVs: Number Of TLVs

	NumberOfTLVs *float32 `json:"numberOfTLVs,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RootAddressCount: Root Address Count
	RootAddressCount *Multivalue `json:"rootAddressCount,omitempty"`
	// RootAddressStep: Root Address Step
	RootAddressStep *Multivalue `json:"rootAddressStep,omitempty"`
	// SourceAddressV4: IPv4 Source Address
	SourceAddressV4 *Multivalue `json:"sourceAddressV4,omitempty"`
	// SourceAddressV6: IPv6 Source Address
	SourceAddressV6 *Multivalue `json:"sourceAddressV6,omitempty"`
	// SourceCountPerLSP: Source Count Per LSP
	SourceCountPerLSP *Multivalue `json:"sourceCountPerLSP,omitempty"`
	// StartGroupAddressV4: Start Group Address(V4)
	StartGroupAddressV4 *Multivalue `json:"startGroupAddressV4,omitempty"`
	// StartGroupAddressV6: Start Group Address(V6)
	StartGroupAddressV6 *Multivalue           `json:"startGroupAddressV6,omitempty"`
	LdpTLVList          []*TopologyLdpTlvList `json:"ldpTLVList"`
	Tag                 []*TopologyTag        `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpRootRangeV4) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpRootRangeV4) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpRootRangeV4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpRootRangeV4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ContinuousIncrementOVAcrossRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "continuousIncrementOVAcrossRoot",
		isMultivalue: true,
	})
	n.FilterOnGroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterOnGroupAddress",
		isMultivalue: true,
	})
	n.GroupCountPerLSP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCountPerLSP",
		isMultivalue: true,
	})
	n.LspCountPerRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspCountPerRoot",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RootAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressCount",
		isMultivalue: true,
	})
	n.RootAddressStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressStep",
		isMultivalue: true,
	})
	n.SourceAddressV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressV4",
		isMultivalue: true,
	})
	n.SourceAddressV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressV6",
		isMultivalue: true,
	})
	n.SourceCountPerLSP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceCountPerLSP",
		isMultivalue: true,
	})
	n.StartGroupAddressV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressV4",
		isMultivalue: true,
	})
	n.StartGroupAddressV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressV6",
		isMultivalue: true,
	})
	for i, o := range n.LdpTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpRootRangeV6: LDP Basic RootRange V6 Configuration
type TopologyLdpRootRangeV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ContinuousIncrementOVAcrossRoot: Continuous Increment Opaque Value Across Root
	ContinuousIncrementOVAcrossRoot *Multivalue `json:"continuousIncrementOVAcrossRoot,omitempty"`
	// FilterOnGroupAddress: If selected, all the LSPs will belong to the same set of groups
	FilterOnGroupAddress *Multivalue `json:"filterOnGroupAddress,omitempty"`
	// GroupCountPerLSP: Group Count Per LSP
	GroupCountPerLSP *Multivalue `json:"groupCountPerLSP,omitempty"`
	// LspCountPerRoot: LSP Count Per Root
	LspCountPerRoot *Multivalue `json:"lspCountPerRoot,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfTLVs: Number Of TLVs

	NumberOfTLVs *float32 `json:"numberOfTLVs,omitempty"`
	// RootAddress: Root Address
	RootAddress *Multivalue `json:"rootAddress,omitempty"`
	// RootAddressCount: Root Address Count
	RootAddressCount *Multivalue `json:"rootAddressCount,omitempty"`
	// RootAddressStep: Root Address Step
	RootAddressStep *Multivalue `json:"rootAddressStep,omitempty"`
	// SourceAddressV4: IPv4 Source Address
	SourceAddressV4 *Multivalue `json:"sourceAddressV4,omitempty"`
	// SourceAddressV6: IPv6 Source Address
	SourceAddressV6 *Multivalue `json:"sourceAddressV6,omitempty"`
	// SourceCountPerLSP: Source Count Per LSP
	SourceCountPerLSP *Multivalue `json:"sourceCountPerLSP,omitempty"`
	// StartGroupAddressV4: Start Group Address(V4)
	StartGroupAddressV4 *Multivalue `json:"startGroupAddressV4,omitempty"`
	// StartGroupAddressV6: Start Group Address(V6)
	StartGroupAddressV6 *Multivalue           `json:"startGroupAddressV6,omitempty"`
	LdpTLVList          []*TopologyLdpTlvList `json:"ldpTLVList"`
	Tag                 []*TopologyTag        `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpRootRangeV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpRootRangeV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpRootRangeV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpRootRangeV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ContinuousIncrementOVAcrossRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "continuousIncrementOVAcrossRoot",
		isMultivalue: true,
	})
	n.FilterOnGroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filterOnGroupAddress",
		isMultivalue: true,
	})
	n.GroupCountPerLSP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCountPerLSP",
		isMultivalue: true,
	})
	n.LspCountPerRoot.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspCountPerRoot",
		isMultivalue: true,
	})
	n.RootAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddress",
		isMultivalue: true,
	})
	n.RootAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressCount",
		isMultivalue: true,
	})
	n.RootAddressStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rootAddressStep",
		isMultivalue: true,
	})
	n.SourceAddressV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressV4",
		isMultivalue: true,
	})
	n.SourceAddressV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressV6",
		isMultivalue: true,
	})
	n.SourceCountPerLSP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceCountPerLSP",
		isMultivalue: true,
	})
	n.StartGroupAddressV4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressV4",
		isMultivalue: true,
	})
	n.StartGroupAddressV6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startGroupAddressV6",
		isMultivalue: true,
	})
	for i, o := range n.LdpTLVList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTLVList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpSimulatedTopologyConfig: LDP Simulated Topology specific configuration
type TopologyLdpSimulatedTopologyConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpSimulatedTopologyConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpSimulatedTopologyConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpSimulatedTopologyConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpSimulatedTopologyConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyLdpTargetedIpv6Peer: IPv6 LDP Targeted Peers
type TopologyLdpTargetedIpv6Peer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Authentication: The type of cryptographic authentication to be used for this targeted peer
	Authentication *Multivalue `json:"authentication,omitempty"`
	// IPAddress: The IP address of the non-directly linked LDP peer to which the targeted Hello is being sent
	IPAddress *Multivalue `json:"iPAddress,omitempty"`
	// InitiateTargetedHello: If selected, a Targeted Hello will be sent to the LDP Peer specified by the IP address in this row
	InitiateTargetedHello *Multivalue `json:"initiateTargetedHello,omitempty"`
	// MD5Key: A value to be used as a secret MD5 key for authentication
	MD5Key *Multivalue `json:"mD5Key,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetedHelloInterval: Targeted Hello Interval
	TargetedHelloInterval *Multivalue `json:"targetedHelloInterval,omitempty"`
	// TargetedHoldTime: Targeted Hold Time
	TargetedHoldTime *Multivalue `json:"targetedHoldTime,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpTargetedIpv6Peer) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpTargetedIpv6Peer) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpTargetedIpv6Peer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpTargetedIpv6Peer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.IPAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iPAddress",
		isMultivalue: true,
	})
	n.InitiateTargetedHello.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initiateTargetedHello",
		isMultivalue: true,
	})
	n.MD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mD5Key",
		isMultivalue: true,
	})
	n.TargetedHelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetedHelloInterval",
		isMultivalue: true,
	})
	n.TargetedHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetedHoldTime",
		isMultivalue: true,
	})
}

// TopologyLdpTargetedPeer: LDP Targeted Peers
type TopologyLdpTargetedPeer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Authentication: The type of cryptographic authentication to be used for this targeted peer
	Authentication *Multivalue `json:"authentication,omitempty"`
	// IPAddress: The IP address of the non-directly linked LDP peer to which the targeted Hello is being sent
	IPAddress *Multivalue `json:"iPAddress,omitempty"`
	// InitiateTargetedHello: If selected, a Targeted Hello will be sent to the LDP Peer specified by the IP address in this row
	InitiateTargetedHello *Multivalue `json:"initiateTargetedHello,omitempty"`
	// MD5Key: A value to be used as a secret MD5 key for authentication
	MD5Key *Multivalue `json:"mD5Key,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TargetedHelloInterval: Targeted Hello Interval
	TargetedHelloInterval *Multivalue `json:"targetedHelloInterval,omitempty"`
	// TargetedHoldTime: Targeted Hold Time
	TargetedHoldTime *Multivalue `json:"targetedHoldTime,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpTargetedPeer) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpTargetedPeer) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpTargetedPeer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpTargetedPeer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.IPAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iPAddress",
		isMultivalue: true,
	})
	n.InitiateTargetedHello.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initiateTargetedHello",
		isMultivalue: true,
	})
	n.MD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mD5Key",
		isMultivalue: true,
	})
	n.TargetedHelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetedHelloInterval",
		isMultivalue: true,
	})
	n.TargetedHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetedHoldTime",
		isMultivalue: true,
	})
}

// TopologyLdpTargetedRouter: LDP Targeted Router Configuration
type TopologyLdpTargetedRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BfdOpeMode: BFD Operation Mode
	BfdOpeMode *Multivalue `json:"bfdOpeMode,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableBfdMplsLearnedLsp: If selected, BFD MPLS is enabled.
	EnableBfdMplsLearnedLsp *Multivalue `json:"enableBfdMplsLearnedLsp,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableFec128Advertisement: If selected, FEC128 P2P-PW app type is enabled in SAC TLV.
	EnableFec128Advertisement *Multivalue `json:"enableFec128Advertisement,omitempty"`
	// EnableFec129Advertisement: If selected, FEC129 P2P-PW app type is enabled in SAC TLV.
	EnableFec129Advertisement *Multivalue `json:"enableFec129Advertisement,omitempty"`
	// EnableGracefulRestart: If selected, LDP Graceful Restart is enabled on this Ixia-emulated LDP Router.
	EnableGracefulRestart *Multivalue `json:"enableGracefulRestart,omitempty"`
	// EnableIpv4Advertisement: If selected, IPv4-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv4Advertisement *Multivalue `json:"enableIpv4Advertisement,omitempty"`
	// EnableIpv6Advertisement: If selected, IPv6-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv6Advertisement *Multivalue `json:"enableIpv6Advertisement,omitempty"`
	// EnableLspPingLearnedLsp: If selected, LSP Ping is enabled for learned LSPs.
	EnableLspPingLearnedLsp *Multivalue `json:"enableLspPingLearnedLsp,omitempty"`
	// EnableP2MPCapability: If selected, LDP Router is P2MP capable.
	EnableP2MPCapability *Multivalue `json:"enableP2MPCapability,omitempty"`
	// IgnoreStateAdvertisementControlCapability: If selected, LDP Router ignores SAC TLV it receives.
	IgnoreStateAdvertisementControlCapability *Multivalue `json:"ignoreStateAdvertisementControlCapability,omitempty"`
	// IncludeSac: Select to include 'State Advertisement Control Capability' TLV in Initialization message and Capability message
	IncludeSac *Multivalue `json:"includeSac,omitempty"`
	// Ipv6peerCount: The number of ipv6 Target Peers configured for this LDP router

	Ipv6peerCount *float32 `json:"ipv6peerCount,omitempty"`
	// KeepAliveHoldTime: The period of time, in seconds, between KEEP-ALIVE messages sent to the DUT.
	KeepAliveHoldTime *Multivalue `json:"keepAliveHoldTime,omitempty"`
	// KeepAliveInterval: The frequency, in seconds, at which IxNetwork sends KEEP-ALIVE requests.
	KeepAliveInterval *Multivalue `json:"keepAliveInterval,omitempty"`
	// LabelSpaceID: Identifies the set of labels that will be used. Part of the LDP Identifier
	LabelSpaceID *Multivalue `json:"labelSpaceID,omitempty"`
	// LdpVersion: Version of LDP. When RFC 5036 is chosen, LDP version is version 1. When draft-pdutta-mpls-ldp-adj-capability-00 is chosen, LDP version is version 2

	LdpVersion *string `json:"ldpVersion,omitempty"`
	// LeafRangesCountV4: The number of Leaf Ranges configured for this LDP router

	LeafRangesCountV4 *float32 `json:"leafRangesCountV4,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OperationMode: The type of LDP Label Advertisement
	OperationMode *Multivalue `json:"operationMode,omitempty"`
	// PeerCount: The number of Target Peers configured for this LDP router

	PeerCount *float32 `json:"peerCount,omitempty"`
	// ReconnectTime: Reconnect Time ms
	ReconnectTime *Multivalue `json:"reconnectTime,omitempty"`
	// RecoveryTime: The restarting LSR advertises the amount of time that it will retain its MPLS forwarding state.
	RecoveryTime *Multivalue `json:"recoveryTime,omitempty"`
	// RootRangesCountV4: The number of Root Ranges configured for this LDP router

	RootRangesCountV4 *float32 `json:"rootRangesCountV4,omitempty"`
	// SessionPreference: The transport connection preference of the LDP router that is conveyed in Dual-stack capability TLV included in LDP Hello message.
	SessionPreference *Multivalue `json:"sessionPreference,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	LdpLeafRangeV4 *TopologyLdpLeafRangeV4 `json:"ldpLeafRangeV4,omitempty"`

	LdpRootRangeV4 *TopologyLdpRootRangeV4 `json:"ldpRootRangeV4,omitempty"`

	LdpTargetedIpv6Peer *TopologyLdpTargetedIpv6Peer `json:"ldpTargetedIpv6Peer,omitempty"`

	LdpTargetedPeer *TopologyLdpTargetedPeer `json:"ldpTargetedPeer,omitempty"`
	Ldpotherpws     []*TopologyLdpotherpws   `json:"ldpotherpws"`
	Ldppwvpls       []*TopologyLdppwvpls     `json:"ldppwvpls"`
	Ldpvplsbgpad    []*TopologyLdpvplsbgpad  `json:"ldpvplsbgpad"`
	LearnedInfo     []*TopologyLearnedInfo   `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpTargetedRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpTargetedRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpTargetedRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpTargetedRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BfdOpeMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdOpeMode",
		isMultivalue: true,
	})
	n.EnableBfdMplsLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdMplsLearnedLsp",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableFec128Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec128Advertisement",
		isMultivalue: true,
	})
	n.EnableFec129Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec129Advertisement",
		isMultivalue: true,
	})
	n.EnableGracefulRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestart",
		isMultivalue: true,
	})
	n.EnableIpv4Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv4Advertisement",
		isMultivalue: true,
	})
	n.EnableIpv6Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv6Advertisement",
		isMultivalue: true,
	})
	n.EnableLspPingLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLspPingLearnedLsp",
		isMultivalue: true,
	})
	n.EnableP2MPCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableP2MPCapability",
		isMultivalue: true,
	})
	n.IgnoreStateAdvertisementControlCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreStateAdvertisementControlCapability",
		isMultivalue: true,
	})
	n.IncludeSac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSac",
		isMultivalue: true,
	})
	n.KeepAliveHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveHoldTime",
		isMultivalue: true,
	})
	n.KeepAliveInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveInterval",
		isMultivalue: true,
	})
	n.LabelSpaceID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceID",
		isMultivalue: true,
	})
	n.OperationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "operationMode",
		isMultivalue: true,
	})
	n.ReconnectTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconnectTime",
		isMultivalue: true,
	})
	n.RecoveryTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "recoveryTime",
		isMultivalue: true,
	})
	n.SessionPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionPreference",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.LdpLeafRangeV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpLeafRangeV4",
	})
	n.LdpRootRangeV4.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpRootRangeV4",
	})
	n.LdpTargetedIpv6Peer.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpTargetedIpv6Peer",
	})
	n.LdpTargetedPeer.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpTargetedPeer",
	})
	for i, o := range n.Ldpotherpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpotherpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldppwvpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldppwvpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldpvplsbgpad {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpvplsbgpad",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpTargetedRouterV6: LDPv6 Targeted Router Configuration
type TopologyLdpTargetedRouterV6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BfdOpeMode: BFD Operation Mode
	BfdOpeMode *Multivalue `json:"bfdOpeMode,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableBfdMplsLearnedLsp: If selected, BFD MPLS is enabled.
	EnableBfdMplsLearnedLsp *Multivalue `json:"enableBfdMplsLearnedLsp,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableFec128Advertisement: If selected, FEC128 P2P-PW app type is enabled in SAC TLV.
	EnableFec128Advertisement *Multivalue `json:"enableFec128Advertisement,omitempty"`
	// EnableFec129Advertisement: If selected, FEC129 P2P-PW app type is enabled in SAC TLV.
	EnableFec129Advertisement *Multivalue `json:"enableFec129Advertisement,omitempty"`
	// EnableGracefulRestart: If selected, LDP Graceful Restart is enabled on this Ixia-emulated LDP Router.
	EnableGracefulRestart *Multivalue `json:"enableGracefulRestart,omitempty"`
	// EnableIpv4Advertisement: If selected, IPv4-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv4Advertisement *Multivalue `json:"enableIpv4Advertisement,omitempty"`
	// EnableIpv6Advertisement: If selected, IPv6-Prefix LSP app type is enabled in SAC TLV.
	EnableIpv6Advertisement *Multivalue `json:"enableIpv6Advertisement,omitempty"`
	// EnableLspPingLearnedLsp: If selected, LSP Ping is enabled for learned LSPs.
	EnableLspPingLearnedLsp *Multivalue `json:"enableLspPingLearnedLsp,omitempty"`
	// EnableP2MPCapability: If selected, LDP Router is P2MP capable.
	EnableP2MPCapability *Multivalue `json:"enableP2MPCapability,omitempty"`
	// IgnoreStateAdvertisementControlCapability: If selected, LDP Router ignores SAC TLV it receives.
	IgnoreStateAdvertisementControlCapability *Multivalue `json:"ignoreStateAdvertisementControlCapability,omitempty"`
	// IncludeSac: Select to include 'State Advertisement Control Capability' TLV in Initialization message and Capability message
	IncludeSac *Multivalue `json:"includeSac,omitempty"`
	// Ipv6peerCount: The number of ipv6 Target Peers configured for this LDP router

	Ipv6peerCount *float32 `json:"ipv6peerCount,omitempty"`
	// KeepAliveHoldTime: The period of time, in seconds, between KEEP-ALIVE messages sent to the DUT.
	KeepAliveHoldTime *Multivalue `json:"keepAliveHoldTime,omitempty"`
	// KeepAliveInterval: The frequency, in seconds, at which IxNetwork sends KEEP-ALIVE requests.
	KeepAliveInterval *Multivalue `json:"keepAliveInterval,omitempty"`
	// LabelSpaceID: Identifies the set of labels that will be used. Part of the LDP Identifier
	LabelSpaceID *Multivalue `json:"labelSpaceID,omitempty"`
	// LdpVersion: Version of LDP. When RFC 5036 is chosen, LDP version is version 1. When draft-pdutta-mpls-ldp-adj-capability-00 is chosen, LDP version is version 2

	LdpVersion *string `json:"ldpVersion,omitempty"`
	// LeafRangesCountV6: The number of Leaf Ranges configured for this LDP router

	LeafRangesCountV6 *float32 `json:"leafRangesCountV6,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OperationMode: The type of LDP Label Advertisement
	OperationMode *Multivalue `json:"operationMode,omitempty"`
	// PeerCount: The number of Target Peers configured for this LDP router

	PeerCount *float32 `json:"peerCount,omitempty"`
	// ReconnectTime: Reconnect Time ms
	ReconnectTime *Multivalue `json:"reconnectTime,omitempty"`
	// RecoveryTime: The restarting LSR advertises the amount of time that it will retain its MPLS forwarding state.
	RecoveryTime *Multivalue `json:"recoveryTime,omitempty"`
	// RootRangesCountV6: The number of Root Ranges configured for this LDP router

	RootRangesCountV6 *float32 `json:"rootRangesCountV6,omitempty"`
	// SessionPreference: The transport connection preference of the LDP router that is conveyed in Dual-stack capability TLV included in LDP Hello message.
	SessionPreference *Multivalue `json:"sessionPreference,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	Connector *TopologyConnector `json:"connector,omitempty"`

	LdpLeafRangeV6 *TopologyLdpLeafRangeV6 `json:"ldpLeafRangeV6,omitempty"`

	LdpRootRangeV6 *TopologyLdpRootRangeV6 `json:"ldpRootRangeV6,omitempty"`

	LdpTargetedIpv6Peer *TopologyLdpTargetedIpv6Peer `json:"ldpTargetedIpv6Peer,omitempty"`

	LdpTargetedPeer *TopologyLdpTargetedPeer `json:"ldpTargetedPeer,omitempty"`
	Ldpotherpws     []*TopologyLdpotherpws   `json:"ldpotherpws"`
	Ldppwvpls       []*TopologyLdppwvpls     `json:"ldppwvpls"`
	Ldpvplsbgpad    []*TopologyLdpvplsbgpad  `json:"ldpvplsbgpad"`
	LearnedInfo     []*TopologyLearnedInfo   `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpTargetedRouterV6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpTargetedRouterV6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpTargetedRouterV6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpTargetedRouterV6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BfdOpeMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdOpeMode",
		isMultivalue: true,
	})
	n.EnableBfdMplsLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdMplsLearnedLsp",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableFec128Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec128Advertisement",
		isMultivalue: true,
	})
	n.EnableFec129Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFec129Advertisement",
		isMultivalue: true,
	})
	n.EnableGracefulRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestart",
		isMultivalue: true,
	})
	n.EnableIpv4Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv4Advertisement",
		isMultivalue: true,
	})
	n.EnableIpv6Advertisement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIpv6Advertisement",
		isMultivalue: true,
	})
	n.EnableLspPingLearnedLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLspPingLearnedLsp",
		isMultivalue: true,
	})
	n.EnableP2MPCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableP2MPCapability",
		isMultivalue: true,
	})
	n.IgnoreStateAdvertisementControlCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ignoreStateAdvertisementControlCapability",
		isMultivalue: true,
	})
	n.IncludeSac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSac",
		isMultivalue: true,
	})
	n.KeepAliveHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveHoldTime",
		isMultivalue: true,
	})
	n.KeepAliveInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepAliveInterval",
		isMultivalue: true,
	})
	n.LabelSpaceID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceID",
		isMultivalue: true,
	})
	n.OperationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "operationMode",
		isMultivalue: true,
	})
	n.ReconnectTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconnectTime",
		isMultivalue: true,
	})
	n.RecoveryTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "recoveryTime",
		isMultivalue: true,
	})
	n.SessionPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionPreference",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	n.LdpLeafRangeV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpLeafRangeV6",
	})
	n.LdpRootRangeV6.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpRootRangeV6",
	})
	n.LdpTargetedIpv6Peer.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpTargetedIpv6Peer",
	})
	n.LdpTargetedPeer.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ldpTargetedPeer",
	})
	for i, o := range n.Ldpotherpws {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpotherpws",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldppwvpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldppwvpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldpvplsbgpad {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpvplsbgpad",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpTlvList: LDP Opaque TLV
type TopologyLdpTlvList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: If selected, Then the TLV is enabled
	Active *Multivalue `json:"active,omitempty"`
	// Increment: Increment Step
	Increment *Multivalue `json:"increment,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TlvLength: Length
	TlvLength *Multivalue `json:"tlvLength,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// Value: Value
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpTlvList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpTlvList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpTlvList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpTlvList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Increment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "increment",
		isMultivalue: true,
	})
	n.TlvLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tlvLength",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyLdpotherpws: LDP FEC128 Pseudo Wire Configuration[Other than Ethernet VLAN type]
type TopologyLdpotherpws struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ATMPresent: If selected, indicates that ATM Transparent Cell Transport mode is being used
	ATMPresent *Multivalue `json:"aTMPresent,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AutoPeerID: If selected, LDP Peer IP would be taken from LDP router's peer configuration.
	AutoPeerID *Multivalue `json:"autoPeerID,omitempty"`
	// AutoPeerId: If selected, LDP Peer IP would be taken from LDP router's peer configuration.

	AutoPeerId *bool `json:"autoPeerId,omitempty"`
	// BfdPwCV: BFD PW-ACH CV
	BfdPwCV *Multivalue `json:"bfdPwCV,omitempty"`
	// BfdUdpCV: BFD IP/UDP CV
	BfdUdpCV *Multivalue `json:"bfdUdpCV,omitempty"`
	// CAS: CAS Value
	CAS *Multivalue `json:"cAS,omitempty"`
	// CBitEnabled: If selected, sets the C-Bit (flag). It is the highest order bit in the VC Type field. If the bit is set, it indicates the presence of a control word on this VC.
	CBitEnabled *Multivalue `json:"cBitEnabled,omitempty"`
	// CEMOption: The value of the CEM option
	CEMOption *Multivalue `json:"cEMOption,omitempty"`
	// CEMOptionPresent: If selected, indicates that a CEM option is present
	CEMOptionPresent *Multivalue `json:"cEMOptionPresent,omitempty"`
	// CEMPayLoadEnable: If selected, indicates that there is a Circuit Emulation Service over MPLS (CEM) payload
	CEMPayLoadEnable *Multivalue `json:"cEMPayLoadEnable,omitempty"`
	// CEMPayload: The length of the CEM payload (in bytes)
	CEMPayload *Multivalue `json:"cEMPayload,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DescEnabled: If selected, indicates that an optional Interface Description is present
	DescEnabled *Multivalue `json:"descEnabled,omitempty"`
	// Description: An optional user-defined Interface Description. It may be used with ALL VC types. Valid length is 0 to 80 octets
	Description *Multivalue `json:"description,omitempty"`
	// DownInterval: Time interval for which the PW status will remain down
	DownInterval *Multivalue `json:"downInterval,omitempty"`
	// DownStart: The duration in time after session becomes up and a notification message being sent to make the session down
	DownStart *Multivalue `json:"downStart,omitempty"`
	// EnableCCCVNegotiation: If selected, indicates that CCCV Negotiation is enabled
	EnableCCCVNegotiation *Multivalue `json:"enableCCCVNegotiation,omitempty"`
	// EnablePWStatus: If selected, this enables the use of PW Status TLV in notification messages to notify the PW status
	EnablePWStatus *Multivalue `json:"enablePWStatus,omitempty"`
	// Frequency: Configures the frequency of the payload type
	Frequency *Multivalue `json:"frequency,omitempty"`
	// GroupId: A user-defined 32-bit value used to identify a group of VCs
	GroupId *Multivalue `json:"groupId,omitempty"`
	// IfaceType: The 15-bit VC Type used in the VC FEC element.It depends on the Layer 2 protocol used on the interface
	IfaceType *Multivalue `json:"ifaceType,omitempty"`
	// IncludeRTPHeader: If selected, indicates that RTP Header is present
	IncludeRTPHeader *Multivalue `json:"includeRTPHeader,omitempty"`
	// IncludeSSRC: Click to enable SSRC
	IncludeSSRC *Multivalue `json:"includeSSRC,omitempty"`
	// IncludeTDMBitrate: If selected, indicates that TDM Bitrate is present
	IncludeTDMBitrate *Multivalue `json:"includeTDMBitrate,omitempty"`
	// IncludeTDMOption: Include TDM Option
	IncludeTDMOption *Multivalue `json:"includeTDMOption,omitempty"`
	// IncludeTDMPayload: If selected, indicates that TDM Payload is present
	IncludeTDMPayload *Multivalue `json:"includeTDMPayload,omitempty"`
	// Ipv6PeerId: The 128-bit IPv6 address of the LDP Peer.
	Ipv6PeerId *Multivalue `json:"ipv6PeerId,omitempty"`
	// LSPPingCV: LSP Ping CV
	LSPPingCV *Multivalue `json:"lSPPingCV,omitempty"`
	// Label: Label
	Label *Multivalue `json:"label,omitempty"`
	// MaxATMCells: The Maximum number of ATM Cells which may be concatenated and sent in a single MPLS frame
	MaxATMCells *Multivalue `json:"maxATMCells,omitempty"`
	// Mtu: The 2-octet value for the maximum Transmission Unit (MTU).
	Mtu *Multivalue `json:"mtu,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PWACHCC: PW-ACH CC
	PWACHCC *Multivalue `json:"pWACHCC,omitempty"`
	// PWStatusCode: PW Status Code to be sent when to transition to down state if PW Status Send Notification is enabled
	PWStatusCode *Multivalue `json:"pWStatusCode,omitempty"`
	// PayloadType: Configures the pay load type
	PayloadType *Multivalue `json:"payloadType,omitempty"`
	// PeerId: The 32-bit IPv4 address of the LDP Peer.
	PeerId *Multivalue `json:"peerId,omitempty"`
	// PwStatusSendNotification: If selected, it signifies whether to send a notification message with a PW status for the corresponding PW
	PwStatusSendNotification *Multivalue `json:"pwStatusSendNotification,omitempty"`
	// RepeatCount: The number of times to repeat the Up/Down status of the PW. '0' means keep toggling the Up/Down state indefinitely.
	RepeatCount *Multivalue `json:"repeatCount,omitempty"`
	// RouterAlertCC: Router Alert CC
	RouterAlertCC *Multivalue `json:"routerAlertCC,omitempty"`
	// SP: SP Value
	SP *Multivalue `json:"sP,omitempty"`
	// SSRC: SSRC Value
	SSRC *Multivalue `json:"sSRC,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TDMBitrate: The value of the TDM bitrate
	TDMBitrate *Multivalue `json:"tDMBitrate,omitempty"`
	// TDMDataSize: The total size of the TDM data
	TDMDataSize *Multivalue `json:"tDMDataSize,omitempty"`
	// TimestampMode: Timestamp Mode
	TimestampMode *Multivalue `json:"timestampMode,omitempty"`
	// UpInterval: Time Interval for which the PW status will remain in Up state before transitioning again to Down state.
	UpInterval *Multivalue `json:"upInterval,omitempty"`
	// VCIDStart: The value of the VC ID
	VCIDStart *Multivalue `json:"vCIDStart,omitempty"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	Ethernet            []*TopologyEthernet            `json:"ethernet"`
	Ipv4Loopback        []*TopologyIpv4Loopback        `json:"ipv4Loopback"`
	Ipv6Loopback        []*TopologyIpv6Loopback        `json:"ipv6Loopback"`
	LdpBasicRouter      []*TopologyLdpBasicRouter      `json:"ldpBasicRouter"`
	LdpBasicRouterV6    []*TopologyLdpBasicRouterV6    `json:"ldpBasicRouterV6"`
	LdpTargetedRouter   []*TopologyLdpTargetedRouter   `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6 []*TopologyLdpTargetedRouterV6 `json:"ldpTargetedRouterV6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpotherpws) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpotherpws) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpotherpws) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpotherpws) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ATMPresent.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "aTMPresent",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AutoPeerID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoPeerID",
		isMultivalue: true,
	})
	n.BfdPwCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdPwCV",
		isMultivalue: true,
	})
	n.BfdUdpCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdUdpCV",
		isMultivalue: true,
	})
	n.CAS.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cAS",
		isMultivalue: true,
	})
	n.CBitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cBitEnabled",
		isMultivalue: true,
	})
	n.CEMOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cEMOption",
		isMultivalue: true,
	})
	n.CEMOptionPresent.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cEMOptionPresent",
		isMultivalue: true,
	})
	n.CEMPayLoadEnable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cEMPayLoadEnable",
		isMultivalue: true,
	})
	n.CEMPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cEMPayload",
		isMultivalue: true,
	})
	n.DescEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "descEnabled",
		isMultivalue: true,
	})
	n.Description.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "description",
		isMultivalue: true,
	})
	n.DownInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downInterval",
		isMultivalue: true,
	})
	n.DownStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downStart",
		isMultivalue: true,
	})
	n.EnableCCCVNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCCCVNegotiation",
		isMultivalue: true,
	})
	n.EnablePWStatus.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePWStatus",
		isMultivalue: true,
	})
	n.Frequency.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "frequency",
		isMultivalue: true,
	})
	n.GroupId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupId",
		isMultivalue: true,
	})
	n.IfaceType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ifaceType",
		isMultivalue: true,
	})
	n.IncludeRTPHeader.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeRTPHeader",
		isMultivalue: true,
	})
	n.IncludeSSRC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSSRC",
		isMultivalue: true,
	})
	n.IncludeTDMBitrate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTDMBitrate",
		isMultivalue: true,
	})
	n.IncludeTDMOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTDMOption",
		isMultivalue: true,
	})
	n.IncludeTDMPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTDMPayload",
		isMultivalue: true,
	})
	n.Ipv6PeerId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6PeerId",
		isMultivalue: true,
	})
	n.LSPPingCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPPingCV",
		isMultivalue: true,
	})
	n.Label.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "label",
		isMultivalue: true,
	})
	n.MaxATMCells.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxATMCells",
		isMultivalue: true,
	})
	n.Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtu",
		isMultivalue: true,
	})
	n.PWACHCC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pWACHCC",
		isMultivalue: true,
	})
	n.PWStatusCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pWStatusCode",
		isMultivalue: true,
	})
	n.PayloadType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "payloadType",
		isMultivalue: true,
	})
	n.PeerId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerId",
		isMultivalue: true,
	})
	n.PwStatusSendNotification.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pwStatusSendNotification",
		isMultivalue: true,
	})
	n.RepeatCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "repeatCount",
		isMultivalue: true,
	})
	n.RouterAlertCC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerAlertCC",
		isMultivalue: true,
	})
	n.SP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sP",
		isMultivalue: true,
	})
	n.SSRC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sSRC",
		isMultivalue: true,
	})
	n.TDMBitrate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tDMBitrate",
		isMultivalue: true,
	})
	n.TDMDataSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tDMDataSize",
		isMultivalue: true,
	})
	n.TimestampMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timestampMode",
		isMultivalue: true,
	})
	n.UpInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upInterval",
		isMultivalue: true,
	})
	n.VCIDStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vCIDStart",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdppwvpls: LDP FEC128 Configuration
type TopologyLdppwvpls struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AutoPeerID: If selected, LDP Peer IP would be taken from LDP router's peer configuration.
	AutoPeerID *Multivalue `json:"autoPeerID,omitempty"`
	// AutoPeerId: If selected, LDP Peer IP would be taken from LDP router's peer configuration.

	AutoPeerId *bool `json:"autoPeerId,omitempty"`
	// BfdPwCV: BFD PW-ACH CV
	BfdPwCV *Multivalue `json:"bfdPwCV,omitempty"`
	// BfdUdpCV: BFD IP/UDP CV
	BfdUdpCV *Multivalue `json:"bfdUdpCV,omitempty"`
	// CBitEnabled: If selected, sets the C-Bit (flag). It is the highest order bit in the VC Type field. If the bit is set, it indicates the presence of a control word on this VC.
	CBitEnabled *Multivalue `json:"cBitEnabled,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DescEnabled: If selected, indicates that an optional Interface Description is present
	DescEnabled *Multivalue `json:"descEnabled,omitempty"`
	// Description: An optional user-defined Interface Description. It may be used with ALL VC types. Valid length is 0 to 80 octets
	Description *Multivalue `json:"description,omitempty"`
	// DownInterval: Time interval for which the PW status will remain down
	DownInterval *Multivalue `json:"downInterval,omitempty"`
	// DownStart: The duration in time after session becomes up and a notification message being sent to make the session down
	DownStart *Multivalue `json:"downStart,omitempty"`
	// EnableCCCVNegotiation: If selected, indicates that CCCV Negotiation is enabled
	EnableCCCVNegotiation *Multivalue `json:"enableCCCVNegotiation,omitempty"`
	// EnablePWStatus: If selected, this enables the use of PW Status TLV in notification messages to notify the PW status
	EnablePWStatus *Multivalue `json:"enablePWStatus,omitempty"`
	// GroupId: A user-defined 32-bit value used to identify a group of VCs
	GroupId *Multivalue `json:"groupId,omitempty"`
	// InterfaceType: The 15-bit VC Type used in the VC FEC element.It depends on the Layer 2 protocol used on the interface
	InterfaceType *Multivalue `json:"interfaceType,omitempty"`
	// Ipv6PeerId: The 128-bit IPv6 address of the LDP Peer.
	Ipv6PeerId *Multivalue `json:"ipv6PeerId,omitempty"`
	// LSPPingCV: LSP Ping CV
	LSPPingCV *Multivalue `json:"lSPPingCV,omitempty"`
	// Label: Label
	Label *Multivalue `json:"label,omitempty"`
	// Mtu: The 2-octet value for the maximum Transmission Unit (MTU).
	Mtu *Multivalue `json:"mtu,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PWACHCC: PW-ACH CC
	PWACHCC *Multivalue `json:"pWACHCC,omitempty"`
	// PWStatusCode: PW Status Code to be sent when to transition to down state if PW Status Send Notification is enabled
	PWStatusCode *Multivalue `json:"pWStatusCode,omitempty"`
	// PeerId: The 32-bit IPv4 address of the LDP Peer.
	PeerId *Multivalue `json:"peerId,omitempty"`
	// PwStatusSendNotification: If selected, it signifies whether to send a notification message with a PW status for the corresponding PW
	PwStatusSendNotification *Multivalue `json:"pwStatusSendNotification,omitempty"`
	// RepeatCount: The number of times to repeat the Up/Down status of the PW. '0' means keep toggling the Up/Down state indefinitely.
	RepeatCount *Multivalue `json:"repeatCount,omitempty"`
	// RouterAlertCC: Router Alert CC
	RouterAlertCC *Multivalue `json:"routerAlertCC,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UpInterval: Time Interval for which the PW status will remain in Up state before transitioning again to Down state.
	UpInterval *Multivalue `json:"upInterval,omitempty"`
	// VCIDStart: The value of the VC ID
	VCIDStart *Multivalue `json:"vCIDStart,omitempty"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	Ethernet            []*TopologyEthernet            `json:"ethernet"`
	Ipv4Loopback        []*TopologyIpv4Loopback        `json:"ipv4Loopback"`
	Ipv6Loopback        []*TopologyIpv6Loopback        `json:"ipv6Loopback"`
	LdpBasicRouter      []*TopologyLdpBasicRouter      `json:"ldpBasicRouter"`
	LdpBasicRouterV6    []*TopologyLdpBasicRouterV6    `json:"ldpBasicRouterV6"`
	LdpTargetedRouter   []*TopologyLdpTargetedRouter   `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6 []*TopologyLdpTargetedRouterV6 `json:"ldpTargetedRouterV6"`
	Mpls                []*TopologyMpls                `json:"mpls"`
	Tag                 []*TopologyTag                 `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdppwvpls) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdppwvpls) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdppwvpls) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdppwvpls) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AutoPeerID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoPeerID",
		isMultivalue: true,
	})
	n.BfdPwCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdPwCV",
		isMultivalue: true,
	})
	n.BfdUdpCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdUdpCV",
		isMultivalue: true,
	})
	n.CBitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cBitEnabled",
		isMultivalue: true,
	})
	n.DescEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "descEnabled",
		isMultivalue: true,
	})
	n.Description.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "description",
		isMultivalue: true,
	})
	n.DownInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downInterval",
		isMultivalue: true,
	})
	n.DownStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downStart",
		isMultivalue: true,
	})
	n.EnableCCCVNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCCCVNegotiation",
		isMultivalue: true,
	})
	n.EnablePWStatus.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePWStatus",
		isMultivalue: true,
	})
	n.GroupId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupId",
		isMultivalue: true,
	})
	n.InterfaceType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceType",
		isMultivalue: true,
	})
	n.Ipv6PeerId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6PeerId",
		isMultivalue: true,
	})
	n.LSPPingCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPPingCV",
		isMultivalue: true,
	})
	n.Label.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "label",
		isMultivalue: true,
	})
	n.Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtu",
		isMultivalue: true,
	})
	n.PWACHCC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pWACHCC",
		isMultivalue: true,
	})
	n.PWStatusCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pWStatusCode",
		isMultivalue: true,
	})
	n.PeerId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerId",
		isMultivalue: true,
	})
	n.PwStatusSendNotification.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pwStatusSendNotification",
		isMultivalue: true,
	})
	n.RepeatCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "repeatCount",
		isMultivalue: true,
	})
	n.RouterAlertCC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerAlertCC",
		isMultivalue: true,
	})
	n.UpInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upInterval",
		isMultivalue: true,
	})
	n.VCIDStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vCIDStart",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLdpv6ConnectedInterface: LDPv6 Interface level Configuration
type TopologyLdpv6ConnectedInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Authentication: The type of cryptographic authentication to be used on this link interface
	Authentication *Multivalue `json:"authentication,omitempty"`
	// BasicHelloInterval: The number of seconds between this router's Hello packets.
	BasicHelloInterval *Multivalue `json:"basicHelloInterval,omitempty"`
	// BasicHoldTime: Maximum length of time that a sending LSR will retain the record of Hellos sent by the receiving LSR, without receiving another Hello message.
	BasicHoldTime *Multivalue `json:"basicHoldTime,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// LabelSpaceID: Identifies the set of labels that will be used. Part of the LDP Identifier.
	LabelSpaceID *Multivalue `json:"labelSpaceID,omitempty"`
	// MD5Key: A value to be used as the secret MD5 Key.
	MD5Key *Multivalue `json:"mD5Key,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OperationMode: The type of LDP Label Advertisement.
	OperationMode *Multivalue `json:"operationMode,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpv6ConnectedInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpv6ConnectedInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpv6ConnectedInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpv6ConnectedInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.BasicHelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "basicHelloInterval",
		isMultivalue: true,
	})
	n.BasicHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "basicHoldTime",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.LabelSpaceID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceID",
		isMultivalue: true,
	})
	n.MD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mD5Key",
		isMultivalue: true,
	})
	n.OperationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "operationMode",
		isMultivalue: true,
	})
}

// TopologyLdpv6LoopbackInterface: LDPv6 Loopback Interface level Configuration
type TopologyLdpv6LoopbackInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpv6LoopbackInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpv6LoopbackInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpv6LoopbackInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpv6LoopbackInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyLdpvplsbgpad: LDP FEC129 Configuration
type TopologyLdpvplsbgpad struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AsNumberVplsId: The AS number of the VPLS Id
	AsNumberVplsId *Multivalue `json:"asNumberVplsId,omitempty"`
	// AssignedNumberVplsId: The assigned number for the VPLS Id
	AssignedNumberVplsId *Multivalue `json:"assignedNumberVplsId,omitempty"`
	// AutoPeerID: If selected, LDP Peer IP would be taken from LDP router's peer configuration.
	AutoPeerID *Multivalue `json:"autoPeerID,omitempty"`
	// AutoPeerId: If selected, LDP Peer IP would be taken from LDP router's peer configuration.

	AutoPeerId *bool `json:"autoPeerId,omitempty"`
	// BfdPwCV: BFD PW-ACH CV
	BfdPwCV *Multivalue `json:"bfdPwCV,omitempty"`
	// BfdUdpCV: BFD IP/UDP CV
	BfdUdpCV *Multivalue `json:"bfdUdpCV,omitempty"`
	// CBitEnabled: If selected, sets the C-Bit (flag). It is the highest order bit in the VC Type field. If the bit is set, it indicates the presence of a control word on this VC.
	CBitEnabled *Multivalue `json:"cBitEnabled,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DescEnabled: If selected, indicates that an optional Interface Description is present
	DescEnabled *Multivalue `json:"descEnabled,omitempty"`
	// Description: An optional user-defined Interface Description. It may be used with ALL VC types. Valid length is 0 to 80 octets
	Description *Multivalue `json:"description,omitempty"`
	// DownInterval: Time interval for which the PW status will remain down
	DownInterval *Multivalue `json:"downInterval,omitempty"`
	// DownStart: The duration in time after session becomes up and a notification message being sent to make the session down
	DownStart *Multivalue `json:"downStart,omitempty"`
	// EnableCCCVNegotiation: If selected, indicates that CCCV Negotiation is enabled
	EnableCCCVNegotiation *Multivalue `json:"enableCCCVNegotiation,omitempty"`
	// EnablePWStatus: If selected, this enables the use of PW Status TLV in notification messages to notify the PW status
	EnablePWStatus *Multivalue `json:"enablePWStatus,omitempty"`
	// GroupId: A user-defined 32-bit value used to identify a group of VCs
	GroupId *Multivalue `json:"groupId,omitempty"`
	// InterfaceType: The 15-bit VC Type used in the VC FEC element.It depends on the Layer 2 protocol used on the interface
	InterfaceType *Multivalue `json:"interfaceType,omitempty"`
	// IpAddressVplsId: The IP address of the VPLS id.
	IpAddressVplsId *Multivalue `json:"ipAddressVplsId,omitempty"`
	// Ipv6PeerId: The 128-bit IPv6 address of the LDP Peer.
	Ipv6PeerId *Multivalue `json:"ipv6PeerId,omitempty"`
	// LSPPingCV: LSP Ping CV
	LSPPingCV *Multivalue `json:"lSPPingCV,omitempty"`
	// Label: Label
	Label *Multivalue `json:"label,omitempty"`
	// Mtu: The 2-octet value for the maximum Transmission Unit (MTU).
	Mtu *Multivalue `json:"mtu,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PWACHCC: PW-ACH CC
	PWACHCC *Multivalue `json:"pWACHCC,omitempty"`
	// PWStatusCode: PW Status Code to be sent when to transition to down state if PW Status Send Notification is enabled
	PWStatusCode *Multivalue `json:"pWStatusCode,omitempty"`
	// PeerId: The 32-bit IPv4 address of the LDP Peer.
	PeerId *Multivalue `json:"peerId,omitempty"`
	// ProvisioningModelType: Provisioning Model Type. Manual or BGP Autodiscovery
	ProvisioningModelType *Multivalue `json:"provisioningModelType,omitempty"`
	// PwStatusSendNotification: If selected, it signifies whether to send a notification message with a PW status for the corresponding PW
	PwStatusSendNotification *Multivalue `json:"pwStatusSendNotification,omitempty"`
	// RepeatCount: The number of times to repeat the Up/Down status of the PW. '0' means keep toggling the Up/Down state indefinitely.
	RepeatCount *Multivalue `json:"repeatCount,omitempty"`
	// RouterAlertCC: Router Alert CC
	RouterAlertCC *Multivalue `json:"routerAlertCC,omitempty"`
	// SourceAIIType: Source AII Type
	SourceAIIType *Multivalue `json:"sourceAIIType,omitempty"`
	// SourceAIIasIP: Source AII as IP
	SourceAIIasIP *Multivalue `json:"sourceAIIasIP,omitempty"`
	// SourceAIIasNumber: Source AII as Number
	SourceAIIasNumber *Multivalue `json:"sourceAIIasNumber,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TargetAIIType: Target AII Type
	TargetAIIType *Multivalue `json:"targetAIIType,omitempty"`
	// TargetAIIasIP: Target AII as IP
	TargetAIIasIP *Multivalue `json:"targetAIIasIP,omitempty"`
	// TargetAIIasNumber: Target AII as Number
	TargetAIIasNumber *Multivalue `json:"targetAIIasNumber,omitempty"`
	// TypeVplsId: The VPLS Id format
	TypeVplsId *Multivalue `json:"typeVplsId,omitempty"`
	// UpInterval: Time Interval for which the PW status will remain in Up state before transitioning again to Down state.
	UpInterval *Multivalue `json:"upInterval,omitempty"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	Ethernet            []*TopologyEthernet            `json:"ethernet"`
	Ipv4Loopback        []*TopologyIpv4Loopback        `json:"ipv4Loopback"`
	Ipv6Loopback        []*TopologyIpv6Loopback        `json:"ipv6Loopback"`
	LdpBasicRouter      []*TopologyLdpBasicRouter      `json:"ldpBasicRouter"`
	LdpBasicRouterV6    []*TopologyLdpBasicRouterV6    `json:"ldpBasicRouterV6"`
	LdpTargetedRouter   []*TopologyLdpTargetedRouter   `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6 []*TopologyLdpTargetedRouterV6 `json:"ldpTargetedRouterV6"`
	Tag                 []*TopologyTag                 `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLdpvplsbgpad) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLdpvplsbgpad) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLdpvplsbgpad) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLdpvplsbgpad) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumberVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumberVplsId",
		isMultivalue: true,
	})
	n.AssignedNumberVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "assignedNumberVplsId",
		isMultivalue: true,
	})
	n.AutoPeerID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoPeerID",
		isMultivalue: true,
	})
	n.BfdPwCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdPwCV",
		isMultivalue: true,
	})
	n.BfdUdpCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdUdpCV",
		isMultivalue: true,
	})
	n.CBitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cBitEnabled",
		isMultivalue: true,
	})
	n.DescEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "descEnabled",
		isMultivalue: true,
	})
	n.Description.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "description",
		isMultivalue: true,
	})
	n.DownInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downInterval",
		isMultivalue: true,
	})
	n.DownStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downStart",
		isMultivalue: true,
	})
	n.EnableCCCVNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCCCVNegotiation",
		isMultivalue: true,
	})
	n.EnablePWStatus.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePWStatus",
		isMultivalue: true,
	})
	n.GroupId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupId",
		isMultivalue: true,
	})
	n.InterfaceType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceType",
		isMultivalue: true,
	})
	n.IpAddressVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipAddressVplsId",
		isMultivalue: true,
	})
	n.Ipv6PeerId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6PeerId",
		isMultivalue: true,
	})
	n.LSPPingCV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lSPPingCV",
		isMultivalue: true,
	})
	n.Label.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "label",
		isMultivalue: true,
	})
	n.Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtu",
		isMultivalue: true,
	})
	n.PWACHCC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pWACHCC",
		isMultivalue: true,
	})
	n.PWStatusCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pWStatusCode",
		isMultivalue: true,
	})
	n.PeerId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerId",
		isMultivalue: true,
	})
	n.ProvisioningModelType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "provisioningModelType",
		isMultivalue: true,
	})
	n.PwStatusSendNotification.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pwStatusSendNotification",
		isMultivalue: true,
	})
	n.RepeatCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "repeatCount",
		isMultivalue: true,
	})
	n.RouterAlertCC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerAlertCC",
		isMultivalue: true,
	})
	n.SourceAIIType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAIIType",
		isMultivalue: true,
	})
	n.SourceAIIasIP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAIIasIP",
		isMultivalue: true,
	})
	n.SourceAIIasNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAIIasNumber",
		isMultivalue: true,
	})
	n.TargetAIIType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAIIType",
		isMultivalue: true,
	})
	n.TargetAIIasIP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAIIasIP",
		isMultivalue: true,
	})
	n.TargetAIIasNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "targetAIIasNumber",
		isMultivalue: true,
	})
	n.TypeVplsId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeVplsId",
		isMultivalue: true,
	})
	n.UpInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "upInterval",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLearnedInfo: The main learned information node that contains tables of learned information.
type TopologyLearnedInfo struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath           `json:"xpath,omitempty"`
	Col   []*TopologyCol   `json:"col"`
	Table []*TopologyTable `json:"table"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLearnedInfo) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLearnedInfo) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLearnedInfo) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLearnedInfo) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Col {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "col",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Table {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "table",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLearnedInfoUpdate: The learned information trigger node that contains trigger tables of learned information.
type TopologyLearnedInfoUpdate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath                           *XPath                                     `json:"xpath,omitempty"`
	MplsoamSbfdResponderLearnedInfo []*TopologyMplsoamSbfdResponderLearnedInfo `json:"mplsoamSbfdResponderLearnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLearnedInfoUpdate) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLearnedInfoUpdate) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLearnedInfoUpdate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLearnedInfoUpdate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.MplsoamSbfdResponderLearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsoamSbfdResponderLearnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLearnedLspIndex: TBD
type TopologyLearnedLspIndex struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLearnedLspIndex) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLearnedLspIndex) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLearnedLspIndex) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLearnedLspIndex) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyLearnedMsgDbType: TBD
type TopologyLearnedMsgDbType struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLearnedMsgDbType) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLearnedMsgDbType) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLearnedMsgDbType) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLearnedMsgDbType) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyLength: Tlv length container
type TopologyLength struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// Encoding: Encoding of the tlv value, any change will result in the value being reset

	Encoding *string `json:"encoding,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables/disables this field

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`
	// Size: Size of the tlv value in bits/bytes based on sizeType, any change will result in the value being reset

	Size *float32 `json:"size,omitempty"`
	// SizeType: Size type of the tlv value, any change will result in the value being reset

	SizeType *string `json:"sizeType,omitempty"`
	// Value: Value represented as a multivalue object
	Value       *Multivalue            `json:"value,omitempty"`
	Restriction []*TopologyRestriction `json:"restriction"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLength) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLength) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLength) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLength) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
	for i, o := range n.Restriction {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "restriction",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLevel: Fat Tree Topology - Per Level Info
type TopologyLevel struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// NodeCount: Number of Nodes Per Level

	NodeCount *float32 `json:"nodeCount,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLevel) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLevel) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLevel) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLevel) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyLightweightDhcp6RelayTlvProfile: Lightweight DHCPv6 Relay Agent TLV Profiles.
type TopologyLightweightDhcp6RelayTlvProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name       *string               `json:"name,omitempty"`
	TlvProfile []*TopologyTlvProfile `json:"tlvProfile"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLightweightDhcp6RelayTlvProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLightweightDhcp6RelayTlvProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLightweightDhcp6RelayTlvProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLightweightDhcp6RelayTlvProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLightweightDhcpv6relayAgent: Lightweight DHCPv6 Relay Agent protocol.
type TopologyLightweightDhcpv6relayAgent struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	LightweightDhcp6RelayTlvProfile *TopologyLightweightDhcp6RelayTlvProfile `json:"lightweightDhcp6RelayTlvProfile,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLightweightDhcpv6relayAgent) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLightweightDhcpv6relayAgent) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLightweightDhcpv6relayAgent) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLightweightDhcpv6relayAgent) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LightweightDhcp6RelayTlvProfile.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lightweightDhcp6RelayTlvProfile",
	})
}

// TopologyLink: TBD
type TopologyLink struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// FromMp: From MP
	FromMp *Multivalue `json:"fromMp,omitempty"`
	// FromMpIndex: From MP Index
	FromMpIndex *Multivalue `json:"fromMpIndex,omitempty"`
	// LinkType: Link Type
	LinkType *Multivalue `json:"linkType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ToMp: To MP
	ToMp *Multivalue `json:"toMp,omitempty"`
	// ToMpIndex: To MP Index
	ToMpIndex *Multivalue `json:"toMpIndex,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLink) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLink) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLink) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLink) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.FromMp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fromMp",
		isMultivalue: true,
	})
	n.FromMpIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fromMpIndex",
		isMultivalue: true,
	})
	n.LinkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkType",
		isMultivalue: true,
	})
	n.ToMp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "toMp",
		isMultivalue: true,
	})
	n.ToMpIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "toMpIndex",
		isMultivalue: true,
	})
}

// TopologyLinkLsaRoutes: Link Lsa routes
type TopologyLinkLsaRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// DCBit: Demand Circuit bit
	DCBit *Multivalue `json:"dCBit,omitempty"`
	// EBit: bit describing how AS-external-LSAs are flooded
	EBit *Multivalue `json:"eBit,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6) before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LABit: Options-LA Bit(Local Address)
	LABit *Multivalue `json:"lABit,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LinkLocalAddress: 128 Bits IPv6 address.
	LinkLocalAddress *Multivalue `json:"linkLocalAddress,omitempty"`
	// LinkStateId: Link State Id of the simulated IPv6 network
	LinkStateId *Multivalue `json:"linkStateId,omitempty"`
	// LinkStateIdStep: Link State Id Step for the LSAs to be generated for this set of IPv6 Inter-Area networks.
	LinkStateIdStep *Multivalue `json:"linkStateIdStep,omitempty"`
	// MCBit: Options-MC Bit(Multicast)
	MCBit *Multivalue `json:"mCBit,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised by a Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// NBit: bit for handling Type 7 LSAs
	NBit *Multivalue `json:"nBit,omitempty"`
	// NUBit: Options-NU Bit(No Unicast)
	NUBit *Multivalue `json:"nUBit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Prefixes of the simulated IPv6 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PBit: Options-P Bit(Propagate)
	PBit *Multivalue `json:"pBit,omitempty"`
	// Prefix: Prefix Length
	Prefix *Multivalue `json:"prefix,omitempty"`
	// RBit: Router bit
	RBit *Multivalue `json:"rBit,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// ReservedBit6: (6) Reserved Bit
	ReservedBit6 *Multivalue `json:"reservedBit6,omitempty"`
	// ReservedBit7: (7) Reserved Bit
	ReservedBit7 *Multivalue `json:"reservedBit7,omitempty"`
	// RouterPriority: Router Priority
	RouterPriority *Multivalue `json:"routerPriority,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// UnusedBit4: Options-(4)Unused
	UnusedBit4 *Multivalue `json:"unusedBit4,omitempty"`
	// UnusedBit5: Options-(5)Unused
	UnusedBit5 *Multivalue `json:"unusedBit5,omitempty"`
	// UnusedBit6: Options-(6)Unused
	UnusedBit6 *Multivalue `json:"unusedBit6,omitempty"`
	// UnusedBit7: Options-(7)Unused
	UnusedBit7 *Multivalue `json:"unusedBit7,omitempty"`
	// V6Bit: bit for excluding the router/link from IPv6 routing calculations. If clear, router/link is excluded
	V6Bit *Multivalue `json:"v6Bit,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// XBit: bit for forwarding of IP multicast datagrams
	XBit *Multivalue `json:"xBit,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLinkLsaRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLinkLsaRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLinkLsaRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLinkLsaRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.DCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dCBit",
		isMultivalue: true,
	})
	n.EBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eBit",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LABit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lABit",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LinkLocalAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkLocalAddress",
		isMultivalue: true,
	})
	n.LinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateId",
		isMultivalue: true,
	})
	n.LinkStateIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateIdStep",
		isMultivalue: true,
	})
	n.MCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mCBit",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nBit",
		isMultivalue: true,
	})
	n.NUBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nUBit",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pBit",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.RBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rBit",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.ReservedBit6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedBit6",
		isMultivalue: true,
	})
	n.ReservedBit7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservedBit7",
		isMultivalue: true,
	})
	n.RouterPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerPriority",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.UnusedBit4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit4",
		isMultivalue: true,
	})
	n.UnusedBit5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit5",
		isMultivalue: true,
	})
	n.UnusedBit6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit6",
		isMultivalue: true,
	})
	n.UnusedBit7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unusedBit7",
		isMultivalue: true,
	})
	n.V6Bit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "v6Bit",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.XBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "xBit",
		isMultivalue: true,
	})
}

// TopologyLinkTable: Topology Link Table. sizes of fromNodeIndex and toNodeIndex are the same.
type TopologyLinkTable struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// FromNodeIndex: from node index.
	FromNodeIndex []string `json:"fromNodeIndex"`
	// ToNodeIndex: to node index.
	ToNodeIndex []string `json:"toNodeIndex"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLinkTable) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLinkTable) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLinkTable) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLinkTable) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyLns: L2TP Network Server protocol.
type TopologyLns struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// BearerCapability: Indicates to the DUT the bearer device types from which incoming calls will be accepted.
	BearerCapability *Multivalue `json:"bearerCapability,omitempty"`
	// BearerType: The bearer type.
	BearerType *Multivalue `json:"bearerType,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ControlMsgsRetryCounter: Number of L2TP retries
	ControlMsgsRetryCounter *Multivalue `json:"controlMsgsRetryCounter,omitempty"`
	// CredentialsCount: Number of L2TP authentication credentials the LNS accepts for multiple tunnels establishment.

	CredentialsCount *float32 `json:"credentialsCount,omitempty"`
	// EnableControlChecksum: If checked, UDP checksum is enabled on control plane packets
	EnableControlChecksum *Multivalue `json:"enableControlChecksum,omitempty"`
	// EnableDataChecksum: If checked, UDP checksum is enabled on data plane packets
	EnableDataChecksum *Multivalue `json:"enableDataChecksum,omitempty"`
	// EnableExcludeHdlc: If checked, HDLC header is not encoded in the L2TP packets.

	EnableExcludeHdlc *bool `json:"enableExcludeHdlc,omitempty"`
	// EnableHelloRequest: If checked, L2TP hello request is enabled
	EnableHelloRequest *Multivalue `json:"enableHelloRequest,omitempty"`
	// EnablePeriodicCSURQ: If checked, CSURQ will be sent at CSURQ interval periodically
	EnablePeriodicCSURQ *Multivalue `json:"enablePeriodicCSURQ,omitempty"`
	// FramingCapability: Designates sync or async framing
	FramingCapability *Multivalue `json:"framingCapability,omitempty"`
	// HelloRequestInterval: Timeout for L2TP hello request, in seconds
	HelloRequestInterval *Multivalue `json:"helloRequestInterval,omitempty"`
	// InitRetransmitInterval: The initial amount of time that can elapse before an unacknowledged control message is retransmitted.
	InitRetransmitInterval *Multivalue `json:"initRetransmitInterval,omitempty"`
	// LacHostName: This is the hostname used in authentication.
	LacHostName *Multivalue `json:"lacHostName,omitempty"`
	// LacSecret: L2TP secret to be used in authentication
	LacSecret *Multivalue `json:"lacSecret,omitempty"`
	// LnsHostName: L2TP hostname sent by Ixia port when acting as LNS
	LnsHostName *Multivalue `json:"lnsHostName,omitempty"`
	// MaxRetransmitInterval: The maximum amount of time that can elapse for receiving a reply for a control message.
	MaxRetransmitInterval *Multivalue `json:"maxRetransmitInterval,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoCallTimeout: Timeout for no call establishment, in seconds
	NoCallTimeout *Multivalue `json:"noCallTimeout,omitempty"`
	// OffsetByte: L2TP offset byte. Applicable only if offset bit is set.
	OffsetByte *Multivalue `json:"offsetByte,omitempty"`
	// OffsetLength: L2TP offset length in bytes. Applicable only if offset bit set.
	OffsetLength *Multivalue `json:"offsetLength,omitempty"`
	// PeriodicCSURQInterval: CSURQ interval, in seconds
	PeriodicCSURQInterval *Multivalue `json:"periodicCSURQInterval,omitempty"`
	// ReceiveWindowSize: L2TP Receive Window Size
	ReceiveWindowSize *Multivalue `json:"receiveWindowSize,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TunnelAuthentication: Enables or disables L2TP tunnel authentication
	TunnelAuthentication *Multivalue `json:"tunnelAuthentication,omitempty"`
	// UdpDestinationPort: UDP port to employ for tunneling destinations
	UdpDestinationPort *Multivalue `json:"udpDestinationPort,omitempty"`
	// UdpSourcePort: UDP port to employ for tunneling sources
	UdpSourcePort *Multivalue `json:"udpSourcePort,omitempty"`
	// UseHiddenAVPs: If checked, Attribute Value Pair hiding is enabled
	UseHiddenAVPs *Multivalue `json:"useHiddenAVPs,omitempty"`
	// UseLengthBitInPayload: If checked, length bit is set in L2TP data packets.
	UseLengthBitInPayload *Multivalue `json:"useLengthBitInPayload,omitempty"`
	// UseOffsetBitInPayload: If checked, offset bit is enabled in L2TP data packets
	UseOffsetBitInPayload *Multivalue `json:"useOffsetBitInPayload,omitempty"`
	// UseSequenceNoInPayload: If checked, sequence bit is set in L2TP data packets.
	UseSequenceNoInPayload *Multivalue `json:"useSequenceNoInPayload,omitempty"`

	LnsAuthCredentials *TopologyLnsAuthCredentials `json:"lnsAuthCredentials,omitempty"`
	Pppoxserver        []*TopologyPppoxserver      `json:"pppoxserver"`
	Tag                []*TopologyTag              `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLns) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLns) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLns) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLns) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BearerCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bearerCapability",
		isMultivalue: true,
	})
	n.BearerType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bearerType",
		isMultivalue: true,
	})
	n.ControlMsgsRetryCounter.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "controlMsgsRetryCounter",
		isMultivalue: true,
	})
	n.EnableControlChecksum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableControlChecksum",
		isMultivalue: true,
	})
	n.EnableDataChecksum.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDataChecksum",
		isMultivalue: true,
	})
	n.EnableHelloRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloRequest",
		isMultivalue: true,
	})
	n.EnablePeriodicCSURQ.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePeriodicCSURQ",
		isMultivalue: true,
	})
	n.FramingCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "framingCapability",
		isMultivalue: true,
	})
	n.HelloRequestInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloRequestInterval",
		isMultivalue: true,
	})
	n.InitRetransmitInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initRetransmitInterval",
		isMultivalue: true,
	})
	n.LacHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacHostName",
		isMultivalue: true,
	})
	n.LacSecret.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacSecret",
		isMultivalue: true,
	})
	n.LnsHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lnsHostName",
		isMultivalue: true,
	})
	n.MaxRetransmitInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRetransmitInterval",
		isMultivalue: true,
	})
	n.NoCallTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noCallTimeout",
		isMultivalue: true,
	})
	n.OffsetByte.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetByte",
		isMultivalue: true,
	})
	n.OffsetLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetLength",
		isMultivalue: true,
	})
	n.PeriodicCSURQInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicCSURQInterval",
		isMultivalue: true,
	})
	n.ReceiveWindowSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "receiveWindowSize",
		isMultivalue: true,
	})
	n.TunnelAuthentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelAuthentication",
		isMultivalue: true,
	})
	n.UdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpDestinationPort",
		isMultivalue: true,
	})
	n.UdpSourcePort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpSourcePort",
		isMultivalue: true,
	})
	n.UseHiddenAVPs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useHiddenAVPs",
		isMultivalue: true,
	})
	n.UseLengthBitInPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useLengthBitInPayload",
		isMultivalue: true,
	})
	n.UseOffsetBitInPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useOffsetBitInPayload",
		isMultivalue: true,
	})
	n.UseSequenceNoInPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useSequenceNoInPayload",
		isMultivalue: true,
	})
	n.LnsAuthCredentials.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "lnsAuthCredentials",
	})
	for i, o := range n.Pppoxserver {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pppoxserver",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyLnsAuthCredentials: LNS Authentication Credentials.
type TopologyLnsAuthCredentials struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// LacHostName: LAC Hostname used for tunnel authentication.
	LacHostName *Multivalue `json:"lacHostName,omitempty"`
	// LacSecret: Secret value used for tunnel authentication.
	LacSecret *Multivalue `json:"lacSecret,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLnsAuthCredentials) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLnsAuthCredentials) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLnsAuthCredentials) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLnsAuthCredentials) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LacHostName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacHostName",
		isMultivalue: true,
	})
	n.LacSecret.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lacSecret",
		isMultivalue: true,
	})
}

// TopologyLocalIntefaceId: TBD
type TopologyLocalIntefaceId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLocalIntefaceId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLocalIntefaceId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLocalIntefaceId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLocalIntefaceId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyLocalIpv4Address: TBD
type TopologyLocalIpv4Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLocalIpv4Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLocalIpv4Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLocalIpv4Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLocalIpv4Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyLocalIpv6Address: TBD
type TopologyLocalIpv6Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLocalIpv6Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLocalIpv6Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLocalIpv6Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLocalIpv6Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyLocalNodeId: TBD
type TopologyLocalNodeId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyLocalNodeId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyLocalNodeId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyLocalNodeId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyLocalNodeId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyMacPools: Represents an Ethernet device set
type TopologyMacPools struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableVlans: Enables VLANs for the sessions
	EnableVlans *Multivalue `json:"enableVlans,omitempty"`
	// Mac: MAC addresses of the devices
	Mac *Multivalue `json:"mac,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfAddresses: Number of MAC addresses in the simulated MAC range

	NumberOfAddresses *float32 `json:"numberOfAddresses,omitempty"`
	// NumberOfAddressesAsy: Number of MAC addresses in the simulated MAC range
	NumberOfAddressesAsy *Multivalue `json:"numberOfAddressesAsy,omitempty"`
	// PrefixLength: The length (in bits) of the mask to be used in conjunction with all the addresses created in the range
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// UseVlans: Flag to determine whether VLANs are enabled

	UseVlans *bool `json:"useVlans,omitempty"`
	// VlanCount: Number of active VLANs

	VlanCount      *float32                  `json:"vlanCount,omitempty"`
	CMacProperties []*TopologyCMacProperties `json:"cMacProperties"`

	Connector               *TopologyConnector                 `json:"connector,omitempty"`
	EvpnIPv4PrefixRange     []*TopologyEvpnIPv4PrefixRange     `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange     []*TopologyEvpnIPv6PrefixRange     `json:"evpnIPv6PrefixRange"`
	Ipv4PrefixPools         []*TopologyIpv4PrefixPools         `json:"ipv4PrefixPools"`
	Ipv6PrefixPools         []*TopologyIpv6PrefixPools         `json:"ipv6PrefixPools"`
	IsisSpbMacCloudConfig   []*TopologyIsisSpbMacCloudConfig   `json:"isisSpbMacCloudConfig"`
	IsisTrillUCastMacConfig []*TopologyIsisTrillUCastMacConfig `json:"isisTrillUCastMacConfig"`
	Tag                     []*TopologyTag                     `json:"tag"`
	Vlan                    []*TopologyVlan                    `json:"vlan"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMacPools) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMacPools) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMacPools) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMacPools) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableVlans.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableVlans",
		isMultivalue: true,
	})
	n.Mac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mac",
		isMultivalue: true,
	})
	n.NumberOfAddressesAsy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfAddressesAsy",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4PrefixPools {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4PrefixPools",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6PrefixPools {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6PrefixPools",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbMacCloudConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbMacCloudConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillUCastMacConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillUCastMacConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyMacsec: MACsec
type TopologyMacsec struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActiveDevice: Determines whether a MACsec device is active or not. If disabled, MACsec will not be started on the device.
	ActiveDevice *Multivalue `json:"activeDevice,omitempty"`
	// BadIcv: Checkbox to insert Bad ICV in the packet.
	BadIcv *Multivalue `json:"badIcv,omitempty"`
	// CipherSuite: The type of cipher suite. Options include: 1) GCM-AES-128 2) GCM-AES-256 3) GCM-AES-XPN-128 4) GCM-AES-XPN-256
	CipherSuite *Multivalue `json:"cipherSuite,omitempty"`
	// ConfidentialityOffset: Determines the confidentiality offset for both transmit and receive channel.
	ConfidentialityOffset *Multivalue `json:"confidentialityOffset,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DutMsbOfXpn: The 32 most significant bits of the XPN that DUT will be using to construct the 64 bits XPN value when test starts.
	DutMsbOfXpn *Multivalue `json:"dutMsbOfXpn,omitempty"`
	// DutSciMac: MAC component of SCI with which MACsec traffic is expected from the DUT.
	DutSciMac *Multivalue `json:"dutSciMac,omitempty"`
	// DutSciPortId: Port ID component of SCI with which MACsec traffic is expected from the DUT.
	DutSciPortId *Multivalue `json:"dutSciPortId,omitempty"`
	// EnableConfidentiality: Determines whether transmitted MACsec payload is encrypted or not.
	EnableConfidentiality *Multivalue `json:"enableConfidentiality,omitempty"`
	// EnableEncryptedVlans: Enables VLANs for the sessions.
	EnableEncryptedVlans *Multivalue `json:"enableEncryptedVlans,omitempty"`
	// EnableOutOfWindowPn: Used for -ve testing to include a packet with PN = (HPN-W) within the set of packets as configured.
	EnableOutOfWindowPn *Multivalue `json:"enableOutOfWindowPn,omitempty"`
	// EncryptedVlanCount: Determines if VLAN information to be encrypted or not. Maximum 6 VLANs can be added in the encrypted payload.

	EncryptedVlanCount *float32 `json:"encryptedVlanCount,omitempty"`
	// EndStation: Determines whether this device should act as the End Station.
	EndStation *Multivalue `json:"endStation,omitempty"`
	// IncludeSci: Determines whether SCI should be included in the SecTAG of the transmitted MACsec traffic.
	IncludeSci *Multivalue `json:"includeSci,omitempty"`
	// InterleaveDuration: Determines how long the Old and New SAKs should be interleaved.

	InterleaveDuration *float32 `json:"interleaveDuration,omitempty"`
	// InterleaveOldSak: Determines whether Ixia interleaves Old and New SAKs after Rekey is triggered.

	InterleaveOldSak *bool `json:"interleaveOldSak,omitempty"`
	// MalformedPktPercent: This value will determine how much of the packets will have malformed TCI settings. 100% means all packets will be sent with the negative configuration.
	MalformedPktPercent *Multivalue `json:"malformedPktPercent,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OverrideTciSetting: If enabled, the default TCI settings as per configuration will be allowed for overwriting. Used to simulate mal-configured SecTAG for negative testing.
	OverrideTciSetting *Multivalue `json:"overrideTciSetting,omitempty"`
	// PeriodicRekeyAttempts: Determines the number of times Rekey will happen after MACsec is started.

	PeriodicRekeyAttempts *float32 `json:"periodicRekeyAttempts,omitempty"`
	// PeriodicRekeyInterval: Determines the time interval between two subsequent Rekey events. The timer starts with the first MACsec packet transmission from a device.

	PeriodicRekeyInterval *float32 `json:"periodicRekeyInterval,omitempty"`
	// PnExhaustionBehaviour: What should Ixia tx port do if PN has exhausted but no new SAK is available from MKA or Rekey Timer has not expired.
	PnExhaustionBehaviour *Multivalue `json:"pnExhaustionBehaviour,omitempty"`
	// PortId: Port ID component of SCI with which MACsec traffic is transmitted.
	PortId *Multivalue `json:"portId,omitempty"`
	// RekeyMode: Rekey criteria, either PN based or Timer based.

	RekeyMode *string `json:"rekeyMode,omitempty"`
	// ReplayWindowSize: Window size required for calculating LAPN.
	ReplayWindowSize *Multivalue `json:"replayWindowSize,omitempty"`
	// RxSakPoolSize: Determines the number of SAKs configured for each device for the Rx secure channel. Multiple SAKs are needed if DUT is expected to trigger Rekey during the test.

	RxSakPoolSize *float32 `json:"rxSakPoolSize,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartingPn: PN value with which packet transmission will begin.
	StartingPn *Multivalue `json:"startingPn,omitempty"`
	// StartingXpn: PN value with which packet transmission will begin.
	StartingXpn *Multivalue `json:"startingXpn,omitempty"`
	// SystemId: System Identifier component of the SCI field with which MACsec traffic is transmitted.
	SystemId *Multivalue `json:"systemId,omitempty"`
	// TciCBit: Determines the C bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciCBit *Multivalue `json:"tciCBit,omitempty"`
	// TciEBit: Determines the E bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciEBit *Multivalue `json:"tciEBit,omitempty"`
	// TciEsBit: Determines the ES bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciEsBit *Multivalue `json:"tciEsBit,omitempty"`
	// TciScBit: Determines the SC bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciScBit *Multivalue `json:"tciScBit,omitempty"`
	// TciScbBit: Determines the SCB bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciScbBit *Multivalue `json:"tciScbBit,omitempty"`
	// TimerBasedRekeyBehaviour: Control to do timer based Rekey.

	TimerBasedRekeyBehaviour *string `json:"timerBasedRekeyBehaviour,omitempty"`
	// TxSakPoolSize: Determines the number of SAKs configured for each device for the Tx secure channel. Multiple SAKs are needed if Rekey scenario is to be simulated.

	TxSakPoolSize *float32 `json:"txSakPoolSize,omitempty"`
	// Version: Version bit in TCI field of SecTAG if Override TCI Settings is enabled.
	Version                 *Multivalue                        `json:"version,omitempty"`
	Ancp                    []*TopologyAncp                    `json:"ancp"`
	Dhcpv4relayAgent        []*TopologyDhcpv4relayAgent        `json:"dhcpv4relayAgent"`
	Dhcpv4server            []*TopologyDhcpv4server            `json:"dhcpv4server"`
	Dhcpv6relayAgent        []*TopologyDhcpv6relayAgent        `json:"dhcpv6relayAgent"`
	Dhcpv6server            []*TopologyDhcpv6server            `json:"dhcpv6server"`
	Geneve                  []*TopologyGeneve                  `json:"geneve"`
	Greoipv4                []*TopologyGreoipv4                `json:"greoipv4"`
	Greoipv6                []*TopologyGreoipv6                `json:"greoipv6"`
	InnerVlanList           []*TopologyInnerVlanList           `json:"innerVlanList"`
	Ipv4                    []*TopologyIpv4                    `json:"ipv4"`
	Ipv6                    []*TopologyIpv6                    `json:"ipv6"`
	Ipv6sr                  []*TopologyIpv6sr                  `json:"ipv6sr"`
	Lac                     []*TopologyLac                     `json:"lac"`
	LdpBasicRouter          []*TopologyLdpBasicRouter          `json:"ldpBasicRouter"`
	LdpBasicRouterV6        []*TopologyLdpBasicRouterV6        `json:"ldpBasicRouterV6"`
	LdpConnectedInterface   []*TopologyLdpConnectedInterface   `json:"ldpConnectedInterface"`
	LdpTargetedRouter       []*TopologyLdpTargetedRouter       `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6     []*TopologyLdpTargetedRouterV6     `json:"ldpTargetedRouterV6"`
	Ldpv6ConnectedInterface []*TopologyLdpv6ConnectedInterface `json:"ldpv6ConnectedInterface"`
	Lns                     []*TopologyLns                     `json:"lns"`
	Ntpclock                []*TopologyNtpclock                `json:"ntpclock"`
	OpenFlowController      []*TopologyOpenFlowController      `json:"openFlowController"`
	OpenFlowSwitch          []*TopologyOpenFlowSwitch          `json:"openFlowSwitch"`
	Ovsdbcontroller         []*TopologyOvsdbcontroller         `json:"ovsdbcontroller"`
	Ovsdbserver             []*TopologyOvsdbserver             `json:"ovsdbserver"`
	Ptp                     []*TopologyPtp                     `json:"ptp"`
	RsvpteIf                []*TopologyRsvpteIf                `json:"rsvpteIf"`
	RsvpteLsps              []*TopologyRsvpteLsps              `json:"rsvpteLsps"`

	RxSakPool *TopologyRxSakPool `json:"rxSakPool,omitempty"`

	TxSakPool *TopologyTxSakPool `json:"txSakPool,omitempty"`
	Vxlan     []*TopologyVxlan   `json:"vxlan"`
	Vxlanv6   []*TopologyVxlanv6 `json:"vxlanv6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMacsec) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMacsec) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMacsec) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMacsec) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActiveDevice.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeDevice",
		isMultivalue: true,
	})
	n.BadIcv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "badIcv",
		isMultivalue: true,
	})
	n.CipherSuite.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cipherSuite",
		isMultivalue: true,
	})
	n.ConfidentialityOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "confidentialityOffset",
		isMultivalue: true,
	})
	n.DutMsbOfXpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutMsbOfXpn",
		isMultivalue: true,
	})
	n.DutSciMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutSciMac",
		isMultivalue: true,
	})
	n.DutSciPortId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutSciPortId",
		isMultivalue: true,
	})
	n.EnableConfidentiality.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableConfidentiality",
		isMultivalue: true,
	})
	n.EnableEncryptedVlans.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEncryptedVlans",
		isMultivalue: true,
	})
	n.EnableOutOfWindowPn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOutOfWindowPn",
		isMultivalue: true,
	})
	n.EndStation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endStation",
		isMultivalue: true,
	})
	n.IncludeSci.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSci",
		isMultivalue: true,
	})
	n.MalformedPktPercent.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "malformedPktPercent",
		isMultivalue: true,
	})
	n.OverrideTciSetting.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideTciSetting",
		isMultivalue: true,
	})
	n.PnExhaustionBehaviour.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pnExhaustionBehaviour",
		isMultivalue: true,
	})
	n.PortId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portId",
		isMultivalue: true,
	})
	n.ReplayWindowSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "replayWindowSize",
		isMultivalue: true,
	})
	n.StartingPn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingPn",
		isMultivalue: true,
	})
	n.StartingXpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingXpn",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
	n.TciCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciCBit",
		isMultivalue: true,
	})
	n.TciEBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciEBit",
		isMultivalue: true,
	})
	n.TciEsBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciEsBit",
		isMultivalue: true,
	})
	n.TciScBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciScBit",
		isMultivalue: true,
	})
	n.TciScbBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciScbBit",
		isMultivalue: true,
	})
	n.Version.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "version",
		isMultivalue: true,
	})
	for i, o := range n.Ancp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ancp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv4relayAgent {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4relayAgent",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv4server {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4server",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6relayAgent {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6relayAgent",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6server {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6server",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Geneve {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "geneve",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Greoipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "greoipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Greoipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "greoipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.InnerVlanList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "innerVlanList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6sr {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6sr",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lac {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lac",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpConnectedInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpConnectedInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ldpv6ConnectedInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpv6ConnectedInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lns {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lns",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ntpclock {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ntpclock",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OpenFlowController {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "openFlowController",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OpenFlowSwitch {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "openFlowSwitch",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ovsdbcontroller {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ovsdbcontroller",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ovsdbserver {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ovsdbserver",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ptp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ptp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpteIf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpteIf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpteLsps {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpteLsps",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.RxSakPool.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rxSakPool",
	})
	n.TxSakPool.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txSakPool",
	})
	for i, o := range n.Vxlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlanv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlanv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyManager: Managers to which the OVSDB will initiate connections to.
type TopologyManager struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ManagerActive: Enable Manager
	ManagerActive *Multivalue `json:"managerActive,omitempty"`
	// ManagerIp: IPv4 Address of the Manager
	ManagerIp *Multivalue `json:"managerIp,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TcpPort: Specify the TCP port for the Manager
	TcpPort *Multivalue `json:"tcpPort,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyManager) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyManager) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyManager) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyManager) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ManagerActive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managerActive",
		isMultivalue: true,
	})
	n.ManagerIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "managerIp",
		isMultivalue: true,
	})
	n.TcpPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpPort",
		isMultivalue: true,
	})
}

// TopologyMatchAction: Match Criteria and Instruction-Action.
type TopologyMatchAction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name *string `json:"name,omitempty"`

	Instructions *TopologyInstructions `json:"instructions,omitempty"`

	MatchCriteria *TopologyMatchCriteria `json:"matchCriteria,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMatchAction) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMatchAction) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMatchAction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMatchAction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Instructions.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "instructions",
	})
	n.MatchCriteria.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "matchCriteria",
	})
}

// TopologyMatchCriteria: Match
type TopologyMatchCriteria struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name  *string                       `json:"name,omitempty"`
	Field []*TopologyMatchCriteriaField `json:"field"`

	MatchCriteria *TopologyMatchCriteria `json:"matchCriteria,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMatchCriteria) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMatchCriteria) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMatchCriteria) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMatchCriteria) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.MatchCriteria.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "matchCriteria",
	})
}

// TopologyMatchCriteriaField: Fixed size field.
type TopologyMatchCriteriaField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the field.

	Description *string `json:"description,omitempty"`
	// Encoding: The encoding of the field in bytes.

	Encoding *string `json:"encoding,omitempty"`
	// Enum: Internal enumeration type used to restrict possible field values.

	Enum *string `json:"enum,omitempty"`
	// IsEditable: Information on the requirement of the field.

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsEnabled: Enables disables the field.

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// IsRequired: Information on the requirement of the field.

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of packet field

	Name *string `json:"name,omitempty"`
	// SingleValue: If true the field can only be configured with a single value pattern.

	SingleValue *bool `json:"singleValue,omitempty"`
	// Size: The size of the field in bytes.

	Size *float32 `json:"size,omitempty"`
	// SizeType: The size types/data unit of the field.

	SizeType *string `json:"sizeType,omitempty"`
	// Value: The string value of the field.
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMatchCriteriaField) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMatchCriteriaField) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMatchCriteriaField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMatchCriteriaField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyMdLevels: TBD
type TopologyMdLevels struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// MdMegLevel: MD/MEG Level
	MdMegLevel *Multivalue `json:"mdMegLevel,omitempty"`
	// MdName: MD Name For MAC + Int, Please Use MAC-Int eg. 11:22:33:44:55:66-1 For Others, Use Any String
	MdName *Multivalue `json:"mdName,omitempty"`
	// MdNameFormat: MD Name Format
	MdNameFormat *Multivalue `json:"mdNameFormat,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMdLevels) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMdLevels) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMdLevels) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMdLevels) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.MdMegLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdMegLevel",
		isMultivalue: true,
	})
	n.MdName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdName",
		isMultivalue: true,
	})
	n.MdNameFormat.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mdNameFormat",
		isMultivalue: true,
	})
}

// TopologyMeters: Openflow Meter Configuration
type TopologyMeters struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Advertise: When this check box is cleared, no meter is advertised when the OpenFlow channel comes up or when the Enable check box is selected or cleared.
	Advertise *Multivalue `json:"advertise,omitempty"`
	// Flags: Select the meter configuration flags from the list.
	Flags *Multivalue `json:"flags,omitempty"`
	// MeterDesc: A description of the meter
	MeterDesc *Multivalue `json:"meterDesc,omitempty"`
	// MeterId: The value by which a meter is uniquely identified .
	MeterId *Multivalue `json:"meterId,omitempty"`
	// Multiplier: Number of instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfBands: Specify the number of Bands.

	NumberOfBands *float32         `json:"numberOfBands,omitempty"`
	Bands         []*TopologyBands `json:"bands"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMeters) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMeters) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMeters) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMeters) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Advertise.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertise",
		isMultivalue: true,
	})
	n.Flags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flags",
		isMultivalue: true,
	})
	n.MeterDesc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "meterDesc",
		isMultivalue: true,
	})
	n.MeterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "meterId",
		isMultivalue: true,
	})
	for i, o := range n.Bands {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bands",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyMka: Mka Configuration
type TopologyMka struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActiveDevice: Active
	ActiveDevice *Multivalue `json:"activeDevice,omitempty"`
	// CipherSuite: Cipher Suite
	CipherSuite *Multivalue `json:"cipherSuite,omitempty"`
	// ConfidentialityOffset: Confidentiality Offset
	ConfidentialityOffset *Multivalue `json:"confidentialityOffset,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DataPlaneParameters: By default MACsec data plane parameters (eg. LLPN, OLPN, LRX, ORX, LTX, OTX) will be learned from the underlying MAC layer as per MACSec data traffic Tx/Rx status. If MACSec traffic is not running (User is only doing MKA conformance test w/o MACSec traffic), then these variables need to be configured manually. Such variables are grouped into the page Data Plane Parameters. So it can be either Learned or Simulated.
	DataPlaneParameters *Multivalue `json:"dataPlaneParameters,omitempty"`
	// DelayProtect: Delay Protect behavior of the device
	DelayProtect *Multivalue `json:"delayProtect,omitempty"`
	// KeyServerPriority: Key Server Priority
	KeyServerPriority *Multivalue `json:"keyServerPriority,omitempty"`
	// KeyType: The source of CAK

	KeyType *string `json:"keyType,omitempty"`
	// LlpnStep: LLPN Step
	LlpnStep *Multivalue `json:"llpnStep,omitempty"`
	// MacsecCapability: MACsec capabilities
	MacsecCapability *Multivalue `json:"macsecCapability,omitempty"`
	// MacsecDesired: Whether MACsec is desired or not. Advertised in periodic hellos
	MacsecDesired *Multivalue `json:"macsecDesired,omitempty"`
	// MkaHelloTime: MKA Hello Time
	MkaHelloTime *Multivalue `json:"mkaHelloTime,omitempty"`
	// MkaLifeTime: MKA Life Time of a Peer

	MkaLifeTime *float32 `json:"mkaLifeTime,omitempty"`
	// MkaVersion: MKA Version
	MkaVersion *Multivalue `json:"mkaVersion,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OlpnStep: OLPN Step
	OlpnStep *Multivalue `json:"olpnStep,omitempty"`
	// OmitPeerInfo: In Group CA case, when multiple Ixia emulated devices are configured to be part of the same CA, for negative testing User may want to send live/potential peer list without any Ixia emulated peer info.This can be achieved by enabling this checkbox.
	OmitPeerInfo *Multivalue `json:"omitPeerInfo,omitempty"`
	// PeriodicRekeyAttempts: Number of times Rekey should be triggered.

	PeriodicRekeyAttempts *float32 `json:"periodicRekeyAttempts,omitempty"`
	// PeriodicRekeyInterval: Time interval between two Rekey triggers.

	PeriodicRekeyInterval *float32 `json:"periodicRekeyInterval,omitempty"`
	// RandomizeMemberIdentifier: If this box is checked, then Ixia MKA devices will generate random member identifiers. Otherwise member identifiers of the form MAC Address-Counter will be generated to aid in debugging

	RandomizeMemberIdentifier *bool `json:"randomizeMemberIdentifier,omitempty"`
	// RekeyBehaviour: Determines the Rekey behavior.

	RekeyBehaviour *string `json:"rekeyBehaviour,omitempty"`
	// RekeyMode: Rekey criteria.

	RekeyMode *string `json:"rekeyMode,omitempty"`
	// RekeyThresholdPN: Rekey Threshold PN
	RekeyThresholdPN *Multivalue `json:"rekeyThresholdPN,omitempty"`
	// RekeyThresholdXPN: Rekey Threshold XPN
	RekeyThresholdXPN *Multivalue `json:"rekeyThresholdXPN,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartingDistributedAN: Starting Distributed AN
	StartingDistributedAN *Multivalue `json:"startingDistributedAN,omitempty"`
	// StartingKeyNumber: Starting Key Number
	StartingKeyNumber *Multivalue `json:"startingKeyNumber,omitempty"`
	// StartingLLPN: Starting LLPN
	StartingLLPN *Multivalue `json:"startingLLPN,omitempty"`
	// StartingOLPN: Starting OLPN
	StartingOLPN *Multivalue `json:"startingOLPN,omitempty"`

	CakCache    *TopologyCakCache      `json:"cakCache,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`

	TxChannels *TopologyTxChannels `json:"txChannels,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMka) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMka) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMka) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMka) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActiveDevice.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeDevice",
		isMultivalue: true,
	})
	n.CipherSuite.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cipherSuite",
		isMultivalue: true,
	})
	n.ConfidentialityOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "confidentialityOffset",
		isMultivalue: true,
	})
	n.DataPlaneParameters.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataPlaneParameters",
		isMultivalue: true,
	})
	n.DelayProtect.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayProtect",
		isMultivalue: true,
	})
	n.KeyServerPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keyServerPriority",
		isMultivalue: true,
	})
	n.LlpnStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "llpnStep",
		isMultivalue: true,
	})
	n.MacsecCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "macsecCapability",
		isMultivalue: true,
	})
	n.MacsecDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "macsecDesired",
		isMultivalue: true,
	})
	n.MkaHelloTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mkaHelloTime",
		isMultivalue: true,
	})
	n.MkaVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mkaVersion",
		isMultivalue: true,
	})
	n.OlpnStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "olpnStep",
		isMultivalue: true,
	})
	n.OmitPeerInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "omitPeerInfo",
		isMultivalue: true,
	})
	n.RekeyThresholdPN.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rekeyThresholdPN",
		isMultivalue: true,
	})
	n.RekeyThresholdXPN.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rekeyThresholdXPN",
		isMultivalue: true,
	})
	n.StartingDistributedAN.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingDistributedAN",
		isMultivalue: true,
	})
	n.StartingKeyNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingKeyNumber",
		isMultivalue: true,
	})
	n.StartingLLPN.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingLLPN",
		isMultivalue: true,
	})
	n.StartingOLPN.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingOLPN",
		isMultivalue: true,
	})
	n.CakCache.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "cakCache",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.TxChannels.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txChannels",
	})
}

// TopologyMldHost: MLD Host
type TopologyMldHost struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableIptv: Enable IPTV
	EnableIptv *Multivalue `json:"enableIptv,omitempty"`
	// EnableProxyReporting: Enable Proxy Reporting
	EnableProxyReporting *Multivalue `json:"enableProxyReporting,omitempty"`
	// GQResponseMode: General Query Response Mode
	GQResponseMode *Multivalue `json:"gQResponseMode,omitempty"`
	// GSResponseMode: Group Specific Response Mode
	GSResponseMode *Multivalue `json:"gSResponseMode,omitempty"`
	// ImResponse: Immediate Response
	ImResponse *Multivalue `json:"imResponse,omitempty"`
	// JlMultiplier: No. of Join/Leave messages to send per opertation

	JlMultiplier *float32 `json:"jlMultiplier,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfGrpRanges: Defines the number of group range per host required

	NoOfGrpRanges *float32 `json:"noOfGrpRanges,omitempty"`
	// ReportFreq: Report Frequency measured in seconds
	ReportFreq *Multivalue `json:"reportFreq,omitempty"`
	// RouterAlert: Enables Router Alert option of IPv4 Packet
	RouterAlert *Multivalue `json:"routerAlert,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// USResponseMode: Unsolicited Response Mode
	USResponseMode *Multivalue `json:"uSResponseMode,omitempty"`
	// VersionType: Specifies the MLD Version Type
	VersionType *Multivalue `json:"versionType,omitempty"`

	Iptv *TopologyIptv `json:"iptv,omitempty"`

	MldMcastIPv6GroupList *TopologyMldMcastIPv6GroupList `json:"mldMcastIPv6GroupList,omitempty"`
	Tag                   []*TopologyTag                 `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMldHost) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMldHost) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMldHost) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMldHost) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableIptv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIptv",
		isMultivalue: true,
	})
	n.EnableProxyReporting.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableProxyReporting",
		isMultivalue: true,
	})
	n.GQResponseMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gQResponseMode",
		isMultivalue: true,
	})
	n.GSResponseMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gSResponseMode",
		isMultivalue: true,
	})
	n.ImResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "imResponse",
		isMultivalue: true,
	})
	n.ReportFreq.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reportFreq",
		isMultivalue: true,
	})
	n.RouterAlert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerAlert",
		isMultivalue: true,
	})
	n.USResponseMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uSResponseMode",
		isMultivalue: true,
	})
	n.VersionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "versionType",
		isMultivalue: true,
	})
	n.Iptv.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "iptv",
	})
	n.MldMcastIPv6GroupList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "mldMcastIPv6GroupList",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyMldMcastIPv6GroupList: MLD Multicast IPv6 Groups
type TopologyMldMcastIPv6GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfSrcRanges: Sources per Multicast Group (multiplier)

	NoOfSrcRanges *float32 `json:"noOfSrcRanges,omitempty"`
	// SourceMode: Specifies the IGMP/MLD Source Type
	SourceMode *Multivalue `json:"sourceMode,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`

	MldUcastIPv6SourceList *TopologyMldUcastIPv6SourceList `json:"mldUcastIPv6SourceList,omitempty"`
	Tag                    []*TopologyTag                  `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMldMcastIPv6GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMldMcastIPv6GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMldMcastIPv6GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMldMcastIPv6GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SourceMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMode",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.MldUcastIPv6SourceList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "mldUcastIPv6SourceList",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyMldQuerier: MLD Querier Configuration
type TopologyMldQuerier struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DiscardLearntInfo: Discard Learned Info
	DiscardLearntInfo *Multivalue `json:"discardLearntInfo,omitempty"`
	// GeneralQueryInterval: General Query Interval in seconds
	GeneralQueryInterval *Multivalue `json:"generalQueryInterval,omitempty"`
	// GeneralQueryResponseInterval: General Query Response Interval in milliseconds
	GeneralQueryResponseInterval *Multivalue `json:"generalQueryResponseInterval,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ProxyQuerier: Enable Proxy Querier
	ProxyQuerier *Multivalue `json:"proxyQuerier,omitempty"`
	// RobustnessVariable: Robustness Variable
	RobustnessVariable *Multivalue `json:"robustnessVariable,omitempty"`
	// RouterAlert: Router Alert
	RouterAlert *Multivalue `json:"routerAlert,omitempty"`
	// SpecificQueryResponseInterval: Specific Query Response Interval in milliseconds
	SpecificQueryResponseInterval *Multivalue `json:"specificQueryResponseInterval,omitempty"`
	// SpecificQueryTransmissionCount: Specific Query Transmission Count
	SpecificQueryTransmissionCount *Multivalue `json:"specificQueryTransmissionCount,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartupQueryCount: Startup Query Count
	StartupQueryCount *Multivalue `json:"startupQueryCount,omitempty"`
	// SupportElection: Support Election
	SupportElection *Multivalue `json:"supportElection,omitempty"`
	// SupportOlderVersionHost: Support Older Version Host
	SupportOlderVersionHost *Multivalue `json:"supportOlderVersionHost,omitempty"`
	// SupportOlderVersionQuerier: Support Older Version Querier
	SupportOlderVersionQuerier *Multivalue `json:"supportOlderVersionQuerier,omitempty"`
	// VersionType: Version
	VersionType *Multivalue            `json:"versionType,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMldQuerier) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMldQuerier) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMldQuerier) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMldQuerier) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DiscardLearntInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLearntInfo",
		isMultivalue: true,
	})
	n.GeneralQueryInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "generalQueryInterval",
		isMultivalue: true,
	})
	n.GeneralQueryResponseInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "generalQueryResponseInterval",
		isMultivalue: true,
	})
	n.ProxyQuerier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "proxyQuerier",
		isMultivalue: true,
	})
	n.RobustnessVariable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "robustnessVariable",
		isMultivalue: true,
	})
	n.RouterAlert.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerAlert",
		isMultivalue: true,
	})
	n.SpecificQueryResponseInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "specificQueryResponseInterval",
		isMultivalue: true,
	})
	n.SpecificQueryTransmissionCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "specificQueryTransmissionCount",
		isMultivalue: true,
	})
	n.StartupQueryCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startupQueryCount",
		isMultivalue: true,
	})
	n.SupportElection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportElection",
		isMultivalue: true,
	})
	n.SupportOlderVersionHost.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportOlderVersionHost",
		isMultivalue: true,
	})
	n.SupportOlderVersionQuerier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportOlderVersionQuerier",
		isMultivalue: true,
	})
	n.VersionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "versionType",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyMldUcastIPv6SourceList: MLD Unicast IPv6 Source
type TopologyMldUcastIPv6SourceList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StartUcastAddr: Start Multicast Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcAddrCnt: Source Address Count
	UcastSrcAddrCnt *Multivalue `json:"ucastSrcAddrCnt,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMldUcastIPv6SourceList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMldUcastIPv6SourceList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMldUcastIPv6SourceList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMldUcastIPv6SourceList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcAddrCnt",
		isMultivalue: true,
	})
}

// TopologyMpls: MPLS protocol.
type TopologyMpls struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Bos: bos
	Bos *Multivalue `json:"bos,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// Cos: EXP
	Cos *Multivalue `json:"cos,omitempty"`
	// DestMac: Destination Mac.
	DestMac *Multivalue `json:"destMac,omitempty"`
	// Enablecw: Enable Control Word

	Enablecw *bool `json:"enablecw,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Overridecos: Override Cos

	Overridecos *bool `json:"overridecos,omitempty"`
	// RxLabelValue: Rx Label
	RxLabelValue *Multivalue `json:"rxLabelValue,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TransportType: TransportType

	TransportType *string `json:"transportType,omitempty"`
	// Ttl: TTL
	Ttl *Multivalue `json:"ttl,omitempty"`
	// TxLabelValue: Tx Label
	TxLabelValue *Multivalue `json:"txLabelValue,omitempty"`
	// UpperLayer: Value to Determine who is upper Layer.

	UpperLayer *string              `json:"upperLayer,omitempty"`
	BondedGRE  []*TopologyBondedGre `json:"bondedGRE"`
	CfmBridge  []*TopologyCfmBridge `json:"cfmBridge"`

	Connector             *TopologyConnector               `json:"connector,omitempty"`
	Dhcpv4client          []*TopologyDhcpv4client          `json:"dhcpv4client"`
	Dhcpv6client          []*TopologyDhcpv6client          `json:"dhcpv6client"`
	ECpriRe               []*TopologyECpriRe               `json:"eCpriRe"`
	ECpriRec              []*TopologyECpriRec              `json:"eCpriRec"`
	Ethernet              []*TopologyEthernet              `json:"ethernet"`
	Ipv4                  []*TopologyIpv4                  `json:"ipv4"`
	Ipv6                  []*TopologyIpv6                  `json:"ipv6"`
	Ipv6Autoconfiguration []*TopologyIpv6Autoconfiguration `json:"ipv6Autoconfiguration"`
	IsisDceSimRouter      []*TopologyIsisDceSimRouter      `json:"isisDceSimRouter"`
	IsisFabricPath        []*TopologyIsisFabricPath        `json:"isisFabricPath"`
	IsisL3                []*TopologyIsisL3                `json:"isisL3"`
	IsisSpbBcb            []*TopologyIsisSpbBcb            `json:"isisSpbBcb"`
	IsisSpbBeb            []*TopologyIsisSpbBeb            `json:"isisSpbBeb"`
	IsisSpbSimRouter      []*TopologyIsisSpbSimRouter      `json:"isisSpbSimRouter"`
	IsisTrill             []*TopologyIsisTrill             `json:"isisTrill"`
	IsisTrillSimRouter    []*TopologyIsisTrillSimRouter    `json:"isisTrillSimRouter"`
	Lacp                  []*TopologyLacp                  `json:"lacp"`
	Lagportlacp           []*TopologyLagportlacp           `json:"lagportlacp"`
	Lagportstaticlag      []*TopologyLagportstaticlag      `json:"lagportstaticlag"`
	Mka                   []*TopologyMka                   `json:"mka"`
	Mpls                  []*TopologyMpls                  `json:"mpls"`
	MsrpListener          []*TopologyMsrpListener          `json:"msrpListener"`
	MsrpTalker            []*TopologyMsrpTalker            `json:"msrpTalker"`
	StaticLag             []*TopologyStaticLag             `json:"staticLag"`

	Streams *TopologyStreams `json:"streams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMpls) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMpls) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMpls) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMpls) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Bos.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bos",
		isMultivalue: true,
	})
	n.Cos.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cos",
		isMultivalue: true,
	})
	n.DestMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destMac",
		isMultivalue: true,
	})
	n.RxLabelValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxLabelValue",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
	n.TxLabelValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txLabelValue",
		isMultivalue: true,
	})
	for i, o := range n.BondedGRE {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bondedGRE",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CfmBridge {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmBridge",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Dhcpv4client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv4client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Dhcpv6client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Autoconfiguration {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Autoconfiguration",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDceSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDceSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisFabricPath {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisFabricPath",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBcb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBcb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbBeb {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbBeb",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrill {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrill",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillSimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillSimRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportlacp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportlacp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Lagportstaticlag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "lagportstaticlag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mka {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mka",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Mpls {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mpls",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpListener {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpListener",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MsrpTalker {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "msrpTalker",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StaticLag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "staticLag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Streams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "streams",
	})
}

// TopologyMplsLabel: TBD
type TopologyMplsLabel struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMplsLabel) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMplsLabel) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMplsLabel) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMplsLabel) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyMplsLabelList: TBD
type TopologyMplsLabelList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// MplsEXP: EXP bits in the MPLS Label.
	MplsEXP *Multivalue `json:"mplsEXP,omitempty"`
	// MplsLabel: Note that 3 is treated as Implicit NULL and not included in the SBFD Packet sent on the wire. This can be used to create assymetric label stacks for different Initiator S-BFD sessions.
	MplsLabel *Multivalue `json:"mplsLabel,omitempty"`
	// MplsTTL: MPLS TTL in the MPLS Label field.
	MplsTTL *Multivalue `json:"mplsTTL,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMplsLabelList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMplsLabelList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMplsLabelList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMplsLabelList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.MplsEXP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsEXP",
		isMultivalue: true,
	})
	n.MplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabel",
		isMultivalue: true,
	})
	n.MplsTTL.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsTTL",
		isMultivalue: true,
	})
}

// TopologyMplsOam: TBD
type TopologyMplsOam struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BfdCvType: This signifies the BFD Connectivity Verification type
	BfdCvType *Multivalue `json:"bfdCvType,omitempty"`
	// BfdDiscriminatorEnd: This signifies the last BFD Discriminator value. This value should be greater than the BFD Discriminator Start value
	BfdDiscriminatorEnd *Multivalue `json:"bfdDiscriminatorEnd,omitempty"`
	// BfdDiscriminatorStart: This signifies the first BFD Discriminator value
	BfdDiscriminatorStart *Multivalue `json:"bfdDiscriminatorStart,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ControlChannel: This signifies the communication control channel
	ControlChannel *Multivalue `json:"controlChannel,omitempty"`
	// DestinationAddressIpv4: The destination IPv4 Address
	DestinationAddressIpv4 *Multivalue `json:"destinationAddressIpv4,omitempty"`
	// DownstreamAddressType: This signifies the address Type of the downstream traffic
	DownstreamAddressType *Multivalue `json:"downstreamAddressType,omitempty"`
	// DownstreamInterfaceAddressNumbered: This signifies the interface address of the downstream traffic in IPv4 format
	DownstreamInterfaceAddressNumbered *Multivalue `json:"downstreamInterfaceAddressNumbered,omitempty"`
	// DownstreamInterfaceAddressUnnumbered: This signifies the interface address of the downstream traffic
	DownstreamInterfaceAddressUnnumbered *Multivalue `json:"downstreamInterfaceAddressUnnumbered,omitempty"`
	// DownstreamIpAddress: This signifies the IPv4/IPv6 address of the downstream traffic
	DownstreamIpAddress *Multivalue `json:"downstreamIpAddress,omitempty"`
	// EchoRequestInterval: This signifies the minimum interval, in milliseconds, between received Echo packets that this interface is capable of supporting
	EchoRequestInterval *Multivalue `json:"echoRequestInterval,omitempty"`
	// EchoResponseTimeout: This signifies the minimum timeout interval, in milliseconds, between received Echo packets
	EchoResponseTimeout *Multivalue `json:"echoResponseTimeout,omitempty"`
	// EnableDSIflag: This signifies the activation of the DS I Flag
	EnableDSIflag *Multivalue `json:"enableDSIflag,omitempty"`
	// EnableDownstreamMappingTlv: This signifies the enable of the downstream mapping TLV
	EnableDownstreamMappingTlv *Multivalue `json:"enableDownstreamMappingTlv,omitempty"`
	// EnableDsNflag: This signifies the activation of the DS N Flag
	EnableDsNflag *Multivalue `json:"enableDsNflag,omitempty"`
	// EnableFecValidation: Selection of the check box enables FEC validation
	EnableFecValidation *Multivalue `json:"enableFecValidation,omitempty"`
	// EnablePeriodicPing: If true, the router is pinged at regular intervals
	EnablePeriodicPing *Multivalue `json:"enablePeriodicPing,omitempty"`
	// EnableSBfdResponder: Enables S-BFD Responder

	EnableSBfdResponder *bool `json:"enableSBfdResponder,omitempty"`
	// FlapTxIntervals: This signifies the number of seconds between route flaps for BFD. A value of zero means no flapping
	FlapTxIntervals *Multivalue `json:"flapTxIntervals,omitempty"`
	// IncludePadTlv: If true, includes Pad TLV in triggered ping
	IncludePadTlv *Multivalue `json:"includePadTlv,omitempty"`
	// IncludeVendorEnterpriseNumbeTlv: If true, include the TLV number of the vendor, in triggered ping
	IncludeVendorEnterpriseNumbeTlv *Multivalue `json:"includeVendorEnterpriseNumbeTlv,omitempty"`
	// InitiatorSBFDSessionCount: Number of configured S-BFD Initiator sessions with static MPLS labels per MPLS-OAM Interface. Labels should be configured as the actual label values (not SIDs) for SR-LSPs and should include list of labels learned by Ixia port and not the ones configured on the Tx Port itself.

	InitiatorSBFDSessionCount *float32 `json:"initiatorSBFDSessionCount,omitempty"`
	// MinRxInterval: This signifies the minimum interval, in milliseconds, between received BFD Control packets that this interface is capable of supporting
	MinRxInterval *Multivalue `json:"minRxInterval,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PadTlvFirstOctet: This signifies the selection of the first octet of the Pad TLV
	PadTlvFirstOctet *Multivalue `json:"padTlvFirstOctet,omitempty"`
	// PadTlvLength: This signifies the specification of the length of the Pad TLV
	PadTlvLength *Multivalue `json:"padTlvLength,omitempty"`
	// ReplyMode: This signifies the selection of the mode of reply
	ReplyMode *Multivalue `json:"replyMode,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TimeoutMultiplier: This signifies the negotiated transmit interval, multiplied by this value, provides the detection time for the interface
	TimeoutMultiplier *Multivalue `json:"timeoutMultiplier,omitempty"`
	// TxInterval: This signifies the minimum interval, in milliseconds, that the interface would like to use when transmitting BFD Control packets
	TxInterval *Multivalue `json:"txInterval,omitempty"`
	// VendorEnterpriseNumber: This signifies the specification of the enterprise number of the vendor
	VendorEnterpriseNumber *Multivalue                  `json:"vendorEnterpriseNumber,omitempty"`
	LearnedInfo            []*TopologyLearnedInfo       `json:"learnedInfo"`
	LearnedInfoUpdate      []*TopologyLearnedInfoUpdate `json:"learnedInfoUpdate"`

	SbfdInitiator *TopologySbfdInitiator `json:"sbfdInitiator,omitempty"`

	SbfdResponder *TopologySbfdResponder `json:"sbfdResponder,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMplsOam) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMplsOam) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMplsOam) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMplsOam) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BfdCvType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdCvType",
		isMultivalue: true,
	})
	n.BfdDiscriminatorEnd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdDiscriminatorEnd",
		isMultivalue: true,
	})
	n.BfdDiscriminatorStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bfdDiscriminatorStart",
		isMultivalue: true,
	})
	n.ControlChannel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "controlChannel",
		isMultivalue: true,
	})
	n.DestinationAddressIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationAddressIpv4",
		isMultivalue: true,
	})
	n.DownstreamAddressType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downstreamAddressType",
		isMultivalue: true,
	})
	n.DownstreamInterfaceAddressNumbered.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downstreamInterfaceAddressNumbered",
		isMultivalue: true,
	})
	n.DownstreamInterfaceAddressUnnumbered.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downstreamInterfaceAddressUnnumbered",
		isMultivalue: true,
	})
	n.DownstreamIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "downstreamIpAddress",
		isMultivalue: true,
	})
	n.EchoRequestInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoRequestInterval",
		isMultivalue: true,
	})
	n.EchoResponseTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoResponseTimeout",
		isMultivalue: true,
	})
	n.EnableDSIflag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDSIflag",
		isMultivalue: true,
	})
	n.EnableDownstreamMappingTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDownstreamMappingTlv",
		isMultivalue: true,
	})
	n.EnableDsNflag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDsNflag",
		isMultivalue: true,
	})
	n.EnableFecValidation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFecValidation",
		isMultivalue: true,
	})
	n.EnablePeriodicPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePeriodicPing",
		isMultivalue: true,
	})
	n.FlapTxIntervals.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapTxIntervals",
		isMultivalue: true,
	})
	n.IncludePadTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePadTlv",
		isMultivalue: true,
	})
	n.IncludeVendorEnterpriseNumbeTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeVendorEnterpriseNumbeTlv",
		isMultivalue: true,
	})
	n.MinRxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minRxInterval",
		isMultivalue: true,
	})
	n.PadTlvFirstOctet.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "padTlvFirstOctet",
		isMultivalue: true,
	})
	n.PadTlvLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "padTlvLength",
		isMultivalue: true,
	})
	n.ReplyMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "replyMode",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	n.TxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txInterval",
		isMultivalue: true,
	})
	n.VendorEnterpriseNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vendorEnterpriseNumber",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfoUpdate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfoUpdate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.SbfdInitiator.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sbfdInitiator",
	})
	n.SbfdResponder.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sbfdResponder",
	})
}

// TopologyMplsoamRouter: MPLSOAM Router Configuration
type TopologyMplsoamRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMplsoamRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMplsoamRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMplsoamRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMplsoamRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyMplsoamSbfdResponderLearnedInfo: GUI columns and TCL attributes for SBFD Responder Learned Information
type TopologyMplsoamSbfdResponderLearnedInfo struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMplsoamSbfdResponderLearnedInfo) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMplsoamSbfdResponderLearnedInfo) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMplsoamSbfdResponderLearnedInfo) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMplsoamSbfdResponderLearnedInfo) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyMsrpListener: MSRP Listener level Configuration
type TopologyMsrpListener struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseAs: Attribute Advertise As Type
	AdvertiseAs *Multivalue `json:"advertiseAs,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DeclareUnsolicitedVlan: Declare VLAN membership of configured VLAN range using MVRP even before learning any streams

	DeclareUnsolicitedVlan *bool `json:"declareUnsolicitedVlan,omitempty"`
	// JoinTimer: MRP Join Timer in miliseconds
	JoinTimer *Multivalue `json:"joinTimer,omitempty"`
	// LeaveAllTimer: MRP Leave All timer in milisecond
	LeaveAllTimer *Multivalue `json:"leaveAllTimer,omitempty"`
	// LeaveTimer: MRP Leave Timer in milisecond
	LeaveTimer *Multivalue `json:"leaveTimer,omitempty"`
	// ListenerDomainCount: Domain Count

	ListenerDomainCount *float32 `json:"listenerDomainCount,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ProtocolVersion: MRP protocol version
	ProtocolVersion *Multivalue `json:"protocolVersion,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartVlanId: Start VLAN ID of VLAN range
	StartVlanId *Multivalue `json:"startVlanId,omitempty"`
	// SubscribeAll: Send MSRP Listener Ready for all streams advertised in recieved MSRP Talker Advertise

	SubscribeAll *bool `json:"subscribeAll,omitempty"`
	// SubscribedStreamCount: Count of streams Listener want to listen

	SubscribedStreamCount *float32 `json:"subscribedStreamCount,omitempty"`
	// VlanCount: VLAN count of VLAN range
	VlanCount   *Multivalue            `json:"vlanCount,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`

	MsrpListenerDomains *TopologyMsrpListenerDomains `json:"msrpListenerDomains,omitempty"`

	SubscribedStreams *TopologySubscribedStreams `json:"subscribedStreams,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMsrpListener) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMsrpListener) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMsrpListener) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMsrpListener) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseAs",
		isMultivalue: true,
	})
	n.JoinTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "joinTimer",
		isMultivalue: true,
	})
	n.LeaveAllTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leaveAllTimer",
		isMultivalue: true,
	})
	n.LeaveTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leaveTimer",
		isMultivalue: true,
	})
	n.ProtocolVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protocolVersion",
		isMultivalue: true,
	})
	n.StartVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startVlanId",
		isMultivalue: true,
	})
	n.VlanCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanCount",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.MsrpListenerDomains.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "msrpListenerDomains",
	})
	n.SubscribedStreams.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "subscribedStreams",
	})
}

// TopologyMsrpListenerDomains: Domains Informations for Msrp Listener
type TopologyMsrpListenerDomains struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrClassIdType: SR Class ID
	SrClassIdType *Multivalue `json:"srClassIdType,omitempty"`
	// SrClassPriorityType: SR Class Priority.Class A maps to priority 3 and Class B maps to priority 2.
	SrClassPriorityType *Multivalue `json:"srClassPriorityType,omitempty"`
	// SrClassVid: VLAN ID that associated streams will be tagged with by Talker
	SrClassVid *Multivalue `json:"srClassVid,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMsrpListenerDomains) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMsrpListenerDomains) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMsrpListenerDomains) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMsrpListenerDomains) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.SrClassIdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srClassIdType",
		isMultivalue: true,
	})
	n.SrClassPriorityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srClassPriorityType",
		isMultivalue: true,
	})
	n.SrClassVid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srClassVid",
		isMultivalue: true,
	})
}

// TopologyMsrpTalker: MSRP Talker level Configuration
type TopologyMsrpTalker struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseAs: Attribute Advertise As Type
	AdvertiseAs *Multivalue `json:"advertiseAs,omitempty"`
	// AdvertiseVlanMembership: Advertise VLAN Membership from these talkers

	AdvertiseVlanMembership *bool `json:"advertiseVlanMembership,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// JoinTimer: MRP Join Timer in miliseconds
	JoinTimer *Multivalue `json:"joinTimer,omitempty"`
	// LeaveAllTimer: MRP Leave All timer in milisecond
	LeaveAllTimer *Multivalue `json:"leaveAllTimer,omitempty"`
	// LeaveTimer: MRP Leave Timer in milisecond
	LeaveTimer *Multivalue `json:"leaveTimer,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ProtocolVersion: MRP protocol version
	ProtocolVersion *Multivalue `json:"protocolVersion,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StreamCount: number of stream id instances per talker instance (multiplier)

	StreamCount *float32 `json:"streamCount,omitempty"`
	// TalkerDomainCount: Domain Count

	TalkerDomainCount *float32               `json:"talkerDomainCount,omitempty"`
	LearnedInfo       []*TopologyLearnedInfo `json:"learnedInfo"`

	MsrpTalkerDomains *TopologyMsrpTalkerDomains `json:"msrpTalkerDomains,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMsrpTalker) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMsrpTalker) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMsrpTalker) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMsrpTalker) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseAs.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseAs",
		isMultivalue: true,
	})
	n.JoinTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "joinTimer",
		isMultivalue: true,
	})
	n.LeaveAllTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leaveAllTimer",
		isMultivalue: true,
	})
	n.LeaveTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leaveTimer",
		isMultivalue: true,
	})
	n.ProtocolVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protocolVersion",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.MsrpTalkerDomains.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "msrpTalkerDomains",
	})
}

// TopologyMsrpTalkerDomains: Domains Informations for Msrp Talker
type TopologyMsrpTalkerDomains struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrClassIdType: SR Class ID
	SrClassIdType *Multivalue `json:"srClassIdType,omitempty"`
	// SrClassPriorityType: SR Class Priority.Class A maps to priority 3 and Class B maps to priority 2.
	SrClassPriorityType *Multivalue `json:"srClassPriorityType,omitempty"`
	// SrClassVid: VLAN ID that associated streams will be tagged with by Talker
	SrClassVid *Multivalue `json:"srClassVid,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyMsrpTalkerDomains) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyMsrpTalkerDomains) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyMsrpTalkerDomains) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyMsrpTalkerDomains) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.SrClassIdType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srClassIdType",
		isMultivalue: true,
	})
	n.SrClassPriorityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srClassPriorityType",
		isMultivalue: true,
	})
	n.SrClassVid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srClassVid",
		isMultivalue: true,
	})
}

// TopologyNaiType: TBD
type TopologyNaiType struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNaiType) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNaiType) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNaiType) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNaiType) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyNetTopologyCustom: Custom, user defined topology.
type TopologyNetTopologyCustom struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32 `json:"linkMultiplier,omitempty"`

	LinkTable *TopologyLinkTable `json:"linkTable,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyCustom) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyCustom) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyCustom) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyCustom) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.LinkTable.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "linkTable",
	})
}

// TopologyNetTopologyFatTree: Fat Tree topology
type TopologyNetTopologyFatTree struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LevelCount: Number of Levels

	LevelCount *float32 `json:"levelCount,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32         `json:"linkMultiplier,omitempty"`
	Level          []*TopologyLevel `json:"level"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyFatTree) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyFatTree) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyFatTree) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyFatTree) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Level {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "level",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyNetTopologyGrid: grid topology
type TopologyNetTopologyGrid struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Columns: number of columns

	Columns *float32 `json:"columns,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32 `json:"linkMultiplier,omitempty"`
	// Rows: number of rows

	Rows *float32 `json:"rows,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyGrid) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyGrid) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyGrid) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyGrid) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyNetTopologyHubNSpoke: hub-n-spoke topology
type TopologyNetTopologyHubNSpoke struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableLevel2Spokes: Enable Level 2 Spokes

	EnableLevel2Spokes *bool `json:"enableLevel2Spokes,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32 `json:"linkMultiplier,omitempty"`
	// NumberOfFirstLevelSpokes: Number of First Level Spokes

	NumberOfFirstLevelSpokes *float32 `json:"numberOfFirstLevelSpokes,omitempty"`
	// NumberOfSecondLevelSpokes: Number of Second Level Spokes

	NumberOfSecondLevelSpokes *float32 `json:"numberOfSecondLevelSpokes,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyHubNSpoke) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyHubNSpoke) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyHubNSpoke) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyHubNSpoke) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyNetTopologyLinear: Linear topology
type TopologyNetTopologyLinear struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32 `json:"linkMultiplier,omitempty"`
	// Nodes: number of nodes

	Nodes *float32 `json:"nodes,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyLinear) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyLinear) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyLinear) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyLinear) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyNetTopologyMesh: mesh topology
type TopologyNetTopologyMesh struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32 `json:"linkMultiplier,omitempty"`
	// Nodes: number of nodes

	Nodes *float32 `json:"nodes,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyMesh) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyMesh) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyMesh) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyMesh) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyNetTopologyRing: ring topology
type TopologyNetTopologyRing struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32 `json:"linkMultiplier,omitempty"`
	// Nodes: number of nodes

	Nodes *float32 `json:"nodes,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyRing) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyRing) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyRing) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyRing) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyNetTopologyTree: tree topology
type TopologyNetTopologyTree struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// IncludeEntryPoint: if true, entry node belongs to ring topology, otherwise it is outside of ring

	IncludeEntryPoint *bool `json:"includeEntryPoint,omitempty"`
	// LinkMultiplier: number of links between two nodes

	LinkMultiplier *float32 `json:"linkMultiplier,omitempty"`
	// MaxChildPerNode: Maximum children per node

	MaxChildPerNode *float32 `json:"maxChildPerNode,omitempty"`
	// Nodes: number of nodes

	Nodes *float32 `json:"nodes,omitempty"`
	// TreeDepth: Depth of the Tree, defined as length of path from root node to deepest node in the tree

	TreeDepth *float32 `json:"treeDepth,omitempty"`
	// UseTreeDepth: Use Tree Depth

	UseTreeDepth *bool `json:"useTreeDepth,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetTopologyTree) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetTopologyTree) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetTopologyTree) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetTopologyTree) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyNetconfClient: Netconf Client emulates a Netconf Controller which connects to a DUT supporting Netconf as per RFC6241/RFC6242
type TopologyNetconfClient struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CapabilitiesBase1Dot0: This specifies whether base1.0 support should be advertised in Capabilities.
	CapabilitiesBase1Dot0 *Multivalue `json:"capabilitiesBase1Dot0,omitempty"`
	// CapabilitiesBase1Dot1: This specifies whether base1.1 support should be advertised in Capabilities.
	CapabilitiesBase1Dot1 *Multivalue `json:"capabilitiesBase1Dot1,omitempty"`
	// CapabilitiesCandidate: This specifies whether Netconf Client supports capability candidate to make changes into an intermediate candidate database. Normally this is preferred over writable-running.
	CapabilitiesCandidate *Multivalue `json:"capabilitiesCandidate,omitempty"`
	// CapabilitiesConfirmedCommit: This specifies whether Netconf Client supports capability confirmed-commit to specify ability to commit a group of commands or none as a batch.
	CapabilitiesConfirmedCommit *Multivalue `json:"capabilitiesConfirmedCommit,omitempty"`
	// CapabilitiesInterleave: This specifies whether Netconf Client supports capability interleave to interleave notifications and responses.
	CapabilitiesInterleave *Multivalue `json:"capabilitiesInterleave,omitempty"`
	// CapabilitiesNotification: This specifies whether Netconf Client supports capability notification to aynchronously handle notifications from Netconf server device connected to.
	CapabilitiesNotification *Multivalue `json:"capabilitiesNotification,omitempty"`
	// CapabilitiesRollbackOnError: This specifies whether Netconf Client supports capability rollback to rollback partial changes make changes on detection of error during validate or commit.
	CapabilitiesRollbackOnError *Multivalue `json:"capabilitiesRollbackOnError,omitempty"`
	// CapabilitiesStartup: This specifies whether Netconf Client supports capability startup to make changes in config persistent on device restart.
	CapabilitiesStartup *Multivalue `json:"capabilitiesStartup,omitempty"`
	// CapabilitiesUrl: This specifies whether Netconf Client supports capability url to specify netconf commands using url.
	CapabilitiesUrl *Multivalue `json:"capabilitiesUrl,omitempty"`
	// CapabilitiesValidate: This specifies whether Netconf Client supports capability validate to specify ability to validate a netconf command prior to commit.
	CapabilitiesValidate *Multivalue `json:"capabilitiesValidate,omitempty"`
	// CapabilitiesWritableRunning: This specifies whether Netconf Client supports capability writable-running to directly modify running config.
	CapabilitiesWritableRunning *Multivalue `json:"capabilitiesWritableRunning,omitempty"`
	// CapabilitiesXpath: This specifies whether Netconf Client supports capability xpath to specify netconf commands and filters using xpath extensions.
	CapabilitiesXpath *Multivalue `json:"capabilitiesXpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DecryptedCapture: This specifies whether SSH packets for this session will be captured and stored on client in decrypted form.
	DecryptedCapture *Multivalue `json:"decryptedCapture,omitempty"`
	// DoNotValidateServerResponse: If this option is enabled, the Netconf client will not parse server responses. Use this option to optimize memory usage in the client.
	DoNotValidateServerResponse *Multivalue `json:"doNotValidateServerResponse,omitempty"`
	// EnablePassphrase: If the Private Key was passphrase protected, this should be enabled to allow configuration of passphrase used.
	EnablePassphrase *Multivalue `json:"enablePassphrase,omitempty"`
	// FetchSchemaInfo: This specifies whether a get-schema operation will be performed after capability exchange
	FetchSchemaInfo *Multivalue `json:"fetchSchemaInfo,omitempty"`
	// LogCleanUpOption: Debug Log Clean Up

	LogCleanUpOption *string `json:"logCleanUpOption,omitempty"`
	// LogFileAge: This field determines how old logs to be deleted.

	LogFileAge *float32 `json:"logFileAge,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfCommandSnippetsPerClient: Number of Command Snippets per client.Maximum 100 are allowed per client.

	NumberOfCommandSnippetsPerClient *float32 `json:"numberOfCommandSnippetsPerClient,omitempty"`
	// OutputDirectory: Location of Directory in Client where the decrypted capture, if enabled, and server replies, if enabled, will be stored.
	OutputDirectory *Multivalue `json:"outputDirectory,omitempty"`
	// Passphrase: The passphrase with which the Private Key was additionally protected during generation. For multiple clients and assymetric passphrases( which cannot be expressed easily as a pattern) please explore File option in Master Row Pattern Editor by putting the file namesin a .csv and pulling those values into the column cells.
	Passphrase *Multivalue `json:"passphrase,omitempty"`
	// Password: Password for Username/Password mode.
	Password *Multivalue `json:"password,omitempty"`
	// PortNumber: The TCP Port Number the Netconf Server is listening on to which to connect.
	PortNumber *Multivalue `json:"portNumber,omitempty"`
	// PrivateKeyDirectory: Directory containing Private Key file for this session.
	PrivateKeyDirectory *Multivalue `json:"privateKeyDirectory,omitempty"`
	// PrivateKeyFileName: File containing Private Key.(e.g. generated using ssh_keygen) . For multiple clients and assymetric key file names( which cannot be expressed easily as a pattern) please explore File option in Master Row Pattern Editor by putting the file namesin a .csv and pulling those values into the column cells.
	PrivateKeyFileName *Multivalue `json:"privateKeyFileName,omitempty"`
	// SaveReplyXML: If this is enabled, Hellos and replies to commands sent via Command Snippets or global command (such as 'get') by the Netconf Server will be stored in the Output Directoryin current run folder/Replies. Any RPC errors recieved will be stored in a separate Error directory for convenience of debugging error scenarios.This option can be enabled even when a session is already up in which case the replies will be saved from that point of time.
	SaveReplyXML *Multivalue `json:"saveReplyXML,omitempty"`
	// SchemaOutputDirectory: Location of Directory in Client where the retrieved modules will be stored.
	SchemaOutputDirectory *Multivalue `json:"schemaOutputDirectory,omitempty"`
	// SendCloseOnStop: This specifies whether a <close-session> message will be sent on stopping this client
	SendCloseOnStop *Multivalue `json:"sendCloseOnStop,omitempty"`
	// ServerIpv4Address: Specify the IPv4 address of the DUT to which the Netconf Server should connect.
	ServerIpv4Address *Multivalue `json:"serverIpv4Address,omitempty"`
	// SshAuthenticationMechanism: The authentication mechanism for connecting to Netconf Server.
	SshAuthenticationMechanism *Multivalue `json:"sshAuthenticationMechanism,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UserName: Username for Username/Password mode and also used for Key-based Authentication as the username.
	UserName *Multivalue `json:"userName,omitempty"`

	CommandSnippetsData *TopologyCommandSnippetsData `json:"commandSnippetsData,omitempty"`
	LearnedInfo         []*TopologyLearnedInfo       `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetconfClient) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetconfClient) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetconfClient) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetconfClient) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CapabilitiesBase1Dot0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesBase1Dot0",
		isMultivalue: true,
	})
	n.CapabilitiesBase1Dot1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesBase1Dot1",
		isMultivalue: true,
	})
	n.CapabilitiesCandidate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesCandidate",
		isMultivalue: true,
	})
	n.CapabilitiesConfirmedCommit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesConfirmedCommit",
		isMultivalue: true,
	})
	n.CapabilitiesInterleave.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesInterleave",
		isMultivalue: true,
	})
	n.CapabilitiesNotification.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesNotification",
		isMultivalue: true,
	})
	n.CapabilitiesRollbackOnError.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesRollbackOnError",
		isMultivalue: true,
	})
	n.CapabilitiesStartup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesStartup",
		isMultivalue: true,
	})
	n.CapabilitiesUrl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesUrl",
		isMultivalue: true,
	})
	n.CapabilitiesValidate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesValidate",
		isMultivalue: true,
	})
	n.CapabilitiesWritableRunning.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesWritableRunning",
		isMultivalue: true,
	})
	n.CapabilitiesXpath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesXpath",
		isMultivalue: true,
	})
	n.DecryptedCapture.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "decryptedCapture",
		isMultivalue: true,
	})
	n.DoNotValidateServerResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "doNotValidateServerResponse",
		isMultivalue: true,
	})
	n.EnablePassphrase.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePassphrase",
		isMultivalue: true,
	})
	n.FetchSchemaInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fetchSchemaInfo",
		isMultivalue: true,
	})
	n.OutputDirectory.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outputDirectory",
		isMultivalue: true,
	})
	n.Passphrase.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "passphrase",
		isMultivalue: true,
	})
	n.Password.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "password",
		isMultivalue: true,
	})
	n.PortNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portNumber",
		isMultivalue: true,
	})
	n.PrivateKeyDirectory.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "privateKeyDirectory",
		isMultivalue: true,
	})
	n.PrivateKeyFileName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "privateKeyFileName",
		isMultivalue: true,
	})
	n.SaveReplyXML.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "saveReplyXML",
		isMultivalue: true,
	})
	n.SchemaOutputDirectory.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "schemaOutputDirectory",
		isMultivalue: true,
	})
	n.SendCloseOnStop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendCloseOnStop",
		isMultivalue: true,
	})
	n.ServerIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverIpv4Address",
		isMultivalue: true,
	})
	n.SshAuthenticationMechanism.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sshAuthenticationMechanism",
		isMultivalue: true,
	})
	n.UserName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userName",
		isMultivalue: true,
	})
	n.CommandSnippetsData.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "commandSnippetsData",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyNetconfServer: Netconf Server emulates a Netconf DUT which connects to a Netconf Client supporting Netconf as per RFC6241/RFC6242
type TopologyNetconfServer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CapabilitiesBase1Dot0: Whether base1.0 support should be advertised in Capabilities.
	CapabilitiesBase1Dot0 *Multivalue `json:"capabilitiesBase1Dot0,omitempty"`
	// CapabilitiesBase1Dot1: Whether base1.1 support should be advertised in Capabilities.
	CapabilitiesBase1Dot1 *Multivalue `json:"capabilitiesBase1Dot1,omitempty"`
	// CapabilitiesCandidate: Whether supports capability candidate to make changes into an intermediate candidate database. Normally this is preferred over writable-running.
	CapabilitiesCandidate *Multivalue `json:"capabilitiesCandidate,omitempty"`
	// CapabilitiesConfirmedCommit: Whether supports capability confirmed-commit to specify ability to commit a group of commands or none as a batch.
	CapabilitiesConfirmedCommit *Multivalue `json:"capabilitiesConfirmedCommit,omitempty"`
	// CapabilitiesInterleave: Whether supports capability interleave to interleave notifications and responses.
	CapabilitiesInterleave *Multivalue `json:"capabilitiesInterleave,omitempty"`
	// CapabilitiesNotification: Whether supports capability notification to aynchronously send notifications to Netconf client.
	CapabilitiesNotification *Multivalue `json:"capabilitiesNotification,omitempty"`
	// CapabilitiesRollbackOnError: Whether supports capability rollback to rollback partial changes make changes on detection of error during validate or commit.
	CapabilitiesRollbackOnError *Multivalue `json:"capabilitiesRollbackOnError,omitempty"`
	// CapabilitiesStartup: Whether supports capability startup to make changes in config persistent on device restart.
	CapabilitiesStartup *Multivalue `json:"capabilitiesStartup,omitempty"`
	// CapabilitiesUrl: Whether supports capability url to specify netconf commands using url.
	CapabilitiesUrl *Multivalue `json:"capabilitiesUrl,omitempty"`
	// CapabilitiesValidate: Whether supports capability validate to specify ability to validate a netconf command prior to commit.
	CapabilitiesValidate *Multivalue `json:"capabilitiesValidate,omitempty"`
	// CapabilitiesWritableRunning: Whether supports capability writable-running to directly modify running config.
	CapabilitiesWritableRunning *Multivalue `json:"capabilitiesWritableRunning,omitempty"`
	// CapabilitiesXpath: Whether supports capability xpath to specify netconf commands and filters using xpath extensions.
	CapabilitiesXpath *Multivalue `json:"capabilitiesXpath,omitempty"`
	// ClientIpv4Address: Specify the IPv4 address of the Netconf Client which will connect with this Server.
	ClientIpv4Address *Multivalue `json:"clientIpv4Address,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DecryptedCapture: This specifies whether SSH packets for this session will be captured and stored on client in decrypted form. Note that this is not linked to IxNetwork control or data capture which will capture the packets in encrypted format only. The Decrypted Capture can be viewed by either doing right-click on a client where this option is enabled and doing Get Decrypted Capture ( allowed on 5 servers at a time ; each of the captures will be opened in a new Wireshark pop-up) OR by stopping the server and then directly opening it from the configured Output Directory from inside the current run folder/capture. This option can be enabled even when a session is already up in which case the capture will be started from that point of time.
	DecryptedCapture *Multivalue `json:"decryptedCapture,omitempty"`
	// ErrorInfo: Contains protocol or data-model-specific error content.
	ErrorInfo *Multivalue `json:"errorInfo,omitempty"`
	// ErrorPercentage: The percentage of requests whose response will be errors
	ErrorPercentage *Multivalue `json:"errorPercentage,omitempty"`
	// ErrorSeverity: Contains a string identifying the error severity, as determined by the device.
	ErrorSeverity *Multivalue `json:"errorSeverity,omitempty"`
	// ErrorTag: Contains a string identifying the error condition.
	ErrorTag *Multivalue `json:"errorTag,omitempty"`
	// ErrorType: Defines the conceptual layer that the error occurred.
	ErrorType *Multivalue `json:"errorType,omitempty"`
	// GetConfigReplyXML: File containing the response to a <get-config> request.
	GetConfigReplyXML *Multivalue `json:"getConfigReplyXML,omitempty"`
	// IncludeErrorInfo: This specifies whether 'error-info' element should be included in rpc error messages.
	IncludeErrorInfo *Multivalue `json:"includeErrorInfo,omitempty"`
	// IncludeRxTimestampInReplyMsg: Whether timestamp of received request messages will be included in the replies
	IncludeRxTimestampInReplyMsg *Multivalue `json:"includeRxTimestampInReplyMsg,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OutputDirectory: Location of Directory in Client where the decrypted capture(if enabled) will be stored.
	OutputDirectory *Multivalue `json:"outputDirectory,omitempty"`
	// Password: Password for Username/Password mode.
	Password *Multivalue `json:"password,omitempty"`
	// PortNumber: The TCP Port Number the Netconf Server is listening on to which to connect.
	PortNumber *Multivalue `json:"portNumber,omitempty"`
	// PublicKeyDirectory: Directory containing public key file for this session
	PublicKeyDirectory *Multivalue `json:"publicKeyDirectory,omitempty"`
	// PublicKeyFileName: File containing public key (e.g. generated using ssh_keygen). For multiple server rows and assymetric public key filenames( which cannot be expressed easily as a pattern) please explore File option in Master Row Pattern Editor by putting the file namesin a .csv and pulling those values into the column cells.
	PublicKeyFileName *Multivalue `json:"publicKeyFileName,omitempty"`
	// ResponseXMLDirectory: Directory where Reply XMLs for <get-config> operations are present
	ResponseXMLDirectory *Multivalue `json:"responseXMLDirectory,omitempty"`
	// SendOkResponse: This specifies whether <ok> element should be sent in <rpc-reply> in response to <get-config> requests. If this is unchecked, custom reply based on <get-config> response xml will be sent out
	SendOkResponse *Multivalue `json:"sendOkResponse,omitempty"`
	// SshAuthenticationMechanism: The authentication mechanism for connecting to Netconf Client.
	SshAuthenticationMechanism *Multivalue `json:"sshAuthenticationMechanism,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// UserName: Username for Username/Password mode and Username for Key-Based authentication mode if applicable.
	UserName *Multivalue `json:"userName,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetconfServer) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetconfServer) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetconfServer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetconfServer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CapabilitiesBase1Dot0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesBase1Dot0",
		isMultivalue: true,
	})
	n.CapabilitiesBase1Dot1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesBase1Dot1",
		isMultivalue: true,
	})
	n.CapabilitiesCandidate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesCandidate",
		isMultivalue: true,
	})
	n.CapabilitiesConfirmedCommit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesConfirmedCommit",
		isMultivalue: true,
	})
	n.CapabilitiesInterleave.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesInterleave",
		isMultivalue: true,
	})
	n.CapabilitiesNotification.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesNotification",
		isMultivalue: true,
	})
	n.CapabilitiesRollbackOnError.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesRollbackOnError",
		isMultivalue: true,
	})
	n.CapabilitiesStartup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesStartup",
		isMultivalue: true,
	})
	n.CapabilitiesUrl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesUrl",
		isMultivalue: true,
	})
	n.CapabilitiesValidate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesValidate",
		isMultivalue: true,
	})
	n.CapabilitiesWritableRunning.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesWritableRunning",
		isMultivalue: true,
	})
	n.CapabilitiesXpath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilitiesXpath",
		isMultivalue: true,
	})
	n.ClientIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientIpv4Address",
		isMultivalue: true,
	})
	n.DecryptedCapture.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "decryptedCapture",
		isMultivalue: true,
	})
	n.ErrorInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorInfo",
		isMultivalue: true,
	})
	n.ErrorPercentage.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorPercentage",
		isMultivalue: true,
	})
	n.ErrorSeverity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorSeverity",
		isMultivalue: true,
	})
	n.ErrorTag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorTag",
		isMultivalue: true,
	})
	n.ErrorType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorType",
		isMultivalue: true,
	})
	n.GetConfigReplyXML.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "getConfigReplyXML",
		isMultivalue: true,
	})
	n.IncludeErrorInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeErrorInfo",
		isMultivalue: true,
	})
	n.IncludeRxTimestampInReplyMsg.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeRxTimestampInReplyMsg",
		isMultivalue: true,
	})
	n.OutputDirectory.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "outputDirectory",
		isMultivalue: true,
	})
	n.Password.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "password",
		isMultivalue: true,
	})
	n.PortNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portNumber",
		isMultivalue: true,
	})
	n.PublicKeyDirectory.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "publicKeyDirectory",
		isMultivalue: true,
	})
	n.PublicKeyFileName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "publicKeyFileName",
		isMultivalue: true,
	})
	n.ResponseXMLDirectory.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "responseXMLDirectory",
		isMultivalue: true,
	})
	n.SendOkResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendOkResponse",
		isMultivalue: true,
	})
	n.SshAuthenticationMechanism.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sshAuthenticationMechanism",
		isMultivalue: true,
	})
	n.UserName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userName",
		isMultivalue: true,
	})
}

// TopologyNetworkGroup: Describes a set of network clouds with similar configuration and the same multiplicity for devices behind.
type TopologyNetworkGroup struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: Enables/disables device.
	Enabled *Multivalue `json:"enabled,omitempty"`
	// Multiplier: Number of device instances per parent device instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name                         *string                                 `json:"name,omitempty"`
	BgpIPRouteProperty           []*TopologyBgpIpRouteProperty           `json:"bgpIPRouteProperty"`
	BgpL3VpnRouteProperty        []*TopologyBgpL3VpnRouteProperty        `json:"bgpL3VpnRouteProperty"`
	BgpMVpnReceiverSitesIpv4     []*TopologyBgpMVpnReceiverSitesIpv4     `json:"bgpMVpnReceiverSitesIpv4"`
	BgpMVpnReceiverSitesIpv6     []*TopologyBgpMVpnReceiverSitesIpv6     `json:"bgpMVpnReceiverSitesIpv6"`
	BgpMVpnSenderSitesIpv4       []*TopologyBgpMVpnSenderSitesIpv4       `json:"bgpMVpnSenderSitesIpv4"`
	BgpMVpnSenderSitesIpv6       []*TopologyBgpMVpnSenderSitesIpv6       `json:"bgpMVpnSenderSitesIpv6"`
	BgpV6IPRouteProperty         []*TopologyBgpV6IpRouteProperty         `json:"bgpV6IPRouteProperty"`
	BgpV6L3VpnRouteProperty      []*TopologyBgpV6L3VpnRouteProperty      `json:"bgpV6L3VpnRouteProperty"`
	CMacProperties               []*TopologyCMacProperties               `json:"cMacProperties"`
	DeviceGroup                  []*TopologyDeviceGroup                  `json:"deviceGroup"`
	DslPools                     []*TopologyDslPools                     `json:"dslPools"`
	ECpriReRadioChannelsOrUsers  []*TopologyECpriReRadioChannelsOrUsers  `json:"eCpriReRadioChannelsOrUsers"`
	ECpriRecRadioChannelsOrUsers []*TopologyECpriRecRadioChannelsOrUsers `json:"eCpriRecRadioChannelsOrUsers"`
	EvpnIPv4PrefixRange          []*TopologyEvpnIPv4PrefixRange          `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange          []*TopologyEvpnIPv6PrefixRange          `json:"evpnIPv6PrefixRange"`
	Ipv4PrefixPools              []*TopologyIpv4PrefixPools              `json:"ipv4PrefixPools"`
	Ipv6PrefixPools              []*TopologyIpv6PrefixPools              `json:"ipv6PrefixPools"`
	IsisL3RouteProperty          []*TopologyIsisL3RouteProperty          `json:"isisL3RouteProperty"`
	IsisSpbMacCloudConfig        []*TopologyIsisSpbMacCloudConfig        `json:"isisSpbMacCloudConfig"`
	IsisTrillUCastMacConfig      []*TopologyIsisTrillUCastMacConfig      `json:"isisTrillUCastMacConfig"`
	LdpFECProperty               []*TopologyLdpFecProperty               `json:"ldpFECProperty"`
	LdpIpv6FECProperty           []*TopologyLdpIpv6FecProperty           `json:"ldpIpv6FECProperty"`
	MacPools                     []*TopologyMacPools                     `json:"macPools"`
	NetworkGroup                 []*TopologyNetworkGroup                 `json:"networkGroup"`
	NetworkRangeInfo             []*TopologyNetworkRangeInfo             `json:"networkRangeInfo"`

	NetworkTopology     *TopologyNetworkTopology       `json:"networkTopology,omitempty"`
	OspfRouteProperty   []*TopologyOspfRouteProperty   `json:"ospfRouteProperty"`
	Ospfv3RouteProperty []*TopologyOspfv3RouteProperty `json:"ospfv3RouteProperty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetworkGroup) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetworkGroup) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetworkGroup) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetworkGroup) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Enabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enabled",
		isMultivalue: true,
	})
	for i, o := range n.BgpIPRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIPRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpL3VpnRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpL3VpnRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnReceiverSitesIpv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnReceiverSitesIpv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnReceiverSitesIpv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnReceiverSitesIpv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnSenderSitesIpv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnSenderSitesIpv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpMVpnSenderSitesIpv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpMVpnSenderSitesIpv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpV6IPRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpV6IPRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpV6L3VpnRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpV6L3VpnRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.DeviceGroup {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "deviceGroup",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.DslPools {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dslPools",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriReRadioChannelsOrUsers {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriReRadioChannelsOrUsers",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRecRadioChannelsOrUsers {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRecRadioChannelsOrUsers",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4PrefixPools {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4PrefixPools",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6PrefixPools {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6PrefixPools",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3RouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3RouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbMacCloudConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbMacCloudConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillUCastMacConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillUCastMacConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpFECProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpFECProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpIpv6FECProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpIpv6FECProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MacPools {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "macPools",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetworkGroup {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "networkGroup",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetworkRangeInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "networkRangeInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.NetworkTopology.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "networkTopology",
	})
	for i, o := range n.OspfRouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfRouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3RouteProperty {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3RouteProperty",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyNetworkRangeInfo: RBRangeInfo help : TODO.
type TopologyNetworkRangeInfo struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkRangeIPByMask: Use mask to generate range of addresses
	NetworkRangeIPByMask *Multivalue `json:"networkRangeIPByMask,omitempty"`
	// NetworkRangeInterfaceIp: Interface IP address for a non-connected interface
	NetworkRangeInterfaceIp *Multivalue `json:"networkRangeInterfaceIp,omitempty"`
	// NetworkRangeInterfaceIpMask: Interface IP mask for a non-connected interface
	NetworkRangeInterfaceIpMask *Multivalue `json:"networkRangeInterfaceIpMask,omitempty"`
	// NetworkRangeIp: Network Range IP
	NetworkRangeIp *Multivalue `json:"networkRangeIp,omitempty"`
	// NetworkRangeIpIncrementBy: Network Range IP Increment By
	NetworkRangeIpIncrementBy *Multivalue `json:"networkRangeIpIncrementBy,omitempty"`
	// NetworkRangeIpMask: Network Range IP Mask
	NetworkRangeIpMask *Multivalue `json:"networkRangeIpMask,omitempty"`
	// NetworkRangeLinkType: Link Type
	NetworkRangeLinkType *Multivalue `json:"networkRangeLinkType,omitempty"`
	// NetworkRangeRID: Network Range RID
	NetworkRangeRID *Multivalue `json:"networkRangeRID,omitempty"`
	// NetworkRangeRIDIncrement: Network Range RID Increment
	NetworkRangeRIDIncrement *Multivalue `json:"networkRangeRIDIncrement,omitempty"`
	// NumColumns: 4 Byte Integer.
	NumColumns *Multivalue `json:"numColumns,omitempty"`
	// NumRows: 4 Byte Integer.
	NumRows             *Multivalue                    `json:"numRows,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetworkRangeInfo) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetworkRangeInfo) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetworkRangeInfo) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetworkRangeInfo) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.NetworkRangeIPByMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeIPByMask",
		isMultivalue: true,
	})
	n.NetworkRangeInterfaceIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeInterfaceIp",
		isMultivalue: true,
	})
	n.NetworkRangeInterfaceIpMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeInterfaceIpMask",
		isMultivalue: true,
	})
	n.NetworkRangeIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeIp",
		isMultivalue: true,
	})
	n.NetworkRangeIpIncrementBy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeIpIncrementBy",
		isMultivalue: true,
	})
	n.NetworkRangeIpMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeIpMask",
		isMultivalue: true,
	})
	n.NetworkRangeLinkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeLinkType",
		isMultivalue: true,
	})
	n.NetworkRangeRID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeRID",
		isMultivalue: true,
	})
	n.NetworkRangeRIDIncrement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkRangeRIDIncrement",
		isMultivalue: true,
	})
	n.NumColumns.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numColumns",
		isMultivalue: true,
	})
	n.NumRows.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numRows",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyNetworkTopology: Container for Network Topology related objects
type TopologyNetworkTopology struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath                            *XPath                                      `json:"xpath,omitempty"`
	CfmSimulatedTopology             []*TopologyCfmSimulatedTopology             `json:"cfmSimulatedTopology"`
	ExternalLink                     []*TopologyExternalLink                     `json:"externalLink"`
	IsisDceSimulatedTopologyConfig   []*TopologyIsisDceSimulatedTopologyConfig   `json:"isisDceSimulatedTopologyConfig"`
	IsisL3SimulatedTopologyConfig    []*TopologyIsisL3SimulatedTopologyConfig    `json:"isisL3SimulatedTopologyConfig"`
	IsisSpbSimulatedTopologyConfig   []*TopologyIsisSpbSimulatedTopologyConfig   `json:"isisSpbSimulatedTopologyConfig"`
	IsisTrillSimulatedTopologyConfig []*TopologyIsisTrillSimulatedTopologyConfig `json:"isisTrillSimulatedTopologyConfig"`
	LdpSimulatedTopologyConfig       []*TopologyLdpSimulatedTopologyConfig       `json:"ldpSimulatedTopologyConfig"`

	NetTopologyCustom *TopologyNetTopologyCustom `json:"netTopologyCustom,omitempty"`

	NetTopologyFatTree *TopologyNetTopologyFatTree `json:"netTopologyFatTree,omitempty"`

	NetTopologyGrid *TopologyNetTopologyGrid `json:"netTopologyGrid,omitempty"`

	NetTopologyHubNSpoke *TopologyNetTopologyHubNSpoke `json:"netTopologyHubNSpoke,omitempty"`

	NetTopologyLinear *TopologyNetTopologyLinear `json:"netTopologyLinear,omitempty"`

	NetTopologyMesh *TopologyNetTopologyMesh `json:"netTopologyMesh,omitempty"`

	NetTopologyRing *TopologyNetTopologyRing `json:"netTopologyRing,omitempty"`

	NetTopologyTree               *TopologyNetTopologyTree                 `json:"netTopologyTree,omitempty"`
	OspfSimulatedTopologyConfig   []*TopologyOspfSimulatedTopologyConfig   `json:"ospfSimulatedTopologyConfig"`
	Ospfv3SimulatedTopologyConfig []*TopologyOspfv3SimulatedTopologyConfig `json:"ospfv3SimulatedTopologyConfig"`
	SimInterface                  []*TopologySimInterface                  `json:"simInterface"`
	SimRouter                     []*TopologySimRouter                     `json:"simRouter"`
	SimRouterBridge               []*TopologySimRouterBridge               `json:"simRouterBridge"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNetworkTopology) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNetworkTopology) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNetworkTopology) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNetworkTopology) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.CfmSimulatedTopology {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmSimulatedTopology",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ExternalLink {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "externalLink",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisDceSimulatedTopologyConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDceSimulatedTopologyConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisL3SimulatedTopologyConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3SimulatedTopologyConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbSimulatedTopologyConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbSimulatedTopologyConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillSimulatedTopologyConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillSimulatedTopologyConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpSimulatedTopologyConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpSimulatedTopologyConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.NetTopologyCustom.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyCustom",
	})
	n.NetTopologyFatTree.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyFatTree",
	})
	n.NetTopologyGrid.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyGrid",
	})
	n.NetTopologyHubNSpoke.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyHubNSpoke",
	})
	n.NetTopologyLinear.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyLinear",
	})
	n.NetTopologyMesh.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyMesh",
	})
	n.NetTopologyRing.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyRing",
	})
	n.NetTopologyTree.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "netTopologyTree",
	})
	for i, o := range n.OspfSimulatedTopologyConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfSimulatedTopologyConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3SimulatedTopologyConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3SimulatedTopologyConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SimInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "simInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SimRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "simRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SimRouterBridge {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "simRouterBridge",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyNicknameRecordList: Fabric-Path Switch Ids
type TopologyNicknameRecordList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BroadcastRootPriority: Broadcast Root Priority
	BroadcastRootPriority *Multivalue `json:"broadcastRootPriority,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Switch Id
	Nickname *Multivalue `json:"nickname,omitempty"`
	// Priority: Priority
	Priority *Multivalue `json:"priority,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNicknameRecordList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNicknameRecordList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNicknameRecordList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNicknameRecordList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BroadcastRootPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "broadcastRootPriority",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
}

// TopologyNssaRoutes: OSPFv3 NSSA Routes directly derived from RB class since I could not agree with Options and Link State ID PrefixLen in the OSPFv3 specific base class
type TopologyNssaRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6) before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// ForwardingAddress: Forwarding Address of IPv6 NSSA LSAs that will be generated due to this range.
	ForwardingAddress *Multivalue `json:"forwardingAddress,omitempty"`
	// IncludeForwardingAddress: Include Forwarding Address
	IncludeForwardingAddress *Multivalue `json:"includeForwardingAddress,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LinkStateId: Start Link State Id for the LSAs to be generated for this set of IPv6 NSSA networks.
	LinkStateId *Multivalue `json:"linkStateId,omitempty"`
	// LinkStateIdStep: Link State Id Step for the LSAs to be generated for this set of IPv6 NSSA networks.
	LinkStateIdStep *Multivalue `json:"linkStateIdStep,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised by a Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Prefixes of the simulated IPv6 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// Prefix: Prefix Length
	Prefix *Multivalue `json:"prefix,omitempty"`
	// Propagate: Propagate
	Propagate *Multivalue `json:"propagate,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNssaRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNssaRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNssaRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNssaRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.ForwardingAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forwardingAddress",
		isMultivalue: true,
	})
	n.IncludeForwardingAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeForwardingAddress",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LinkStateId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateId",
		isMultivalue: true,
	})
	n.LinkStateIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkStateIdStep",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefix",
		isMultivalue: true,
	})
	n.Propagate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "propagate",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyNtpServers: NTP Servers
type TopologyNtpServers struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuthDelay: Authentication Delay (microsecs)
	AuthDelay *Multivalue `json:"authDelay,omitempty"`
	// Authentication: Authentication Type
	Authentication *Multivalue `json:"authentication,omitempty"`
	// AuthenticationKey: Authentication Key
	AuthenticationKey *Multivalue `json:"authenticationKey,omitempty"`
	// BurstMode: Burst Mode
	BurstMode *Multivalue `json:"burstMode,omitempty"`
	// InitialBurstMode: Initial Burst Mode
	InitialBurstMode *Multivalue `json:"initialBurstMode,omitempty"`
	// IsParentV6: Parent v6

	IsParentV6 *bool `json:"isParentV6,omitempty"`
	// KeyId: Key Identifier
	KeyId *Multivalue `json:"keyId,omitempty"`
	// MaxPollInterval: Max Poll Interval (log2 seconds)
	MaxPollInterval *Multivalue `json:"maxPollInterval,omitempty"`
	// MinPollInterval: Min Poll Interval (log2 seconds)
	MinPollInterval *Multivalue `json:"minPollInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ParticipateInClockSelect: Participate in Clock Select
	ParticipateInClockSelect *Multivalue `json:"participateInClockSelect,omitempty"`
	// ServerIPAddress: Server IP Address
	ServerIPAddress *Multivalue `json:"serverIPAddress,omitempty"`
	// ServerIPv6Address: Server IPv6 Address
	ServerIPv6Address *Multivalue `json:"serverIPv6Address,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNtpServers) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNtpServers) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNtpServers) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNtpServers) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuthDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authDelay",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.AuthenticationKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authenticationKey",
		isMultivalue: true,
	})
	n.BurstMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "burstMode",
		isMultivalue: true,
	})
	n.InitialBurstMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initialBurstMode",
		isMultivalue: true,
	})
	n.KeyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keyId",
		isMultivalue: true,
	})
	n.MaxPollInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxPollInterval",
		isMultivalue: true,
	})
	n.MinPollInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minPollInterval",
		isMultivalue: true,
	})
	n.ParticipateInClockSelect.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "participateInClockSelect",
		isMultivalue: true,
	})
	n.ServerIPAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverIPAddress",
		isMultivalue: true,
	})
	n.ServerIPv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverIPv6Address",
		isMultivalue: true,
	})
}

// TopologyNtpclock: Ntp
type TopologyNtpclock struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AcceptNTPPacketswithCryptoNAK: Accept NTP Packets with Crypto-NAK

	AcceptNTPPacketswithCryptoNAK *bool `json:"acceptNTPPacketswithCryptoNAK,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// IsParentV6: Parent v6

	IsParentV6 *bool `json:"isParentV6,omitempty"`
	// MaximumFrequencyTolerance: Maximum frequency tolerance (ppm)
	MaximumFrequencyTolerance *Multivalue `json:"maximumFrequencyTolerance,omitempty"`
	// Mimimumsurvivorcount: Minimum survivor count
	Mimimumsurvivorcount *Multivalue `json:"mimimumsurvivorcount,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NtpServerCount: NTP server Count

	NtpServerCount *float32 `json:"ntpServerCount,omitempty"`
	// Precision: Precision(log2 seconds)
	Precision *Multivalue `json:"precision,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	NtpServers *TopologyNtpServers `json:"ntpServers,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyNtpclock) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyNtpclock) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyNtpclock) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyNtpclock) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.MaximumFrequencyTolerance.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maximumFrequencyTolerance",
		isMultivalue: true,
	})
	n.Mimimumsurvivorcount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mimimumsurvivorcount",
		isMultivalue: true,
	})
	n.Precision.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "precision",
		isMultivalue: true,
	})
	n.NtpServers.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ntpServers",
	})
}

// TopologyOFSwitchLearnedInfoConfig: Openflow Switch Learned Info Configuration
type TopologyOFSwitchLearnedInfoConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// FlowStatOutGroupMode: Specify the Output Group Type. The options are: 1) All Groups 2) Any Group 3) Custom/Manual

	FlowStatOutGroupMode *string `json:"flowStatOutGroupMode,omitempty"`
	// FlowStatOutGroupValue: If Out Group is Custom/Manual, type the output group value in the box provided

	FlowStatOutGroupValue *float32 `json:"flowStatOutGroupValue,omitempty"`
	// FlowStatOutPortMode: Specify the Output Port Type. The options are: 1) OFPP_IN_PORT 2) OFPP_NORMAL 3) OFPP_FLOOD 4) OFPP_ALL 5) OFPP_CONTROLLER 6) OFPP_LOCAL 7) OFPP_ANY 8) Custom/Manual

	FlowStatOutPortMode *string `json:"flowStatOutPortMode,omitempty"`
	// FlowStatOutPortValue: If Out Port is Custom/Manual, type the output port value.

	FlowStatOutPortValue *float32 `json:"flowStatOutPortValue,omitempty"`
	// FlowStatTableIdMode: The identifier of the table. The options are: 1) All Tables 2) Custom/Manual.

	FlowStatTableIdMode *string `json:"flowStatTableIdMode,omitempty"`
	// FlowStatTableIdValue: If Table ID is Custom/ Manual, type the Table ID Number

	FlowStatTableIdValue *float32 `json:"flowStatTableIdValue,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOFSwitchLearnedInfoConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOFSwitchLearnedInfoConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOFSwitchLearnedInfoConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOFSwitchLearnedInfoConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyObject: Tlv object container which can contain one of a field, sub tlv or container
type TopologyObject struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: The name of the object

	Name                *string                        `json:"name,omitempty"`
	Container           []*TopologyContainer           `json:"container"`
	Field               []*TopologyField               `json:"field"`
	RepeatableContainer []*TopologyRepeatableContainer `json:"repeatableContainer"`
	SubTlv              []*TopologySubTlv              `json:"subTlv"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyObject) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyObject) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyObject) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyObject) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Container {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "container",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RepeatableContainer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "repeatableContainer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SubTlv {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "subTlv",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOfHostData: Contains number of host ports per switch and number of hosts per host port
type TopologyOfHostData struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfHostPorts: number of Host Ports per OF Switch.

	NumberOfHostPorts *float32 `json:"numberOfHostPorts,omitempty"`
	// NumberOfHostsPerPort: Number of Host Groups for each Host Port. Configure Number of Hosts Per Host Group using the Count field in Encapsulations Tab

	NumberOfHostsPerPort *float32 `json:"numberOfHostsPerPort,omitempty"`
	// ParentSwitchPortName: Description of the parent Switch Port.
	ParentSwitchPortName *Multivalue `json:"parentSwitchPortName,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOfHostData) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOfHostData) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOfHostData) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOfHostData) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ParentSwitchPortName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "parentSwitchPortName",
		isMultivalue: true,
	})
}

// TopologyOfSwitchChannel: Openflow Switch Channel level Configuration
type TopologyOfSwitchChannel struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuxConnectionsPerChannel: Number of Auxiliary Connections per Switch Channel

	AuxConnectionsPerChannel *float32 `json:"auxConnectionsPerChannel,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DatapathId: The Test Datapath ID of the OF Channel
	DatapathId *Multivalue `json:"datapathId,omitempty"`
	// DatapathIdHex: The Test Datapath ID Hex of the OF Channel
	DatapathIdHex *Multivalue `json:"datapathIdHex,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RemoteIp: The IP address of the DUT at the other end of the OF Channel.
	RemoteIp *Multivalue `json:"remoteIp,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs       []Href                             `json:"-"`
	AuxiliaryConnectionList []*TopologyAuxiliaryConnectionList `json:"auxiliaryConnectionList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOfSwitchChannel) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOfSwitchChannel) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOfSwitchChannel) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOfSwitchChannel) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DatapathId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "datapathId",
		isMultivalue: true,
	})
	n.DatapathIdHex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "datapathIdHex",
		isMultivalue: true,
	})
	n.RemoteIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIp",
		isMultivalue: true,
	})
	for i, o := range n.AuxiliaryConnectionList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "auxiliaryConnectionList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOfSwitchPorts: Openflow Switch Ports level Configuration
type TopologyOfSwitchPorts struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertisedFeatures: Select the features (link modes, link types, and link features) from the list that will be advertised by the port
	AdvertisedFeatures *Multivalue `json:"advertisedFeatures,omitempty"`
	// Config: Select the port administrative settings to indicate the behavior of the physical port.
	Config *Multivalue `json:"config,omitempty"`
	// CurrentFeatures: Select the current features (link modes, link types, and link features) from the list that the port will support
	CurrentFeatures *Multivalue `json:"currentFeatures,omitempty"`
	// CurrentSpeed: The current bit rate (raw transmission speed) of the link in kilobytes per second. This indicates the current capacity of the link.
	CurrentSpeed *Multivalue `json:"currentSpeed,omitempty"`
	// EtherAddr: The Ethernet address for the OpenFlow switch port.
	EtherAddr *Multivalue `json:"etherAddr,omitempty"`
	// ForcedConnectionType: Users override for connection type.
	ForcedConnectionType *Multivalue `json:"forcedConnectionType,omitempty"`
	// MaxSpeed: The maximum bit rate (raw transmission speed) of the link in kilobytes per second. This indicates the maximum configured capacity of the link.
	MaxSpeed *Multivalue `json:"maxSpeed,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumQueueRange: Specify the number of Queue ranges to be configured for this switch port

	NumQueueRange *float32 `json:"numQueueRange,omitempty"`
	// PeerAdvertisedFeatures: Select the features (link modes, link types, and link features) from the list that will be advertised by the peer
	PeerAdvertisedFeatures *Multivalue `json:"peerAdvertisedFeatures,omitempty"`
	// PortIndex: Index of port in particular OF Switch.
	PortIndex *Multivalue `json:"portIndex,omitempty"`
	// PortLivenessSupport: If selected, port liveness is supported in its port state. A port is considered live when it is not down or when its link is not down.
	PortLivenessSupport *Multivalue `json:"portLivenessSupport,omitempty"`
	// PortName: Specify the name of the Port.
	PortName *Multivalue `json:"portName,omitempty"`
	// PortNumber: The OpenFlow pipeline receives and sends packets on ports.
	PortNumber *Multivalue `json:"portNumber,omitempty"`
	// RemotePortIndex: Index of the Remote Port. Please refer Port Index to enter value in this field.
	RemotePortIndex *Multivalue `json:"remotePortIndex,omitempty"`
	// RemoteSwitch: The name of the remote Switch at the other end of the Switch OF Channel
	RemoteSwitch *Multivalue `json:"remoteSwitch,omitempty"`
	// RemoteSwitchIndex: Index of the Remote Switch. Please refer Switch Index to enter value in this field.
	RemoteSwitchIndex *Multivalue `json:"remoteSwitchIndex,omitempty"`
	// RemoteSwitchPort: The remote Switch port number identifier
	RemoteSwitchPort *Multivalue `json:"remoteSwitchPort,omitempty"`
	// State: Specify the port states
	State *Multivalue `json:"state,omitempty"`
	// SupportedFeatures: Select the features (link modes, link types, and link features) from the list that will be supported by the port
	SupportedFeatures *Multivalue `json:"supportedFeatures,omitempty"`
	// SwitchIndex: Index of the OF Switch.
	SwitchIndex *Multivalue `json:"switchIndex,omitempty"`
	// TransmissionDelay: The delay in milliseconds, between internal Switch ports
	TransmissionDelay *Multivalue `json:"transmissionDelay,omitempty"`

	OfSwitchQueues *TopologyOfSwitchQueues `json:"ofSwitchQueues,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOfSwitchPorts) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOfSwitchPorts) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOfSwitchPorts) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOfSwitchPorts) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertisedFeatures.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertisedFeatures",
		isMultivalue: true,
	})
	n.Config.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "config",
		isMultivalue: true,
	})
	n.CurrentFeatures.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "currentFeatures",
		isMultivalue: true,
	})
	n.CurrentSpeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "currentSpeed",
		isMultivalue: true,
	})
	n.EtherAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "etherAddr",
		isMultivalue: true,
	})
	n.ForcedConnectionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forcedConnectionType",
		isMultivalue: true,
	})
	n.MaxSpeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSpeed",
		isMultivalue: true,
	})
	n.PeerAdvertisedFeatures.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerAdvertisedFeatures",
		isMultivalue: true,
	})
	n.PortIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portIndex",
		isMultivalue: true,
	})
	n.PortLivenessSupport.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portLivenessSupport",
		isMultivalue: true,
	})
	n.PortName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portName",
		isMultivalue: true,
	})
	n.PortNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portNumber",
		isMultivalue: true,
	})
	n.RemotePortIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remotePortIndex",
		isMultivalue: true,
	})
	n.RemoteSwitch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteSwitch",
		isMultivalue: true,
	})
	n.RemoteSwitchIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteSwitchIndex",
		isMultivalue: true,
	})
	n.RemoteSwitchPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteSwitchPort",
		isMultivalue: true,
	})
	n.State.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "state",
		isMultivalue: true,
	})
	n.SupportedFeatures.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportedFeatures",
		isMultivalue: true,
	})
	n.SwitchIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "switchIndex",
		isMultivalue: true,
	})
	n.TransmissionDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transmissionDelay",
		isMultivalue: true,
	})
	n.OfSwitchQueues.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ofSwitchQueues",
	})
}

// TopologyOfSwitchQueues: OF Switch Port Queues configuration
type TopologyOfSwitchQueues struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// MaxRate: Specify the maximum data rate guaranteed.
	MaxRate *Multivalue `json:"maxRate,omitempty"`
	// MinRate: Specify the minimum data rate guaranteed.
	MinRate *Multivalue `json:"minRate,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ParentPort: Parent port index.
	ParentPort *Multivalue `json:"parentPort,omitempty"`
	// QueueId: Specify the queue identifier for the packets.
	QueueId *Multivalue `json:"queueId,omitempty"`
	// QueueProperty: Configure the queue property from the options
	QueueProperty *Multivalue `json:"queueProperty,omitempty"`
	// SwitchIndex: Index of the OF Switch.
	SwitchIndex *Multivalue `json:"switchIndex,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOfSwitchQueues) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOfSwitchQueues) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOfSwitchQueues) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOfSwitchQueues) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.MaxRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRate",
		isMultivalue: true,
	})
	n.MinRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minRate",
		isMultivalue: true,
	})
	n.ParentPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "parentPort",
		isMultivalue: true,
	})
	n.QueueId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "queueId",
		isMultivalue: true,
	})
	n.QueueProperty.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "queueProperty",
		isMultivalue: true,
	})
	n.SwitchIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "switchIndex",
		isMultivalue: true,
	})
}

// TopologyOpenFlowChannel: Openflow Controller Channel level Configuration
type TopologyOpenFlowChannel struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CalcFlowRate: If selected, the statistics on the rate of transmission of flows per second by the controller is published.
	CalcFlowRate *Multivalue `json:"calcFlowRate,omitempty"`
	// CalcFlowRateWithBarrier: If selected, statistics on the rate of transmission of flows per second by the controller, along with Barrier Request messages is published.
	CalcFlowRateWithBarrier *Multivalue `json:"calcFlowRateWithBarrier,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DatapathId: The Datapath ID of the OF Channel.
	DatapathId *Multivalue `json:"datapathId,omitempty"`
	// DatapathIdHex: The Datapath ID in hexadecimal format.
	DatapathIdHex *Multivalue `json:"datapathIdHex,omitempty"`
	// EnableHelloElement: If selected, the Controller sends a hello message consisting of an OpenFlow header and a set of variable size hello elements to inform the initial handshake of the connection.
	EnableHelloElement *Multivalue `json:"enableHelloElement,omitempty"`
	// FlowTxBurstSize: Specify the number of Flow transmitting packets that can be sent in a single burst within the time frame specified by the Inter Flow Burst Gap value.
	FlowTxBurstSize *Multivalue `json:"flowTxBurstSize,omitempty"`
	// GroupsPerChannel: Number of Groups per Channel

	GroupsPerChannel *float32 `json:"groupsPerChannel,omitempty"`
	// InterFlowBurstGap: Specify the duration (in milliseconds) for which the controller waits between successive flow advertisements.
	InterFlowBurstGap *Multivalue `json:"interFlowBurstGap,omitempty"`
	// MaxFlowsAtATime: The Max Number of Flows Processed at a Time is the size of an internal buffer maintained by the Ixiacontroller, which prevents it from sending more flows than the Openflow switch can consume at a time.
	MaxFlowsAtATime *Multivalue `json:"maxFlowsAtATime,omitempty"`
	// MetersPerChannel: Number of Meters per Channel

	MetersPerChannel *float32 `json:"metersPerChannel,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RemoteIp: The IP address of the DUT at the other end of the OF Channel.
	RemoteIp *Multivalue `json:"remoteIp,omitempty"`
	// SendRoleRequest: If selected, the controller sends a Role Request message after the connection is established; to change its role according to the Role Request option selected.
	SendRoleRequest *Multivalue `json:"sendRoleRequest,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartupGenerationId: A 64-bit sequence number field that identifies a given mastership view.
	StartupGenerationId *Multivalue `json:"startupGenerationId,omitempty"`
	// StartupRoleRequest: This defines role of the controller.Options include: 1) No Change 2) Equal 3) Master 4) Slave
	StartupRoleRequest *Multivalue `json:"startupRoleRequest,omitempty"`
	// TablesPerChannel: Number of Tables per Channel

	TablesPerChannel *float32 `json:"tablesPerChannel,omitempty"`
	// UseDatapathID: If selected, the Datapath ID and IP address are used as the OF Channel identifier.
	UseDatapathID *Multivalue       `json:"useDatapathID,omitempty"`
	Groups        []*TopologyGroups `json:"groups"`
	Meters        []*TopologyMeters `json:"meters"`
	Tables        []*TopologyTables `json:"tables"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOpenFlowChannel) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOpenFlowChannel) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOpenFlowChannel) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOpenFlowChannel) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CalcFlowRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "calcFlowRate",
		isMultivalue: true,
	})
	n.CalcFlowRateWithBarrier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "calcFlowRateWithBarrier",
		isMultivalue: true,
	})
	n.DatapathId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "datapathId",
		isMultivalue: true,
	})
	n.DatapathIdHex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "datapathIdHex",
		isMultivalue: true,
	})
	n.EnableHelloElement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloElement",
		isMultivalue: true,
	})
	n.FlowTxBurstSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowTxBurstSize",
		isMultivalue: true,
	})
	n.InterFlowBurstGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interFlowBurstGap",
		isMultivalue: true,
	})
	n.MaxFlowsAtATime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxFlowsAtATime",
		isMultivalue: true,
	})
	n.RemoteIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIp",
		isMultivalue: true,
	})
	n.SendRoleRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendRoleRequest",
		isMultivalue: true,
	})
	n.StartupGenerationId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startupGenerationId",
		isMultivalue: true,
	})
	n.StartupRoleRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startupRoleRequest",
		isMultivalue: true,
	})
	n.UseDatapathID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useDatapathID",
		isMultivalue: true,
	})
	for i, o := range n.Groups {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "groups",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Meters {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "meters",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tables {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tables",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOpenFlowController: OpenFlow Session (Device) level Configuration
type TopologyOpenFlowController struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AcceptUnconfiguredChannel: If selected, un-configured channels are accepted for this interface.
	AcceptUnconfiguredChannel *Multivalue `json:"acceptUnconfiguredChannel,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuxConnTimeout: The inactive time in milliseconds after which the auxiliary connection will timeout and close.
	AuxConnTimeout *Multivalue `json:"auxConnTimeout,omitempty"`
	// AuxNonHelloStartupOption: Specify the action from the following options for non-hello message when connection is established. The options are: 1) Accept Connection 2) Return Error
	AuxNonHelloStartupOption *Multivalue `json:"auxNonHelloStartupOption,omitempty"`
	// BadVersionErrorAction: Specify the action to be performed when an invalid version error occurs. The options are: 1) Re-send Hello 2) Terminate Connection
	BadVersionErrorAction *Multivalue `json:"badVersionErrorAction,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DelFlowsAtStartup: If selected, Controller sends an OpenFlow delete message (for all wild card entries) at start-up. This deletes all existing flows in the DUT.
	DelFlowsAtStartup *Multivalue `json:"delFlowsAtStartup,omitempty"`
	// DirectoryName: Location of Directory in Client where the Certificate and Key Files are available
	DirectoryName *Multivalue `json:"directoryName,omitempty"`
	// EchoInterval: The periodic interval in seconds at which the Interface sends Echo Request Packets.
	EchoInterval *Multivalue `json:"echoInterval,omitempty"`
	// EchoTimeOut: If selected, the echo request times out when they have been sent for a specified number of times, or when the time value specified has lapsed, but no response is received
	EchoTimeOut *Multivalue `json:"echoTimeOut,omitempty"`
	// FeatRequestTimeout: The inactive time in milliseconds after which the feature request will timeout.
	FeatRequestTimeout *Multivalue `json:"featRequestTimeout,omitempty"`
	// FeatureRquestTimeoutAction: Specify the action to be performed when a feature request times out. The options are: 1) Re-send Feature Request 2) Terminate Connection
	FeatureRquestTimeoutAction *Multivalue `json:"featureRquestTimeoutAction,omitempty"`
	// FileCaCertificate: Browse and upload a CA Certificate file for TLS session.
	FileCaCertificate *Multivalue `json:"fileCaCertificate,omitempty"`
	// FileCertificate: Browse and upload the certificate file for TLS session.
	FileCertificate *Multivalue `json:"fileCertificate,omitempty"`
	// FilePrivKey: Browse and upload the private key file for TLS session.
	FilePrivKey *Multivalue `json:"filePrivKey,omitempty"`
	// InstallFlowForLLDP: If selected, the controller sends add flow to each connected switch in such a way that each switch forwards LLDP packet to all other connected switches.
	InstallFlowForLLDP *Multivalue `json:"installFlowForLLDP,omitempty"`
	// InstallLLDPFlow: If selected, LLDP Flow is installed.
	InstallLLDPFlow *Multivalue `json:"installLLDPFlow,omitempty"`
	// LLDPDestinactionMac: Specify the LLDP Destination MAC address.
	LLDPDestinactionMac *Multivalue `json:"lLDPDestinactionMac,omitempty"`
	// LldpDstMacAddress: The destination MAC Address for the LLDP packet.
	LldpDstMacAddress *Multivalue `json:"lldpDstMacAddress,omitempty"`
	// ModeOfConnection: The mode of connection used for the Interface. Options include: 1) Active 2) Passive 3) Mixed
	ModeOfConnection *Multivalue `json:"modeOfConnection,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfChannels: Total number of OpenFlow channels to be added for this protocol interface.

	NumberOfChannels *float32 `json:"numberOfChannels,omitempty"`
	// PeriodicEcho: If selected, the Interface sends echo requests periodically to keep the OpenFlow session connected.
	PeriodicEcho *Multivalue `json:"periodicEcho,omitempty"`
	// PeriodicLLDP: If selected, the interface sends LLDP packets periodically to discover new links.
	PeriodicLLDP *Multivalue `json:"periodicLLDP,omitempty"`
	// PeriodicLLDPInterval: The periodic interval in milliseconds at which the Interface sends LLDP packets.
	PeriodicLLDPInterval *Multivalue `json:"periodicLLDPInterval,omitempty"`
	// ResponseTimeout: The time in milliseconds after which the trigger request times out, if no response is received
	ResponseTimeout *Multivalue `json:"responseTimeout,omitempty"`
	// SendPortFeatureAtStartup: If selected, port Description request is sent when the connection is established
	SendPortFeatureAtStartup *Multivalue `json:"sendPortFeatureAtStartup,omitempty"`
	// SetAsyncConfig: Un-checked state means getting the async config, Checked means setting asynchronous config with available parameters

	SetAsyncConfig *bool `json:"setAsyncConfig,omitempty"`
	// SetSwitchConfig: Un-checked state means getting the async config, Checked means setting asynchronous config with available parameters

	SetSwitchConfig *bool `json:"setSwitchConfig,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StartupEmptyTableFeatureRequest: If selected, the Table Feature Request is sent at start up.
	StartupEmptyTableFeatureRequest *Multivalue `json:"startupEmptyTableFeatureRequest,omitempty"`
	// StartupFeatureRequest: If selected, port feature request is sent when the connection is established.
	StartupFeatureRequest *Multivalue `json:"startupFeatureRequest,omitempty"`
	// TcpPort: Specify the TCP port for this interface
	TcpPort *Multivalue `json:"tcpPort,omitempty"`
	// TimeoutOption: The types of timeout options supported. Choose one of the following: 1) Multiplier 2) Timeout Value
	TimeoutOption *Multivalue `json:"timeoutOption,omitempty"`
	// TimeoutOptionValue: The value specified for the selected Timeout option.
	TimeoutOptionValue *Multivalue `json:"timeoutOptionValue,omitempty"`
	// TlsVersion: TLS version selection
	TlsVersion *Multivalue `json:"tlsVersion,omitempty"`
	// TriggerLldp: If selected, LLDP is triggered
	TriggerLldp *Multivalue `json:"triggerLldp,omitempty"`
	// TypeOfConnection: The type of connection used for the Interface. Options include: 1) TCP 2) TLS
	TypeOfConnection *Multivalue `json:"typeOfConnection,omitempty"`
	// VersionSupported: Indicates the supported OpenFlow version number.
	VersionSupported  *Multivalue                  `json:"versionSupported,omitempty"`
	LearnedInfo       []*TopologyLearnedInfo       `json:"learnedInfo"`
	LearnedInfoUpdate []*TopologyLearnedInfoUpdate `json:"learnedInfoUpdate"`
	OpenFlowChannel   []*TopologyOpenFlowChannel   `json:"openFlowChannel"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOpenFlowController) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOpenFlowController) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOpenFlowController) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOpenFlowController) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AcceptUnconfiguredChannel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "acceptUnconfiguredChannel",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuxConnTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxConnTimeout",
		isMultivalue: true,
	})
	n.AuxNonHelloStartupOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxNonHelloStartupOption",
		isMultivalue: true,
	})
	n.BadVersionErrorAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "badVersionErrorAction",
		isMultivalue: true,
	})
	n.DelFlowsAtStartup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delFlowsAtStartup",
		isMultivalue: true,
	})
	n.DirectoryName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "directoryName",
		isMultivalue: true,
	})
	n.EchoInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoInterval",
		isMultivalue: true,
	})
	n.EchoTimeOut.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoTimeOut",
		isMultivalue: true,
	})
	n.FeatRequestTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "featRequestTimeout",
		isMultivalue: true,
	})
	n.FeatureRquestTimeoutAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "featureRquestTimeoutAction",
		isMultivalue: true,
	})
	n.FileCaCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCaCertificate",
		isMultivalue: true,
	})
	n.FileCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCertificate",
		isMultivalue: true,
	})
	n.FilePrivKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filePrivKey",
		isMultivalue: true,
	})
	n.InstallFlowForLLDP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "installFlowForLLDP",
		isMultivalue: true,
	})
	n.InstallLLDPFlow.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "installLLDPFlow",
		isMultivalue: true,
	})
	n.LLDPDestinactionMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lLDPDestinactionMac",
		isMultivalue: true,
	})
	n.LldpDstMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lldpDstMacAddress",
		isMultivalue: true,
	})
	n.ModeOfConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "modeOfConnection",
		isMultivalue: true,
	})
	n.PeriodicEcho.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicEcho",
		isMultivalue: true,
	})
	n.PeriodicLLDP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicLLDP",
		isMultivalue: true,
	})
	n.PeriodicLLDPInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicLLDPInterval",
		isMultivalue: true,
	})
	n.ResponseTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "responseTimeout",
		isMultivalue: true,
	})
	n.SendPortFeatureAtStartup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendPortFeatureAtStartup",
		isMultivalue: true,
	})
	n.StartupEmptyTableFeatureRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startupEmptyTableFeatureRequest",
		isMultivalue: true,
	})
	n.StartupFeatureRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startupFeatureRequest",
		isMultivalue: true,
	})
	n.TcpPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpPort",
		isMultivalue: true,
	})
	n.TimeoutOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutOption",
		isMultivalue: true,
	})
	n.TimeoutOptionValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutOptionValue",
		isMultivalue: true,
	})
	n.TlsVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tlsVersion",
		isMultivalue: true,
	})
	n.TriggerLldp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggerLldp",
		isMultivalue: true,
	})
	n.TypeOfConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeOfConnection",
		isMultivalue: true,
	})
	n.VersionSupported.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "versionSupported",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfoUpdate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfoUpdate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OpenFlowChannel {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "openFlowChannel",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOpenFlowSwitch: OpenFlow Session (Device) level Configuration
type TopologyOpenFlowSwitch struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuxConnTimeout: The inactive time in milliseconds after which the auxiliary connection will timeout and close.
	AuxConnTimeout *Multivalue `json:"auxConnTimeout,omitempty"`
	// AuxNonHelloStartupOption: Specify the action from the following options for non-hello message when connection is established. The options are: 1) Accept Connection 2) Return Error
	AuxNonHelloStartupOption *Multivalue `json:"auxNonHelloStartupOption,omitempty"`
	// BadVersionErrorAction: Specify the action to be performed when an invalid version error occurs. The options are: 1) Re-send Hello 2) Terminate Connection
	BadVersionErrorAction *Multivalue `json:"badVersionErrorAction,omitempty"`
	// BandTypes: Select meter band types from the list
	BandTypes *Multivalue `json:"bandTypes,omitempty"`
	// BarrierReplyDelayType: Select the Barrier Reply Delay Type
	BarrierReplyDelayType *Multivalue `json:"barrierReplyDelayType,omitempty"`
	// BarrierReplyMaxDelay: Configure Barrier Reply Max Delay in milli seconds.
	BarrierReplyMaxDelay *Multivalue `json:"barrierReplyMaxDelay,omitempty"`
	// Capabilities: Capabilities
	Capabilities *Multivalue `json:"capabilities,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ControllerFlowTxRate: If selected, statistics is published showing the rate at which Flows are transmitted per second, by the Controller
	ControllerFlowTxRate *Multivalue `json:"controllerFlowTxRate,omitempty"`
	// DatapathDesc: The description of the Data Path used.
	DatapathDesc *Multivalue `json:"datapathDesc,omitempty"`
	// DatapathId: The Datapath ID of the OF Channel.
	DatapathId *Multivalue `json:"datapathId,omitempty"`
	// DatapathIdHex: The Datapath ID in Hex of the OF Channel.
	DatapathIdHex *Multivalue `json:"datapathIdHex,omitempty"`
	// DirectoryName: Location of Directory in Client where the Certificate and Key Files are available
	DirectoryName *Multivalue `json:"directoryName,omitempty"`
	// EchoInterval: The periodic interval in seconds at which the Interface sends Echo Request Packets.
	EchoInterval *Multivalue `json:"echoInterval,omitempty"`
	// EchoTimeOut: If selected, the echo request times out when they have been sent for a specified number of times, or when the time value specified has lapsed, but no response is received
	EchoTimeOut *Multivalue `json:"echoTimeOut,omitempty"`
	// EnableHelloElement: Enable Hello Element
	EnableHelloElement *Multivalue `json:"enableHelloElement,omitempty"`
	// FileCaCertificate: Browse and upload a CA Certificate file for TLS session.
	FileCaCertificate *Multivalue `json:"fileCaCertificate,omitempty"`
	// FileCertificate: Browse and upload the certificate file for TLS session.
	FileCertificate *Multivalue `json:"fileCertificate,omitempty"`
	// FilePrivKey: Browse and upload the private key file for TLS session.
	FilePrivKey *Multivalue `json:"filePrivKey,omitempty"`
	// FlowRemovedMask: Specify the flow removed message types that will not be received when the controller has the Master role
	FlowRemovedMask *Multivalue `json:"flowRemovedMask,omitempty"`
	// FlowRemovedMaskSlave: Specify the flow removed message types that will not be received when the controller has the Slave role
	FlowRemovedMaskSlave *Multivalue `json:"flowRemovedMaskSlave,omitempty"`
	// GroupCapabilities: Group configuration flags: Weight:Support weight for select groups. Liveness:Support liveness for select groups. Chaining:Support chaining groups. Check Loops:Check chaining for loops and delete.
	GroupCapabilities *Multivalue `json:"groupCapabilities,omitempty"`
	// GroupType: Can be of the following types per switch: 1)All: Execute all buckets in the group. 2)Select:Execute one bucket in the group. 3)Indirect:Execute the one defined bucket in this group. 4)Fast Failover:Execute the first live bucket.
	GroupType *Multivalue `json:"groupType,omitempty"`
	// HardwareDesc: The description of the hardware used.
	HardwareDesc *Multivalue `json:"hardwareDesc,omitempty"`
	// InterPacketInBurstGap: Specify the duration (in milliseconds) for which the switch waits between successive packet-in bursts.The default value is 1,000 milliseconds.
	InterPacketInBurstGap *Multivalue `json:"interPacketInBurstGap,omitempty"`
	// ManufacturerDesc: The description of the manufacturer. The default value is Ixia.
	ManufacturerDesc *Multivalue `json:"manufacturerDesc,omitempty"`
	// MaxBandPerMeter: Maximum number of bands per meter
	MaxBandPerMeter *Multivalue `json:"maxBandPerMeter,omitempty"`
	// MaxColorValue: Maximum Color Value
	MaxColorValue *Multivalue `json:"maxColorValue,omitempty"`
	// MaxNumberOfBucketsPerGroups: To specify the maximum number of group buckets each group can have.
	MaxNumberOfBucketsPerGroups *Multivalue `json:"maxNumberOfBucketsPerGroups,omitempty"`
	// MaxPacketInBytes: The maximum length of the Packet-in messages in bytes.
	MaxPacketInBytes *Multivalue `json:"maxPacketInBytes,omitempty"`
	// MeterCapabilities: Select meter capabilities from the list
	MeterCapabilities *Multivalue `json:"meterCapabilities,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumMeter: Maximum number of Openflow meters configured for the switch
	NumMeter *Multivalue `json:"numMeter,omitempty"`
	// NumberOfBuffers: Specify the maximum number of packets the switch can buffer when sending packets to the controller using packet-in messages.
	NumberOfBuffers *Multivalue `json:"numberOfBuffers,omitempty"`
	// NumberOfChannels: Total number of OpenFlow channels to be added for this protocol interface.

	NumberOfChannels *float32 `json:"numberOfChannels,omitempty"`
	// NumberOfPacketIn: Specify the number of packet-in ranges supported by the switch.The maximum allowed value is 10 ranges.

	NumberOfPacketIn *float32 `json:"numberOfPacketIn,omitempty"`
	// NumberOfTableRanges: Number of Tables per Switch

	NumberOfTableRanges *float32 `json:"numberOfTableRanges,omitempty"`
	// NumberOfUnconnectedPorts: Number of Unconnected Ports per Switch

	NumberOfUnconnectedPorts *float32 `json:"numberOfUnconnectedPorts,omitempty"`
	// PacketInMaskMaster: Packet In Mask Master
	PacketInMaskMaster *Multivalue `json:"packetInMaskMaster,omitempty"`
	// PacketInMaskSlave: Packet In Mask Slave
	PacketInMaskSlave *Multivalue `json:"packetInMaskSlave,omitempty"`
	// PacketInReplyDelay: If selected, delay between packet-in and the corresponding packet-out or flow mod is published.
	PacketInReplyDelay *Multivalue `json:"packetInReplyDelay,omitempty"`
	// PacketInReplyTimeout: The amount of time, in seconds, that the switch keeps the packet-in message in buffer, if it does not receive any corresponding packet-out or flow mod.
	PacketInReplyTimeout *Multivalue `json:"packetInReplyTimeout,omitempty"`
	// PacketInTxBurst: Specify the number of packet-in transmitting packets that can be sent in a single burst within the time frame specified by the Inter PacketIn Burst Gap value.
	PacketInTxBurst *Multivalue `json:"packetInTxBurst,omitempty"`
	// PacketOutRxRate: If selected, packet_out rx rate and packet_in tx rate is calculated for the switch.
	PacketOutRxRate *Multivalue `json:"packetOutRxRate,omitempty"`
	// PeriodicEcho: If selected, the Interface sends echo requests periodically to keep the OpenFlow session connected.
	PeriodicEcho *Multivalue `json:"periodicEcho,omitempty"`
	// PortStatusMaskMaster: Port Status Mask Master
	PortStatusMaskMaster *Multivalue `json:"portStatusMaskMaster,omitempty"`
	// PortStatusMaskSlave: Port Status Mask Slave
	PortStatusMaskSlave *Multivalue `json:"portStatusMaskSlave,omitempty"`
	// SerialNumber: The serial number used.
	SerialNumber *Multivalue `json:"serialNumber,omitempty"`
	// SoftwareDesc: The description of the software used.
	SoftwareDesc *Multivalue `json:"softwareDesc,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StoreFlows: If selected, the flow information sent by the Controller are learned by the Switch.
	StoreFlows *Multivalue `json:"storeFlows,omitempty"`
	// SwitchDesc: A description of the Switch
	SwitchDesc *Multivalue `json:"switchDesc,omitempty"`
	// TableMissAction: Specify what the Switch should do when there is no match for the packets
	TableMissAction *Multivalue `json:"tableMissAction,omitempty"`
	// TcpPort: Specify the TCP port for this interface
	TcpPort *Multivalue `json:"tcpPort,omitempty"`
	// TimeoutOption: The types of timeout options supported. Choose one of the following: 1) Multiplier 2) Timeout Value
	TimeoutOption *Multivalue `json:"timeoutOption,omitempty"`
	// TimeoutOptionValue: The value specified for the selected Timeout option.
	TimeoutOptionValue *Multivalue `json:"timeoutOptionValue,omitempty"`
	// TlsVersion: TLS version selection
	TlsVersion *Multivalue `json:"tlsVersion,omitempty"`
	// TransactionID: If selected, PacketIn Delay Calculation will be done by matching transaction ID
	TransactionID *Multivalue `json:"transactionID,omitempty"`
	// TypeOfConnection: The type of connection used for the Interface. Options include: 1) TCP 2) TLS
	TypeOfConnection *Multivalue `json:"typeOfConnection,omitempty"`
	// VersionSupported: Indicates the supported OpenFlow version number.
	VersionSupported *Multivalue                `json:"versionSupported,omitempty"`
	OFSwitchChannel  []*TopologyOfSwitchChannel `json:"OFSwitchChannel"`
	LearnedInfo      []*TopologyLearnedInfo     `json:"learnedInfo"`

	OFSwitchLearnedInfoConfig *TopologyOFSwitchLearnedInfoConfig `json:"oFSwitchLearnedInfoConfig,omitempty"`

	OfSwitchPorts    *TopologyOfSwitchPorts      `json:"ofSwitchPorts,omitempty"`
	PacketInList     []*TopologyPacketInList     `json:"packetInList"`
	SwitchGroupsList []*TopologySwitchGroupsList `json:"switchGroupsList"`
	SwitchTablesList []*TopologySwitchTablesList `json:"switchTablesList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOpenFlowSwitch) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOpenFlowSwitch) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOpenFlowSwitch) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOpenFlowSwitch) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuxConnTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxConnTimeout",
		isMultivalue: true,
	})
	n.AuxNonHelloStartupOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxNonHelloStartupOption",
		isMultivalue: true,
	})
	n.BadVersionErrorAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "badVersionErrorAction",
		isMultivalue: true,
	})
	n.BandTypes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandTypes",
		isMultivalue: true,
	})
	n.BarrierReplyDelayType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "barrierReplyDelayType",
		isMultivalue: true,
	})
	n.BarrierReplyMaxDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "barrierReplyMaxDelay",
		isMultivalue: true,
	})
	n.Capabilities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "capabilities",
		isMultivalue: true,
	})
	n.ControllerFlowTxRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "controllerFlowTxRate",
		isMultivalue: true,
	})
	n.DatapathDesc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "datapathDesc",
		isMultivalue: true,
	})
	n.DatapathId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "datapathId",
		isMultivalue: true,
	})
	n.DatapathIdHex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "datapathIdHex",
		isMultivalue: true,
	})
	n.DirectoryName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "directoryName",
		isMultivalue: true,
	})
	n.EchoInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoInterval",
		isMultivalue: true,
	})
	n.EchoTimeOut.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoTimeOut",
		isMultivalue: true,
	})
	n.EnableHelloElement.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloElement",
		isMultivalue: true,
	})
	n.FileCaCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCaCertificate",
		isMultivalue: true,
	})
	n.FileCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCertificate",
		isMultivalue: true,
	})
	n.FilePrivKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filePrivKey",
		isMultivalue: true,
	})
	n.FlowRemovedMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowRemovedMask",
		isMultivalue: true,
	})
	n.FlowRemovedMaskSlave.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowRemovedMaskSlave",
		isMultivalue: true,
	})
	n.GroupCapabilities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCapabilities",
		isMultivalue: true,
	})
	n.GroupType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupType",
		isMultivalue: true,
	})
	n.HardwareDesc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hardwareDesc",
		isMultivalue: true,
	})
	n.InterPacketInBurstGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interPacketInBurstGap",
		isMultivalue: true,
	})
	n.ManufacturerDesc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "manufacturerDesc",
		isMultivalue: true,
	})
	n.MaxBandPerMeter.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxBandPerMeter",
		isMultivalue: true,
	})
	n.MaxColorValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxColorValue",
		isMultivalue: true,
	})
	n.MaxNumberOfBucketsPerGroups.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxNumberOfBucketsPerGroups",
		isMultivalue: true,
	})
	n.MaxPacketInBytes.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxPacketInBytes",
		isMultivalue: true,
	})
	n.MeterCapabilities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "meterCapabilities",
		isMultivalue: true,
	})
	n.NumMeter.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numMeter",
		isMultivalue: true,
	})
	n.NumberOfBuffers.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfBuffers",
		isMultivalue: true,
	})
	n.PacketInMaskMaster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packetInMaskMaster",
		isMultivalue: true,
	})
	n.PacketInMaskSlave.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packetInMaskSlave",
		isMultivalue: true,
	})
	n.PacketInReplyDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packetInReplyDelay",
		isMultivalue: true,
	})
	n.PacketInReplyTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packetInReplyTimeout",
		isMultivalue: true,
	})
	n.PacketInTxBurst.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packetInTxBurst",
		isMultivalue: true,
	})
	n.PacketOutRxRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packetOutRxRate",
		isMultivalue: true,
	})
	n.PeriodicEcho.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicEcho",
		isMultivalue: true,
	})
	n.PortStatusMaskMaster.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portStatusMaskMaster",
		isMultivalue: true,
	})
	n.PortStatusMaskSlave.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portStatusMaskSlave",
		isMultivalue: true,
	})
	n.SerialNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serialNumber",
		isMultivalue: true,
	})
	n.SoftwareDesc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "softwareDesc",
		isMultivalue: true,
	})
	n.StoreFlows.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "storeFlows",
		isMultivalue: true,
	})
	n.SwitchDesc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "switchDesc",
		isMultivalue: true,
	})
	n.TableMissAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tableMissAction",
		isMultivalue: true,
	})
	n.TcpPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpPort",
		isMultivalue: true,
	})
	n.TimeoutOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutOption",
		isMultivalue: true,
	})
	n.TimeoutOptionValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutOptionValue",
		isMultivalue: true,
	})
	n.TlsVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tlsVersion",
		isMultivalue: true,
	})
	n.TransactionID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transactionID",
		isMultivalue: true,
	})
	n.TypeOfConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeOfConnection",
		isMultivalue: true,
	})
	n.VersionSupported.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "versionSupported",
		isMultivalue: true,
	})
	for i, o := range n.OFSwitchChannel {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "OFSwitchChannel",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.OFSwitchLearnedInfoConfig.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "oFSwitchLearnedInfoConfig",
	})
	n.OfSwitchPorts.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ofSwitchPorts",
	})
	for i, o := range n.PacketInList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "packetInList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SwitchGroupsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "switchGroupsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SwitchTablesList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "switchTablesList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfBierBsObjectList: OSPFv2 BIER Bit String Details
type TopologyOspfBierBsObjectList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BIERBitStringLength: This is a 4 bits field encoding the supported BitString length associated with this BFR-prefix
	BIERBitStringLength *Multivalue `json:"BIERBitStringLength,omitempty"`
	// LabelStart: Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// MaxSI: It is a 1 octet field encoding the maximum Set Identifier used in the encapsulation for this BIER sub-domain for this bitstring length.
	MaxSI *Multivalue `json:"maxSI,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfBierBsObjectList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfBierBsObjectList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfBierBsObjectList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfBierBsObjectList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BIERBitStringLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERBitStringLength",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.MaxSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSI",
		isMultivalue: true,
	})
}

// TopologyOspfBierSubDomainList: OSPFv2 BIER Sub Domain
type TopologyOspfBierSubDomainList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BFRId: A BFR Identifier (BFR-id) is a number within a given sub-domain. Every BFR that may need to function as a BFIR or BFER MUST have a single BFR-id, which identifies it uniquely within that sub-domain
	BFRId *Multivalue `json:"BFRId,omitempty"`
	// Bar: It is a single octet BIER specific algorithm used to calculate underlay paths to reach other BFRs
	Bar *Multivalue `json:"Bar,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Ipa: It is a single octet IGP algorithm to either modify, enhance or replace the calculation of underlay paths to reach other BFRs as defined by the BAR value.
	Ipa *Multivalue `json:"ipa,omitempty"`
	// MtId: Multi-Topology ID - It identifies the topology that is associated with the BIER sub-domain
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfBSLen: Number of Supported Bit String Length

	NumberOfBSLen *float32 `json:"numberOfBSLen,omitempty"`
	// SubDomainId: It is a unique value which identifies the BIER sub-domain within the BIER domain
	SubDomainId          *Multivalue                     `json:"subDomainId,omitempty"`
	OspfBierBSObjectList []*TopologyOspfBierBsObjectList `json:"ospfBierBSObjectList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfBierSubDomainList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfBierSubDomainList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfBierSubDomainList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfBierSubDomainList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BFRId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRId",
		isMultivalue: true,
	})
	n.Bar.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "Bar",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Ipa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipa",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.SubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subDomainId",
		isMultivalue: true,
	})
	for i, o := range n.OspfBierBSObjectList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfBierBSObjectList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfPseudoInterface: Information for Simulated Router Interfaces
type TopologyOspfPseudoInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdjSID: Adjacency SID
	AdjSID *Multivalue `json:"adjSID,omitempty"`
	// AdministratorGroup: Administrator Group
	AdministratorGroup *Multivalue `json:"administratorGroup,omitempty"`
	// BFlag: Backup Flag
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// BandwidthPriority0: Bandwidth for Priority 0 (B/sec)
	BandwidthPriority0 *Multivalue `json:"bandwidthPriority0,omitempty"`
	// BandwidthPriority1: Bandwidth for Priority 1 (B/sec)
	BandwidthPriority1 *Multivalue `json:"bandwidthPriority1,omitempty"`
	// BandwidthPriority2: Bandwidth for Priority 2 (B/sec)
	BandwidthPriority2 *Multivalue `json:"bandwidthPriority2,omitempty"`
	// BandwidthPriority3: Bandwidth for Priority 3 (B/sec)
	BandwidthPriority3 *Multivalue `json:"bandwidthPriority3,omitempty"`
	// BandwidthPriority4: Bandwidth for Priority 4 (B/sec)
	BandwidthPriority4 *Multivalue `json:"bandwidthPriority4,omitempty"`
	// BandwidthPriority5: Bandwidth for Priority 5 (B/sec)
	BandwidthPriority5 *Multivalue `json:"bandwidthPriority5,omitempty"`
	// BandwidthPriority6: Bandwidth for Priority 6 (B/sec)
	BandwidthPriority6 *Multivalue `json:"bandwidthPriority6,omitempty"`
	// BandwidthPriority7: Bandwidth for Priority 7 (B/sec)
	BandwidthPriority7 *Multivalue `json:"bandwidthPriority7,omitempty"`
	// Dedicated1Plus1: This is a Protection Scheme with value 0x10. It means that a dedicated disjoint link is protecting this link. However, the protecting link is not advertised in the link state database and is therefore not available for the routing of LSPs.
	Dedicated1Plus1 *Multivalue `json:"dedicated1Plus1,omitempty"`
	// Dedicated1To1: This is a Protection Scheme with value 0x08. It means that there is one dedicated disjoint link of type Extra Traffic that is protecting this link.
	Dedicated1To1 *Multivalue `json:"dedicated1To1,omitempty"`
	// EnLinkProtection: This enables the link protection on the OSPF link between two mentioned interfaces.
	EnLinkProtection *Multivalue `json:"enLinkProtection,omitempty"`
	// Enable: TE Enabled
	Enable *Multivalue `json:"enable,omitempty"`
	// EnableAdjSID: Enable Adj SID
	EnableAdjSID *Multivalue `json:"enableAdjSID,omitempty"`
	// EnableSRLG: This enables the SRLG on the OSPF link between two mentioned interfaces.
	EnableSRLG *Multivalue `json:"enableSRLG,omitempty"`
	// Enhanced: This is a Protection Scheme with value 0x20. It means that a protection scheme that is more reliable than Dedicated 1+1, e.g., 4 fiber BLSR/MS-SPRING, is being used to protect this link.
	Enhanced *Multivalue `json:"enhanced,omitempty"`
	// ExtraTraffic: This is a Protection Scheme with value 0x01. It means that the link is protecting another link or links. The LSPs on a link of this type will be lost if any of the links it is protecting fail.
	ExtraTraffic *Multivalue `json:"extraTraffic,omitempty"`
	// LFlag: Local/Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MaxBandwidth: Maximum Bandwidth (B/sec)
	MaxBandwidth *Multivalue `json:"maxBandwidth,omitempty"`
	// MaxReservableBandwidth: Maximum Reservable Bandwidth (B/sec)
	MaxReservableBandwidth *Multivalue `json:"maxReservableBandwidth,omitempty"`
	// Metric: Link Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// MetricLevel: TE Metric Level
	MetricLevel *Multivalue `json:"metricLevel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlag: Persistent Flag
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// Reserved40: This is a Protection Scheme with value 0x40.
	Reserved40 *Multivalue `json:"reserved40,omitempty"`
	// Reserved80: This is a Protection Scheme with value 0x80.
	Reserved80 *Multivalue `json:"reserved80,omitempty"`
	// SFlag: Set/Group Flag
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// Shared: This is a Protection Scheme with value 0x04. It means that there are one or more disjoint links of type Extra Traffic that are protecting this link. These Extra Traffic links are shared between one or more links of type Shared.
	Shared *Multivalue `json:"shared,omitempty"`
	// SrlgCount: This field value shows how many SRLG Value columns would be there in the GUI.

	SrlgCount *float32 `json:"srlgCount,omitempty"`
	// Unprotected: This is a Protection Scheme with value 0x02. It means that there is no other link protecting this link. The LSPs on a link of this type will be lost if the link fails.
	Unprotected *Multivalue `json:"unprotected,omitempty"`
	// VFlag: Value/Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// Weight: Weight
	Weight        *Multivalue              `json:"weight,omitempty"`
	SrlgValueList []*TopologySrlgValueList `json:"srlgValueList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfPseudoInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfPseudoInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfPseudoInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfPseudoInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adjSID",
		isMultivalue: true,
	})
	n.AdministratorGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administratorGroup",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.BandwidthPriority0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority0",
		isMultivalue: true,
	})
	n.BandwidthPriority1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority1",
		isMultivalue: true,
	})
	n.BandwidthPriority2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority2",
		isMultivalue: true,
	})
	n.BandwidthPriority3.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority3",
		isMultivalue: true,
	})
	n.BandwidthPriority4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority4",
		isMultivalue: true,
	})
	n.BandwidthPriority5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority5",
		isMultivalue: true,
	})
	n.BandwidthPriority6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority6",
		isMultivalue: true,
	})
	n.BandwidthPriority7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority7",
		isMultivalue: true,
	})
	n.Dedicated1Plus1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicated1Plus1",
		isMultivalue: true,
	})
	n.Dedicated1To1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicated1To1",
		isMultivalue: true,
	})
	n.EnLinkProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enLinkProtection",
		isMultivalue: true,
	})
	n.Enable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable",
		isMultivalue: true,
	})
	n.EnableAdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdjSID",
		isMultivalue: true,
	})
	n.EnableSRLG.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSRLG",
		isMultivalue: true,
	})
	n.Enhanced.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enhanced",
		isMultivalue: true,
	})
	n.ExtraTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extraTraffic",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MaxBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxBandwidth",
		isMultivalue: true,
	})
	n.MaxReservableBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxReservableBandwidth",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.MetricLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricLevel",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.Reserved40.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved40",
		isMultivalue: true,
	})
	n.Reserved80.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved80",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.Shared.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shared",
		isMultivalue: true,
	})
	n.Unprotected.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unprotected",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	for i, o := range n.SrlgValueList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "srlgValueList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfPseudoRouter: Simulated Router Information
type TopologyOspfPseudoRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/DeActivate OSPF Simulated Router
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseRouterIdAsStubNetwork: Advertise RouterId As Stub Network
	AdvertiseRouterIdAsStubNetwork *Multivalue `json:"advertiseRouterIdAsStubNetwork,omitempty"`
	// Algorithm: Algorithm for the Node SID/Label
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// BBit: Router-LSA B-Bit
	BBit *Multivalue `json:"bBit,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EBit: Router-LSA E-Bit
	EBit *Multivalue `json:"eBit,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// EnableSegmentRouting: Enable Segment Routing

	EnableSegmentRouting *bool `json:"enableSegmentRouting,omitempty"`
	// EnableSrlb: Enable SRLB

	EnableSrlb *bool `json:"enableSrlb,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// SRAlgorithmCount: SR Algorithm Count

	SRAlgorithmCount *float32 `json:"sRAlgorithmCount,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// SrgbRangeCount: SRGB Range Count

	SrgbRangeCount *float32 `json:"srgbRangeCount,omitempty"`
	// SrlbRangeCount: SRLB Range Count

	SrlbRangeCount *float32 `json:"srlbRangeCount,omitempty"`
	// VFlag: Value or Index Flag
	VFlag                          *Multivalue                               `json:"vFlag,omitempty"`
	OspfPseudoRouterStubNetworks   []*TopologyOspfPseudoRouterStubNetworks   `json:"ospfPseudoRouterStubNetworks"`
	OspfPseudoRouterStubRoutes     []*TopologyOspfPseudoRouterStubRoutes     `json:"ospfPseudoRouterStubRoutes"`
	OspfPseudoRouterSummaryRoutes  []*TopologyOspfPseudoRouterSummaryRoutes  `json:"ospfPseudoRouterSummaryRoutes"`
	OspfPseudoRouterType1ExtRoutes []*TopologyOspfPseudoRouterType1ExtRoutes `json:"ospfPseudoRouterType1ExtRoutes"`
	OspfPseudoRouterType2ExtRoutes []*TopologyOspfPseudoRouterType2ExtRoutes `json:"ospfPseudoRouterType2ExtRoutes"`
	OspfSRAlgorithmList            []*TopologyOspfSrAlgorithmList            `json:"ospfSRAlgorithmList"`
	OspfSRGBRangeSubObjectsList    []*TopologyOspfSrgbRangeSubObjectsList    `json:"ospfSRGBRangeSubObjectsList"`
	OspfSRLBRangeSubObjectsList    []*TopologyOspfSrlbRangeSubObjectsList    `json:"ospfSRLBRangeSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfPseudoRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfPseudoRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfPseudoRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfPseudoRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseRouterIdAsStubNetwork.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseRouterIdAsStubNetwork",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.BBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bBit",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eBit",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	for i, o := range n.OspfPseudoRouterStubNetworks {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfPseudoRouterStubNetworks",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfPseudoRouterStubRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfPseudoRouterStubRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfPseudoRouterSummaryRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfPseudoRouterSummaryRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfPseudoRouterType1ExtRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfPseudoRouterType1ExtRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfPseudoRouterType2ExtRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfPseudoRouterType2ExtRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfSRAlgorithmList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfSRAlgorithmList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfSRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfSRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfSRLBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfSRLBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfPseudoRouterStubNetworks: Simulated Router Information
type TopologyOspfPseudoRouterStubNetworks struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Network addresses of the simulated IPv4 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PrefixLength: Prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: Value or Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfPseudoRouterStubNetworks) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfPseudoRouterStubNetworks) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfPseudoRouterStubNetworks) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfPseudoRouterStubNetworks) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyOspfPseudoRouterStubRoutes: Simulated Router Information
type TopologyOspfPseudoRouterStubRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Network addresses of the simulated IPv4 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PrefixLength: Prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: Value or Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfPseudoRouterStubRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfPseudoRouterStubRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfPseudoRouterStubRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfPseudoRouterStubRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyOspfPseudoRouterSummaryRoutes: Simulated Router Information
type TopologyOspfPseudoRouterSummaryRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseSrcRouterIdTlv: Advertise Source Router Id Sub Tlv for Inter Area Prefixes
	AdvertiseSrcRouterIdTlv *Multivalue `json:"advertiseSrcRouterIdTlv,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Network addresses of the simulated IPv4 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PrefixLength: Prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// SrcRouterId: Originator/Source Router Id of these prefixes
	SrcRouterId *Multivalue `json:"srcRouterId,omitempty"`
	// VFlag: Value or Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfPseudoRouterSummaryRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfPseudoRouterSummaryRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfPseudoRouterSummaryRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfPseudoRouterSummaryRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseSrcRouterIdTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSrcRouterIdTlv",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.SrcRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcRouterId",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyOspfPseudoRouterType1ExtRoutes: External routes without external metric
type TopologyOspfPseudoRouterType1ExtRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Network addresses of the simulated IPv4 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PrefixLength: Prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: Value or Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfPseudoRouterType1ExtRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfPseudoRouterType1ExtRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfPseudoRouterType1ExtRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfPseudoRouterType1ExtRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyOspfPseudoRouterType2ExtRoutes: External routes with external metric
type TopologyOspfPseudoRouterType2ExtRoutes struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Whether this is to be advertised or not
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Network addresses of the simulated IPv4 network
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PrefixLength: Prefix
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RangeSize: Range Size
	RangeSize *Multivalue `json:"rangeSize,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: Value or Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfPseudoRouterType2ExtRoutes) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfPseudoRouterType2ExtRoutes) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfPseudoRouterType2ExtRoutes) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfPseudoRouterType2ExtRoutes) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RangeSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeSize",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyOspfRouteProperty: OSPF route range table
type TopologyOspfRouteProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BAR: It is a single octet BIER specific algorithm used to calculate underlay paths to reach other BFRs
	BAR *Multivalue `json:"BAR,omitempty"`
	// BFRId: A BFR Identifier (BFR-id) is a number within a given sub-domain. Every BFR that may need to function as a BFIR or BFER MUST have a single BFR-id, which identifies it uniquely within that sub-domain
	BFRId *Multivalue `json:"BFRId,omitempty"`
	// BFRIdStep: BFR Id Step
	BFRIdStep *Multivalue `json:"BFRIdStep,omitempty"`
	// BIERBitStringLength: This is a 4 bits field encoding the supported BitString length associated with this BFR-prefix
	BIERBitStringLength *Multivalue `json:"BIERBitStringLength,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdvertiseSrcRouterIdTlv: Advertise Source Router Id Sub Tlv for Inter Area Prefixes
	AdvertiseSrcRouterIdTlv *Multivalue `json:"advertiseSrcRouterIdTlv,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// AllowPropagate: Allow Propagate
	AllowPropagate *Multivalue `json:"allowPropagate,omitempty"`
	// BierAFlag: Attach Flag: If set an Area Border Router (ABR) will generate an Extended Prefix TLV for inter-area prefix that is locally connected or attached in other connected area
	BierAFlag *Multivalue `json:"bierAFlag,omitempty"`
	// BierNFlag: Node Flag: Set when the prefix identifies the advertising router i.e., the prefix is a host prefix advertising a globally reachable address typically associated with a loopback address
	BierNFlag *Multivalue `json:"bierNFlag,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// IncludeBIERInfo: Include BIER Info

	IncludeBIERInfo *bool `json:"includeBIERInfo,omitempty"`
	// IncludeBSLObject: If set, MPLS encapsulation sub-sub-Tlv will be advertised under Bier Info Sub-Tlv
	IncludeBSLObject *Multivalue `json:"includeBSLObject,omitempty"`
	// Ipa: It is a single octet IGP algorithm to either modify, enhance or replace the calculation of underlay paths to reach other BFRs as defined by the BAR value.
	Ipa *Multivalue `json:"ipa,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LabelStart: Label Start
	LabelStart *Multivalue `json:"labelStart,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// MaxSI: It is a 1 octet field encoding the maximum Set Identifier used in the encapsulation for this BIER sub-domain for this bitstring length.
	MaxSI *Multivalue `json:"maxSI,omitempty"`
	// Metric: Route Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// MtId: Multi-Topology ID: It identifies the topology that is associated with the BIER sub-domain
	MtId *Multivalue `json:"mtId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// SrcRouterId: Originator/Source Router Id of these prefixes
	SrcRouterId *Multivalue `json:"srcRouterId,omitempty"`
	// SubDomainId: It is a unique value which identifies the BIER sub-domain within the BIER domain
	SubDomainId *Multivalue `json:"subDomainId,omitempty"`
	// VFlag: Value or Index Flag
	VFlag               *Multivalue                    `json:"vFlag,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfRouteProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfRouteProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfRouteProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfRouteProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BAR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BAR",
		isMultivalue: true,
	})
	n.BFRId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRId",
		isMultivalue: true,
	})
	n.BFRIdStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BFRIdStep",
		isMultivalue: true,
	})
	n.BIERBitStringLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERBitStringLength",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertiseSrcRouterIdTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertiseSrcRouterIdTlv",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.AllowPropagate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allowPropagate",
		isMultivalue: true,
	})
	n.BierAFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierAFlag",
		isMultivalue: true,
	})
	n.BierNFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierNFlag",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.IncludeBSLObject.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeBSLObject",
		isMultivalue: true,
	})
	n.Ipa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipa",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelStart",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.MaxSI.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSI",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.MtId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtId",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.SrcRouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcRouterId",
		isMultivalue: true,
	})
	n.SubDomainId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subDomainId",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfSimulatedTopologyConfig: OSPF Simulated Topology specific configuration
type TopologyOspfSimulatedTopologyConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfSimulatedTopologyConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfSimulatedTopologyConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfSimulatedTopologyConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfSimulatedTopologyConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyOspfSrAlgorithmList: Ospf SR Algorithms
type TopologyOspfSrAlgorithmList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OspfSrAlgorithm: SR Algorithm
	OspfSrAlgorithm *Multivalue `json:"ospfSrAlgorithm,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfSrAlgorithmList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfSrAlgorithmList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfSrAlgorithmList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfSrAlgorithmList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.OspfSrAlgorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ospfSrAlgorithm",
		isMultivalue: true,
	})
}

// TopologyOspfSrMappingServerList: Ospf SR Mapping Server related configuration
type TopologyOspfSrMappingServerList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// IaFlag: Inter Area Flag
	IaFlag *Multivalue `json:"iaFlag,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkAddress: Starting Address of network address pool in the SR Mapping server network range
	NetworkAddress *Multivalue `json:"networkAddress,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// Range_: Range
	Range_ *Multivalue `json:"range,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: Value or Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfSrMappingServerList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfSrMappingServerList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfSrMappingServerList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfSrMappingServerList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.IaFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iaFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.NetworkAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkAddress",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.Range_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "range",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
}

// TopologyOspfSrgbRangeSubObjectsList: Ospf SRGB Range Sub Objects
type TopologyOspfSrgbRangeSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SidCount: SID Count
	SidCount *Multivalue `json:"sidCount,omitempty"`
	// StartSIDLabel: Start SID/Label
	StartSIDLabel *Multivalue `json:"startSIDLabel,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfSrgbRangeSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfSrgbRangeSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfSrgbRangeSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfSrgbRangeSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SidCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidCount",
		isMultivalue: true,
	})
	n.StartSIDLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSIDLabel",
		isMultivalue: true,
	})
}

// TopologyOspfSrlbRangeSubObjectsList: Ospf SRLB Range Sub Objects
type TopologyOspfSrlbRangeSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrlbSidCount: SID Count
	SrlbSidCount *Multivalue `json:"srlbSidCount,omitempty"`
	// SrlbStartSIDLabel: Start SID/Label
	SrlbStartSIDLabel *Multivalue `json:"srlbStartSIDLabel,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfSrlbRangeSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfSrlbRangeSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfSrlbRangeSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfSrlbRangeSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SrlbSidCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlbSidCount",
		isMultivalue: true,
	})
	n.SrlbStartSIDLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlbStartSIDLabel",
		isMultivalue: true,
	})
}

// TopologyOspfTrafficEngineering: Ospf Traffic Engineering Configuration
type TopologyOspfTrafficEngineering struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdministratorGroup: Administrator Group
	AdministratorGroup *Multivalue `json:"administratorGroup,omitempty"`
	// BandwidthPriority0: Bandwidth for Priority 0 (B/sec)
	BandwidthPriority0 *Multivalue `json:"bandwidthPriority0,omitempty"`
	// BandwidthPriority1: Bandwidth for Priority 1 (B/sec)
	BandwidthPriority1 *Multivalue `json:"bandwidthPriority1,omitempty"`
	// BandwidthPriority2: Bandwidth for Priority 2 (B/sec)
	BandwidthPriority2 *Multivalue `json:"bandwidthPriority2,omitempty"`
	// BandwidthPriority3: Bandwidth for Priority 3 (B/sec)
	BandwidthPriority3 *Multivalue `json:"bandwidthPriority3,omitempty"`
	// BandwidthPriority4: Bandwidth for Priority 4 (B/sec)
	BandwidthPriority4 *Multivalue `json:"bandwidthPriority4,omitempty"`
	// BandwidthPriority5: Bandwidth for Priority 5 (B/sec)
	BandwidthPriority5 *Multivalue `json:"bandwidthPriority5,omitempty"`
	// BandwidthPriority6: Bandwidth for Priority 6 (B/sec)
	BandwidthPriority6 *Multivalue `json:"bandwidthPriority6,omitempty"`
	// BandwidthPriority7: Bandwidth for Priority 7 (B/sec)
	BandwidthPriority7 *Multivalue `json:"bandwidthPriority7,omitempty"`
	// Enable: Enabled
	Enable *Multivalue `json:"enable,omitempty"`
	// MaxBandwidth: Maximum Bandwidth (B/sec)
	MaxBandwidth *Multivalue `json:"maxBandwidth,omitempty"`
	// MaxReservableBandwidth: Maximum Reservable Bandwidth (B/sec)
	MaxReservableBandwidth *Multivalue `json:"maxReservableBandwidth,omitempty"`
	// MetricLevel: TE Metric Level
	MetricLevel *Multivalue `json:"metricLevel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfTrafficEngineering) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfTrafficEngineering) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfTrafficEngineering) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfTrafficEngineering) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdministratorGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "administratorGroup",
		isMultivalue: true,
	})
	n.BandwidthPriority0.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority0",
		isMultivalue: true,
	})
	n.BandwidthPriority1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority1",
		isMultivalue: true,
	})
	n.BandwidthPriority2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority2",
		isMultivalue: true,
	})
	n.BandwidthPriority3.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority3",
		isMultivalue: true,
	})
	n.BandwidthPriority4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority4",
		isMultivalue: true,
	})
	n.BandwidthPriority5.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority5",
		isMultivalue: true,
	})
	n.BandwidthPriority6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority6",
		isMultivalue: true,
	})
	n.BandwidthPriority7.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthPriority7",
		isMultivalue: true,
	})
	n.Enable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enable",
		isMultivalue: true,
	})
	n.MaxBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxBandwidth",
		isMultivalue: true,
	})
	n.MaxReservableBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxReservableBandwidth",
		isMultivalue: true,
	})
	n.MetricLevel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricLevel",
		isMultivalue: true,
	})
}

// TopologyOspfv2: Ospf Interface level Configuration
type TopologyOspfv2 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdjSID: Adjacency SID
	AdjSID *Multivalue `json:"adjSID,omitempty"`
	// AreaId: OSPF Area ID for a non-connected interface, displayed in Interger format
	AreaId *Multivalue `json:"areaId,omitempty"`
	// AreaIdIp: OSPF Area ID for a non-connected interface, displayed in IP Address format
	AreaIdIp *Multivalue `json:"areaIdIp,omitempty"`
	// Authentication: Authentication
	Authentication *Multivalue `json:"authentication,omitempty"`
	// AuthenticationPassword: Authentication Password
	AuthenticationPassword *Multivalue `json:"authenticationPassword,omitempty"`
	// BFlag: Backup Flag
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DeadInterval: Dead Interval
	DeadInterval *Multivalue `json:"deadInterval,omitempty"`
	// Dedicated1Plus1: This is a Protection Scheme with value 0x10. It means that a dedicated disjoint link is protecting this link. However, the protecting link is not advertised in the link state database and is therefore not available for the routing of LSPs.
	Dedicated1Plus1 *Multivalue `json:"dedicated1Plus1,omitempty"`
	// Dedicated1To1: This is a Protection Scheme with value 0x08. It means that there is one dedicated disjoint link of type Extra Traffic that is protecting this link.
	Dedicated1To1 *Multivalue `json:"dedicated1To1,omitempty"`
	// DemandCircuit: Option bit 7
	DemandCircuit *Multivalue `json:"demandCircuit,omitempty"`
	// EnLinkProtection: This enables the link protection on the OSPF link between two mentioned interfaces.
	EnLinkProtection *Multivalue `json:"enLinkProtection,omitempty"`
	// EnableAdjSID: Enable Adj SID
	EnableAdjSID *Multivalue `json:"enableAdjSID,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableFast2wayConvergence: Enable 2-way Adj Fast Convergence

	EnableFast2wayConvergence *bool `json:"enableFast2wayConvergence,omitempty"`
	// EnableFastHello: Enable Fast Hello
	EnableFastHello *Multivalue `json:"enableFastHello,omitempty"`
	// EnableSRLG: This enables the SRLG on the OSPF link between two mentioned interfaces.
	EnableSRLG *Multivalue `json:"enableSRLG,omitempty"`
	// Enhanced: This is a Protection Scheme with value 0x20. It means that a protection scheme that is more reliable than Dedicated 1+1, e.g., 4 fiber BLSR/MS-SPRING, is being used to protect this link.
	Enhanced *Multivalue `json:"enhanced,omitempty"`
	// ExternalAttribute: Option bit 4
	ExternalAttribute *Multivalue `json:"externalAttribute,omitempty"`
	// ExternalCapability: Option bit 1
	ExternalCapability *Multivalue `json:"externalCapability,omitempty"`
	// ExtraTraffic: This is a Protection Scheme with value 0x01. It means that the link is protecting another link or links. The LSPs on a link of this type will be lost if any of the links it is protecting fail.
	ExtraTraffic *Multivalue `json:"extraTraffic,omitempty"`
	// HelloInterval: Hello Interval
	HelloInterval *Multivalue `json:"helloInterval,omitempty"`
	// HelloMultiplier: Hello Multiplier
	HelloMultiplier *Multivalue `json:"helloMultiplier,omitempty"`
	// LFlag: Local/Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MaxMtu: Maximum trasmission unit, min=68, max=16000
	MaxMtu *Multivalue `json:"maxMtu,omitempty"`
	// Md5Key: MD5 Key
	Md5Key *Multivalue `json:"md5Key,omitempty"`
	// Md5KeyId: MD5 Key ID
	Md5KeyId *Multivalue `json:"md5KeyId,omitempty"`
	// Metric: Routing Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// MulticastCapability: Option bit 2
	MulticastCapability *Multivalue `json:"multicastCapability,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NeighborIp: Neighbor IP when connected network is Point to Multipoint
	NeighborIp *Multivalue `json:"neighborIp,omitempty"`
	// NetworkType: Network Type
	NetworkType *Multivalue `json:"networkType,omitempty"`
	// NssaCapability: Option bit 3
	NssaCapability *Multivalue `json:"nssaCapability,omitempty"`
	// OpaqueLsaForwarded: Option bit 6
	OpaqueLsaForwarded *Multivalue `json:"opaqueLsaForwarded,omitempty"`
	// PFlag: Persistent Flag
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// Priority: Priority (when DR/BDR)
	Priority *Multivalue `json:"priority,omitempty"`
	// Reserved40: This is a Protection Scheme with value 0x40.
	Reserved40 *Multivalue `json:"reserved40,omitempty"`
	// Reserved80: This is a Protection Scheme with value 0x80.
	Reserved80 *Multivalue `json:"reserved80,omitempty"`
	// SFlag: Set/Group Flag
	SFlag *Multivalue `json:"sFlag,omitempty"`
	// Shared: This is a Protection Scheme with value 0x04. It means that there are one or more disjoint links of type Extra Traffic that are protecting this link. These Extra Traffic links are shared between one or more links of type Shared.
	Shared *Multivalue `json:"shared,omitempty"`
	// SrlgCount: This field value shows how many SRLG Value columns would be there in the GUI.

	SrlgCount *float32 `json:"srlgCount,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SuppressHello: Suppress Hello for BGP-LS
	SuppressHello *Multivalue `json:"suppressHello,omitempty"`
	// TypeAreaId: Area ID Type
	TypeAreaId *Multivalue `json:"typeAreaId,omitempty"`
	// TypeOfServiceRouting: Option bit 0
	TypeOfServiceRouting *Multivalue `json:"typeOfServiceRouting,omitempty"`
	// Unprotected: This is a Protection Scheme with value 0x02. It means that there is no other link protecting this link. The LSPs on a link of this type will be lost if the link fails.
	Unprotected *Multivalue `json:"unprotected,omitempty"`
	// Unused: Option bit 7
	Unused *Multivalue `json:"unused,omitempty"`
	// VFlag: Value/Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// ValidateRxMtu: Validate Received MTU
	ValidateRxMtu *Multivalue `json:"validateRxMtu,omitempty"`
	// Weight: Weight
	Weight *Multivalue `json:"weight,omitempty"`

	Connector   *TopologyConnector     `json:"connector,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`

	OspfSRMappingServerList *TopologyOspfSrMappingServerList `json:"ospfSRMappingServerList,omitempty"`

	OspfTrafficEngineering *TopologyOspfTrafficEngineering `json:"ospfTrafficEngineering,omitempty"`
	SrlgValueList          []*TopologySrlgValueList        `json:"srlgValueList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv2) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv2) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv2) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv2) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adjSID",
		isMultivalue: true,
	})
	n.AreaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaId",
		isMultivalue: true,
	})
	n.AreaIdIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaIdIp",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.AuthenticationPassword.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authenticationPassword",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "deadInterval",
		isMultivalue: true,
	})
	n.Dedicated1Plus1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicated1Plus1",
		isMultivalue: true,
	})
	n.Dedicated1To1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dedicated1To1",
		isMultivalue: true,
	})
	n.DemandCircuit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "demandCircuit",
		isMultivalue: true,
	})
	n.EnLinkProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enLinkProtection",
		isMultivalue: true,
	})
	n.EnableAdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdjSID",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableFastHello.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFastHello",
		isMultivalue: true,
	})
	n.EnableSRLG.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSRLG",
		isMultivalue: true,
	})
	n.Enhanced.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enhanced",
		isMultivalue: true,
	})
	n.ExternalAttribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "externalAttribute",
		isMultivalue: true,
	})
	n.ExternalCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "externalCapability",
		isMultivalue: true,
	})
	n.ExtraTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "extraTraffic",
		isMultivalue: true,
	})
	n.HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloInterval",
		isMultivalue: true,
	})
	n.HelloMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloMultiplier",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MaxMtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxMtu",
		isMultivalue: true,
	})
	n.Md5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "md5Key",
		isMultivalue: true,
	})
	n.Md5KeyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "md5KeyId",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.MulticastCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastCapability",
		isMultivalue: true,
	})
	n.NeighborIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "neighborIp",
		isMultivalue: true,
	})
	n.NetworkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkType",
		isMultivalue: true,
	})
	n.NssaCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nssaCapability",
		isMultivalue: true,
	})
	n.OpaqueLsaForwarded.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "opaqueLsaForwarded",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.Reserved40.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved40",
		isMultivalue: true,
	})
	n.Reserved80.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved80",
		isMultivalue: true,
	})
	n.SFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sFlag",
		isMultivalue: true,
	})
	n.Shared.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "shared",
		isMultivalue: true,
	})
	n.SuppressHello.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "suppressHello",
		isMultivalue: true,
	})
	n.TypeAreaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeAreaId",
		isMultivalue: true,
	})
	n.TypeOfServiceRouting.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeOfServiceRouting",
		isMultivalue: true,
	})
	n.Unprotected.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unprotected",
		isMultivalue: true,
	})
	n.Unused.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unused",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.ValidateRxMtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "validateRxMtu",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.OspfSRMappingServerList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ospfSRMappingServerList",
	})
	n.OspfTrafficEngineering.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ospfTrafficEngineering",
	})
	for i, o := range n.SrlgValueList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "srlgValueList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfv2Router: Ospf Device level Configuration
type TopologyOspfv2Router struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BIERPrefix: A BFR's BFR-Prefix is an IP address (either IPv4 or IPv6) of the BFR, and MUST be unique and routable within the BIER domain.
	BIERPrefix *Multivalue `json:"BIERPrefix,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm for the Node SID/Label
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// BBit: Router-LSA B-Bit
	BBit *Multivalue `json:"bBit,omitempty"`
	// BierAFlag: Attach Flag: If set an Area Border Router (ABR) will generate an Extended Prefix TLV for inter-area prefix that is locally connected or attached in other connected area
	BierAFlag *Multivalue `json:"bierAFlag,omitempty"`
	// BierNFlag: Node Flag: Set when the prefix identifies the advertising router i.e., the prefix is a host prefix advertising a globally reachable address typically associated with a loopback address
	BierNFlag *Multivalue `json:"bierNFlag,omitempty"`
	// ConfigureSIDIndexLabel: Configure SID/Index/Label
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// DiscardLearnedLsa: Discard Learned LSAs
	DiscardLearnedLsa *Multivalue `json:"discardLearnedLsa,omitempty"`
	// DoNotGenerateRouterLsa: Generate Router LSA.
	DoNotGenerateRouterLsa *Multivalue `json:"doNotGenerateRouterLsa,omitempty"`
	// EBit: Router-LSA E-Bit
	EBit *Multivalue `json:"eBit,omitempty"`
	// EFlag: Explicit-Null Flag
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// EnableBIER: Enable BIER

	EnableBIER *bool `json:"enableBIER,omitempty"`
	// EnableMappingServer: Enable Mapping Server of Segment Routing
	EnableMappingServer *Multivalue `json:"enableMappingServer,omitempty"`
	// EnableMappingServerPreference: Enable Mapping Server Preference of Segment Routing, used if multiple Mapping Servers are configured
	EnableMappingServerPreference *Multivalue `json:"enableMappingServerPreference,omitempty"`
	// EnableSegmentRouting: Enable Segment Routing

	EnableSegmentRouting *bool `json:"enableSegmentRouting,omitempty"`
	// EnableSrlb: Enable SRLB

	EnableSrlb *bool `json:"enableSrlb,omitempty"`
	// GracefulRestart: Enable Graceful Restart,if enabled Discard Learned LSAs should be disabled in order to learn the LSAs
	GracefulRestart *Multivalue `json:"gracefulRestart,omitempty"`
	// HighPerfLearningModeForSR: This option can be used to increase scale. When enabled then the minimum information required to generate traffic is stored instead of the entire LSA. For example, for SR traffic generation, sid, vflag, SRGB details are stored and label is calculated accordingly. Please note when this flag is enabled, we will not store any LSAs so Learned Info will not display any details. Currently this is supported for only SR opaque LSAs, other Opaque LSAs like BIER, Graceful Restart is not supported, also not supported for BGP-LS scenarios.
	HighPerfLearningModeForSR *Multivalue `json:"highPerfLearningModeForSR,omitempty"`
	// InterFloodLsUpdateBurstGap: Inter Flood LSUpdate burst gap (ms)
	InterFloodLsUpdateBurstGap *Multivalue `json:"interFloodLsUpdateBurstGap,omitempty"`
	// LFlag: Local or Global Flag
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LsaRefreshTime: LSA Refresh time (s)
	LsaRefreshTime *Multivalue `json:"lsaRefreshTime,omitempty"`
	// LsaRetransmitTime: LSA Retransmit time(s)
	LsaRetransmitTime *Multivalue `json:"lsaRetransmitTime,omitempty"`
	// MFlag: Mapping Server Flag
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// MappingServerPreferenceValue: Preference Value
	MappingServerPreferenceValue *Multivalue `json:"mappingServerPreferenceValue,omitempty"`
	// MaxLsUpdatesPerBurst: Max Flood LSUpdates Per Burst
	MaxLsUpdatesPerBurst *Multivalue `json:"maxLsUpdatesPerBurst,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfAddressPrefix: Number Of Address Prefix Range

	NoOfAddressPrefix *float32 `json:"noOfAddressPrefix,omitempty"`
	// NoOfBIERSubDomains: Number of BIER Sub Domains

	NoOfBIERSubDomains *float32 `json:"noOfBIERSubDomains,omitempty"`
	// NpFlag: No-PHP Flag
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// OobResyncBreakout: Enable out-of-band resynchronization breakout
	OobResyncBreakout *Multivalue `json:"oobResyncBreakout,omitempty"`
	// SRAlgorithmCount: SR Algorithm Count

	SRAlgorithmCount *float32 `json:"sRAlgorithmCount,omitempty"`
	// SidIndexLabel: SID/Index/Label
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// SrgbRangeCount: SRGB Range Count

	SrgbRangeCount *float32 `json:"srgbRangeCount,omitempty"`
	// SrlbRangeCount: SRLB Range Count

	SrlbRangeCount *float32 `json:"srlbRangeCount,omitempty"`
	// StrictLsaChecking: Terminate graceful restart when an LSA has changed
	StrictLsaChecking *Multivalue `json:"strictLsaChecking,omitempty"`
	// SupportForRfc3623: Support RFC 3623 features,if enabled Discard Learned LSAs should be disabled in order to learn the LSAs
	SupportForRfc3623 *Multivalue `json:"supportForRfc3623,omitempty"`
	// SupportReasonSoftReloadUpgrade: Support graceful restart helper mode when restart reason is Software Reload or Upgrade.
	SupportReasonSoftReloadUpgrade *Multivalue `json:"supportReasonSoftReloadUpgrade,omitempty"`
	// SupportReasonSoftRestart: Support graceful restart helper mode when restart reason is OSPFv2 software restart.
	SupportReasonSoftRestart *Multivalue `json:"supportReasonSoftRestart,omitempty"`
	// SupportReasonSwitchRedundantCntrlProcessor: Support graceful restart helper mode when restart reason is unplanned switchover.
	SupportReasonSwitchRedundantCntrlProcessor *Multivalue `json:"supportReasonSwitchRedundantCntrlProcessor,omitempty"`
	// SupportReasonUnknown: Support graceful restart helper mode when restart reason is unknown and unplanned.
	SupportReasonUnknown *Multivalue `json:"supportReasonUnknown,omitempty"`
	// VFlag: Value or Index Flag
	VFlag *Multivalue `json:"vFlag,omitempty"`

	OspfBierSubDomainList       *TopologyOspfBierSubDomainList         `json:"ospfBierSubDomainList,omitempty"`
	OspfSRAlgorithmList         []*TopologyOspfSrAlgorithmList         `json:"ospfSRAlgorithmList"`
	OspfSRGBRangeSubObjectsList []*TopologyOspfSrgbRangeSubObjectsList `json:"ospfSRGBRangeSubObjectsList"`
	OspfSRLBRangeSubObjectsList []*TopologyOspfSrlbRangeSubObjectsList `json:"ospfSRLBRangeSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv2Router) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv2Router) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv2Router) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv2Router) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BIERPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "BIERPrefix",
		isMultivalue: true,
	})
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.BBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bBit",
		isMultivalue: true,
	})
	n.BierAFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierAFlag",
		isMultivalue: true,
	})
	n.BierNFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bierNFlag",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.DiscardLearnedLsa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLearnedLsa",
		isMultivalue: true,
	})
	n.DoNotGenerateRouterLsa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "doNotGenerateRouterLsa",
		isMultivalue: true,
	})
	n.EBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eBit",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.EnableMappingServer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMappingServer",
		isMultivalue: true,
	})
	n.EnableMappingServerPreference.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMappingServerPreference",
		isMultivalue: true,
	})
	n.GracefulRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gracefulRestart",
		isMultivalue: true,
	})
	n.HighPerfLearningModeForSR.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "highPerfLearningModeForSR",
		isMultivalue: true,
	})
	n.InterFloodLsUpdateBurstGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interFloodLsUpdateBurstGap",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LsaRefreshTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lsaRefreshTime",
		isMultivalue: true,
	})
	n.LsaRetransmitTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lsaRetransmitTime",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.MappingServerPreferenceValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mappingServerPreferenceValue",
		isMultivalue: true,
	})
	n.MaxLsUpdatesPerBurst.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLsUpdatesPerBurst",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.OobResyncBreakout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oobResyncBreakout",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.StrictLsaChecking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "strictLsaChecking",
		isMultivalue: true,
	})
	n.SupportForRfc3623.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportForRfc3623",
		isMultivalue: true,
	})
	n.SupportReasonSoftReloadUpgrade.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportReasonSoftReloadUpgrade",
		isMultivalue: true,
	})
	n.SupportReasonSoftRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportReasonSoftRestart",
		isMultivalue: true,
	})
	n.SupportReasonSwitchRedundantCntrlProcessor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportReasonSwitchRedundantCntrlProcessor",
		isMultivalue: true,
	})
	n.SupportReasonUnknown.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportReasonUnknown",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.OspfBierSubDomainList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ospfBierSubDomainList",
	})
	for i, o := range n.OspfSRAlgorithmList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfSRAlgorithmList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfSRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfSRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfSRLBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfSRLBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfv3: Ospfv3 Interface level Configuration
type TopologyOspfv3 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AdjSID: An Adjacency Segment Identifier (Adj-SID) represents a router adjacency in Segment Routing
	AdjSID *Multivalue `json:"adjSID,omitempty"`
	// AreaId: OSPFv3 Area ID for a non-connected interface, displayed in Interger format
	AreaId *Multivalue `json:"areaId,omitempty"`
	// AreaIdIp: OSPFv3 Area ID for a non-connected interface, displayed in IP Address format
	AreaIdIp *Multivalue `json:"areaIdIp,omitempty"`
	// AuthAlgo: Authentication Algorithms
	AuthAlgo *Multivalue `json:"authAlgo,omitempty"`
	// BFlag: B Flag: Backup Flag: If set, the Adj-SID refers to an adjacency that is eligible for protection
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DeadInterval: Dead Interval
	DeadInterval *Multivalue `json:"deadInterval,omitempty"`
	// DemandCircuit: Option bit 5
	DemandCircuit *Multivalue `json:"demandCircuit,omitempty"`
	// EnableAdjSID: Makes the Adjacency Segment Identifier (Adj-SID) available
	EnableAdjSID *Multivalue `json:"enableAdjSID,omitempty"`
	// EnableAuthentication: Enable Authentication
	EnableAuthentication *Multivalue `json:"enableAuthentication,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableFastHello: Enable Fast Hello
	EnableFastHello *Multivalue `json:"enableFastHello,omitempty"`
	// EnableIgnoreDbDescMtu: Ignore DB-Desc MTU
	EnableIgnoreDbDescMtu *Multivalue `json:"enableIgnoreDbDescMtu,omitempty"`
	// ExternalCapability: Option bit 1
	ExternalCapability *Multivalue `json:"externalCapability,omitempty"`
	// GFlag: G-Flag: Group Flag: If set, the G-Flag indicates that the Adj-SID refers to a group of adjacencies where it may be assigned
	GFlag *Multivalue `json:"gFlag,omitempty"`
	// HelloInterval: Hello Interval
	HelloInterval *Multivalue `json:"helloInterval,omitempty"`
	// HelloMultiplier: Hello Multiplier
	HelloMultiplier *Multivalue `json:"helloMultiplier,omitempty"`
	// InstanceId: Instance ID
	InstanceId *Multivalue `json:"instanceId,omitempty"`
	// Key: Key
	Key *Multivalue `json:"key,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NetworkType: Network Type
	NetworkType *Multivalue `json:"networkType,omitempty"`
	// NssaCapability: Option bit 3
	NssaCapability *Multivalue `json:"nssaCapability,omitempty"`
	// PFlag: P-Flag:Persistent Flag: If set, the SID is persistently allocated. The SID value remains consistent across router restart and session/interface flap
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// Priority: Priority (when DR/BDR)
	Priority *Multivalue `json:"priority,omitempty"`
	// Router: Option bit 4
	Router *Multivalue `json:"router,omitempty"`
	// SaId: Security Association ID
	SaId *Multivalue `json:"saId,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TypeAreaId: Area ID Type
	TypeAreaId *Multivalue `json:"typeAreaId,omitempty"`
	// V6: Option bit 0
	V6 *Multivalue `json:"v6,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// Weight: Weight of the SID for the purpose of load balancing
	Weight *Multivalue `json:"weight,omitempty"`

	Connector   *TopologyConnector     `json:"connector,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv3) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv3) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv3) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv3) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adjSID",
		isMultivalue: true,
	})
	n.AreaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaId",
		isMultivalue: true,
	})
	n.AreaIdIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "areaIdIp",
		isMultivalue: true,
	})
	n.AuthAlgo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authAlgo",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "deadInterval",
		isMultivalue: true,
	})
	n.DemandCircuit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "demandCircuit",
		isMultivalue: true,
	})
	n.EnableAdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdjSID",
		isMultivalue: true,
	})
	n.EnableAuthentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAuthentication",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableFastHello.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFastHello",
		isMultivalue: true,
	})
	n.EnableIgnoreDbDescMtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIgnoreDbDescMtu",
		isMultivalue: true,
	})
	n.ExternalCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "externalCapability",
		isMultivalue: true,
	})
	n.GFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gFlag",
		isMultivalue: true,
	})
	n.HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloInterval",
		isMultivalue: true,
	})
	n.HelloMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloMultiplier",
		isMultivalue: true,
	})
	n.InstanceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "instanceId",
		isMultivalue: true,
	})
	n.Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "key",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
	n.NetworkType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "networkType",
		isMultivalue: true,
	})
	n.NssaCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nssaCapability",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.Router.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "router",
		isMultivalue: true,
	})
	n.SaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "saId",
		isMultivalue: true,
	})
	n.TypeAreaId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "typeAreaId",
		isMultivalue: true,
	})
	n.V6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "v6",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfv3PseudoInterface: Information for Simulated Router Interfaces
type TopologyOspfv3PseudoInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdjSID: An Adjacency Segment Identifier (Adj-SID) represents a router adjacency in Segment Routing
	AdjSID *Multivalue `json:"adjSID,omitempty"`
	// BFlag: B Flag: Backup Flag: If set, the Adj-SID refers to an adjacency that is eligible for protection
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// EnableAdjSID: Makes the Adjacency Segment Identifier (Adj-SID) available
	EnableAdjSID *Multivalue `json:"enableAdjSID,omitempty"`
	// GFlag: G-Flag: Group Flag: If set, the G-Flag indicates that the Adj-SID refers to a group of adjacencies where it may be assigned
	GFlag *Multivalue `json:"gFlag,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// Metric: Link Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlag: P-Flag:Persistent Flag: If set, the SID is persistently allocated. The SID value remains consistent across router restart and session/interface flap
	PFlag *Multivalue `json:"pFlag,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag *Multivalue `json:"vFlag,omitempty"`
	// Weight: Weight of the SID for the purpose of load balancing
	Weight *Multivalue `json:"weight,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv3PseudoInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv3PseudoInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv3PseudoInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv3PseudoInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "adjSID",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.EnableAdjSID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableAdjSID",
		isMultivalue: true,
	})
	n.GFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.PFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlag",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	n.Weight.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "weight",
		isMultivalue: true,
	})
}

// TopologyOspfv3PseudoRouter: Simulated Router Information
type TopologyOspfv3PseudoRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm for the Node SID/Label
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// BBit: Router-LSA B-Bit
	BBit *Multivalue `json:"bBit,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EBit: Router-LSA E-Bit
	EBit *Multivalue `json:"eBit,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6) before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// EnableSrMpls: Makes the Segment Routing configuration enabled

	EnableSrMpls *bool `json:"enableSrMpls,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised by a Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// SrgbRangeCount: count of the configurable list of SRGB

	SrgbRangeCount *float32 `json:"srgbRangeCount,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag                         *Multivalue                              `json:"vFlag,omitempty"`
	ExternalRoutes                []*TopologyExternalRoutes                `json:"externalRoutes"`
	InterAreaPrefix               []*TopologyInterAreaPrefix               `json:"interAreaPrefix"`
	InterAreaRouter               []*TopologyInterAreaRouter               `json:"interAreaRouter"`
	IntraAreaPrefix               []*TopologyIntraAreaPrefix               `json:"intraAreaPrefix"`
	LinkLsaRoutes                 []*TopologyLinkLsaRoutes                 `json:"linkLsaRoutes"`
	NssaRoutes                    []*TopologyNssaRoutes                    `json:"nssaRoutes"`
	Ospfv3SRGBRangeSubObjectsList []*TopologyOspfv3SrgbRangeSubObjectsList `json:"ospfv3SRGBRangeSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv3PseudoRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv3PseudoRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv3PseudoRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv3PseudoRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.BBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bBit",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eBit",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	for i, o := range n.ExternalRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "externalRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.InterAreaPrefix {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "interAreaPrefix",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.InterAreaRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "interAreaRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IntraAreaPrefix {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "intraAreaPrefix",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LinkLsaRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "linkLsaRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NssaRoutes {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "nssaRoutes",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3SRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3SRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfv3RouteProperty: OSPFv3 route range table
type TopologyOspfv3RouteProperty struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// AllowPropagate: Allow Propagate
	AllowPropagate *Multivalue `json:"allowPropagate,omitempty"`
	// AutoSelectForwardingAddress: Auto Select Forwarding Address
	AutoSelectForwardingAddress *Multivalue `json:"autoSelectForwardingAddress,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6) before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// ForwardingAddress: Forwarding addresses of the Type-7 LSA
	ForwardingAddress *Multivalue `json:"forwardingAddress,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised by a Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// Metric: Route Metric
	Metric *Multivalue `json:"metric,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop the Prefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// RouteOrigin: Route Origin
	RouteOrigin *Multivalue `json:"routeOrigin,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag               *Multivalue                    `json:"vFlag,omitempty"`
	CMacProperties      []*TopologyCMacProperties      `json:"cMacProperties"`
	EvpnIPv4PrefixRange []*TopologyEvpnIPv4PrefixRange `json:"evpnIPv4PrefixRange"`
	EvpnIPv6PrefixRange []*TopologyEvpnIPv6PrefixRange `json:"evpnIPv6PrefixRange"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv3RouteProperty) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv3RouteProperty) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv3RouteProperty) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv3RouteProperty) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.AllowPropagate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allowPropagate",
		isMultivalue: true,
	})
	n.AutoSelectForwardingAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoSelectForwardingAddress",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.ForwardingAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forwardingAddress",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.Metric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metric",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.RouteOrigin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routeOrigin",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	for i, o := range n.CMacProperties {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cMacProperties",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv4PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv4PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EvpnIPv6PrefixRange {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "evpnIPv6PrefixRange",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfv3Router: Ospfv3 Device level Configuration
type TopologyOspfv3Router struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Algorithm: Algorithm for the Node SID/Label
	Algorithm *Multivalue `json:"algorithm,omitempty"`
	// BBit: Router-LSA B-Bit
	BBit *Multivalue `json:"bBit,omitempty"`
	// ConfigureSIDIndexLabel: Lets the corresponding router send Prefix SID. By default, it is selected
	ConfigureSIDIndexLabel *Multivalue `json:"configureSIDIndexLabel,omitempty"`
	// DisableAutoGenerateLinkLsa: Support graceful restart helper mode when restart reason is unknown and unplanned.
	DisableAutoGenerateLinkLsa *Multivalue `json:"disableAutoGenerateLinkLsa,omitempty"`
	// DisableAutoGenerateRouterLsa: Support graceful restart helper mode when restart reason is unknown and unplanned.
	DisableAutoGenerateRouterLsa *Multivalue `json:"disableAutoGenerateRouterLsa,omitempty"`
	// DiscardLearnedLsa: Discard Learned LSAs
	DiscardLearnedLsa *Multivalue `json:"discardLearnedLsa,omitempty"`
	// EBit: Router-LSA E-Bit
	EBit *Multivalue `json:"eBit,omitempty"`
	// EFlag: E Flag: Explicit-Null Flag: If set, any upstream neighbor of the Prefix-SID originator MUST replace the Prefix-SID with a Prefix-SID having an Explicit-NULL value (0 for IPv4 and 2 for IPv6)before forwarding the packet
	EFlag *Multivalue `json:"eFlag,omitempty"`
	// EnableGracefulRestartHelperMode: Enable Graceful Restart helper Mode,if enabled Discard Learned LSAs should be disabled in order to learn the LSAs
	EnableGracefulRestartHelperMode *Multivalue `json:"enableGracefulRestartHelperMode,omitempty"`
	// EnableSrMpls: Makes the Segment Routing configuration enabled

	EnableSrMpls *bool `json:"enableSrMpls,omitempty"`
	// EnableStrictLsaChecking: Terminate graceful restart when an LSA has changed
	EnableStrictLsaChecking *Multivalue `json:"enableStrictLsaChecking,omitempty"`
	// EnableSupportReasonSwReloadUpgrade: Support graceful restart helper mode when restart reason is Software Reload or Upgrade.
	EnableSupportReasonSwReloadUpgrade *Multivalue `json:"enableSupportReasonSwReloadUpgrade,omitempty"`
	// EnableSupportReasonSwRestart: Support graceful restart helper mode when restart reason is Ospfv3 software restart.
	EnableSupportReasonSwRestart *Multivalue `json:"enableSupportReasonSwRestart,omitempty"`
	// EnableSupportReasonSwitchToRedundantControlProcessor: Support graceful restart helper mode when restart reason is unplanned switchover.
	EnableSupportReasonSwitchToRedundantControlProcessor *Multivalue `json:"enableSupportReasonSwitchToRedundantControlProcessor,omitempty"`
	// EnableSupportReasonUnknown: Support graceful restart helper mode when restart reason is unknown and unplanned.
	EnableSupportReasonUnknown *Multivalue `json:"enableSupportReasonUnknown,omitempty"`
	// LFlag: L-Flag: Local Flag. If set, then the value/index carried by the SID has local significance
	LFlag *Multivalue `json:"lFlag,omitempty"`
	// LoopbackAddress: The IPv6 loopback prefix
	LoopbackAddress *Multivalue `json:"loopbackAddress,omitempty"`
	// LsaRefreshTime: LSA Refresh time (s)
	LsaRefreshTime *Multivalue `json:"lsaRefreshTime,omitempty"`
	// LsaRetransmitTime: LSA Retransmit time(s)
	LsaRetransmitTime *Multivalue `json:"lsaRetransmitTime,omitempty"`
	// MFlag: M-Flag: Mapping Server Flag: If set, the SID was advertised bya Segment Routing Mapping Server
	MFlag *Multivalue `json:"mFlag,omitempty"`
	// MaxNumLsaPerSecond: Inter Flood LSUpdate burst gap (ms)
	MaxNumLsaPerSecond *Multivalue `json:"maxNumLsaPerSecond,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NpFlag: NP Flag: No-PHP Flag: If set, then the penultimate hop MUST NOT pop thePrefix-SID before delivering the packet to the node that advertised the Prefix-SID
	NpFlag *Multivalue `json:"npFlag,omitempty"`
	// SidIndexLabel: SID/Index/Label value associated with the IGP Prefix segment attached to the specific IPv6 prefix
	SidIndexLabel *Multivalue `json:"sidIndexLabel,omitempty"`
	// SrgbRangeCount: count of the configurable list of SRGB

	SrgbRangeCount *float32 `json:"srgbRangeCount,omitempty"`
	// VFlag: V-Flag: Value flag. If set, then the SID carries an absolute value label value
	VFlag                         *Multivalue                              `json:"vFlag,omitempty"`
	Ospfv3SRGBRangeSubObjectsList []*TopologyOspfv3SrgbRangeSubObjectsList `json:"ospfv3SRGBRangeSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv3Router) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv3Router) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv3Router) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv3Router) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Algorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "algorithm",
		isMultivalue: true,
	})
	n.BBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bBit",
		isMultivalue: true,
	})
	n.ConfigureSIDIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSIDIndexLabel",
		isMultivalue: true,
	})
	n.DisableAutoGenerateLinkLsa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableAutoGenerateLinkLsa",
		isMultivalue: true,
	})
	n.DisableAutoGenerateRouterLsa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableAutoGenerateRouterLsa",
		isMultivalue: true,
	})
	n.DiscardLearnedLsa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLearnedLsa",
		isMultivalue: true,
	})
	n.EBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eBit",
		isMultivalue: true,
	})
	n.EFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "eFlag",
		isMultivalue: true,
	})
	n.EnableGracefulRestartHelperMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestartHelperMode",
		isMultivalue: true,
	})
	n.EnableStrictLsaChecking.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableStrictLsaChecking",
		isMultivalue: true,
	})
	n.EnableSupportReasonSwReloadUpgrade.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSupportReasonSwReloadUpgrade",
		isMultivalue: true,
	})
	n.EnableSupportReasonSwRestart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSupportReasonSwRestart",
		isMultivalue: true,
	})
	n.EnableSupportReasonSwitchToRedundantControlProcessor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSupportReasonSwitchToRedundantControlProcessor",
		isMultivalue: true,
	})
	n.EnableSupportReasonUnknown.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableSupportReasonUnknown",
		isMultivalue: true,
	})
	n.LFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lFlag",
		isMultivalue: true,
	})
	n.LoopbackAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "loopbackAddress",
		isMultivalue: true,
	})
	n.LsaRefreshTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lsaRefreshTime",
		isMultivalue: true,
	})
	n.LsaRetransmitTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lsaRetransmitTime",
		isMultivalue: true,
	})
	n.MFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mFlag",
		isMultivalue: true,
	})
	n.MaxNumLsaPerSecond.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxNumLsaPerSecond",
		isMultivalue: true,
	})
	n.NpFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "npFlag",
		isMultivalue: true,
	})
	n.SidIndexLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidIndexLabel",
		isMultivalue: true,
	})
	n.VFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vFlag",
		isMultivalue: true,
	})
	for i, o := range n.Ospfv3SRGBRangeSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3SRGBRangeSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyOspfv3SimulatedTopologyConfig: OSPFv3 Simulated Topology specific configuration
type TopologyOspfv3SimulatedTopologyConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv3SimulatedTopologyConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv3SimulatedTopologyConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv3SimulatedTopologyConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv3SimulatedTopologyConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
}

// TopologyOspfv3SrgbRangeSubObjectsList: Ospfv3 SRGB Range Sub Objects
type TopologyOspfv3SrgbRangeSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SidCount: SID Count
	SidCount *Multivalue `json:"sidCount,omitempty"`
	// StartSIDLabel: Start SID/Label
	StartSIDLabel *Multivalue `json:"startSIDLabel,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOspfv3SrgbRangeSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOspfv3SrgbRangeSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOspfv3SrgbRangeSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOspfv3SrgbRangeSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SidCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidCount",
		isMultivalue: true,
	})
	n.StartSIDLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSIDLabel",
		isMultivalue: true,
	})
}

// TopologyOvsdbcontroller: TBD
type TopologyOvsdbcontroller struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ClearDumpDbFiles: TBD
	ClearDumpDbFiles *Multivalue `json:"clearDumpDbFiles,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ConnectionType: Connection should use TCP or TLS
	ConnectionType *Multivalue `json:"connectionType,omitempty"`
	// ControllerTcpPort: Specify the TCP port for the Controller
	ControllerTcpPort *Multivalue `json:"controllerTcpPort,omitempty"`
	// DirectoryName: Location of Directory in Client where the Certificate and Key Files are available
	DirectoryName *Multivalue `json:"directoryName,omitempty"`
	// DumpdbDirectoryName: Location of Directory in Client where the DumpDb Files are available
	DumpdbDirectoryName *Multivalue `json:"dumpdbDirectoryName,omitempty"`
	// EnableLogging: If true, Port debug logs will be recorded, Maximum recording will be upto 500 MB .

	EnableLogging *bool `json:"enableLogging,omitempty"`
	// EnableOvsdbServerIp: TBD
	EnableOvsdbServerIp *Multivalue `json:"enableOvsdbServerIp,omitempty"`
	// ErrorCode: Error Code
	ErrorCode *Multivalue `json:"errorCode,omitempty"`
	// ErrorDesc: Description of Error occured
	ErrorDesc *Multivalue `json:"errorDesc,omitempty"`
	// ErrorLogDirectoryName: Location of Directory in Client where the ErrorLog Files are available
	ErrorLogDirectoryName *Multivalue `json:"errorLogDirectoryName,omitempty"`
	// ErrorLogicalSwitchName: Error occured for this Logical Switch Name
	ErrorLogicalSwitchName *Multivalue `json:"errorLogicalSwitchName,omitempty"`
	// ErrorPhysicalSwitchName: Error occured for this Physical Switch Name
	ErrorPhysicalSwitchName *Multivalue `json:"errorPhysicalSwitchName,omitempty"`
	// ErrorTimeStamp: Time Stamp at which Last Error occurred
	ErrorTimeStamp *Multivalue `json:"errorTimeStamp,omitempty"`
	// FileCaCertificate: CA Certificate File
	FileCaCertificate *Multivalue `json:"fileCaCertificate,omitempty"`
	// FileCertificate: Certificate File
	FileCertificate *Multivalue `json:"fileCertificate,omitempty"`
	// FileHWGatewayCertificate: HW Gateway Certificate File
	FileHWGatewayCertificate *Multivalue `json:"fileHWGatewayCertificate,omitempty"`
	// FilePrivKey: Private Key File
	FilePrivKey *Multivalue `json:"filePrivKey,omitempty"`
	// HSCConfiguration: Each VTEP has its own Hardware Switch Controller.
	HSCConfiguration *Multivalue `json:"hSCConfiguration,omitempty"`
	// LatestDumpDbFileNames: Api to fetch latest DumpDb Files

	LatestDumpDbFileNames *string `json:"latestDumpDbFileNames,omitempty"`
	// LatestErrorFileNames: Api to fetch latest Error Files

	LatestErrorFileNames *string `json:"latestErrorFileNames,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OvsdbSchema: Database schema
	OvsdbSchema *Multivalue `json:"ovsdbSchema,omitempty"`
	// OvsdbServerIp: The IP address of the DUT or Ovs Server.
	OvsdbServerIp *Multivalue `json:"ovsdbServerIp,omitempty"`
	// PseudoConnectedTo: GUI-only connection

	PseudoConnectedTo *string `json:"pseudoConnectedTo,omitempty"`
	// PseudoConnectedToRefs: Track refs for PseudoConnectedTo.
	PseudoConnectedToRefs []Href `json:"-"`
	// PseudoConnectedToBfd: GUI-only connection

	PseudoConnectedToBfd *string `json:"pseudoConnectedToBfd,omitempty"`
	// PseudoConnectedToBfdRefs: Track refs for PseudoConnectedToBfd.
	PseudoConnectedToBfdRefs []Href `json:"-"`
	// PseudoConnectedToVxlanReplicator: GUI-only connection

	PseudoConnectedToVxlanReplicator *string `json:"pseudoConnectedToVxlanReplicator,omitempty"`
	// PseudoConnectedToVxlanReplicatorRefs: Track refs for PseudoConnectedToVxlanReplicator.
	PseudoConnectedToVxlanReplicatorRefs []Href `json:"-"`
	// ServerAddDeleteConnectionError: API to retrieve error occured while Adding/ Deleting Server

	ServerAddDeleteConnectionError *string `json:"serverAddDeleteConnectionError,omitempty"`
	// ServerConnectionIp: The IP address of the DUT or Ovs Server which needs to be Added/Deleted.
	ServerConnectionIp *Multivalue `json:"serverConnectionIp,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TableNames: TBD
	TableNames *Multivalue `json:"tableNames,omitempty"`
	// TimeOut: Transact request Time Out in seconds. For scale scenarios increase this Timeout value.

	TimeOut *float32 `json:"timeOut,omitempty"`
	// VerifyHWGatewayCertificate: Verify HW Gateway Certificate
	VerifyHWGatewayCertificate *Multivalue `json:"verifyHWGatewayCertificate,omitempty"`
	// VerifyPeerCertificate: Verify Peer Certificate
	VerifyPeerCertificate *Multivalue `json:"verifyPeerCertificate,omitempty"`
	// Vxlan: TBD

	Vxlan *string `json:"vxlan,omitempty"`
	// VxlanRefs: Track refs for Vxlan.
	VxlanRefs []Href `json:"-"`
	// VxlanReplicator: TBD

	VxlanReplicator *string `json:"vxlanReplicator,omitempty"`
	// VxlanReplicatorRefs: Track refs for VxlanReplicator.
	VxlanReplicatorRefs []Href `json:"-"`

	ClusterData *TopologyClusterData `json:"clusterData,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOvsdbcontroller) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOvsdbcontroller) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOvsdbcontroller) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOvsdbcontroller) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ClearDumpDbFiles.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clearDumpDbFiles",
		isMultivalue: true,
	})
	n.ConnectionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "connectionType",
		isMultivalue: true,
	})
	n.ControllerTcpPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "controllerTcpPort",
		isMultivalue: true,
	})
	n.DirectoryName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "directoryName",
		isMultivalue: true,
	})
	n.DumpdbDirectoryName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dumpdbDirectoryName",
		isMultivalue: true,
	})
	n.EnableOvsdbServerIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableOvsdbServerIp",
		isMultivalue: true,
	})
	n.ErrorCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorCode",
		isMultivalue: true,
	})
	n.ErrorDesc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorDesc",
		isMultivalue: true,
	})
	n.ErrorLogDirectoryName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorLogDirectoryName",
		isMultivalue: true,
	})
	n.ErrorLogicalSwitchName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorLogicalSwitchName",
		isMultivalue: true,
	})
	n.ErrorPhysicalSwitchName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorPhysicalSwitchName",
		isMultivalue: true,
	})
	n.ErrorTimeStamp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorTimeStamp",
		isMultivalue: true,
	})
	n.FileCaCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCaCertificate",
		isMultivalue: true,
	})
	n.FileCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCertificate",
		isMultivalue: true,
	})
	n.FileHWGatewayCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileHWGatewayCertificate",
		isMultivalue: true,
	})
	n.FilePrivKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filePrivKey",
		isMultivalue: true,
	})
	n.HSCConfiguration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hSCConfiguration",
		isMultivalue: true,
	})
	n.OvsdbSchema.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ovsdbSchema",
		isMultivalue: true,
	})
	n.OvsdbServerIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ovsdbServerIp",
		isMultivalue: true,
	})
	n.ServerConnectionIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverConnectionIp",
		isMultivalue: true,
	})
	n.TableNames.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tableNames",
		isMultivalue: true,
	})
	n.VerifyHWGatewayCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "verifyHWGatewayCertificate",
		isMultivalue: true,
	})
	n.VerifyPeerCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "verifyPeerCertificate",
		isMultivalue: true,
	})
	n.ClusterData.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "clusterData",
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
}

// TopologyOvsdbserver: TBD
type TopologyOvsdbserver struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// ConnectionType: Connection should use TCP or TLS
	ConnectionType *Multivalue `json:"connectionType,omitempty"`
	// DirectoryName: Location of Directory in Client where the Certificate and Key Files are available
	DirectoryName *Multivalue `json:"directoryName,omitempty"`
	// FileCaCertificate: CA Certificate File
	FileCaCertificate *Multivalue `json:"fileCaCertificate,omitempty"`
	// FileCertificate: Certificate File
	FileCertificate *Multivalue `json:"fileCertificate,omitempty"`
	// FilePrivKey: Private Key File
	FilePrivKey *Multivalue `json:"filePrivKey,omitempty"`
	// ManagerCount: Number of Managers the OVSDB Server will initiate connections to

	ManagerCount *float32 `json:"managerCount,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OvsdbSchema: Database schema
	OvsdbSchema *Multivalue `json:"ovsdbSchema,omitempty"`
	// PseudoConnectedTo: GUI-only connection

	PseudoConnectedTo *string `json:"pseudoConnectedTo,omitempty"`
	// PseudoConnectedToRefs: Track refs for PseudoConnectedTo.
	PseudoConnectedToRefs []Href `json:"-"`
	// ServerTcpPort: Specify the TCP port for the Server
	ServerTcpPort *Multivalue `json:"serverTcpPort,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// Vxlan: TBD

	Vxlan *string `json:"vxlan,omitempty"`
	// VxlanRefs: Track refs for Vxlan.
	VxlanRefs []Href `json:"-"`

	Manager *TopologyManager `json:"manager,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyOvsdbserver) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyOvsdbserver) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyOvsdbserver) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyOvsdbserver) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ConnectionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "connectionType",
		isMultivalue: true,
	})
	n.DirectoryName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "directoryName",
		isMultivalue: true,
	})
	n.FileCaCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCaCertificate",
		isMultivalue: true,
	})
	n.FileCertificate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fileCertificate",
		isMultivalue: true,
	})
	n.FilePrivKey.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "filePrivKey",
		isMultivalue: true,
	})
	n.OvsdbSchema.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ovsdbSchema",
		isMultivalue: true,
	})
	n.ServerTcpPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverTcpPort",
		isMultivalue: true,
	})
	n.Manager.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "manager",
	})
}

// TopologyPacketInList: Openflow Switch PacketIn Configuration
type TopologyPacketInList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AuxiliaryId: The identifier for auxiliary connections.
	AuxiliaryId *Multivalue `json:"auxiliaryId,omitempty"`
	// FlowTable: If selected, the Switch looks up for each PacketIn configured in the Flow Table.
	FlowTable *Multivalue `json:"flowTable,omitempty"`
	// InPort: The Switch Port on which, this Packet has come.
	InPort *Multivalue `json:"inPort,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PacketInName: The description of the packet-in.
	PacketInName *Multivalue `json:"packetInName,omitempty"`
	// PhysicalInPort: The physical In port value for this PacketIn range. It is the underlying physical port when packet is received on a logical port.
	PhysicalInPort *Multivalue `json:"physicalInPort,omitempty"`
	// SendPacketIn: If selected, the Switch starts sending PacketIn messages when the session comes up.
	SendPacketIn *Multivalue `json:"sendPacketIn,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPacketInList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPacketInList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPacketInList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPacketInList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AuxiliaryId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxiliaryId",
		isMultivalue: true,
	})
	n.FlowTable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flowTable",
		isMultivalue: true,
	})
	n.InPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "inPort",
		isMultivalue: true,
	})
	n.PacketInName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "packetInName",
		isMultivalue: true,
	})
	n.PhysicalInPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "physicalInPort",
		isMultivalue: true,
	})
	n.SendPacketIn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendPacketIn",
		isMultivalue: true,
	})
}

// TopologyPbbEVpnParameter: PBB-EVPN
type TopologyPbbEVpnParameter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// BMac: Broadcast MAC addresses of the devices
	BMac *Multivalue `json:"bMac,omitempty"`
	// UsePbbEVpnParameters: Flag to determine whether optional PBB EVPN parameters are provided.

	UsePbbEVpnParameters *bool `json:"usePbbEVpnParameters,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPbbEVpnParameter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPbbEVpnParameter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPbbEVpnParameter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPbbEVpnParameter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bMac",
		isMultivalue: true,
	})
}

// TopologyPcReplyLspParameters: PCReply LSP Parameters
type TopologyPcReplyLspParameters struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Bandwidth: Bandwidth (bits/sec)
	Bandwidth *Multivalue `json:"bandwidth,omitempty"`
	// BiDirectional: Bi-directional
	BiDirectional *Multivalue `json:"biDirectional,omitempty"`
	// BindingType: Indicates the type of binding included in the TLV. Types are as follows: 20bit MPLS Label 32bit MPLS Label. SRv6 SID Default value is 20bit MPLS Label.
	BindingType *Multivalue `json:"bindingType,omitempty"`
	// Bos: This bit is set to True for the last entry in the label stack i.e., for the bottom of the stack, and False for all other label stack entries. This control will be editable only if Binding Type is MPLS Label 32bit.
	Bos *Multivalue `json:"bos,omitempty"`
	// EnableCFlag: C Flag
	EnableCFlag *Multivalue `json:"enableCFlag,omitempty"`
	// EnableEro: Include ERO
	EnableEro *Multivalue `json:"enableEro,omitempty"`
	// EnableLoose: Loose
	EnableLoose *Multivalue `json:"enableLoose,omitempty"`
	// EnableXro: Include XRO
	EnableXro *Multivalue `json:"enableXro,omitempty"`
	// ExcludeAny: Exclude Any
	ExcludeAny *Multivalue `json:"excludeAny,omitempty"`
	// FailBit: Fail Bit
	FailBit *Multivalue `json:"failBit,omitempty"`
	// HoldingPriority: Holding Priority
	HoldingPriority *Multivalue `json:"holdingPriority,omitempty"`
	// IncludeAll: Include All
	IncludeAll *Multivalue `json:"includeAll,omitempty"`
	// IncludeAny: Include Any
	IncludeAny *Multivalue `json:"includeAny,omitempty"`
	// IncludeBandwidth: Include Bandwidth
	IncludeBandwidth *Multivalue `json:"includeBandwidth,omitempty"`
	// IncludeConfiguredERO: If this is enabled, entire ERO will go out in packet even if there is Binding SID, which means no SR-ERO/SRv6-ERO validation will be done.
	IncludeConfiguredERO *Multivalue `json:"includeConfiguredERO,omitempty"`
	// IncludeLsp: Include LSP
	IncludeLsp *Multivalue `json:"includeLsp,omitempty"`
	// IncludeLspa: Include LSPA
	IncludeLspa *Multivalue `json:"includeLspa,omitempty"`
	// IncludeMetric: Include Metric
	IncludeMetric *Multivalue `json:"includeMetric,omitempty"`
	// IncludeRp: Include RP
	IncludeRp *Multivalue `json:"includeRp,omitempty"`
	// IncludeSymbolicPathNameTlv: Indicates if Symbolic-Path-Name TLV is to be included in PCInitiate message.
	IncludeSymbolicPathNameTlv *Multivalue `json:"includeSymbolicPathNameTlv,omitempty"`
	// IncludeTEPathBindingTLV: Indicates if TE-PATH-BINDING TLV is to be included in PCInitiate message.
	IncludeTEPathBindingTLV *Multivalue `json:"includeTEPathBindingTLV,omitempty"`
	// LocalProtection: Local Protection
	LocalProtection *Multivalue `json:"localProtection,omitempty"`
	// MplsLabel: This control will be editable if the Binding Type is set to either 20bit or 32bit MPLS-Label. This field will take the 20bit value of the MPLS-Label
	MplsLabel *Multivalue `json:"mplsLabel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NatureOfIssue: Nature Of Issue
	NatureOfIssue *Multivalue `json:"natureOfIssue,omitempty"`
	// NumberOfEroSubObjects: Number of ERO Sub Objects

	NumberOfEroSubObjects *float32 `json:"numberOfEroSubObjects,omitempty"`
	// NumberOfMetricSubObject: Number of Metric

	NumberOfMetricSubObject *float32 `json:"numberOfMetricSubObject,omitempty"`
	// NumberOfXroSubObjects: Number of XRO Sub Objects

	NumberOfXroSubObjects *float32 `json:"numberOfXroSubObjects,omitempty"`
	// PlspId: An identifier for the LSP. A PCC creates a unique PLSP-ID for each LSP that is constant for the lifetime of a PCEP session. The PCC will advertise the same PLSP-ID on all PCEP sessions it maintains at a given time.
	PlspId *Multivalue `json:"plspId,omitempty"`
	// PriorityValue: Priority
	PriorityValue *Multivalue `json:"priorityValue,omitempty"`
	// ProcessType: Indicates how the XRO is responded in the Path Request Response.
	ProcessType *Multivalue `json:"processType,omitempty"`
	// ReflectLSP: Reflect LSP
	ReflectLSP *Multivalue `json:"reflectLSP,omitempty"`
	// ReflectRP: Reflect RP
	ReflectRP *Multivalue `json:"reflectRP,omitempty"`
	// ReflectedObjectNoPath: Reflected Object
	ReflectedObjectNoPath *Multivalue `json:"reflectedObjectNoPath,omitempty"`
	// RequestId: Request ID
	RequestId *Multivalue `json:"requestId,omitempty"`
	// ResponseOptions: Reply Options
	ResponseOptions *Multivalue `json:"responseOptions,omitempty"`
	// ResponsePathType: Indicates which type of LSP will be responsed in the Path Request Response.
	ResponsePathType *Multivalue `json:"responsePathType,omitempty"`
	// SendEmptyTLV: If enabled all fields after Binding Type will be grayed out.
	SendEmptyTLV *Multivalue `json:"sendEmptyTLV,omitempty"`
	// SetupPriority: Setup Priority
	SetupPriority *Multivalue `json:"setupPriority,omitempty"`
	// Srv6SID: SRv6 SID with a format of a 16 byte IPv6 address.
	Srv6SID *Multivalue `json:"srv6SID,omitempty"`
	// SymbolicPathName: Each LSP (path) must have a symbolic name that is unique in the PCC. It must remain constant throughout a path's lifetime, which may span across multiple consecutive PCEP sessions and/or PCC restarts.
	SymbolicPathName *Multivalue `json:"symbolicPathName,omitempty"`
	// Tc: This field is used to carry traffic class information. This control will be editable only if Binding Type is MPLS Label 32bit.
	Tc *Multivalue `json:"tc,omitempty"`
	// Ttl: This field is used to encode a time-to-live value. This control will be editable only if Binding Type is MPLS Label 32bit.
	Ttl                      *Multivalue                         `json:"ttl,omitempty"`
	PceXroSubObjectsList     []*TopologyPceXroSubObjectsList     `json:"pceXroSubObjectsList"`
	PcepEroSubObjectsList    []*TopologyPcepEroSubObjectsList    `json:"pcepEroSubObjectsList"`
	PcepMetricSubObjectsList []*TopologyPcepMetricSubObjectsList `json:"pcepMetricSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcReplyLspParameters) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcReplyLspParameters) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcReplyLspParameters) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcReplyLspParameters) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Bandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidth",
		isMultivalue: true,
	})
	n.BiDirectional.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "biDirectional",
		isMultivalue: true,
	})
	n.BindingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingType",
		isMultivalue: true,
	})
	n.Bos.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bos",
		isMultivalue: true,
	})
	n.EnableCFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCFlag",
		isMultivalue: true,
	})
	n.EnableEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEro",
		isMultivalue: true,
	})
	n.EnableLoose.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLoose",
		isMultivalue: true,
	})
	n.EnableXro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableXro",
		isMultivalue: true,
	})
	n.ExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAny",
		isMultivalue: true,
	})
	n.FailBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "failBit",
		isMultivalue: true,
	})
	n.HoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdingPriority",
		isMultivalue: true,
	})
	n.IncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAll",
		isMultivalue: true,
	})
	n.IncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAny",
		isMultivalue: true,
	})
	n.IncludeBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeBandwidth",
		isMultivalue: true,
	})
	n.IncludeConfiguredERO.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeConfiguredERO",
		isMultivalue: true,
	})
	n.IncludeLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLsp",
		isMultivalue: true,
	})
	n.IncludeLspa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLspa",
		isMultivalue: true,
	})
	n.IncludeMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMetric",
		isMultivalue: true,
	})
	n.IncludeRp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeRp",
		isMultivalue: true,
	})
	n.IncludeSymbolicPathNameTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSymbolicPathNameTlv",
		isMultivalue: true,
	})
	n.IncludeTEPathBindingTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTEPathBindingTLV",
		isMultivalue: true,
	})
	n.LocalProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localProtection",
		isMultivalue: true,
	})
	n.MplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabel",
		isMultivalue: true,
	})
	n.NatureOfIssue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "natureOfIssue",
		isMultivalue: true,
	})
	n.PlspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "plspId",
		isMultivalue: true,
	})
	n.PriorityValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priorityValue",
		isMultivalue: true,
	})
	n.ProcessType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "processType",
		isMultivalue: true,
	})
	n.ReflectLSP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reflectLSP",
		isMultivalue: true,
	})
	n.ReflectRP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reflectRP",
		isMultivalue: true,
	})
	n.ReflectedObjectNoPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reflectedObjectNoPath",
		isMultivalue: true,
	})
	n.RequestId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requestId",
		isMultivalue: true,
	})
	n.ResponseOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "responseOptions",
		isMultivalue: true,
	})
	n.ResponsePathType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "responsePathType",
		isMultivalue: true,
	})
	n.SendEmptyTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendEmptyTLV",
		isMultivalue: true,
	})
	n.SetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setupPriority",
		isMultivalue: true,
	})
	n.Srv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SID",
		isMultivalue: true,
	})
	n.SymbolicPathName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "symbolicPathName",
		isMultivalue: true,
	})
	n.Tc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tc",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
	for i, o := range n.PceXroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pceXroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PcepEroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepEroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PcepMetricSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepMetricSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPcRequestMatchCriteria: PCRequest Match Criteria
type TopologyPcRequestMatchCriteria struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// DestIpv4Address: Destination IPv4 Address
	DestIpv4Address *Multivalue `json:"destIpv4Address,omitempty"`
	// DestIpv6Address: Destination IPv6 Address
	DestIpv6Address *Multivalue `json:"destIpv6Address,omitempty"`
	// IpVersion: IP Version
	IpVersion *Multivalue `json:"ipVersion,omitempty"`
	// IroType: Match IRO Option
	IroType *Multivalue `json:"iroType,omitempty"`
	// MatchEndPoints: Indicates Whether response parameters will be matched based on endpoints in the PCReq messaged received from PCC.
	MatchEndPoints *Multivalue `json:"matchEndPoints,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcIpv4Address: Source IPv4 Address
	SrcIpv4Address *Multivalue `json:"srcIpv4Address,omitempty"`
	// SrcIpv6Address: Source IPv6 Address
	SrcIpv6Address *Multivalue `json:"srcIpv6Address,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcRequestMatchCriteria) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcRequestMatchCriteria) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcRequestMatchCriteria) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcRequestMatchCriteria) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DestIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destIpv4Address",
		isMultivalue: true,
	})
	n.DestIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destIpv6Address",
		isMultivalue: true,
	})
	n.IpVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipVersion",
		isMultivalue: true,
	})
	n.IroType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "iroType",
		isMultivalue: true,
	})
	n.MatchEndPoints.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "matchEndPoints",
		isMultivalue: true,
	})
	n.SrcIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcIpv4Address",
		isMultivalue: true,
	})
	n.SrcIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcIpv6Address",
		isMultivalue: true,
	})
}

// TopologyPcc: Pcep Session (Device) level Configuration
type TopologyPcc struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ActivePreEstablishedLsps: TBD

	ActivePreEstablishedLsps *float32 `json:"active_pre_established_lsps,omitempty"`
	// Authentication: The type of cryptographic authentication to be used on this link interface
	Authentication *Multivalue `json:"authentication,omitempty"`
	// BurstInterval: Interval in milisecond in which desired rate of messages needs to be maintained.
	BurstInterval *Multivalue `json:"burstInterval,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DeadInterval: This is the time interval, after the expiration of which, a PCEP peer declares the session down if no PCEP message has been received.
	DeadInterval *Multivalue `json:"deadInterval,omitempty"`
	// ErrorValue: To configure the type of error. Editable only if Return Instantiation Error is enabled.
	ErrorValue *Multivalue `json:"errorValue,omitempty"`
	// ExpectedInitiatedLspsForTraffic: Based on the value in this control the number of Expected Initiated LSPs for Traffic can be configured. This is used for traffic only.

	ExpectedInitiatedLspsForTraffic *float32 `json:"expectedInitiatedLspsForTraffic,omitempty"`
	// KeepaliveInterval: Frequency/Time Interval of sending PCEP messages to keep the session active.
	KeepaliveInterval *Multivalue `json:"keepaliveInterval,omitempty"`
	// LspInstantiationCapability: If Stateful PCE Capability is enabled then this control should be activated to set the LSP Instantiation capability in the Stateful PCE Capability TLV.
	LspInstantiationCapability *Multivalue `json:"lspInstantiationCapability,omitempty"`
	// LspUpdateCapability: If Stateful PCE Capability is enabled then this control should be activated to set the update capability in the Stateful PCE Capability TLV.
	LspUpdateCapability *Multivalue `json:"lspUpdateCapability,omitempty"`
	// MD5Key: A value to be used as the secret MD5 Key.
	MD5Key *Multivalue `json:"mD5Key,omitempty"`
	// MaxLspPerPcReq: Max LSPs Per PCReq
	MaxLspPerPcReq *Multivalue `json:"maxLspPerPcReq,omitempty"`
	// MaxLspsPerPcRpt: Controls the maximum LSP information that can be present in a Path report message when the session is stateful session.
	MaxLspsPerPcRpt *Multivalue `json:"maxLspsPerPcRpt,omitempty"`
	// MaxReconnectInterval: This is the maximum time interval, by which recoonect timer will be increased upto.
	MaxReconnectInterval *Multivalue `json:"maxReconnectInterval,omitempty"`
	// MaxRequestedLspPerInterval: Maximum number of LSP computation request messages can be sent per interval.
	MaxRequestedLspPerInterval *Multivalue `json:"maxRequestedLspPerInterval,omitempty"`
	// MaxSyncLspPerInterval: Maximum number of LSP sync can be sent per interval.
	MaxSyncLspPerInterval *Multivalue `json:"maxSyncLspPerInterval,omitempty"`
	// MaximumSidDepth: Maximum SID Depth field (MSD) specifies the maximum number of SIDs that a PCC is capable of imposing on a packet. Editable only if SR PCE Capability is enabled.
	MaximumSidDepth *Multivalue `json:"maximumSidDepth,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfBackupPCEs: Number of Backup PCEs

	NumberOfBackupPCEs *float32 `json:"numberOfBackupPCEs,omitempty"`
	// PccPpagTLVType: PPAG TLV Type specifies PCC's capability of interpreting this type of PPAG TLV
	PccPpagTLVType *Multivalue `json:"pccPpagTLVType,omitempty"`
	// PccTEPathBindingTLVType: PCC TE-PATH-BINDING TLV Type is a TLV that carries MPLS label binding or SRv6 Binding SID. This is only configurable if the Binding SID Draft Version is set to ietf-pce-binding-label-sid. The minimum value is 0. The maximum value is 65535. The default value is 31.
	PccTEPathBindingTLVType *Multivalue `json:"pccTEPathBindingTLVType,omitempty"`
	// PceIpv4Address: IPv4 address of the PCE. This column is greyed out in case of PCCv6.
	PceIpv4Address *Multivalue `json:"pceIpv4Address,omitempty"`
	// PreEstablishedSrLspsPerPcc: Pre-Established SR LSPs per PCC

	PreEstablishedSrLspsPerPcc *float32 `json:"preEstablishedSrLspsPerPcc,omitempty"`
	// RateControl: The rate control is an optional feature associated with PCE initiated LSP.
	RateControl *Multivalue `json:"rateControl,omitempty"`
	// ReconnectInterval: This is the time interval, after the expiration of which, retry to establish the broken session by PCC happen.
	ReconnectInterval *Multivalue `json:"reconnectInterval,omitempty"`
	// RequestedLspsPerPcc: Requested LSPs per PCC

	RequestedLspsPerPcc *float32 `json:"requestedLspsPerPcc,omitempty"`
	// ReturnInstantiationError: If enabled, then PCC will reply PCErr upon receiving PCInitiate message.
	ReturnInstantiationError *Multivalue `json:"returnInstantiationError,omitempty"`
	// SrPceCapability: The SR PCE Capability TLV is an optional TLV associated with the OPEN Object to exchange SR capability of PCEP speakers.
	SrPceCapability *Multivalue `json:"srPceCapability,omitempty"`
	// Srv6MaxSL: This field specifies the maximum value of the Segments Left (SL) in the SRH.
	Srv6MaxSL *Multivalue `json:"srv6MaxSL,omitempty"`
	// Srv6PceCapability: The SRv6 PCE Capability TLV is a sub-TLV that comes under PATH-SETUP-TYPE-CAPABILITY TLV if PST List contains SRv6 PST type. This TLV is associated with the OPEN Object to exchange SRv6 capability of PCEP speakers.
	Srv6PceCapability *Multivalue `json:"srv6PceCapability,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StateTimeoutInterval: This is the time interval, after the expiration of which, LSP is cleaned up by PCC.
	StateTimeoutInterval *Multivalue `json:"stateTimeoutInterval,omitempty"`
	// TcpPort: PCEP operates over TCP using a registered TCP port (default - 4189). This allows the requirements of reliable messaging and flow control to bemet without further protocol work. This control can be configured when user does not want to use the default one.
	TcpPort *Multivalue `json:"tcpPort,omitempty"`

	ExpectedInitiatedLspList *TopologyExpectedInitiatedLspList `json:"expectedInitiatedLspList,omitempty"`
	LearnedInfo              []*TopologyLearnedInfo            `json:"learnedInfo"`

	PccLearnedLspDb *TopologyPccLearnedLspDb `json:"pccLearnedLspDb,omitempty"`

	PcepBackupPCEs *TopologyPcepBackupPcEs `json:"pcepBackupPCEs,omitempty"`

	PreEstablishedSrLsps *TopologyPreEstablishedSrLsps `json:"preEstablishedSrLsps,omitempty"`

	RequestedLsps *TopologyRequestedLsps `json:"requestedLsps,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcc) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcc) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcc) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcc) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.BurstInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "burstInterval",
		isMultivalue: true,
	})
	n.DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "deadInterval",
		isMultivalue: true,
	})
	n.ErrorValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "errorValue",
		isMultivalue: true,
	})
	n.KeepaliveInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepaliveInterval",
		isMultivalue: true,
	})
	n.LspInstantiationCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspInstantiationCapability",
		isMultivalue: true,
	})
	n.LspUpdateCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspUpdateCapability",
		isMultivalue: true,
	})
	n.MD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mD5Key",
		isMultivalue: true,
	})
	n.MaxLspPerPcReq.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLspPerPcReq",
		isMultivalue: true,
	})
	n.MaxLspsPerPcRpt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLspsPerPcRpt",
		isMultivalue: true,
	})
	n.MaxReconnectInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxReconnectInterval",
		isMultivalue: true,
	})
	n.MaxRequestedLspPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxRequestedLspPerInterval",
		isMultivalue: true,
	})
	n.MaxSyncLspPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxSyncLspPerInterval",
		isMultivalue: true,
	})
	n.MaximumSidDepth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maximumSidDepth",
		isMultivalue: true,
	})
	n.PccPpagTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pccPpagTLVType",
		isMultivalue: true,
	})
	n.PccTEPathBindingTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pccTEPathBindingTLVType",
		isMultivalue: true,
	})
	n.PceIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceIpv4Address",
		isMultivalue: true,
	})
	n.RateControl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rateControl",
		isMultivalue: true,
	})
	n.ReconnectInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reconnectInterval",
		isMultivalue: true,
	})
	n.ReturnInstantiationError.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "returnInstantiationError",
		isMultivalue: true,
	})
	n.SrPceCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srPceCapability",
		isMultivalue: true,
	})
	n.Srv6MaxSL.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6MaxSL",
		isMultivalue: true,
	})
	n.Srv6PceCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6PceCapability",
		isMultivalue: true,
	})
	n.StateTimeoutInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stateTimeoutInterval",
		isMultivalue: true,
	})
	n.TcpPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpPort",
		isMultivalue: true,
	})
	n.ExpectedInitiatedLspList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "expectedInitiatedLspList",
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.PccLearnedLspDb.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pccLearnedLspDb",
	})
	n.PcepBackupPCEs.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pcepBackupPCEs",
	})
	n.PreEstablishedSrLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "preEstablishedSrLsps",
	})
	n.RequestedLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "requestedLsps",
	})
}

// TopologyPccGroup: Pce Group (Device) level Configuration
type TopologyPccGroup struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Authentication: The type of cryptographic authentication to be used on this link interface
	Authentication *Multivalue `json:"authentication,omitempty"`
	// BurstInterval: Interval in milisecond in which desired rate of messages needs to be maintained.
	BurstInterval *Multivalue `json:"burstInterval,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DeadInterval: This is the time interval, after the expiration of which, a PCEP peer declares the session down if no PCEP message has been received.
	DeadInterval *Multivalue `json:"deadInterval,omitempty"`
	// KeepaliveInterval: Frequency/Time Interval of sending PCEP messages to keep the session active.
	KeepaliveInterval *Multivalue `json:"keepaliveInterval,omitempty"`
	// LspInstantiationCapability: If Stateful PCE Capability is enabled then this control should be activated to set the LSP Instantiation capability in the Stateful PCE Capability TLV.
	LspInstantiationCapability *Multivalue `json:"lspInstantiationCapability,omitempty"`
	// LspUpdateCapability: If the Stateful PCE Capability is enabled then this control should be activated to set the update capability in the Stateful PCE Capability TLV.
	LspUpdateCapability *Multivalue `json:"lspUpdateCapability,omitempty"`
	// MD5Key: A value to be used as the secret MD5 Key.
	MD5Key *Multivalue `json:"mD5Key,omitempty"`
	// MaxInitiatedLspPerInterval: Maximum number of messages can be sent per interval.
	MaxInitiatedLspPerInterval *Multivalue `json:"maxInitiatedLspPerInterval,omitempty"`
	// MaxLspPerPcUpdate: Controls the maximum number of LSPs that can be present in a PcUpdate message.
	MaxLspPerPcUpdate *Multivalue `json:"maxLspPerPcUpdate,omitempty"`
	// MaxLspsPerPcInitiate: Controls the maximum number of LSPs that can be present in a PCInitiate message.
	MaxLspsPerPcInitiate *Multivalue `json:"maxLspsPerPcInitiate,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PcReplyLspsPerPcc: Controls the maximum number of PCE LSPs that can be send as PATH Response.

	PcReplyLspsPerPcc *float32 `json:"pcReplyLspsPerPcc,omitempty"`
	// PccIpv4Address: IPv4 address of the PCC. This column is greyed out in case of PCEv6.
	PccIpv4Address *Multivalue `json:"pccIpv4Address,omitempty"`
	// PceInitiatedLspsPerPcc: Controls the maximum number of PCE LSPs that can be Initiated per PCC.

	PceInitiatedLspsPerPcc *float32 `json:"pceInitiatedLspsPerPcc,omitempty"`
	// PcePpagTLVType: PPAG TLV Type specifies PCE's capability of interpreting this type of PPAG TLV
	PcePpagTLVType *Multivalue `json:"pcePpagTLVType,omitempty"`
	// PceTEPathBindingTLVType: PCE TE-PATH-BINDING TLV Type is a TLV that carries MPLS label binding or SRv6 Binding SID. This is only configurable if the Binding SID Draft Version is set to ietf-pce-binding-label-sid. The minimum value is 0. The maximum value is 65535. The default value is 31.
	PceTEPathBindingTLVType *Multivalue `json:"pceTEPathBindingTLVType,omitempty"`
	// RateControl: The rate control is an optional feature associated with PCE initiated LSP.
	RateControl *Multivalue `json:"rateControl,omitempty"`
	// SrPceCapability: The SR PCE Capability TLV is an optional TLV associated with the OPEN Object to exchange SR capability of PCEP speakers.
	SrPceCapability *Multivalue `json:"srPceCapability,omitempty"`
	// Srv6PceCapability: The SRv6 PCE Capability TLV is a sub-TLV that comes under PATH-SETUP-TYPE-CAPABILITY TLV if PST List contains SRv6 PST type. This TLV is associated with the OPEN Object to exchange SRv6 capability of PCEP speakers.
	Srv6PceCapability *Multivalue `json:"srv6PceCapability,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StatefulPceCapability: If enabled, the server will work like a Stateful PCE else like a stateless PCE.
	StatefulPceCapability *Multivalue                  `json:"statefulPceCapability,omitempty"`
	LearnedInfo           []*TopologyLearnedInfo       `json:"learnedInfo"`
	LearnedInfoUpdate     []*TopologyLearnedInfoUpdate `json:"learnedInfoUpdate"`

	PcReplyLspParameters *TopologyPcReplyLspParameters `json:"pcReplyLspParameters,omitempty"`

	PcRequestMatchCriteria *TopologyPcRequestMatchCriteria `json:"pcRequestMatchCriteria,omitempty"`

	PceInitiateLSPParameters *TopologyPceInitiateLspParameters `json:"pceInitiateLSPParameters,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPccGroup) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPccGroup) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPccGroup) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPccGroup) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Authentication.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authentication",
		isMultivalue: true,
	})
	n.BurstInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "burstInterval",
		isMultivalue: true,
	})
	n.DeadInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "deadInterval",
		isMultivalue: true,
	})
	n.KeepaliveInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "keepaliveInterval",
		isMultivalue: true,
	})
	n.LspInstantiationCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspInstantiationCapability",
		isMultivalue: true,
	})
	n.LspUpdateCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspUpdateCapability",
		isMultivalue: true,
	})
	n.MD5Key.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mD5Key",
		isMultivalue: true,
	})
	n.MaxInitiatedLspPerInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxInitiatedLspPerInterval",
		isMultivalue: true,
	})
	n.MaxLspPerPcUpdate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLspPerPcUpdate",
		isMultivalue: true,
	})
	n.MaxLspsPerPcInitiate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxLspsPerPcInitiate",
		isMultivalue: true,
	})
	n.PccIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pccIpv4Address",
		isMultivalue: true,
	})
	n.PcePpagTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pcePpagTLVType",
		isMultivalue: true,
	})
	n.PceTEPathBindingTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceTEPathBindingTLVType",
		isMultivalue: true,
	})
	n.RateControl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rateControl",
		isMultivalue: true,
	})
	n.SrPceCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srPceCapability",
		isMultivalue: true,
	})
	n.Srv6PceCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6PceCapability",
		isMultivalue: true,
	})
	n.StatefulPceCapability.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "statefulPceCapability",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfoUpdate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfoUpdate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.PcReplyLspParameters.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pcReplyLspParameters",
	})
	n.PcRequestMatchCriteria.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pcRequestMatchCriteria",
	})
	n.PceInitiateLSPParameters.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pceInitiateLSPParameters",
	})
}

// TopologyPccLearnedLspDb: PCC Learned LSPs Information Database
type TopologyPccLearnedLspDb struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`

	DestIpv4Address *TopologyDestIpv4Address `json:"destIpv4Address,omitempty"`

	DestIpv6Address *TopologyDestIpv6Address `json:"destIpv6Address,omitempty"`

	ErrorInfo *TopologyErrorInfo `json:"errorInfo,omitempty"`

	IpVersion *TopologyIpVersion `json:"ipVersion,omitempty"`

	Ipv4NodeId *TopologyIpv4NodeId `json:"ipv4NodeId,omitempty"`

	Ipv6NodeId *TopologyIpv6NodeId `json:"ipv6NodeId,omitempty"`

	LearnedLspIndex *TopologyLearnedLspIndex `json:"learnedLspIndex,omitempty"`

	LearnedMsgDbType *TopologyLearnedMsgDbType `json:"learnedMsgDbType,omitempty"`

	LocalIntefaceId *TopologyLocalIntefaceId `json:"localIntefaceId,omitempty"`

	LocalIpv4Address *TopologyLocalIpv4Address `json:"localIpv4Address,omitempty"`

	LocalIpv6Address *TopologyLocalIpv6Address `json:"localIpv6Address,omitempty"`

	LocalNodeId *TopologyLocalNodeId `json:"localNodeId,omitempty"`

	MplsLabel *TopologyMplsLabel `json:"mplsLabel,omitempty"`

	NaiType *TopologyNaiType `json:"naiType,omitempty"`

	PlspId *TopologyPlspId `json:"plspId,omitempty"`

	RemoteInterfaceId *TopologyRemoteInterfaceId `json:"remoteInterfaceId,omitempty"`

	RemoteIpv4Address *TopologyRemoteIpv4Address `json:"remoteIpv4Address,omitempty"`

	RemoteIpv6Address *TopologyRemoteIpv6Address `json:"remoteIpv6Address,omitempty"`

	RemoteNodeId *TopologyRemoteNodeId `json:"remoteNodeId,omitempty"`

	RequestId *TopologyRequestId `json:"requestId,omitempty"`

	Sid *TopologySid `json:"sid,omitempty"`

	SidType *TopologySidType `json:"sidType,omitempty"`

	SourceIpv4Address *TopologySourceIpv4Address `json:"sourceIpv4Address,omitempty"`

	SourceIpv6Address *TopologySourceIpv6Address `json:"sourceIpv6Address,omitempty"`

	SymbolicPathName *TopologySymbolicPathName `json:"symbolicPathName,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPccLearnedLspDb) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPccLearnedLspDb) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPccLearnedLspDb) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPccLearnedLspDb) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.DestIpv4Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "destIpv4Address",
	})
	n.DestIpv6Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "destIpv6Address",
	})
	n.ErrorInfo.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "errorInfo",
	})
	n.IpVersion.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ipVersion",
	})
	n.Ipv4NodeId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ipv4NodeId",
	})
	n.Ipv6NodeId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ipv6NodeId",
	})
	n.LearnedLspIndex.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "learnedLspIndex",
	})
	n.LearnedMsgDbType.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "learnedMsgDbType",
	})
	n.LocalIntefaceId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "localIntefaceId",
	})
	n.LocalIpv4Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "localIpv4Address",
	})
	n.LocalIpv6Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "localIpv6Address",
	})
	n.LocalNodeId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "localNodeId",
	})
	n.MplsLabel.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "mplsLabel",
	})
	n.NaiType.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "naiType",
	})
	n.PlspId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "plspId",
	})
	n.RemoteInterfaceId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "remoteInterfaceId",
	})
	n.RemoteIpv4Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "remoteIpv4Address",
	})
	n.RemoteIpv6Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "remoteIpv6Address",
	})
	n.RemoteNodeId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "remoteNodeId",
	})
	n.RequestId.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "requestId",
	})
	n.Sid.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sid",
	})
	n.SidType.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sidType",
	})
	n.SourceIpv4Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sourceIpv4Address",
	})
	n.SourceIpv6Address.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sourceIpv6Address",
	})
	n.SymbolicPathName.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "symbolicPathName",
	})
}

// TopologyPccRequestedMetricSubObjectsList: TBD
type TopologyPccRequestedMetricSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Active
	Active *Multivalue `json:"active,omitempty"`
	// EnableBflag: B Flag
	EnableBflag *Multivalue `json:"enableBflag,omitempty"`
	// EnableCflag: C Flag
	EnableCflag *Multivalue `json:"enableCflag,omitempty"`
	// MetricType: Metric Type
	MetricType *Multivalue `json:"metricType,omitempty"`
	// MetricValue: Metric Value
	MetricValue *Multivalue `json:"metricValue,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlagMetric: Metric P Flag
	PFlagMetric *Multivalue `json:"pFlagMetric,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPccRequestedMetricSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPccRequestedMetricSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPccRequestedMetricSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPccRequestedMetricSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableBflag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBflag",
		isMultivalue: true,
	})
	n.EnableCflag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableCflag",
		isMultivalue: true,
	})
	n.MetricType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricType",
		isMultivalue: true,
	})
	n.MetricValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricValue",
		isMultivalue: true,
	})
	n.PFlagMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagMetric",
		isMultivalue: true,
	})
}

// TopologyPce: Pcep Session (Device) level Configuration
type TopologyPce struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// MaxPendingConnection: This control allows the user to configure the maximum number of pending connections that an IXIA PCE controller will process concurrently.
	MaxPendingConnection *Multivalue `json:"maxPendingConnection,omitempty"`
	// MaxUnknownMessage: This control allows the user to configure the maximum number of unknown messages that PCE will receive before closing the session. If the PCE receives unrecognized messages at a rate equal or greater than this value per minute, the PCE MUST send a PCEP CLOSE message with this as the close value. The PCE MUST close the TCP session and MUST NOT send any further PCEP messages on the PCEP session.
	MaxUnknownMessage *Multivalue `json:"maxUnknownMessage,omitempty"`
	// MaxUnknownRequest: This control allows the user to configure the maximum number of unknown requests that PCE will receive before closing the session. If the PCE receives PCRep/ PCReq messages with unknown requests at a rate equal or greater than this value per minute, the PCE MUST send a PCEP CLOSE message with this as the close value. The PCE MUST close the TCP session and MUST NOT send any further PCEP messages on the PCEP session.
	MaxUnknownRequest *Multivalue `json:"maxUnknownRequest,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PceActionMode: PCE Mode of Action

	PceActionMode *string `json:"pceActionMode,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TcpPort: PCEP operates over TCP using a registered TCP port (default - 4189). This allows the requirements of reliable messaging and flow control to be met without further protocol work. This control can be configured when user does not want to use the default one.
	TcpPort  *Multivalue         `json:"tcpPort,omitempty"`
	PccGroup []*TopologyPccGroup `json:"pccGroup"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPce) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPce) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPce) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPce) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.MaxPendingConnection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxPendingConnection",
		isMultivalue: true,
	})
	n.MaxUnknownMessage.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxUnknownMessage",
		isMultivalue: true,
	})
	n.MaxUnknownRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxUnknownRequest",
		isMultivalue: true,
	})
	n.TcpPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tcpPort",
		isMultivalue: true,
	})
	for i, o := range n.PccGroup {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pccGroup",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPceInitiateLspParameters: This tab configures the Initiated LSP Parameters.
type TopologyPceInitiateLspParameters struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AssociationId: The Association ID of this LSP.
	AssociationId *Multivalue `json:"associationId,omitempty"`
	// Bandwidth: Bandwidth (bits/sec)
	Bandwidth *Multivalue `json:"bandwidth,omitempty"`
	// BindingType: Indicates the type of binding included in the TLV. Types are as follows: 20bit MPLS Label 32bit MPLS Label SRv6 SID Default value is 20bit MPLS Label.
	BindingType *Multivalue `json:"bindingType,omitempty"`
	// Bos: This bit is set to True for the last entry in the label stack i.e., for the bottom of the stack, and False for all other label stack entries. This control will be editable only if Binding Type is MPLS Label 32bit.
	Bos *Multivalue `json:"bos,omitempty"`
	// DestEndPointIpv4: Dest IPv4 address of the path for which a path computation is Initiated. Will be greyed out if IP Version is IPv6.
	DestEndPointIpv4 *Multivalue `json:"destEndPointIpv4,omitempty"`
	// DestEndPointIpv6: Dest IPv6 address of the path for which a path computation is Initiated. Will be greyed out if IP Version is IPv4.
	DestEndPointIpv6 *Multivalue `json:"destEndPointIpv6,omitempty"`
	// EnableXro: Include XRO
	EnableXro *Multivalue `json:"enableXro,omitempty"`
	// ExcludeAny: This is a type of Resource Affinity Procedure that is used to validate a link. This control accepts a link only if the link carries all of the attributes in the set.
	ExcludeAny *Multivalue `json:"excludeAny,omitempty"`
	// FailBit: Fail Bit
	FailBit *Multivalue `json:"failBit,omitempty"`
	// HoldingPriority: The priority of the LSP with respect to holding resources. The value 0 is the highest priority. Holding Priority is used in deciding whether this session can be preempted by another session.
	HoldingPriority *Multivalue `json:"holdingPriority,omitempty"`
	// IncludeAll: This is a type of Resource Affinity Procedure that is used to validate a link. This control excludes a link from consideration if the link carries any of the attributes in the set.
	IncludeAll *Multivalue `json:"includeAll,omitempty"`
	// IncludeAny: This is a type of Resource Affinity Procedure that is used to validate a link. This control accepts a link if the link carries any of the attributes in the set.
	IncludeAny *Multivalue `json:"includeAny,omitempty"`
	// IncludeAssociation: Indicates whether PPAG will be included in a PCInitiate message. All other attributes in sub-tab-PPAG would be editable only if this checkbox is enabled.
	IncludeAssociation *Multivalue `json:"includeAssociation,omitempty"`
	// IncludeBandwidth: Indicates whether Bandwidth will be included in a PCInitiate message. All other attributes in sub-tab-Bandwidth would be editable only if this checkbox is enabled.
	IncludeBandwidth *Multivalue `json:"includeBandwidth,omitempty"`
	// IncludeConfiguredERO: If this is enabled, entire ERO will go out in packet even if there is Binding SID, which means no SR-ERO/SRv6-ERO validation will be done.
	IncludeConfiguredERO *Multivalue `json:"includeConfiguredERO,omitempty"`
	// IncludeEndPoints: Indicates whether END-POINTS object will be included in a PCInitiate message. All other attributes in sub-tab-End Points would be editable only if this checkbox is enabled
	IncludeEndPoints *Multivalue `json:"includeEndPoints,omitempty"`
	// IncludeEro: Specifies whether ERO is active or inactive. All subsequent attributes of the sub-tab-ERO would be editable only if this is enabled.
	IncludeEro *Multivalue `json:"includeEro,omitempty"`
	// IncludeLsp: Indicates whether LSP will be included in a PCInitiate message. All other attributes in sub-tab-LSP would be editable only if this checkbox is enabled.
	IncludeLsp *Multivalue `json:"includeLsp,omitempty"`
	// IncludeLspa: Indicates whether LSPA will be included in a PCInitiate message. All other attributes in sub-tab-LSPA would be editable only if this checkbox is enabled.
	IncludeLspa *Multivalue `json:"includeLspa,omitempty"`
	// IncludeMetric: Indicates whether the PCInitiate message will have the metric list that is configured. All subsequent attributes of the sub-tab-Metric would be editable only if this is enabled.
	IncludeMetric *Multivalue `json:"includeMetric,omitempty"`
	// IncludeSrp: Indicates whether SRP object will be included in a PCInitiate message. All other attributes in sub-tab-SRP would be editable only if this checkbox is enabled.
	IncludeSrp *Multivalue `json:"includeSrp,omitempty"`
	// IncludeSymbolicPathNameTlv: Indicates if Symbolic-Path-Name TLV is to be included in PCInitiate message.
	IncludeSymbolicPathNameTlv *Multivalue `json:"includeSymbolicPathNameTlv,omitempty"`
	// IncludeTEPathBindingTLV: Indicates if TE-PATH-BINDING TLV is to be included in PCInitiate message.
	IncludeTEPathBindingTLV *Multivalue `json:"includeTEPathBindingTLV,omitempty"`
	// IpVersion: Drop down to select the IP Version with 2 choices : IPv4 / IPv6
	IpVersion *Multivalue `json:"ipVersion,omitempty"`
	// LocalProtection: When set, this means that the path must include links protected with Fast Reroute
	LocalProtection *Multivalue `json:"localProtection,omitempty"`
	// MplsLabel: This control will be editable if the Binding Type is set to either 20bit or 32bit MPLS-Label. This field will take the 20bit value of the MPLS-Label
	MplsLabel *Multivalue `json:"mplsLabel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfEroSubObjects: Value that indicates the number of ERO Sub Objects to be configured.

	NumberOfEroSubObjects *float32 `json:"numberOfEroSubObjects,omitempty"`
	// NumberOfMetricSubObject: Value that indicates the number of Metric Objects to be configured.

	NumberOfMetricSubObject *float32 `json:"numberOfMetricSubObject,omitempty"`
	// NumberOfXroSubObjects: Number of XRO Sub Objects

	NumberOfXroSubObjects *float32 `json:"numberOfXroSubObjects,omitempty"`
	// OverridePlspId: Indicates if PLSP-ID will be set by the state machine or user. If disabled user wont have the control and state machine will set it.

	OverridePlspId *bool `json:"overridePlspId,omitempty"`
	// OverrideSrpIdNumber: Indicates whether SRP ID Number is overridable.

	OverrideSrpIdNumber *bool `json:"overrideSrpIdNumber,omitempty"`
	// PathSetupType: Indicates which type of LSP will be requested in the PCInitiated Request.
	PathSetupType *Multivalue `json:"pathSetupType,omitempty"`
	// PlspId: An identifier for the LSP. A PCC creates a unique PLSP-ID for each LSP that is constant for the lifetime of a PCEP session. The PCC will advertise the same PLSP-ID on all PCEP sessions it maintains at a given time.
	PlspId *Multivalue `json:"plspId,omitempty"`
	// ProtectionLsp: Indicates whether Protection LSP Bit is On.
	ProtectionLsp *Multivalue `json:"protectionLsp,omitempty"`
	// SendEmptyTLV: If enabled all fields after Binding Type will be grayed out.
	SendEmptyTLV *Multivalue `json:"sendEmptyTLV,omitempty"`
	// SetupPriority: The priority of the LSP with respect to taking resources.The value 0 is the highest priority.The Setup Priority is used in deciding whether this session can preempt another session.
	SetupPriority *Multivalue `json:"setupPriority,omitempty"`
	// SrcEndPointIpv4: Source IPv4 address of the path for which a path computation is Initiated. Will be greyed out if IP Version is set to IPv6.
	SrcEndPointIpv4 *Multivalue `json:"srcEndPointIpv4,omitempty"`
	// SrcEndPointIpv6: Source IPv6 address of the path for which a path computation is Initiated. Will be greyed out if IP version is set to IPv4.
	SrcEndPointIpv6 *Multivalue `json:"srcEndPointIpv6,omitempty"`
	// SrpIdNumber: The SRP object is used to correlate between initiation requests sent by the PCE and the error reports and state reports sent by the PCC. This number is unique per PCEP session and is incremented per initiation.
	SrpIdNumber *Multivalue `json:"srpIdNumber,omitempty"`
	// Srv6SID: SRv6 SID with a format of a 16 byte IPv6 address.
	Srv6SID *Multivalue `json:"srv6SID,omitempty"`
	// StandbyMode: Indicates whether Standby LSP Bit is On.
	StandbyMode *Multivalue `json:"standbyMode,omitempty"`
	// SymbolicPathName: Each LSP (path) must have a symbolic name that is unique in the PCC. It must remain constant throughout a path's lifetime, which may span across multiple consecutive PCEP sessions and/or PCC restarts.
	SymbolicPathName *Multivalue `json:"symbolicPathName,omitempty"`
	// Tc: This field is used to carry traffic class information. This control will be editable only if Binding Type is MPLS Label 32bit.
	Tc *Multivalue `json:"tc,omitempty"`
	// Ttl: This field is used to encode a time-to-live value. This control will be editable only if Binding Type is MPLS Label 32bit.
	Ttl                      *Multivalue                         `json:"ttl,omitempty"`
	PceInitiateXROobject     []*TopologyPceInitiateXrOobject     `json:"pceInitiateXROobject"`
	PcepEroSubObjectsList    []*TopologyPcepEroSubObjectsList    `json:"pcepEroSubObjectsList"`
	PcepMetricSubObjectsList []*TopologyPcepMetricSubObjectsList `json:"pcepMetricSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPceInitiateLspParameters) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPceInitiateLspParameters) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPceInitiateLspParameters) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPceInitiateLspParameters) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AssociationId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "associationId",
		isMultivalue: true,
	})
	n.Bandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidth",
		isMultivalue: true,
	})
	n.BindingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingType",
		isMultivalue: true,
	})
	n.Bos.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bos",
		isMultivalue: true,
	})
	n.DestEndPointIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destEndPointIpv4",
		isMultivalue: true,
	})
	n.DestEndPointIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destEndPointIpv6",
		isMultivalue: true,
	})
	n.EnableXro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableXro",
		isMultivalue: true,
	})
	n.ExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAny",
		isMultivalue: true,
	})
	n.FailBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "failBit",
		isMultivalue: true,
	})
	n.HoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdingPriority",
		isMultivalue: true,
	})
	n.IncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAll",
		isMultivalue: true,
	})
	n.IncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAny",
		isMultivalue: true,
	})
	n.IncludeAssociation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAssociation",
		isMultivalue: true,
	})
	n.IncludeBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeBandwidth",
		isMultivalue: true,
	})
	n.IncludeConfiguredERO.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeConfiguredERO",
		isMultivalue: true,
	})
	n.IncludeEndPoints.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeEndPoints",
		isMultivalue: true,
	})
	n.IncludeEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeEro",
		isMultivalue: true,
	})
	n.IncludeLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLsp",
		isMultivalue: true,
	})
	n.IncludeLspa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLspa",
		isMultivalue: true,
	})
	n.IncludeMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMetric",
		isMultivalue: true,
	})
	n.IncludeSrp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSrp",
		isMultivalue: true,
	})
	n.IncludeSymbolicPathNameTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSymbolicPathNameTlv",
		isMultivalue: true,
	})
	n.IncludeTEPathBindingTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTEPathBindingTLV",
		isMultivalue: true,
	})
	n.IpVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipVersion",
		isMultivalue: true,
	})
	n.LocalProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localProtection",
		isMultivalue: true,
	})
	n.MplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabel",
		isMultivalue: true,
	})
	n.PathSetupType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pathSetupType",
		isMultivalue: true,
	})
	n.PlspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "plspId",
		isMultivalue: true,
	})
	n.ProtectionLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectionLsp",
		isMultivalue: true,
	})
	n.SendEmptyTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendEmptyTLV",
		isMultivalue: true,
	})
	n.SetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setupPriority",
		isMultivalue: true,
	})
	n.SrcEndPointIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcEndPointIpv4",
		isMultivalue: true,
	})
	n.SrcEndPointIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcEndPointIpv6",
		isMultivalue: true,
	})
	n.SrpIdNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srpIdNumber",
		isMultivalue: true,
	})
	n.Srv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SID",
		isMultivalue: true,
	})
	n.StandbyMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "standbyMode",
		isMultivalue: true,
	})
	n.SymbolicPathName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "symbolicPathName",
		isMultivalue: true,
	})
	n.Tc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tc",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
	for i, o := range n.PceInitiateXROobject {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pceInitiateXROobject",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PcepEroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepEroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PcepMetricSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepMetricSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPceInitiateXrOobject: TBD
type TopologyPceInitiateXrOobject struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Controls whether the XRO sub-object will be sent in the PCRequest message.
	Active *Multivalue `json:"active,omitempty"`
	// AsNumber: AS Number
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// Attribute: Indicates how the exclusion subobject is to be indicated
	Attribute *Multivalue `json:"attribute,omitempty"`
	// ExcludeBit: Indicates whether the exclusion is mandatory or desired.
	ExcludeBit *Multivalue `json:"exclude_bit,omitempty"`
	// InterfaceId: Interface ID
	InterfaceId *Multivalue `json:"interfaceId,omitempty"`
	// Ipv4Address: IPv4 Address
	Ipv4Address *Multivalue `json:"ipv4Address,omitempty"`
	// Ipv6Address: IPv6 Address
	Ipv6Address *Multivalue `json:"ipv6Address,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PceId128: 128 bit PKS ID
	PceId128 *Multivalue `json:"pceId128,omitempty"`
	// PceId32: 32 bit PKS ID
	PceId32 *Multivalue `json:"pceId32,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RouterId: Router ID
	RouterId *Multivalue `json:"routerId,omitempty"`
	// SrlgId: SRLG ID
	SrlgId *Multivalue `json:"srlgId,omitempty"`
	// SubObjectType: Using the Sub Object Type control user can configure which sub object needs to be included from the following options: IPv4 Prefix IPv6 Prefix Unnumbered Interface ID AS Number. SRLG
	SubObjectType *Multivalue `json:"subObjectType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPceInitiateXrOobject) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPceInitiateXrOobject) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPceInitiateXrOobject) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPceInitiateXrOobject) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.Attribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attribute",
		isMultivalue: true,
	})
	n.ExcludeBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "exclude_bit",
		isMultivalue: true,
	})
	n.InterfaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceId",
		isMultivalue: true,
	})
	n.Ipv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Address",
		isMultivalue: true,
	})
	n.Ipv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Address",
		isMultivalue: true,
	})
	n.PceId128.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceId128",
		isMultivalue: true,
	})
	n.PceId32.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceId32",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerId",
		isMultivalue: true,
	})
	n.SrlgId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlgId",
		isMultivalue: true,
	})
	n.SubObjectType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subObjectType",
		isMultivalue: true,
	})
}

// TopologyPceXroSubObjectsList: TBD
type TopologyPceXroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Controls whether the XRO sub-object will be sent in the PCRequest message.
	Active *Multivalue `json:"active,omitempty"`
	// AsNumber: AS Number
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// Attribute: Indicates how the exclusion subobject is to be indicated
	Attribute *Multivalue `json:"attribute,omitempty"`
	// ExcludeBit: Indicates whether the exclusion is mandatory or desired.
	ExcludeBit *Multivalue `json:"exclude_bit,omitempty"`
	// InterfaceId: Interface ID
	InterfaceId *Multivalue `json:"interfaceId,omitempty"`
	// Ipv4Address: IPv4 Address
	Ipv4Address *Multivalue `json:"ipv4Address,omitempty"`
	// Ipv6Address: IPv6 Address
	Ipv6Address *Multivalue `json:"ipv6Address,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PceId128: 128 bit PKS ID
	PceId128 *Multivalue `json:"pceId128,omitempty"`
	// PceId32: 32 bit PKS ID
	PceId32 *Multivalue `json:"pceId32,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RouterId: Router ID
	RouterId *Multivalue `json:"routerId,omitempty"`
	// SrlgId: SRLG ID
	SrlgId *Multivalue `json:"srlgId,omitempty"`
	// SubObjectType: Using the Sub Object Type control user can configure which sub object needs to be included from the following options: IPv4 Prefix IPv6 Prefix Unnumbered Interface ID AS Number. SRLG
	SubObjectType *Multivalue `json:"subObjectType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPceXroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPceXroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPceXroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPceXroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.Attribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attribute",
		isMultivalue: true,
	})
	n.ExcludeBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "exclude_bit",
		isMultivalue: true,
	})
	n.InterfaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceId",
		isMultivalue: true,
	})
	n.Ipv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Address",
		isMultivalue: true,
	})
	n.Ipv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Address",
		isMultivalue: true,
	})
	n.PceId128.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceId128",
		isMultivalue: true,
	})
	n.PceId32.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceId32",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerId",
		isMultivalue: true,
	})
	n.SrlgId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlgId",
		isMultivalue: true,
	})
	n.SubObjectType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subObjectType",
		isMultivalue: true,
	})
}

// TopologyPcepBackupPcEs: This tab configures the Backup PCEs connected to the PCC.
type TopologyPcepBackupPcEs struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PceIpv4Address: IPv4 address of the backup PCE. This column is greyed out in case of PCCv6.
	PceIpv4Address *Multivalue `json:"pceIpv4Address,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcepBackupPcEs) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcepBackupPcEs) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcepBackupPcEs) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcepBackupPcEs) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.PceIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceIpv4Address",
		isMultivalue: true,
	})
}

// TopologyPcepEroSubObjectsList: TBD
type TopologyPcepEroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Controls whether the ERO sub-object will be sent in the PCInitiate message.
	Active *Multivalue `json:"active,omitempty"`
	// AsNumber: AS Number
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// Bos: This bit is set to true for the last entry in the label stack i.e., for the bottom of the stack, and false for all other label stack entries. This control will be editable only if SID Type is MPLS Label 32bit.
	Bos *Multivalue `json:"bos,omitempty"`
	// FBit: A Flag which is used to carry additional information pertaining to SID. When this bit is set, the NAI value in the subobject body is null.
	FBit *Multivalue `json:"fBit,omitempty"`
	// Ipv4NodeId: IPv4 Node ID is specified as an IPv4 address. This control can be configured if NAI Type is set to IPv4 Node ID and F bit is disabled.
	Ipv4NodeId *Multivalue `json:"ipv4NodeId,omitempty"`
	// Ipv4Prefix: IPv4 Prefix is specified as an IPv4 address.
	Ipv4Prefix *Multivalue `json:"ipv4Prefix,omitempty"`
	// Ipv6NodeId: IPv6 Node ID is specified as an IPv6 address. This control can be configured if NAI Type is set to IPv6 Node ID and F bit is disabled.
	Ipv6NodeId *Multivalue `json:"ipv6NodeId,omitempty"`
	// Ipv6Prefix: IPv6 Prefix is specified as an IPv6 address.
	Ipv6Prefix *Multivalue `json:"ipv6Prefix,omitempty"`
	// LocalInterfaceId: This is the Local Interface ID of the Unnumbered Adjacency with IPv4 NodeIDs which is specified as a pair of Node ID / Interface ID tuples. This Control can be configured if NAI Type is set to Unnumbered Adjacency with IPv4 NodeIDs and F bit is disabled.
	LocalInterfaceId *Multivalue `json:"localInterfaceId,omitempty"`
	// LocalIpv4Address: This Control can be configured if NAI Type is set to IPv4 Adjacency and F bit is disabled.
	LocalIpv4Address *Multivalue `json:"localIpv4Address,omitempty"`
	// LocalIpv6Address: This Control can be configured if NAI Type is set to IPv6 Adjacency and F bit is disabled.
	LocalIpv6Address *Multivalue `json:"localIpv6Address,omitempty"`
	// LocalNodeId: This is the Local Node ID of the Unnumbered Adjacency with IPv4 NodeIDs which is specified as a pair of Node ID / Interface ID tuples. This Control can be configured if NAI Type is set to Unnumbered Adjacency with IPv4 NodeIDs and F bit is disabled.
	LocalNodeId *Multivalue `json:"localNodeId,omitempty"`
	// LooseHop: Indicates if user wants to represent a loose-hop sub object in the LSP
	LooseHop *Multivalue `json:"looseHop,omitempty"`
	// MplsLabel: This control will be editable if the SID Type is set to either 20bit or 32bit MPLS-Label. This field will take the 20bit value of the MPLS-Label
	MplsLabel *Multivalue `json:"mplsLabel,omitempty"`
	// NaiType: NAI (Node or Adjacency Identifier) contains the NAI associated with the SID. Depending on the value of SID Type, the NAI can have different formats such as, Not Applicable IPv4 Node ID IPv6 Node ID IPv4 Adjacency IPv6 Adjacency Unnumbered Adjacency with IPv4 NodeIDs
	NaiType *Multivalue `json:"naiType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RemoteInterfaceId: This is the Remote Interface ID of the Unnumbered Adjacency with IPv4 NodeIDs which is specified as a pair of Node ID / Interface ID tuples. This Control can be configured if NAI Type is set to Unnumbered Adjacency with IPv4 NodeIDs and F bit is disabled.
	RemoteInterfaceId *Multivalue `json:"remoteInterfaceId,omitempty"`
	// RemoteIpv4Address: This Control can be configured if NAI Type is set to IPv4 Adjacency and F bit is disabled.
	RemoteIpv4Address *Multivalue `json:"remoteIpv4Address,omitempty"`
	// RemoteIpv6Address: This Control can be configured if NAI Type is set to IPv6 Adjacency and F bit is disabled.
	RemoteIpv6Address *Multivalue `json:"remoteIpv6Address,omitempty"`
	// RemoteNodeId: This is the Remote Node ID of the Unnumbered Adjacency with IPv4 NodeIDs which is specified as a pair of Node ID / Interface ID tuples. This Control can be configured if NAI Type is set to Unnumbered Adjacency with IPv4 NodeIDs and F bit is disabled.
	RemoteNodeId *Multivalue `json:"remoteNodeId,omitempty"`
	// Sid: SID is the Segment Identifier
	Sid *Multivalue `json:"sid,omitempty"`
	// SidType: Using the Segment Identifier Type control user can configure whether to include SID or not and if included what is its type. Types are as follows: Null SID 20bit MPLS Label 32bit MPLS Label. If it is Null then S bit is set in the packet. Default value is 20bit MPLS Label.
	SidType *Multivalue `json:"sidType,omitempty"`
	// Srv6FunctionCode: Function Code is is the 16 bit field representing supported functions associated with SRv6 SIDs. This information is optional and included only for maintainability. Following function codes are currently defined - 0: Reserved 1: End Function 2: End.DX6 Function 3: End.DT6 Function 4: End.X Function
	Srv6FunctionCode *Multivalue `json:"srv6FunctionCode,omitempty"`
	// Srv6Identifier: SRv6 Identifier is the 128 bit IPv6 addresses representing SRv6 segment.
	Srv6Identifier *Multivalue `json:"srv6Identifier,omitempty"`
	// Srv6NaiType: The SRv6 NAI Type which indicates the interpretation for NAI (Node or Adjacency Identifier).
	Srv6NaiType *Multivalue `json:"srv6NaiType,omitempty"`
	// SubObjectType: Using the Sub Object Type control user can configure which sub object needs to be included from the following options: Not Applicable IPv4 Prefix IPv6 Prefix AS Number.
	SubObjectType *Multivalue `json:"subObjectType,omitempty"`
	// Tc: This field is used to carry traffic class information. This control will be editable only if SID Type is MPLS Label 32bit.
	Tc *Multivalue `json:"tc,omitempty"`
	// Ttl: This field is used to encode a time-to-live value. This control will be editable only if SID Type is MPLS Label 32bit.
	Ttl *Multivalue `json:"ttl,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcepEroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcepEroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcepEroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcepEroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.Bos.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bos",
		isMultivalue: true,
	})
	n.FBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fBit",
		isMultivalue: true,
	})
	n.Ipv4NodeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4NodeId",
		isMultivalue: true,
	})
	n.Ipv4Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Prefix",
		isMultivalue: true,
	})
	n.Ipv6NodeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6NodeId",
		isMultivalue: true,
	})
	n.Ipv6Prefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Prefix",
		isMultivalue: true,
	})
	n.LocalInterfaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localInterfaceId",
		isMultivalue: true,
	})
	n.LocalIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localIpv4Address",
		isMultivalue: true,
	})
	n.LocalIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localIpv6Address",
		isMultivalue: true,
	})
	n.LocalNodeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localNodeId",
		isMultivalue: true,
	})
	n.LooseHop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "looseHop",
		isMultivalue: true,
	})
	n.MplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabel",
		isMultivalue: true,
	})
	n.NaiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "naiType",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RemoteInterfaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteInterfaceId",
		isMultivalue: true,
	})
	n.RemoteIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIpv4Address",
		isMultivalue: true,
	})
	n.RemoteIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIpv6Address",
		isMultivalue: true,
	})
	n.RemoteNodeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteNodeId",
		isMultivalue: true,
	})
	n.Sid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sid",
		isMultivalue: true,
	})
	n.SidType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sidType",
		isMultivalue: true,
	})
	n.Srv6FunctionCode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6FunctionCode",
		isMultivalue: true,
	})
	n.Srv6Identifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6Identifier",
		isMultivalue: true,
	})
	n.Srv6NaiType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6NaiType",
		isMultivalue: true,
	})
	n.SubObjectType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subObjectType",
		isMultivalue: true,
	})
	n.Tc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tc",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
}

// TopologyPcepIroSubObjectsList: TBD
type TopologyPcepIroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Active
	Active *Multivalue `json:"active,omitempty"`
	// AsNumber: AS Number
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// InterfaceId: Interface ID
	InterfaceId *Multivalue `json:"interfaceId,omitempty"`
	// Ipv4Address: IPv4 Address
	Ipv4Address *Multivalue `json:"ipv4Address,omitempty"`
	// Ipv6Address: IPv6 Address
	Ipv6Address *Multivalue `json:"ipv6Address,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RouterId: Router ID
	RouterId *Multivalue `json:"routerId,omitempty"`
	// SubObjectType: Sub Object Type
	SubObjectType *Multivalue `json:"subObjectType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcepIroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcepIroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcepIroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcepIroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.InterfaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceId",
		isMultivalue: true,
	})
	n.Ipv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Address",
		isMultivalue: true,
	})
	n.Ipv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Address",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerId",
		isMultivalue: true,
	})
	n.SubObjectType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subObjectType",
		isMultivalue: true,
	})
}

// TopologyPcepMetricSubObjectsList: TBD
type TopologyPcepMetricSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Specifies whether the corresponding metric object is active or not.
	Active *Multivalue `json:"active,omitempty"`
	// BFlag: B (bound) flag MUST be set in the METRIC object, which specifies that the SID depth for the computed path MUST NOT exceed the metric-value.
	BFlag *Multivalue `json:"bFlag,omitempty"`
	// MetricType: This is a drop down which has 4 choices: IGP/ TE/ Hop count/ MSD.
	MetricType *Multivalue `json:"metricType,omitempty"`
	// MetricValue: User can specify the metric value corresponding to the metric type selected.
	MetricValue *Multivalue `json:"metricValue,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcepMetricSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcepMetricSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcepMetricSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcepMetricSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bFlag",
		isMultivalue: true,
	})
	n.MetricType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricType",
		isMultivalue: true,
	})
	n.MetricValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metricValue",
		isMultivalue: true,
	})
}

// TopologyPcepXroSubObjectsList: TBD
type TopologyPcepXroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Controls whether the XRO sub-object will be sent in the PCRequest message.
	Active *Multivalue `json:"active,omitempty"`
	// AsNumber: AS Number
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// Attribute: Indicates how the exclusion subobject is to be indicated
	Attribute *Multivalue `json:"attribute,omitempty"`
	// ExcludeBit: Indicates whether the exclusion is mandatory or desired.
	ExcludeBit *Multivalue `json:"exclude_bit,omitempty"`
	// InterfaceId: Interface ID
	InterfaceId *Multivalue `json:"interfaceId,omitempty"`
	// Ipv4Address: IPv4 Address
	Ipv4Address *Multivalue `json:"ipv4Address,omitempty"`
	// Ipv6Address: IPv6 Address
	Ipv6Address *Multivalue `json:"ipv6Address,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PFlagXro: XRO P Flag
	PFlagXro *Multivalue `json:"pFlagXro,omitempty"`
	// PceId128: 128 bit PKS ID
	PceId128 *Multivalue `json:"pceId128,omitempty"`
	// PceId32: 32 bit PKS ID
	PceId32 *Multivalue `json:"pceId32,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// RouterId: Router ID
	RouterId *Multivalue `json:"routerId,omitempty"`
	// SrlgId: SRLG ID
	SrlgId *Multivalue `json:"srlgId,omitempty"`
	// SubObjectType: Using the Sub Object Type control user can configure which sub object needs to be included from the following options: IPv4 Prefix IPv6 Prefix Unnumbered Interface ID AS Number. SRLG
	SubObjectType *Multivalue `json:"subObjectType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPcepXroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPcepXroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPcepXroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPcepXroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.Attribute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attribute",
		isMultivalue: true,
	})
	n.ExcludeBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "exclude_bit",
		isMultivalue: true,
	})
	n.InterfaceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interfaceId",
		isMultivalue: true,
	})
	n.Ipv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4Address",
		isMultivalue: true,
	})
	n.Ipv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6Address",
		isMultivalue: true,
	})
	n.PFlagXro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagXro",
		isMultivalue: true,
	})
	n.PceId128.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceId128",
		isMultivalue: true,
	})
	n.PceId32.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pceId32",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.RouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerId",
		isMultivalue: true,
	})
	n.SrlgId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlgId",
		isMultivalue: true,
	})
	n.SubObjectType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subObjectType",
		isMultivalue: true,
	})
}

// TopologyPimRouter: PIM Device level Configuration
type TopologyPimRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// DrPriority: The Designated Router (DR) priority assigned to this emulated PIM-SM router. This value is used in the election of the DR, and is included in the Hello Messages. The larger the DR value, the higher the priority. The default is 0.
	DrPriority *Multivalue `json:"drPriority,omitempty"`
	// JoinPruneHoldTime: (in seconds) The period during which a router receiving a Join/Prune message must keep the Join/State alive. The default is 3 times the Join/Prune Interval (= 180 seconds).
	JoinPruneHoldTime *Multivalue `json:"joinPruneHoldTime,omitempty"`
	// JoinPruneInterval: (in seconds) The Join/Prune interval specifies the length of time between transmissions of Join/Prune messages. The default is 60 seconds.
	JoinPruneInterval *Multivalue `json:"joinPruneInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DrPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "drPriority",
		isMultivalue: true,
	})
	n.JoinPruneHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "joinPruneHoldTime",
		isMultivalue: true,
	})
	n.JoinPruneInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "joinPruneInterval",
		isMultivalue: true,
	})
}

// TopologyPimV4CandidateRPsList: PIM V4 Candidate RP Ranges
type TopologyPimV4CandidateRPsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvertisementHoldTime: Time interval between two consecutive Candidate RP advertisements
	AdvertisementHoldTime *Multivalue `json:"advertisementHoldTime,omitempty"`
	// BackOffInterval: The back-off time interval for the C-RP-Adv messages
	BackOffInterval *Multivalue `json:"backOffInterval,omitempty"`
	// CrpAddress: Start address of the set of candidate RPs to be simulated
	CrpAddress *Multivalue `json:"crpAddress,omitempty"`
	// CrpAddressCount: Total number of Candidate RPs to be simulated starting from C-RP address
	CrpAddressCount *Multivalue `json:"crpAddressCount,omitempty"`
	// GroupAddress: Starting group address of the group range for which the candidate RP will advertise candidacy
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// GroupCount: Number of groups in the range
	GroupCount *Multivalue `json:"groupCount,omitempty"`
	// GroupMaskLen: Mask width (prefix length in bits) for the group range
	GroupMaskLen *Multivalue `json:"groupMaskLen,omitempty"`
	// MeshingType: It indicates if the mappings for groups and RP addresses are Fully-Meshed or One-To-One. One-to-one indicates that for each group only one RP shall be sent regardless of the RP count. Full meshed means for each group all RPs shall be advertised for candidacy which is essentially a (group to rp) mapping.
	MeshingType *Multivalue `json:"meshingType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeriodicAdvertisementInterval: Rate controlling variable indicating how many C-RP-Adv messages can be sent in the specified time interval
	PeriodicAdvertisementInterval *Multivalue `json:"periodicAdvertisementInterval,omitempty"`
	// Priority: Value of priority to be sent in candidate RP advertisement
	Priority *Multivalue `json:"priority,omitempty"`
	// PriorityChangeInterval: Time interval after which priority of all the RPs get changed
	PriorityChangeInterval *Multivalue `json:"priorityChangeInterval,omitempty"`
	// PriorityType: It indicates the type of priority to be held by the candidate RPs
	PriorityType *Multivalue `json:"priorityType,omitempty"`
	// TriggeredCrpMessageCount: The number of times C-RP advertisements is sent to the newly elected Bootstrap Routers
	TriggeredCrpMessageCount *Multivalue `json:"triggeredCrpMessageCount,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV4CandidateRPsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV4CandidateRPsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV4CandidateRPsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV4CandidateRPsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertisementHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertisementHoldTime",
		isMultivalue: true,
	})
	n.BackOffInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backOffInterval",
		isMultivalue: true,
	})
	n.CrpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "crpAddress",
		isMultivalue: true,
	})
	n.CrpAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "crpAddressCount",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.GroupCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCount",
		isMultivalue: true,
	})
	n.GroupMaskLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupMaskLen",
		isMultivalue: true,
	})
	n.MeshingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "meshingType",
		isMultivalue: true,
	})
	n.PeriodicAdvertisementInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicAdvertisementInterval",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.PriorityChangeInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priorityChangeInterval",
		isMultivalue: true,
	})
	n.PriorityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priorityType",
		isMultivalue: true,
	})
	n.TriggeredCrpMessageCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggeredCrpMessageCount",
		isMultivalue: true,
	})
}

// TopologyPimV4Interface: PIMv4 Interface level Configuration
type TopologyPimV4Interface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AutoPickNeighbor: If selected, the time-saving Auto Pick feature is enabled-and the Upstream Neighbor field is not available for use. The Upstream Neighbor address used in the Join/Prune message is determined automatically from received Hello messages. The first time a Hello message is received-containing a Source (link-local) address that does not belong to this interface, that source address will be used as the Upstream Neighbor address. If not selected, the user can type in the link-local address in the Upstream Neighbor IP field (see Neighbor field below)-to be used for the upstream neighbor address field in the Join/Prune message.
	AutoPickNeighbor *Multivalue `json:"autoPickNeighbor,omitempty"`
	// BootstrapHashMaskLength: Hash Mask Length of the Bootstrap Router (BSR) that is set with the same name in all Bootstrap Messages sent by this BSR.
	BootstrapHashMaskLength *Multivalue `json:"bootstrapHashMaskLength,omitempty"`
	// BootstrapInterval: The time interval (in seconds) between two consecutive bootstrap messages sent by the BSR.
	BootstrapInterval *Multivalue `json:"bootstrapInterval,omitempty"`
	// BootstrapPriority: Priority of the Bootstrap Router (BSR) that is set with the same name in all Bootstrap Messages sent by this BSR.
	BootstrapPriority *Multivalue `json:"bootstrapPriority,omitempty"`
	// BootstrapTimeout: Amount of time (in seconds) of not receiving any Bootstrap Messages, after which, the BSR if candidate at that point of time will decide that the currently elected BSR has gone down and will restart BSR election procedure.
	BootstrapTimeout *Multivalue `json:"bootstrapTimeout,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// CrpRanges: Number of C-RP Ranges

	CrpRanges *float32 `json:"crpRanges,omitempty"`
	// DisableTriggered: If enabled, the triggered hello delay function is disabled.
	DisableTriggered *Multivalue `json:"disableTriggered,omitempty"`
	// DiscardLearnedRpInfo: If selected, disregards group mappings learnt from Bootstrap Message (in case not acting as elected BSR) or from Candidate RP Advertisement (in case of elected BSR).
	DiscardLearnedRpInfo *Multivalue `json:"discardLearnedRpInfo,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableBootstrap: If selected, enables the PIM-SM interface to participate in Bootstrap Router election procedure.
	EnableBootstrap *Multivalue `json:"enableBootstrap,omitempty"`
	// EnablePrune: If selected, the LAN Prune (propagation) Delay is enabled for this PIM-SM interface. (This Indicates that this option is present in the Hello message.)
	EnablePrune *Multivalue `json:"enablePrune,omitempty"`
	// ForceSemantic: If enabled, this forces the BSR to send only one group specific RP list per bootstrap message, even if there is space in the packet to push in more RP list information pertaining to a different group.
	ForceSemantic *Multivalue `json:"forceSemantic,omitempty"`
	// HelloHoldTime: The timeout period in seconds specified in Hello messages. It is the length of time the receiver of this message must keep the neighbor reachable. The default is 3.5 times the Hello Interval (105 seconds).
	HelloHoldTime *Multivalue `json:"helloHoldTime,omitempty"`
	// HelloInterval: The PIM-SM Hello Interval is the length of time in seconds between the transmissions of Hello messages. The default is 30 seconds.
	HelloInterval *Multivalue `json:"helloInterval,omitempty"`
	// JoinPrunes: Number of Join/Prunes

	JoinPrunes *float32 `json:"joinPrunes,omitempty"`
	// LanPruneTbit: If selected, the T flag bit in the LAN Prune Delay option of the Hello message is set (= 1). Setting this bit specifies that the sending PIM-SM router has the ability to disable Join message suppression
	LanPruneTbit *Multivalue `json:"lanPruneTbit,omitempty"`
	// LearnSelectedRpSet: If selected, displays the best RP per group (member of selected RP set).
	LearnSelectedRpSet *Multivalue `json:"learnSelectedRpSet,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OverrideInterval: (in ms) The delay interval for randomizing the transmission time for override messages-when scheduling a delayed Join message. The default value is 2,500 milliseconds (ms). The valid range is 100 to 7FFF msec. (This is part of the LAN Prune Delay option included in Hello messages).
	OverrideInterval *Multivalue `json:"overrideInterval,omitempty"`
	// PruneDelay: (in ms) The value of the LAN Prune (propagation) Delay for this PIM-SM interface. The expected delay for messages propagated on the link. It indicates to an upstream router how long to wait for a Join override message before it prunes an interface. The default value is 500 msec. The valid range is 100 to 0x7FFF msec. (LAN Prune Delay is an Option included in Hello messages.)
	PruneDelay *Multivalue `json:"pruneDelay,omitempty"`
	// SendBidirectional: If selected, sets the bi-directional PIM-SM flag bit (= 1), per IETF DRAFT draft-ietf-pim-bidir-04. (Note: Designated Forwarder election is not currently supported.)
	SendBidirectional *Multivalue `json:"sendBidirectional,omitempty"`
	// SendGenerationIdOption: If selected, enables the Send Generation ID Option, and the Generation ID Mode field will become available to make a mode selection.
	SendGenerationIdOption *Multivalue `json:"sendGenerationIdOption,omitempty"`
	// SendGenerationMode: The mode for creating the 32-bit value for the Generation Identifier (GenID) option in the Hello message. A new GenID is created each time an interface (or router) starts or restarts PIM-SM forwarding. A change in this value indicates to the neighbor(s) that a change of state may have occurred, and that the old PIM-SM states information received from those interfaces should be discarded. Choose one of: Incremental-the GenID increases by 1 for each successive Hello Message sent from this emulated PIM-SM router. Random-each Hello message sent from this emulated PIM-SM router will have a randomly-generated GenID. Constant (the default)-the GenID remains the same in all of the Hello Messages sent from this emulated. PIM-SM router.
	SendGenerationMode *Multivalue `json:"sendGenerationMode,omitempty"`
	// Sources: Number of Sources

	Sources *float32 `json:"sources,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SupportUnicastBsm: If enabled, this supports the sending and processing of Unicast bootstrap messages.
	SupportUnicastBsm *Multivalue `json:"supportUnicastBsm,omitempty"`
	// TriggeredHelloDelay: The time (in seconds) after which the router senses a delay in sending or receiving PIM-SM hello message.
	TriggeredHelloDelay *Multivalue `json:"triggeredHelloDelay,omitempty"`
	// V4Neighbor: (Auto Pick Neighbor must be disabled/not selected to make this field active) The user can manually type in the link-local address to be used for the Upstream Neighbor address field in the Join/Prune message.
	V4Neighbor  *Multivalue            `json:"v4Neighbor,omitempty"`
	LearnedInfo []*TopologyLearnedInfo `json:"learnedInfo"`

	PimV4CandidateRPsList *TopologyPimV4CandidateRPsList `json:"pimV4CandidateRPsList,omitempty"`

	PimV4JoinPruneList *TopologyPimV4JoinPruneList `json:"pimV4JoinPruneList,omitempty"`

	PimV4SourcesList *TopologyPimV4SourcesList `json:"pimV4SourcesList,omitempty"`
	Tag              []*TopologyTag            `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV4Interface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV4Interface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV4Interface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV4Interface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AutoPickNeighbor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoPickNeighbor",
		isMultivalue: true,
	})
	n.BootstrapHashMaskLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapHashMaskLength",
		isMultivalue: true,
	})
	n.BootstrapInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapInterval",
		isMultivalue: true,
	})
	n.BootstrapPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapPriority",
		isMultivalue: true,
	})
	n.BootstrapTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapTimeout",
		isMultivalue: true,
	})
	n.DisableTriggered.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableTriggered",
		isMultivalue: true,
	})
	n.DiscardLearnedRpInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLearnedRpInfo",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableBootstrap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBootstrap",
		isMultivalue: true,
	})
	n.EnablePrune.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePrune",
		isMultivalue: true,
	})
	n.ForceSemantic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forceSemantic",
		isMultivalue: true,
	})
	n.HelloHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloHoldTime",
		isMultivalue: true,
	})
	n.HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloInterval",
		isMultivalue: true,
	})
	n.LanPruneTbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lanPruneTbit",
		isMultivalue: true,
	})
	n.LearnSelectedRpSet.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "learnSelectedRpSet",
		isMultivalue: true,
	})
	n.OverrideInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideInterval",
		isMultivalue: true,
	})
	n.PruneDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneDelay",
		isMultivalue: true,
	})
	n.SendBidirectional.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendBidirectional",
		isMultivalue: true,
	})
	n.SendGenerationIdOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendGenerationIdOption",
		isMultivalue: true,
	})
	n.SendGenerationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendGenerationMode",
		isMultivalue: true,
	})
	n.SupportUnicastBsm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportUnicastBsm",
		isMultivalue: true,
	})
	n.TriggeredHelloDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggeredHelloDelay",
		isMultivalue: true,
	})
	n.V4Neighbor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "v4Neighbor",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.PimV4CandidateRPsList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pimV4CandidateRPsList",
	})
	n.PimV4JoinPruneList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pimV4JoinPruneList",
	})
	n.PimV4SourcesList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pimV4SourcesList",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPimV4JoinPruneList: PIM V4 Join Prune Data
type TopologyPimV4JoinPruneList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// EnableFlapInfo: If selected, enables this Source entry for use in PIM-SM Register messages.
	EnableFlapInfo *Multivalue `json:"enableFlapInfo,omitempty"`
	// EnablePack: If enabled, Multiple Groups can be included within a single packet.
	EnablePack *Multivalue `json:"enablePack,omitempty"`
	// FlapInterval: (in seconds) Specifies the amount of time between emulated flap events. The default is 60 seconds.
	FlapInterval *Multivalue `json:"flapInterval,omitempty"`
	// GroupAddressCount: The number of multicast group addresses to be included in the multicast group range. The maximum number of valid possible addresses depends on the values for the Group Address and the Group Mask Width. The default value is 1.
	GroupAddressCount *Multivalue `json:"groupAddressCount,omitempty"`
	// GroupV4Address: Group Address
	GroupV4Address *Multivalue `json:"groupV4Address,omitempty"`
	// GroupV4MaskWidth: Group Mask width
	GroupV4MaskWidth *Multivalue `json:"groupV4MaskWidth,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PruneSourceAddressCount: The number of Prune Source addresses to be included. The maximum number of valid possible addresses depends on the values for the Source Address and the Source Mask Width. The default value is 0. ONLY used for (*,G) Type to send (S,G,rpt) Prune Messages.
	PruneSourceAddressCount *Multivalue `json:"pruneSourceAddressCount,omitempty"`
	// PruneSourceV4Address: Prune Source Address
	PruneSourceV4Address *Multivalue `json:"pruneSourceV4Address,omitempty"`
	// PruneSourceV4MaskWidth: Prune Source Mask width
	PruneSourceV4MaskWidth *Multivalue `json:"pruneSourceV4MaskWidth,omitempty"`
	// RangeType: The Multicast Range Type. Choose one of: (*, *, RP)-Wildcard Group Set. For (*,*, RP) Join/Prune messages. Refers to all Groups associated with this specific RP. (*, G)-Group Specific type. For (*,G) Join/Prune messages. Refers to all sources associated with a specific Group G on the RP tree. (S, G)-Source specific type. For (S,G) Join/Prune messages. Refers only to specific combination of Source S and Group G. (*, G) -> (S, G)-Switchover type. (For switchover from non-source specific group state to source-specific group state.) Register Triggered (S,G)-These are the ranges of multicast group address and unicast source address to which a PIM-SM Router emulating an RP (for those source-group combinations) will send Triggered (S,G) joins and Register-Stop messages after receiving Register messages.
	RangeType *Multivalue `json:"rangeType,omitempty"`
	// RegisterStopTriggerCount: Available ONLY for use with Register Triggered (S,G) Range Type. (Default = 10)
	RegisterStopTriggerCount *Multivalue `json:"registerStopTriggerCount,omitempty"`
	// RpV4Address: RP Address
	RpV4Address *Multivalue `json:"rpV4Address,omitempty"`
	// SourceAddressCount: The number of multicast source addresses to be included. The maximum number of valid possible addresses depends on the values for the Source Address and the Source Mask Width. The default value is 0.
	SourceAddressCount *Multivalue `json:"sourceAddressCount,omitempty"`
	// SourceGroupMappingType: Choose one of: Fully-meshed, One-to-One
	SourceGroupMappingType *Multivalue `json:"sourceGroupMappingType,omitempty"`
	// SourceV4Address: Source Address
	SourceV4Address *Multivalue `json:"sourceV4Address,omitempty"`
	// SourceV4MaskWidth: Source Mask width
	SourceV4MaskWidth *Multivalue `json:"sourceV4MaskWidth,omitempty"`
	// SwitchOverInterval: (in seconds) The time interval allowed for the switch from using the RP tree to using a Source-specific tree-from (*,G) to (S,G). The default value is 0.
	SwitchOverInterval *Multivalue    `json:"switchOverInterval,omitempty"`
	Tag                []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV4JoinPruneList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV4JoinPruneList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV4JoinPruneList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV4JoinPruneList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableFlapInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFlapInfo",
		isMultivalue: true,
	})
	n.EnablePack.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePack",
		isMultivalue: true,
	})
	n.FlapInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapInterval",
		isMultivalue: true,
	})
	n.GroupAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressCount",
		isMultivalue: true,
	})
	n.GroupV4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupV4Address",
		isMultivalue: true,
	})
	n.GroupV4MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupV4MaskWidth",
		isMultivalue: true,
	})
	n.PruneSourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneSourceAddressCount",
		isMultivalue: true,
	})
	n.PruneSourceV4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneSourceV4Address",
		isMultivalue: true,
	})
	n.PruneSourceV4MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneSourceV4MaskWidth",
		isMultivalue: true,
	})
	n.RangeType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeType",
		isMultivalue: true,
	})
	n.RegisterStopTriggerCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "registerStopTriggerCount",
		isMultivalue: true,
	})
	n.RpV4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rpV4Address",
		isMultivalue: true,
	})
	n.SourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressCount",
		isMultivalue: true,
	})
	n.SourceGroupMappingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceGroupMappingType",
		isMultivalue: true,
	})
	n.SourceV4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceV4Address",
		isMultivalue: true,
	})
	n.SourceV4MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceV4MaskWidth",
		isMultivalue: true,
	})
	n.SwitchOverInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "switchOverInterval",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPimV4SourcesList: PIMv4 Sources Data
type TopologyPimV4SourcesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// DiscardSgJoinStates: If selected, the Learned Join States sent by the RP (DUT) in response to this specific Register Message will be discarded-and will not be displayed in the table of the Register Range window.
	DiscardSgJoinStates *Multivalue `json:"discardSgJoinStates,omitempty"`
	// GroupAddress: The first IPv4 multicast group address in the range of group addresses included in this Register message.
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// GroupCount: The number of group addresses to be included in this register message
	GroupCount *Multivalue `json:"groupCount,omitempty"`
	// MulticastDataLength: (in bytes) This field indicates the length of the UDP packet (the payload) within the IPv4 packet that is encapsulated in the PIM-SM Register Message sent from the DR to the DUT. The default is 64 bytes.
	MulticastDataLength *Multivalue `json:"multicastDataLength,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RegisterProbeTime: (In seconds) Part of the Register-Stop Timer (RST (S,G). Used to control the time intervals for the transmission of Null-Register messages from the Source's DR to the RP. Prior to expiration of the Register Suppression Time of the RST, a Null-Register message is sent to probe the RP, as a reminder to the RP to send a new Register-Stop message and maintain the state. If the RP does not respond with a new Register-Stop message, the Source's DR will start sending Register-encapsulated data again. The default is 5 seconds.
	RegisterProbeTime *Multivalue `json:"registerProbeTime,omitempty"`
	// RpAddress: The IP address of the Rendezvous Point (RP) router-the root of the RPT (Rendezvous Point Tree).
	RpAddress *Multivalue `json:"rpAddress,omitempty"`
	// SendNullRegAtBegin: If selected, a Null Register packet will be sent by the Ixia-emulated Designated Router (DR)/Source Range to the RP to start the message exchange. (A Null Register packet contains no data.) Regardless of whether or not the box is selected-in addition-a Null Register packet will be sent to the RP every time (just before) the Register Stop timer is about to expire on the RP. This will trigger the RP to restart the timer so it will continue sending Register Stop packets to the Ixia-emulated DR/Source Range.
	SendNullRegAtBegin *Multivalue `json:"sendNullRegAtBegin,omitempty"`
	// SourceAddress: The first IPv4 source address to be included in this Register message. (IPv4 Multicast addresses are not valid for sources.)
	SourceAddress *Multivalue `json:"sourceAddress,omitempty"`
	// SourceCount: The number of source addresses to be included in this register message
	SourceCount *Multivalue `json:"sourceCount,omitempty"`
	// SupressionTime: (In seconds) Part of the Register-Stop Timer (RST (S,G). The amount of time, following receipt of a Register-Stop message, that the DR will NOT send Register-encapsulated data to the Rendezvous Point (RP). The default is 60 seconds.
	SupressionTime *Multivalue `json:"supressionTime,omitempty"`
	// SwitchOverInterval: The time interval (in seconds) allowed for the switch from using the RP tree to using a Source-specific tree - from (*, G) to (S,G). The default value is 0.
	SwitchOverInterval *Multivalue `json:"switchOverInterval,omitempty"`
	// TxIterationGap: (in milliseconds) The gap between each iteration of the Register Range. The default is 60,000 ms (= 60 seconds). (Does not apply to NULL Registers, which contain no data.)
	TxIterationGap *Multivalue `json:"txIterationGap,omitempty"`
	// UdpDestinationPort: The number of UDP Destination Ports in the receiving Multicast Group. The default is 3000 UDP Destination Ports.
	UdpDestinationPort *Multivalue `json:"udpDestinationPort,omitempty"`
	// UdpSourcePort: The number of UDP Source Ports sending encapsulated UDP packets to MultiCast Groups (through Register Messages to the RP). The default is 3000 UDP Source Ports.
	UdpSourcePort *Multivalue    `json:"udpSourcePort,omitempty"`
	Tag           []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV4SourcesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV4SourcesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV4SourcesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV4SourcesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DiscardSgJoinStates.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardSgJoinStates",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.GroupCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCount",
		isMultivalue: true,
	})
	n.MulticastDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDataLength",
		isMultivalue: true,
	})
	n.RegisterProbeTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "registerProbeTime",
		isMultivalue: true,
	})
	n.RpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rpAddress",
		isMultivalue: true,
	})
	n.SendNullRegAtBegin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendNullRegAtBegin",
		isMultivalue: true,
	})
	n.SourceAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddress",
		isMultivalue: true,
	})
	n.SourceCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceCount",
		isMultivalue: true,
	})
	n.SupressionTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supressionTime",
		isMultivalue: true,
	})
	n.SwitchOverInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "switchOverInterval",
		isMultivalue: true,
	})
	n.TxIterationGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txIterationGap",
		isMultivalue: true,
	})
	n.UdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpDestinationPort",
		isMultivalue: true,
	})
	n.UdpSourcePort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpSourcePort",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPimV6CandidateRPsList: PIM V6 Candidate RP Ranges
type TopologyPimV6CandidateRPsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AdvertisementHoldTime: Time interval between two consecutive Candidate RP advertisements
	AdvertisementHoldTime *Multivalue `json:"advertisementHoldTime,omitempty"`
	// BackOffInterval: The back-off time interval for the C-RP-Adv messages
	BackOffInterval *Multivalue `json:"backOffInterval,omitempty"`
	// CrpAddress: Start address of the set of candidate RPs to be simulated
	CrpAddress *Multivalue `json:"crpAddress,omitempty"`
	// CrpAddressCount: Total number of Candidate RPs to be simulated starting from C-RP address
	CrpAddressCount *Multivalue `json:"crpAddressCount,omitempty"`
	// GroupAddress: Starting group address of the group range for which the candidate RP will advertise candidacy
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// GroupCount: Number of groups in the range
	GroupCount *Multivalue `json:"groupCount,omitempty"`
	// GroupMaskLen: Mask width (prefix length in bits) for the group range
	GroupMaskLen *Multivalue `json:"groupMaskLen,omitempty"`
	// MeshingType: It indicates if the mappings for groups and RP addresses are Fully-Meshed or One-To-One. One-to-one indicates that for each group only one RP shall be sent regardless of the RP count. Full meshed means for each group all RPs shall be advertised for candidacy which is essentially a (group to rp) mapping.
	MeshingType *Multivalue `json:"meshingType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeriodicAdvertisementInterval: Rate controlling variable indicating how many C-RP-Adv messages can be sent in the specified time interval
	PeriodicAdvertisementInterval *Multivalue `json:"periodicAdvertisementInterval,omitempty"`
	// Priority: Value of priority to be sent in candidate RP advertisement
	Priority *Multivalue `json:"priority,omitempty"`
	// PriorityChangeInterval: Time interval after which priority of all the RPs get changed
	PriorityChangeInterval *Multivalue `json:"priorityChangeInterval,omitempty"`
	// PriorityType: It indicates the type of priority to be held by the candidate RPs
	PriorityType *Multivalue `json:"priorityType,omitempty"`
	// TriggeredCrpMessageCount: The number of times C-RP advertisements is sent to the newly elected Bootstrap Routers
	TriggeredCrpMessageCount *Multivalue `json:"triggeredCrpMessageCount,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV6CandidateRPsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV6CandidateRPsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV6CandidateRPsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV6CandidateRPsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AdvertisementHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertisementHoldTime",
		isMultivalue: true,
	})
	n.BackOffInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backOffInterval",
		isMultivalue: true,
	})
	n.CrpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "crpAddress",
		isMultivalue: true,
	})
	n.CrpAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "crpAddressCount",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.GroupCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCount",
		isMultivalue: true,
	})
	n.GroupMaskLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupMaskLen",
		isMultivalue: true,
	})
	n.MeshingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "meshingType",
		isMultivalue: true,
	})
	n.PeriodicAdvertisementInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "periodicAdvertisementInterval",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.PriorityChangeInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priorityChangeInterval",
		isMultivalue: true,
	})
	n.PriorityType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priorityType",
		isMultivalue: true,
	})
	n.TriggeredCrpMessageCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggeredCrpMessageCount",
		isMultivalue: true,
	})
}

// TopologyPimV6Interface: PIMv6 Interface level Configuration
type TopologyPimV6Interface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AutoPickNeighbor: If selected, the time-saving Auto Pick feature is enabled-and the Upstream Neighbor field is not available for use. The Upstream Neighbor address used in the Join/Prune message is determined automatically from received Hello messages. The first time a Hello message is received-containing a Source (link-local) address that does not belong to this interface, that source address will be used as the Upstream Neighbor address. If not selected, the user can type in the link-local address in the Upstream Neighbor IP field (see Neighbor field below)-to be used for the upstream neighbor address field in the Join/Prune message.
	AutoPickNeighbor *Multivalue `json:"autoPickNeighbor,omitempty"`
	// BootstrapHashMaskLength: Hash Mask Length of the Bootstrap Router (BSR) that is set with the same name in all Bootstrap Messages sent by this BSR.
	BootstrapHashMaskLength *Multivalue `json:"bootstrapHashMaskLength,omitempty"`
	// BootstrapInterval: The time interval (in seconds) between two consecutive bootstrap messages sent by the BSR.
	BootstrapInterval *Multivalue `json:"bootstrapInterval,omitempty"`
	// BootstrapPriority: Priority of the Bootstrap Router (BSR) that is set with the same name in all Bootstrap Messages sent by this BSR.
	BootstrapPriority *Multivalue `json:"bootstrapPriority,omitempty"`
	// BootstrapTimeout: Amount of time (in seconds) of not receiving any Bootstrap Messages, after which, the BSR if candidate at that point of time will decide that the currently elected BSR has gone down and will restart BSR election procedure.
	BootstrapTimeout *Multivalue `json:"bootstrapTimeout,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// CrpRanges: Number of C-RP Ranges

	CrpRanges *float32 `json:"crpRanges,omitempty"`
	// DisableTriggered: If enabled, the triggered hello delay function is disabled.
	DisableTriggered *Multivalue `json:"disableTriggered,omitempty"`
	// DiscardLearnedRpInfo: If selected, disregards group mappings learnt from Bootstrap Message (in case not acting as elected BSR) or from Candidate RP Advertisement (in case of elected BSR).
	DiscardLearnedRpInfo *Multivalue `json:"discardLearnedRpInfo,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableBootstrap: If selected, enables the PIM-SM interface to participate in Bootstrap Router election procedure.
	EnableBootstrap *Multivalue `json:"enableBootstrap,omitempty"`
	// EnablePrune: If selected, the LAN Prune (propagation) Delay is enabled for this PIM-SM interface. (This Indicates that this option is present in the Hello message.)
	EnablePrune *Multivalue `json:"enablePrune,omitempty"`
	// ForceSemantic: If enabled, this forces the BSR to send only one group specific RP list per bootstrap message, even if there is space in the packet to push in more RP list information pertaining to a different group.
	ForceSemantic *Multivalue `json:"forceSemantic,omitempty"`
	// HelloHoldTime: The timeout period in seconds specified in Hello messages. It is the length of time the receiver of this message must keep the neighbor reachable. The default is 3.5 times the Hello Interval (105 seconds).
	HelloHoldTime *Multivalue `json:"helloHoldTime,omitempty"`
	// HelloInterval: The PIM-SM Hello Interval is the length of time in seconds between the transmissions of Hello messages. The default is 30 seconds.
	HelloInterval *Multivalue `json:"helloInterval,omitempty"`
	// JoinPrunes: Number of Join/Prunes

	JoinPrunes *float32 `json:"joinPrunes,omitempty"`
	// LanPruneTbit: If selected, the T flag bit in the LAN Prune Delay option of the Hello message is set (= 1). Setting this bit specifies that the sending PIM-SM router has the ability to disable Join message suppression
	LanPruneTbit *Multivalue `json:"lanPruneTbit,omitempty"`
	// LearnSelectedRpSet: If selected, displays the best RP per group (member of selected RP set).
	LearnSelectedRpSet *Multivalue `json:"learnSelectedRpSet,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NeighborV6Address: (Auto Pick Neighbor must be disabled/not selected to make this field active) The user can manually type in the link-local address to be used for the Upstream Neighbor address field in the Join/Prune message.
	NeighborV6Address *Multivalue `json:"neighborV6Address,omitempty"`
	// OverrideInterval: (in ms) The delay interval for randomizing the transmission time for override messages-when scheduling a delayed Join message. The default value is 2,500 milliseconds (ms). The valid range is 100 to 7FFF msec. (This is part of the LAN Prune Delay option included in Hello messages).
	OverrideInterval *Multivalue `json:"overrideInterval,omitempty"`
	// PruneDelay: (in ms) The value of the LAN Prune (propagation) Delay for this PIM-SM interface. The expected delay for messages propagated on the link. It indicates to an upstream router how long to wait for a Join override message before it prunes an interface. The default value is 500 msec. The valid range is 100 to 0x7FFF msec. (LAN Prune Delay is an Option included in Hello messages.)
	PruneDelay *Multivalue `json:"pruneDelay,omitempty"`
	// SendBidirectional: If selected, sets the bi-directional PIM-SM flag bit (= 1), per IETF DRAFT draft-ietf-pim-bidir-04. (Note: Designated Forwarder election is not currently supported.)
	SendBidirectional *Multivalue `json:"sendBidirectional,omitempty"`
	// SendGenerationIdOption: If selected, enables the Send Generation ID Option, and the Generation ID Mode field will become available to make a mode selection.
	SendGenerationIdOption *Multivalue `json:"sendGenerationIdOption,omitempty"`
	// SendGenerationMode: The mode for creating the 32-bit value for the Generation Identifier (GenID) option in the Hello message. A new GenID is created each time an interface (or router) starts or restarts PIM-SM forwarding. A change in this value indicates to the neighbor(s) that a change of state may have occurred, and that the old PIM-SM states information received from those interfaces should be discarded. Choose one of: Incremental-the GenID increases by 1 for each successive Hello Message sent from this emulated PIM-SM router. Random-each Hello message sent from this emulated PIM-SM router will have a randomly-generated GenID. Constant (the default)-the GenID remains the same in all of the Hello Messages sent from this emulated. PIM-SM router.
	SendGenerationMode *Multivalue `json:"sendGenerationMode,omitempty"`
	// Sources: Number of Sources

	Sources *float32 `json:"sources,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SupportUnicastBsm: If enabled, this supports the sending and processing of Unicast bootstrap messages.
	SupportUnicastBsm *Multivalue `json:"supportUnicastBsm,omitempty"`
	// TriggeredHelloDelay: The time (in seconds) after which the router senses a delay in sending or receiving PIM-SM hello message.
	TriggeredHelloDelay *Multivalue            `json:"triggeredHelloDelay,omitempty"`
	LearnedInfo         []*TopologyLearnedInfo `json:"learnedInfo"`

	PimV6CandidateRPsList *TopologyPimV6CandidateRPsList `json:"pimV6CandidateRPsList,omitempty"`

	PimV6JoinPruneList *TopologyPimV6JoinPruneList `json:"pimV6JoinPruneList,omitempty"`

	PimV6SourcesList *TopologyPimV6SourcesList `json:"pimV6SourcesList,omitempty"`
	Tag              []*TopologyTag            `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV6Interface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV6Interface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV6Interface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV6Interface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AutoPickNeighbor.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoPickNeighbor",
		isMultivalue: true,
	})
	n.BootstrapHashMaskLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapHashMaskLength",
		isMultivalue: true,
	})
	n.BootstrapInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapInterval",
		isMultivalue: true,
	})
	n.BootstrapPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapPriority",
		isMultivalue: true,
	})
	n.BootstrapTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bootstrapTimeout",
		isMultivalue: true,
	})
	n.DisableTriggered.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "disableTriggered",
		isMultivalue: true,
	})
	n.DiscardLearnedRpInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardLearnedRpInfo",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableBootstrap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBootstrap",
		isMultivalue: true,
	})
	n.EnablePrune.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePrune",
		isMultivalue: true,
	})
	n.ForceSemantic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forceSemantic",
		isMultivalue: true,
	})
	n.HelloHoldTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloHoldTime",
		isMultivalue: true,
	})
	n.HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloInterval",
		isMultivalue: true,
	})
	n.LanPruneTbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lanPruneTbit",
		isMultivalue: true,
	})
	n.LearnSelectedRpSet.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "learnSelectedRpSet",
		isMultivalue: true,
	})
	n.NeighborV6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "neighborV6Address",
		isMultivalue: true,
	})
	n.OverrideInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideInterval",
		isMultivalue: true,
	})
	n.PruneDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneDelay",
		isMultivalue: true,
	})
	n.SendBidirectional.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendBidirectional",
		isMultivalue: true,
	})
	n.SendGenerationIdOption.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendGenerationIdOption",
		isMultivalue: true,
	})
	n.SendGenerationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendGenerationMode",
		isMultivalue: true,
	})
	n.SupportUnicastBsm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supportUnicastBsm",
		isMultivalue: true,
	})
	n.TriggeredHelloDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "triggeredHelloDelay",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.PimV6CandidateRPsList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pimV6CandidateRPsList",
	})
	n.PimV6JoinPruneList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pimV6JoinPruneList",
	})
	n.PimV6SourcesList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pimV6SourcesList",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPimV6JoinPruneList: PIM V6 Join Prune Data
type TopologyPimV6JoinPruneList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// EnableFlapInfo: If selected, enables this Source entry for use in PIM-SM Register messages.
	EnableFlapInfo *Multivalue `json:"enableFlapInfo,omitempty"`
	// EnablePack: If enabled, Multiple Groups can be included within a single packet.
	EnablePack *Multivalue `json:"enablePack,omitempty"`
	// FlapInterval: (in seconds) Specifies the amount of time between emulated flap events. The default is 60 seconds.
	FlapInterval *Multivalue `json:"flapInterval,omitempty"`
	// GroupAddressCount: The number of multicast group addresses to be included in the multicast group range. The maximum number of valid possible addresses depends on the values for the Group Address and the Group Mask Width. The default value is 1.
	GroupAddressCount *Multivalue `json:"groupAddressCount,omitempty"`
	// GroupV6Address: An IPv6 address-used with the Group Mask to create a range of multicast addresses.
	GroupV6Address *Multivalue `json:"groupV6Address,omitempty"`
	// GroupV6MaskWidth: The number of bits in the mask applied to the Group Address. (The masked bits in the Group Address form the address prefix.) The default value is 32. The valid range is 1 to 128, depending on address family type.
	GroupV6MaskWidth *Multivalue `json:"groupV6MaskWidth,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PruneSourceAddressCount: The number of Prune Source addresses to be included. The maximum number of valid possible addresses depends on the values for the Source Address and the Source Mask Width. The default value is 0. ONLY used for (*,G) Type to send (S,G,rpt) Prune Messages.
	PruneSourceAddressCount *Multivalue `json:"pruneSourceAddressCount,omitempty"`
	// PruneSourceV6Address: ONLY used for (*,G) Type to send (S,G,rpt) Prune Messages. (Multicast addresses are invalid.)
	PruneSourceV6Address *Multivalue `json:"pruneSourceV6Address,omitempty"`
	// PruneSourceV6MaskWidth: The number of bits in the mask applied to the Prune Source Address. (The masked bits in the Prune Source Address form the address prefix.) The default value is 32. The valid range is 1 to 128, depending on address family type. ONLY used for (*,G) Type to send (S,G,rpt) Prune Messages.
	PruneSourceV6MaskWidth *Multivalue `json:"pruneSourceV6MaskWidth,omitempty"`
	// RangeType: The Multicast Range Type. Choose one of: (*, *, RP)-Wildcard Group Set. For (*,*, RP) Join/Prune messages. Refers to all Groups associated with this specific RP. (*, G)-Group Specific type. For (*,G) Join/Prune messages. Refers to all sources associated with a specific Group G on the RP tree. (S, G)-Source specific type. For (S,G) Join/Prune messages. Refers only to specific combination of Source S and Group G. (*, G) -> (S, G)-Switchover type. (For switchover from non-source specific group state to source-specific group state.) Register Triggered (S,G)-These are the ranges of multicast group address and unicast source address to which a PIM-SM Router emulating an RP (for those source-group combinations) will send Triggered (S,G) joins and Register-Stop messages after receiving Register messages.
	RangeType *Multivalue `json:"rangeType,omitempty"`
	// RegisterStopTriggerCount: Available ONLY for use with Register Triggered (S,G) Range Type. (Default = 10)
	RegisterStopTriggerCount *Multivalue `json:"registerStopTriggerCount,omitempty"`
	// RpV6Address: The IP address of the Rendezvous Point (RP) router-the root of the RP shared multicast distribution tree (RPT).
	RpV6Address *Multivalue `json:"rpV6Address,omitempty"`
	// SourceAddressCount: The number of multicast source addresses to be included. The maximum number of valid possible addresses depends on the values for the Source Address and the Source Mask Width. The default value is 0.
	SourceAddressCount *Multivalue `json:"sourceAddressCount,omitempty"`
	// SourceGroupMappingType: Choose one of: Fully-meshed, One-to-One
	SourceGroupMappingType *Multivalue `json:"sourceGroupMappingType,omitempty"`
	// SourceV6Address: The Multicast Source Address. Used for (S,G) Type and (S,G, rpt) only. (Multicast addresses are invalid.)
	SourceV6Address *Multivalue `json:"sourceV6Address,omitempty"`
	// SourceV6MaskWidth: The number of bits in the mask applied to the Source Address. (The masked bits in the Source Address form the address prefix.) The default value is 32. The valid range is 1 to 128, depending on address family type. Used for (S,G) Type and (S,G, rpt) only.
	SourceV6MaskWidth *Multivalue `json:"sourceV6MaskWidth,omitempty"`
	// SwitchOverInterval: (in seconds) The time interval allowed for the switch from using the RP tree to using a Source-specific tree-from (*,G) to (S,G). The default value is 0.
	SwitchOverInterval *Multivalue    `json:"switchOverInterval,omitempty"`
	Tag                []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV6JoinPruneList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV6JoinPruneList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV6JoinPruneList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV6JoinPruneList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableFlapInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFlapInfo",
		isMultivalue: true,
	})
	n.EnablePack.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePack",
		isMultivalue: true,
	})
	n.FlapInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "flapInterval",
		isMultivalue: true,
	})
	n.GroupAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddressCount",
		isMultivalue: true,
	})
	n.GroupV6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupV6Address",
		isMultivalue: true,
	})
	n.GroupV6MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupV6MaskWidth",
		isMultivalue: true,
	})
	n.PruneSourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneSourceAddressCount",
		isMultivalue: true,
	})
	n.PruneSourceV6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneSourceV6Address",
		isMultivalue: true,
	})
	n.PruneSourceV6MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pruneSourceV6MaskWidth",
		isMultivalue: true,
	})
	n.RangeType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rangeType",
		isMultivalue: true,
	})
	n.RegisterStopTriggerCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "registerStopTriggerCount",
		isMultivalue: true,
	})
	n.RpV6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rpV6Address",
		isMultivalue: true,
	})
	n.SourceAddressCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddressCount",
		isMultivalue: true,
	})
	n.SourceGroupMappingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceGroupMappingType",
		isMultivalue: true,
	})
	n.SourceV6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceV6Address",
		isMultivalue: true,
	})
	n.SourceV6MaskWidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceV6MaskWidth",
		isMultivalue: true,
	})
	n.SwitchOverInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "switchOverInterval",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPimV6SourcesList: PIMv6 Sources Data
type TopologyPimV6SourcesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// DiscardSgJoinStates: If selected, the Learned Join States sent by the RP (DUT) in response to this specific Register Message will be discarded-and will not be displayed in the table of the Register Range window.
	DiscardSgJoinStates *Multivalue `json:"discardSgJoinStates,omitempty"`
	// GroupAddress: The first IPv6 multicast group address in the range of group addresses included in this Register message.
	GroupAddress *Multivalue `json:"groupAddress,omitempty"`
	// GroupCount: The number of group addresses to be included in this register message
	GroupCount *Multivalue `json:"groupCount,omitempty"`
	// MulticastDataLength: (in bytes) This field indicates the length of the UDP packet (the payload) within the IPv4 packet that is encapsulated in the PIM-SM Register Message sent from the DR to the DUT. The default is 64 bytes.
	MulticastDataLength *Multivalue `json:"multicastDataLength,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RegisterProbeTime: (In seconds) Part of the Register-Stop Timer (RST (S,G). Used to control the time intervals for the transmission of Null-Register messages from the Source's DR to the RP. Prior to expiration of the Register Suppression Time of the RST, a Null-Register message is sent to probe the RP, as a reminder to the RP to send a new Register-Stop message and maintain the state. If the RP does not respond with a new Register-Stop message, the Source's DR will start sending Register-encapsulated data again. The default is 5 seconds.
	RegisterProbeTime *Multivalue `json:"registerProbeTime,omitempty"`
	// RpAddress: The IP address of the Rendezvous Point (RP) router-the root of the RPT (Rendezvous Point Tree).
	RpAddress *Multivalue `json:"rpAddress,omitempty"`
	// SendNullRegAtBegin: If selected, a Null Register packet will be sent by the Ixia-emulated Designated Router (DR)/Source Range to the RP to start the message exchange. (A Null Register packet contains no data.) Regardless of whether or not the box is selected-in addition-a Null Register packet will be sent to the RP every time (just before) the Register Stop timer is about to expire on the RP. This will trigger the RP to restart the timer so it will continue sending Register Stop packets to the Ixia-emulated DR/Source Range.
	SendNullRegAtBegin *Multivalue `json:"sendNullRegAtBegin,omitempty"`
	// SourceAddress: The first IPv6 source address to be included in this Register message.
	SourceAddress *Multivalue `json:"sourceAddress,omitempty"`
	// SourceCount: The number of source addresses to be included in this register message
	SourceCount *Multivalue `json:"sourceCount,omitempty"`
	// SupressionTime: (In seconds) Part of the Register-Stop Timer (RST (S,G). The amount of time, following receipt of a Register-Stop message, that the DR will NOT send Register-encapsulated data to the Rendezvous Point (RP). The default is 60 seconds.
	SupressionTime *Multivalue `json:"supressionTime,omitempty"`
	// SwitchOverInterval: The time interval (in seconds) allowed for the switch from using the RP tree to using a Source-specific tree - from (*, G) to (S,G). The default value is 0.
	SwitchOverInterval *Multivalue `json:"switchOverInterval,omitempty"`
	// TxIterationGap: (in milliseconds) The gap between each iteration of the Register Range. The default is 60,000 ms (= 60 seconds). (Does not apply to NULL Registers, which contain no data.)
	TxIterationGap *Multivalue `json:"txIterationGap,omitempty"`
	// UdpDestinationPort: The number of UDP Destination Ports in the receiving Multicast Group. The default is 3000 UDP Destination Ports.
	UdpDestinationPort *Multivalue `json:"udpDestinationPort,omitempty"`
	// UdpSourcePort: The number of UDP Source Ports sending encapsulated UDP packets to MultiCast Groups (through Register Messages to the RP). The default is 3000 UDP Source Ports.
	UdpSourcePort *Multivalue    `json:"udpSourcePort,omitempty"`
	Tag           []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPimV6SourcesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPimV6SourcesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPimV6SourcesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPimV6SourcesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DiscardSgJoinStates.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "discardSgJoinStates",
		isMultivalue: true,
	})
	n.GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupAddress",
		isMultivalue: true,
	})
	n.GroupCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupCount",
		isMultivalue: true,
	})
	n.MulticastDataLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastDataLength",
		isMultivalue: true,
	})
	n.RegisterProbeTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "registerProbeTime",
		isMultivalue: true,
	})
	n.RpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rpAddress",
		isMultivalue: true,
	})
	n.SendNullRegAtBegin.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendNullRegAtBegin",
		isMultivalue: true,
	})
	n.SourceAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceAddress",
		isMultivalue: true,
	})
	n.SourceCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceCount",
		isMultivalue: true,
	})
	n.SupressionTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "supressionTime",
		isMultivalue: true,
	})
	n.SwitchOverInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "switchOverInterval",
		isMultivalue: true,
	})
	n.TxIterationGap.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txIterationGap",
		isMultivalue: true,
	})
	n.UdpDestinationPort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpDestinationPort",
		isMultivalue: true,
	})
	n.UdpSourcePort.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "udpSourcePort",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPlspId: TBD
type TopologyPlspId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPlspId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPlspId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPlspId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPlspId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyPnTlvList: MVPN Opaque TLV
type TopologyPnTlvList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Increment: Increment Step
	Increment *Multivalue `json:"increment,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TlvLength: Length
	TlvLength *Multivalue `json:"tlvLength,omitempty"`
	// Type_: Type
	Type_ *Multivalue `json:"type,omitempty"`
	// Value: Value
	Value *Multivalue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPnTlvList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPnTlvList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPnTlvList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPnTlvList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Increment.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "increment",
		isMultivalue: true,
	})
	n.TlvLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tlvLength",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
	n.Value.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "value",
		isMultivalue: true,
	})
}

// TopologyPppoxServerSessions: PPPoX Server Sessions.
type TopologyPppoxServerSessions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ChapName: User name when CHAP Authentication is being used
	ChapName *Multivalue `json:"chapName,omitempty"`
	// ChapSecret: Secret when CHAP Authentication is being used
	ChapSecret *Multivalue `json:"chapSecret,omitempty"`
	// DomainList: Configure domain group settings
	DomainList *Multivalue `json:"domainList,omitempty"`
	// EnableDomainGroups: Enable domain groups
	EnableDomainGroups *Multivalue `json:"enableDomainGroups,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PapPassword: Password when PAP Authentication is being used
	PapPassword *Multivalue `json:"papPassword,omitempty"`
	// PapUser: User name when PAP Authentication is being used
	PapUser *Multivalue    `json:"papUser,omitempty"`
	Tag     []*TopologyTag `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPppoxServerSessions) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPppoxServerSessions) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPppoxServerSessions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPppoxServerSessions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ChapName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chapName",
		isMultivalue: true,
	})
	n.ChapSecret.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chapSecret",
		isMultivalue: true,
	})
	n.DomainList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "domainList",
		isMultivalue: true,
	})
	n.EnableDomainGroups.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDomainGroups",
		isMultivalue: true,
	})
	n.PapPassword.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "papPassword",
		isMultivalue: true,
	})
	n.PapUser.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "papUser",
		isMultivalue: true,
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPppoxclient: PPPoX Client
type TopologyPppoxclient struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AcMatchMac: ?
	AcMatchMac *Multivalue `json:"acMatchMac,omitempty"`
	// AcMatchName: ?
	AcMatchName *Multivalue `json:"acMatchName,omitempty"`
	// AcOptions: Indicates PPPoE AC retrieval mode
	AcOptions *Multivalue `json:"acOptions,omitempty"`
	// ActualRateDownstream: This parameter specifies the value to be included in the vendor specific PPPoE tag. It is the actual downstream data rate (sub-option 0x81), in kbps.
	ActualRateDownstream *Multivalue `json:"actualRateDownstream,omitempty"`
	// ActualRateUpstream: This parameter specifies the value to be included in the vendor specific PPPoE tag. It is the actual upstream data rate (sub-option 0x82), in kbps.
	ActualRateUpstream *Multivalue `json:"actualRateUpstream,omitempty"`
	// AgentAccessAggregationCircuitId: The value to be inserted into the Agent Access-Aggregation-Circuit-ID-ASCII-Value field of the PPPoX tag.
	AgentAccessAggregationCircuitId *Multivalue `json:"agentAccessAggregationCircuitId,omitempty"`
	// AgentCircuitId: The value to be inserted into the Agent Circuit ID field of the PPPoX tag.
	AgentCircuitId *Multivalue `json:"agentCircuitId,omitempty"`
	// AgentRemoteId: The value to be inserted into the Agent Remote ID field of the PPPoX tag.
	AgentRemoteId *Multivalue `json:"agentRemoteId,omitempty"`
	// AuthRetries: Number of PPP authentication retries
	AuthRetries *Multivalue `json:"authRetries,omitempty"`
	// AuthTimeout: Timeout for PPP authentication, in seconds.
	AuthTimeout *Multivalue `json:"authTimeout,omitempty"`
	// AuthType: The authentication type to use during link setup.
	AuthType *Multivalue `json:"authType,omitempty"`
	// ChapName: User name when CHAP Authentication is being used
	ChapName *Multivalue `json:"chapName,omitempty"`
	// ChapSecret: Secret when CHAP Authentication is being used
	ChapSecret *Multivalue `json:"chapSecret,omitempty"`
	// ClientDnsOptions: The client DNS options.
	ClientDnsOptions *Multivalue `json:"clientDnsOptions,omitempty"`
	// ClientLocalIp: The requested IPv4 address.
	ClientLocalIp *Multivalue `json:"clientLocalIp,omitempty"`
	// ClientLocalIpv6Iid: The requested IPv6 Interface Identifier (IID).
	ClientLocalIpv6Iid *Multivalue `json:"clientLocalIpv6Iid,omitempty"`
	// ClientNcpOptions: The NCP configuration mode for IPv4 addressing.
	ClientNcpOptions *Multivalue `json:"clientNcpOptions,omitempty"`
	// ClientNetmask: The netmask that the client will use with the assigned IP address.
	ClientNetmask *Multivalue `json:"clientNetmask,omitempty"`
	// ClientNetmaskOptions: The client netmask option.
	ClientNetmaskOptions *Multivalue `json:"clientNetmaskOptions,omitempty"`
	// ClientPrimaryDnsAddress: This is the primary DNS server address that the client requests from the server when the value of the Client DNS Options field is set to 'Request Primary only' or 'Request Primary and Secondary'.
	ClientPrimaryDnsAddress *Multivalue `json:"clientPrimaryDnsAddress,omitempty"`
	// ClientSecondaryDnsAddress: This is the secondary DNS server address that the client requests from the server when the value of the Client DNS Options field is set to 'Request Primary and Secondary'.
	ClientSecondaryDnsAddress *Multivalue `json:"clientSecondaryDnsAddress,omitempty"`
	// ClientSignalIWF: This parameter enables or disables the insertion of sub-option 0xFE (signaling of interworked sessions) into the DSL tag in PADI and PADR packets.
	ClientSignalIWF *Multivalue `json:"clientSignalIWF,omitempty"`
	// ClientSignalLoopChar: This parameter enables or disables the insertion of sub-options 0x81 and 0x82 into the DSL tag in PADI and PADR packets.
	ClientSignalLoopChar *Multivalue `json:"clientSignalLoopChar,omitempty"`
	// ClientSignalLoopEncapsulation: This parameter enables or disables the insertion of sub-option 0x90 into the DSL tag in PADI and PADR packets.
	ClientSignalLoopEncapsulation *Multivalue `json:"clientSignalLoopEncapsulation,omitempty"`
	// ClientSignalLoopId: This parameter enables or disables the insertion of sub-options 0x01 , 0x02, 0x03 (Remote ID,Circuit ID and Access Aggregation Circuit ID) into the DSL tag in PADI and PADR packets.
	ClientSignalLoopId *Multivalue `json:"clientSignalLoopId,omitempty"`
	// ClientV6NcpOptions: The NCP configuration mode for IPv6 addressing.
	ClientV6NcpOptions *Multivalue `json:"clientV6NcpOptions,omitempty"`
	// ClientWinsOptions: Specifies the mode in which WINS host addresses are configured.
	ClientWinsOptions *Multivalue `json:"clientWinsOptions,omitempty"`
	// ClientWinsPrimaryAddress: Specifies the primary WINS address.
	ClientWinsPrimaryAddress *Multivalue `json:"clientWinsPrimaryAddress,omitempty"`
	// ClientWinsSecondaryAddress: Specifies the secondary WINS address.
	ClientWinsSecondaryAddress *Multivalue `json:"clientWinsSecondaryAddress,omitempty"`
	// ConnectSpeedUpdateEnable: If checked, LAC will send Connect Speed Update Enable AVP in ICRQ control message
	ConnectSpeedUpdateEnable *Multivalue `json:"connectSpeedUpdateEnable,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DataLink: A one-byte field included with sub-option 0x90.
	DataLink *Multivalue `json:"dataLink,omitempty"`
	// DomainList: Configure domain group settings
	DomainList *Multivalue `json:"domainList,omitempty"`
	// DslTypeTlv: DSL Type to be advertised in PPPoE VSA Tag. For undefined DSL type user has to select User-defined DSL Type.
	DslTypeTlv *Multivalue `json:"dslTypeTlv,omitempty"`
	// EchoReqInterval: Keep alive interval, in seconds
	EchoReqInterval *Multivalue `json:"echoReqInterval,omitempty"`
	// EnableDomainGroups: Enable domain groups
	EnableDomainGroups *Multivalue `json:"enableDomainGroups,omitempty"`
	// EnableEchoReq: ?
	EnableEchoReq *Multivalue `json:"enableEchoReq,omitempty"`
	// EnableEchoRsp: ?
	EnableEchoRsp *Multivalue `json:"enableEchoRsp,omitempty"`
	// EnableHostUniq: Enables PPPoE Host-Uniq tag
	EnableHostUniq *Multivalue `json:"enableHostUniq,omitempty"`
	// EnableMaxPayload: Enables PPPoE Max Payload tag
	EnableMaxPayload *Multivalue `json:"enableMaxPayload,omitempty"`
	// EnableRedial: If checked, PPPoE redial is enabled
	EnableRedial *Multivalue `json:"enableRedial,omitempty"`
	// Encaps1: A one-byte field included with sub-option 0x90.
	Encaps1 *Multivalue `json:"encaps1,omitempty"`
	// Encaps2: A one-byte field included with sub-option 0x90.
	Encaps2 *Multivalue `json:"encaps2,omitempty"`
	// EndpointDiscNegotiation: Enable Endpoint Discriminator Negotiation
	EndpointDiscNegotiation *Multivalue `json:"endpointDiscNegotiation,omitempty"`
	// EndpointDiscriminatorClass: Endpoint Discriminator for PPP
	EndpointDiscriminatorClass *Multivalue `json:"endpointDiscriminatorClass,omitempty"`
	// HostUniq: Indicates Host-Uniq Tag
	HostUniq *Multivalue `json:"hostUniq,omitempty"`
	// HostUniqLength: Host-Uniq Length, in bytes
	HostUniqLength *Multivalue `json:"hostUniqLength,omitempty"`
	// LcpAccm: Async-Control-Character-Map
	LcpAccm *Multivalue `json:"lcpAccm,omitempty"`
	// LcpEnableAccm: Enable Async-Control-Character-Map
	LcpEnableAccm *Multivalue `json:"lcpEnableAccm,omitempty"`
	// LcpMaxFailure: Number of Configure-Nak packets sent without sending a Configure-Ack before assuming that configuration is not converging. Any further Configure-Nak packets for peer requested options are converted to Configure-Reject packets
	LcpMaxFailure *Multivalue `json:"lcpMaxFailure,omitempty"`
	// LcpRetries: Number of LCP retries
	LcpRetries *Multivalue `json:"lcpRetries,omitempty"`
	// LcpStartDelay: Delay time in milliseconds to wait before sending LCP Config Request packet
	LcpStartDelay *Multivalue `json:"lcpStartDelay,omitempty"`
	// LcpTermRetries: Number of LCP Termination Retries
	LcpTermRetries *Multivalue `json:"lcpTermRetries,omitempty"`
	// LcpTimeout: Timeout for LCP phase, in seconds
	LcpTimeout *Multivalue `json:"lcpTimeout,omitempty"`
	// MaxPayload: Max Payload
	MaxPayload *Multivalue `json:"maxPayload,omitempty"`
	// MlpppIPAddress: The IP address used in the ML-PPP endpoint discriminator option of the LCP configure request sent by PPP clients
	MlpppIPAddress *Multivalue `json:"mlpppIPAddress,omitempty"`
	// MlpppMACAddress: The MAC addresses are automatically derived from the local MAC address. An address in this class contains an IEEE 802.1 MAC address is canonical (802.3) format
	MlpppMACAddress *Multivalue `json:"mlpppMACAddress,omitempty"`
	// Mrru: Max Receive Reconstructed Unit for PPP
	Mrru *Multivalue `json:"mrru,omitempty"`
	// MrruNegotiation: Enable MRRU Negotiation
	MrruNegotiation *Multivalue `json:"mrruNegotiation,omitempty"`
	// MruNegotiation: Enable MRU Negotiation
	MruNegotiation *Multivalue `json:"mruNegotiation,omitempty"`
	// Mtu: Max Transmit Unit for PPP
	Mtu *Multivalue `json:"mtu,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NcpRetries: Number of NCP retries
	NcpRetries *Multivalue `json:"ncpRetries,omitempty"`
	// NcpTimeout: Timeout for NCP phase, in seconds
	NcpTimeout *Multivalue `json:"ncpTimeout,omitempty"`
	// NcpType: IP address type (IPv4 or IPv6) for Network Control Protocol
	NcpType *Multivalue `json:"ncpType,omitempty"`
	// PadiRetries: Number of PADI Retries
	PadiRetries *Multivalue `json:"padiRetries,omitempty"`
	// PadiTimeout: Timeout for PADI no response, in seconds
	PadiTimeout *Multivalue `json:"padiTimeout,omitempty"`
	// PadrRetries: Number of PADR Retries
	PadrRetries *Multivalue `json:"padrRetries,omitempty"`
	// PadrTimeout: Timeout for PADR no response, in seconds
	PadrTimeout *Multivalue `json:"padrTimeout,omitempty"`
	// PapPassword: Password when PAP Authentication is being used
	PapPassword *Multivalue `json:"papPassword,omitempty"`
	// PapUser: User name when PAP Authentication is being used
	PapUser *Multivalue `json:"papUser,omitempty"`
	// PonTypeTlv: PON Type to be advertised in PPPoE VSA Tag. For undefined PON type user has to select User-defined PON Type.
	PonTypeTlv *Multivalue `json:"ponTypeTlv,omitempty"`
	// RedialMax: Maximum number of PPPoE redials
	RedialMax *Multivalue `json:"redialMax,omitempty"`
	// RedialTimeout: PPPoE redial timeout, in seconds
	RedialTimeout *Multivalue `json:"redialTimeout,omitempty"`
	// RxConnectSpeed: Rx Connection Speed
	RxConnectSpeed *Multivalue `json:"rxConnectSpeed,omitempty"`
	// ServiceName: Access Concentrator Service Name - this option is only available for PPP servers.
	ServiceName *Multivalue `json:"serviceName,omitempty"`
	// ServiceOptions: Indicates PPPoE service retrieval mode
	ServiceOptions *Multivalue `json:"serviceOptions,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// TxConnectSpeed: Tx Connection Speed
	TxConnectSpeed *Multivalue `json:"txConnectSpeed,omitempty"`
	// UnlimitedRedialAttempts: If checked, PPPoE unlimited redial attempts is enabled
	UnlimitedRedialAttempts *Multivalue `json:"unlimitedRedialAttempts,omitempty"`
	// UserDefinedDslType: User Defined DSL-Type Value.
	UserDefinedDslType *Multivalue `json:"userDefinedDslType,omitempty"`
	// UserDefinedPonType: User Defined PON-Type Value.
	UserDefinedPonType *Multivalue               `json:"userDefinedPonType,omitempty"`
	Bfdv4Interface     []*TopologyBfdv4Interface `json:"bfdv4Interface"`
	Bfdv6Interface     []*TopologyBfdv6Interface `json:"bfdv6Interface"`
	BgpIpv4Peer        []*TopologyBgpIpv4Peer    `json:"bgpIpv4Peer"`
	BgpIpv6Peer        []*TopologyBgpIpv6Peer    `json:"bgpIpv6Peer"`

	Connector      *TopologyConnector        `json:"connector,omitempty"`
	Dhcpv6client   []*TopologyDhcpv6client   `json:"dhcpv6client"`
	ECpriRe        []*TopologyECpriRe        `json:"eCpriRe"`
	ECpriRec       []*TopologyECpriRec       `json:"eCpriRec"`
	Geneve         []*TopologyGeneve         `json:"geneve"`
	IgmpHost       []*TopologyIgmpHost       `json:"igmpHost"`
	IgmpQuerier    []*TopologyIgmpQuerier    `json:"igmpQuerier"`
	MldHost        []*TopologyMldHost        `json:"mldHost"`
	MldQuerier     []*TopologyMldQuerier     `json:"mldQuerier"`
	MplsOam        []*TopologyMplsOam        `json:"mplsOam"`
	NetconfClient  []*TopologyNetconfClient  `json:"netconfClient"`
	NetconfServer  []*TopologyNetconfServer  `json:"netconfServer"`
	Ospfv2         []*TopologyOspfv2         `json:"ospfv2"`
	Ospfv3         []*TopologyOspfv3         `json:"ospfv3"`
	Pcc            []*TopologyPcc            `json:"pcc"`
	Pce            []*TopologyPce            `json:"pce"`
	PimV4Interface []*TopologyPimV4Interface `json:"pimV4Interface"`
	PimV6Interface []*TopologyPimV6Interface `json:"pimV6Interface"`
	Tag            []*TopologyTag            `json:"tag"`
	TlvProfile     []*TopologyTlvProfile     `json:"tlvProfile"`
	Vxlan          []*TopologyVxlan          `json:"vxlan"`
	Vxlanv6        []*TopologyVxlanv6        `json:"vxlanv6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPppoxclient) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPppoxclient) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPppoxclient) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPppoxclient) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AcMatchMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "acMatchMac",
		isMultivalue: true,
	})
	n.AcMatchName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "acMatchName",
		isMultivalue: true,
	})
	n.AcOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "acOptions",
		isMultivalue: true,
	})
	n.ActualRateDownstream.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actualRateDownstream",
		isMultivalue: true,
	})
	n.ActualRateUpstream.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actualRateUpstream",
		isMultivalue: true,
	})
	n.AgentAccessAggregationCircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "agentAccessAggregationCircuitId",
		isMultivalue: true,
	})
	n.AgentCircuitId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "agentCircuitId",
		isMultivalue: true,
	})
	n.AgentRemoteId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "agentRemoteId",
		isMultivalue: true,
	})
	n.AuthRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authRetries",
		isMultivalue: true,
	})
	n.AuthTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authTimeout",
		isMultivalue: true,
	})
	n.AuthType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authType",
		isMultivalue: true,
	})
	n.ChapName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chapName",
		isMultivalue: true,
	})
	n.ChapSecret.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "chapSecret",
		isMultivalue: true,
	})
	n.ClientDnsOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientDnsOptions",
		isMultivalue: true,
	})
	n.ClientLocalIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientLocalIp",
		isMultivalue: true,
	})
	n.ClientLocalIpv6Iid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientLocalIpv6Iid",
		isMultivalue: true,
	})
	n.ClientNcpOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientNcpOptions",
		isMultivalue: true,
	})
	n.ClientNetmask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientNetmask",
		isMultivalue: true,
	})
	n.ClientNetmaskOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientNetmaskOptions",
		isMultivalue: true,
	})
	n.ClientPrimaryDnsAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientPrimaryDnsAddress",
		isMultivalue: true,
	})
	n.ClientSecondaryDnsAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientSecondaryDnsAddress",
		isMultivalue: true,
	})
	n.ClientSignalIWF.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientSignalIWF",
		isMultivalue: true,
	})
	n.ClientSignalLoopChar.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientSignalLoopChar",
		isMultivalue: true,
	})
	n.ClientSignalLoopEncapsulation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientSignalLoopEncapsulation",
		isMultivalue: true,
	})
	n.ClientSignalLoopId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientSignalLoopId",
		isMultivalue: true,
	})
	n.ClientV6NcpOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientV6NcpOptions",
		isMultivalue: true,
	})
	n.ClientWinsOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientWinsOptions",
		isMultivalue: true,
	})
	n.ClientWinsPrimaryAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientWinsPrimaryAddress",
		isMultivalue: true,
	})
	n.ClientWinsSecondaryAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientWinsSecondaryAddress",
		isMultivalue: true,
	})
	n.ConnectSpeedUpdateEnable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "connectSpeedUpdateEnable",
		isMultivalue: true,
	})
	n.DataLink.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataLink",
		isMultivalue: true,
	})
	n.DomainList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "domainList",
		isMultivalue: true,
	})
	n.DslTypeTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dslTypeTlv",
		isMultivalue: true,
	})
	n.EchoReqInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoReqInterval",
		isMultivalue: true,
	})
	n.EnableDomainGroups.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDomainGroups",
		isMultivalue: true,
	})
	n.EnableEchoReq.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEchoReq",
		isMultivalue: true,
	})
	n.EnableEchoRsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEchoRsp",
		isMultivalue: true,
	})
	n.EnableHostUniq.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHostUniq",
		isMultivalue: true,
	})
	n.EnableMaxPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMaxPayload",
		isMultivalue: true,
	})
	n.EnableRedial.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRedial",
		isMultivalue: true,
	})
	n.Encaps1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "encaps1",
		isMultivalue: true,
	})
	n.Encaps2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "encaps2",
		isMultivalue: true,
	})
	n.EndpointDiscNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endpointDiscNegotiation",
		isMultivalue: true,
	})
	n.EndpointDiscriminatorClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endpointDiscriminatorClass",
		isMultivalue: true,
	})
	n.HostUniq.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostUniq",
		isMultivalue: true,
	})
	n.HostUniqLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hostUniqLength",
		isMultivalue: true,
	})
	n.LcpAccm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpAccm",
		isMultivalue: true,
	})
	n.LcpEnableAccm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpEnableAccm",
		isMultivalue: true,
	})
	n.LcpMaxFailure.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpMaxFailure",
		isMultivalue: true,
	})
	n.LcpRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpRetries",
		isMultivalue: true,
	})
	n.LcpStartDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpStartDelay",
		isMultivalue: true,
	})
	n.LcpTermRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpTermRetries",
		isMultivalue: true,
	})
	n.LcpTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpTimeout",
		isMultivalue: true,
	})
	n.MaxPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxPayload",
		isMultivalue: true,
	})
	n.MlpppIPAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mlpppIPAddress",
		isMultivalue: true,
	})
	n.MlpppMACAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mlpppMACAddress",
		isMultivalue: true,
	})
	n.Mrru.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mrru",
		isMultivalue: true,
	})
	n.MrruNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mrruNegotiation",
		isMultivalue: true,
	})
	n.MruNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mruNegotiation",
		isMultivalue: true,
	})
	n.Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtu",
		isMultivalue: true,
	})
	n.NcpRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ncpRetries",
		isMultivalue: true,
	})
	n.NcpTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ncpTimeout",
		isMultivalue: true,
	})
	n.NcpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ncpType",
		isMultivalue: true,
	})
	n.PadiRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "padiRetries",
		isMultivalue: true,
	})
	n.PadiTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "padiTimeout",
		isMultivalue: true,
	})
	n.PadrRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "padrRetries",
		isMultivalue: true,
	})
	n.PadrTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "padrTimeout",
		isMultivalue: true,
	})
	n.PapPassword.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "papPassword",
		isMultivalue: true,
	})
	n.PapUser.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "papUser",
		isMultivalue: true,
	})
	n.PonTypeTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ponTypeTlv",
		isMultivalue: true,
	})
	n.RedialMax.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redialMax",
		isMultivalue: true,
	})
	n.RedialTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redialTimeout",
		isMultivalue: true,
	})
	n.RxConnectSpeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxConnectSpeed",
		isMultivalue: true,
	})
	n.ServiceName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serviceName",
		isMultivalue: true,
	})
	n.ServiceOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serviceOptions",
		isMultivalue: true,
	})
	n.TxConnectSpeed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txConnectSpeed",
		isMultivalue: true,
	})
	n.UnlimitedRedialAttempts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "unlimitedRedialAttempts",
		isMultivalue: true,
	})
	n.UserDefinedDslType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefinedDslType",
		isMultivalue: true,
	})
	n.UserDefinedPonType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "userDefinedPonType",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Bfdv6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Dhcpv6client {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6client",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Geneve {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "geneve",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MplsOam {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsOam",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfClient {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfClient",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfServer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfServer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv2 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv2",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pcc {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcc",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pce {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pce",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TlvProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlvProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlanv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlanv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPppoxserver: PPPoX Server
type TopologyPppoxserver struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AcName: Access Concentrator Name - this option is only available for PPP servers.
	AcName *Multivalue `json:"acName,omitempty"`
	// AcceptAnyAuthValue: Configures a PAP/CHAP authenticator to accept all offered usernames, passwords, and base domain names
	AcceptAnyAuthValue *Multivalue `json:"acceptAnyAuthValue,omitempty"`
	// AuthRetries: Number of PPP authentication retries
	AuthRetries *Multivalue `json:"authRetries,omitempty"`
	// AuthTimeout: Timeout for PPP authentication, in seconds.
	AuthTimeout *Multivalue `json:"authTimeout,omitempty"`
	// AuthType: The authentication type to use during link setup.
	AuthType *Multivalue `json:"authType,omitempty"`
	// ClientBaseIID: Obsolete - use clientIID instead.
	ClientBaseIID *Multivalue `json:"clientBaseIID,omitempty"`
	// ClientBaseIp: The base IP address to be used when creating PPP client addresses. This property is used as an incrementor for the 'clientIpIncr' property
	ClientBaseIp *Multivalue `json:"clientBaseIp,omitempty"`
	// ClientIID: The base IPv6CP (RFC5072) interface identifier for the PPP client. Used in conjunction with 'clientIIDIncr' as its incrementor. Valid for IPv6 only. The identifier is used in assigned global and local scope addresses created after negotiation.
	ClientIID *Multivalue `json:"clientIID,omitempty"`
	// ClientIIDIncr: Client IPv6CP interface identifier increment, used in conjuction with the base identifier
	ClientIIDIncr *Multivalue `json:"clientIIDIncr,omitempty"`
	// ClientIpIncr: The incrementor for the clientBaseIp property address when multiple PPP addresses are created.
	ClientIpIncr *Multivalue `json:"clientIpIncr,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DnsServerList: DNS server list separacted by semicolon
	DnsServerList *Multivalue `json:"dnsServerList,omitempty"`
	// EchoReqInterval: Keep alive interval, in seconds
	EchoReqInterval *Multivalue `json:"echoReqInterval,omitempty"`
	// EnableDnsRa: Enable RDNSS routing advertisments
	EnableDnsRa *Multivalue `json:"enableDnsRa,omitempty"`
	// EnableEchoReq: ?
	EnableEchoReq *Multivalue `json:"enableEchoReq,omitempty"`
	// EnableEchoRsp: ?
	EnableEchoRsp *Multivalue `json:"enableEchoRsp,omitempty"`
	// EnableMaxPayload: Enables PPP Max Payload tag
	EnableMaxPayload *Multivalue `json:"enableMaxPayload,omitempty"`
	// EndpointDiscNegotiation: Enable Endpoint Discriminator Negotiation
	EndpointDiscNegotiation *Multivalue `json:"endpointDiscNegotiation,omitempty"`
	// EndpointDiscriminatorClass: Endpoint Discriminator for PPP
	EndpointDiscriminatorClass *Multivalue `json:"endpointDiscriminatorClass,omitempty"`
	// Ipv6AddrPrefixLen: Address prefix length. The difference between the address and pool prefix lengths determine the size of the IPv6 IP pool
	Ipv6AddrPrefixLen *Multivalue `json:"ipv6AddrPrefixLen,omitempty"`
	// Ipv6PoolPrefix: Pool prefix for the IPv6 IP pool.
	Ipv6PoolPrefix *Multivalue `json:"ipv6PoolPrefix,omitempty"`
	// Ipv6PoolPrefixLen: Pool prefix length. The difference between the address and pool prefix lengths determine the size of the IPv6 IP pool
	Ipv6PoolPrefixLen *Multivalue `json:"ipv6PoolPrefixLen,omitempty"`
	// LcpAccm: Async-Control-Character-Map
	LcpAccm *Multivalue `json:"lcpAccm,omitempty"`
	// LcpEnableAccm: Enable Async-Control-Character-Map
	LcpEnableAccm *Multivalue `json:"lcpEnableAccm,omitempty"`
	// LcpMaxFailure: Number of Configure-Nak packets sent without sending a Configure-Ack before assuming that configuration is not converging. Any further Configure-Nak packets for peer requested options are converted to Configure-Reject packets
	LcpMaxFailure *Multivalue `json:"lcpMaxFailure,omitempty"`
	// LcpRetries: Number of LCP retries
	LcpRetries *Multivalue `json:"lcpRetries,omitempty"`
	// LcpStartDelay: Delay time in milliseconds to wait before sending LCP Config Request packet
	LcpStartDelay *Multivalue `json:"lcpStartDelay,omitempty"`
	// LcpTermRetries: Number of LCP Termination Retries
	LcpTermRetries *Multivalue `json:"lcpTermRetries,omitempty"`
	// LcpTimeout: Timeout for LCP phase, in seconds
	LcpTimeout *Multivalue `json:"lcpTimeout,omitempty"`
	// MlpppIPAddress: The IP address used in the ML-PPP endpoint discriminator option of the LCP configure request sent by PPP clients
	MlpppIPAddress *Multivalue `json:"mlpppIPAddress,omitempty"`
	// MlpppMACAddress: The MAC addresses are automatically derived from the local MAC address. An address in this class contains an IEEE 802.1 MAC address is canonical (802.3) format
	MlpppMACAddress *Multivalue `json:"mlpppMACAddress,omitempty"`
	// Mrru: Max Receive Reconstructed Unit for PPP
	Mrru *Multivalue `json:"mrru,omitempty"`
	// MrruNegotiation: Enable MRRU Negotiation
	MrruNegotiation *Multivalue `json:"mrruNegotiation,omitempty"`
	// MruNegotiation: Enable MRU Negotiation
	MruNegotiation *Multivalue `json:"mruNegotiation,omitempty"`
	// Mtu: Max Transmit Unit for PPP
	Mtu *Multivalue `json:"mtu,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NcpRetries: Number of NCP retries
	NcpRetries *Multivalue `json:"ncpRetries,omitempty"`
	// NcpTimeout: Timeout for NCP phase, in seconds
	NcpTimeout *Multivalue `json:"ncpTimeout,omitempty"`
	// NcpType: IP address type (IPv4 or IPv6) for Network Control Protocol
	NcpType *Multivalue `json:"ncpType,omitempty"`
	// ServerBaseIID: Obsolete - use serverIID instead.
	ServerBaseIID *Multivalue `json:"serverBaseIID,omitempty"`
	// ServerBaseIp: The base IP address to be used when create PPP server addresses. This property is used in conjunction with the 'IPv4 Server IP Increment By' property.
	ServerBaseIp *Multivalue `json:"serverBaseIp,omitempty"`
	// ServerDnsOptions: The server DNS options.
	ServerDnsOptions *Multivalue `json:"serverDnsOptions,omitempty"`
	// ServerIID: The base IPv6CP (RFC5072) interface identifier for the PPP server, used in conjunction with 'serverIIDIncr' as incrementor. Valid for IPv6 only.
	ServerIID *Multivalue `json:"serverIID,omitempty"`
	// ServerIIDIncr: Server IPv6CP interface identifier increment, used in conjuction with the base identifier
	ServerIIDIncr *Multivalue `json:"serverIIDIncr,omitempty"`
	// ServerIpIncr: Server IP increment, used in conjuction with 'IPv4 Server IP' property
	ServerIpIncr *Multivalue `json:"serverIpIncr,omitempty"`
	// ServerNcpOptions: Specifies the NCP configuration mode.
	ServerNcpOptions *Multivalue `json:"serverNcpOptions,omitempty"`
	// ServerNetmask: The netmask that the server will assign to the client when the Server Netmask Options parameter is set to Supply Netmask.
	ServerNetmask *Multivalue `json:"serverNetmask,omitempty"`
	// ServerNetmaskOptions: The server netmask option.
	ServerNetmaskOptions *Multivalue `json:"serverNetmaskOptions,omitempty"`
	// ServerPrimaryDnsAddress: The primary DNS server address that the server will assign to the client when the Server DNS Options parameter is set to either Supply Primary and Secondary or Supply Primary Only.
	ServerPrimaryDnsAddress *Multivalue `json:"serverPrimaryDnsAddress,omitempty"`
	// ServerSecondaryDnsAddress: The secondary DNS server address that the server will assign to the client when the Server DNS Options parameter is set to Supply Primary and Secondary.
	ServerSecondaryDnsAddress *Multivalue `json:"serverSecondaryDnsAddress,omitempty"`
	// ServerSignalDslTypeTlv: DSL-Type TLV to be inserted in PPPoE VSA Tag.
	ServerSignalDslTypeTlv *Multivalue `json:"serverSignalDslTypeTlv,omitempty"`
	// ServerSignalIWF: This parameter enables or disables the insertion of sub-option 0xFE (signaling of interworked sessions) into the DSL tag in PADO and PADS packets.
	ServerSignalIWF *Multivalue `json:"serverSignalIWF,omitempty"`
	// ServerSignalLoopChar: This parameter enables or disables the insertion of sub-options 0x81 and 0x82 into the DSL tag in PADO and PADS packets.
	ServerSignalLoopChar *Multivalue `json:"serverSignalLoopChar,omitempty"`
	// ServerSignalLoopEncapsulation: This parameter enables or disables the insertion of sub-option 0x90 into the DSL tag in PADO and PADS packets.
	ServerSignalLoopEncapsulation *Multivalue `json:"serverSignalLoopEncapsulation,omitempty"`
	// ServerSignalLoopId: This parameter enables or disables the insertion of sub-options 0x01 and 0x02 (Remote ID and Circuit ID) into the DSL tag in PADO and PADS packets.
	ServerSignalLoopId *Multivalue `json:"serverSignalLoopId,omitempty"`
	// ServerSignalPonTypeTlv: PON-Type TLV to be inserted in PPPoE VSA Tag.
	ServerSignalPonTypeTlv *Multivalue `json:"serverSignalPonTypeTlv,omitempty"`
	// ServerV6NcpOptions: Specifies the NCP configuration mode.
	ServerV6NcpOptions *Multivalue `json:"serverV6NcpOptions,omitempty"`
	// ServerWinsOptions: The WINS server discovery mode.
	ServerWinsOptions *Multivalue `json:"serverWinsOptions,omitempty"`
	// ServerWinsPrimaryAddress: The primary WINS server address that the server will assign to the client when the Server WINS Options parameter is set to either Supply Primary and Secondary or Supply Primary Only.
	ServerWinsPrimaryAddress *Multivalue `json:"serverWinsPrimaryAddress,omitempty"`
	// ServerWinsSecondaryAddress: The secondary WINS server address that the server will assign to the client when the Server WINS Options parameter is set to Supply Primary and Secondary.
	ServerWinsSecondaryAddress *Multivalue `json:"serverWinsSecondaryAddress,omitempty"`
	// ServiceName: Access Concentrator Service Name - this option is only available for PPP servers.
	ServiceName *Multivalue `json:"serviceName,omitempty"`
	// SessionsCount: Number of PPP clients a single server can accept (multiplier)

	SessionsCount *float32 `json:"sessionsCount,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href                    `json:"-"`
	Bfdv4Interface    []*TopologyBfdv4Interface `json:"bfdv4Interface"`
	Bfdv6Interface    []*TopologyBfdv6Interface `json:"bfdv6Interface"`
	BgpIpv4Peer       []*TopologyBgpIpv4Peer    `json:"bgpIpv4Peer"`
	BgpIpv6Peer       []*TopologyBgpIpv6Peer    `json:"bgpIpv6Peer"`

	Connector      *TopologyConnector        `json:"connector,omitempty"`
	Dhcpv6server   []*TopologyDhcpv6server   `json:"dhcpv6server"`
	ECpriRe        []*TopologyECpriRe        `json:"eCpriRe"`
	ECpriRec       []*TopologyECpriRec       `json:"eCpriRec"`
	Geneve         []*TopologyGeneve         `json:"geneve"`
	IgmpHost       []*TopologyIgmpHost       `json:"igmpHost"`
	IgmpQuerier    []*TopologyIgmpQuerier    `json:"igmpQuerier"`
	MldHost        []*TopologyMldHost        `json:"mldHost"`
	MldQuerier     []*TopologyMldQuerier     `json:"mldQuerier"`
	MplsOam        []*TopologyMplsOam        `json:"mplsOam"`
	NetconfClient  []*TopologyNetconfClient  `json:"netconfClient"`
	NetconfServer  []*TopologyNetconfServer  `json:"netconfServer"`
	Ospfv2         []*TopologyOspfv2         `json:"ospfv2"`
	Ospfv3         []*TopologyOspfv3         `json:"ospfv3"`
	Pcc            []*TopologyPcc            `json:"pcc"`
	Pce            []*TopologyPce            `json:"pce"`
	PimV4Interface []*TopologyPimV4Interface `json:"pimV4Interface"`
	PimV6Interface []*TopologyPimV6Interface `json:"pimV6Interface"`

	PppoxServerSessions *TopologyPppoxServerSessions `json:"pppoxServerSessions,omitempty"`
	Vxlan               []*TopologyVxlan             `json:"vxlan"`
	Vxlanv6             []*TopologyVxlanv6           `json:"vxlanv6"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPppoxserver) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPppoxserver) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPppoxserver) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPppoxserver) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AcName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "acName",
		isMultivalue: true,
	})
	n.AcceptAnyAuthValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "acceptAnyAuthValue",
		isMultivalue: true,
	})
	n.AuthRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authRetries",
		isMultivalue: true,
	})
	n.AuthTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authTimeout",
		isMultivalue: true,
	})
	n.AuthType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authType",
		isMultivalue: true,
	})
	n.ClientBaseIID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientBaseIID",
		isMultivalue: true,
	})
	n.ClientBaseIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientBaseIp",
		isMultivalue: true,
	})
	n.ClientIID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientIID",
		isMultivalue: true,
	})
	n.ClientIIDIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientIIDIncr",
		isMultivalue: true,
	})
	n.ClientIpIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clientIpIncr",
		isMultivalue: true,
	})
	n.DnsServerList.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dnsServerList",
		isMultivalue: true,
	})
	n.EchoReqInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "echoReqInterval",
		isMultivalue: true,
	})
	n.EnableDnsRa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableDnsRa",
		isMultivalue: true,
	})
	n.EnableEchoReq.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEchoReq",
		isMultivalue: true,
	})
	n.EnableEchoRsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEchoRsp",
		isMultivalue: true,
	})
	n.EnableMaxPayload.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableMaxPayload",
		isMultivalue: true,
	})
	n.EndpointDiscNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endpointDiscNegotiation",
		isMultivalue: true,
	})
	n.EndpointDiscriminatorClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endpointDiscriminatorClass",
		isMultivalue: true,
	})
	n.Ipv6AddrPrefixLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6AddrPrefixLen",
		isMultivalue: true,
	})
	n.Ipv6PoolPrefix.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6PoolPrefix",
		isMultivalue: true,
	})
	n.Ipv6PoolPrefixLen.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6PoolPrefixLen",
		isMultivalue: true,
	})
	n.LcpAccm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpAccm",
		isMultivalue: true,
	})
	n.LcpEnableAccm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpEnableAccm",
		isMultivalue: true,
	})
	n.LcpMaxFailure.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpMaxFailure",
		isMultivalue: true,
	})
	n.LcpRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpRetries",
		isMultivalue: true,
	})
	n.LcpStartDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpStartDelay",
		isMultivalue: true,
	})
	n.LcpTermRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpTermRetries",
		isMultivalue: true,
	})
	n.LcpTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lcpTimeout",
		isMultivalue: true,
	})
	n.MlpppIPAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mlpppIPAddress",
		isMultivalue: true,
	})
	n.MlpppMACAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mlpppMACAddress",
		isMultivalue: true,
	})
	n.Mrru.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mrru",
		isMultivalue: true,
	})
	n.MrruNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mrruNegotiation",
		isMultivalue: true,
	})
	n.MruNegotiation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mruNegotiation",
		isMultivalue: true,
	})
	n.Mtu.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mtu",
		isMultivalue: true,
	})
	n.NcpRetries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ncpRetries",
		isMultivalue: true,
	})
	n.NcpTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ncpTimeout",
		isMultivalue: true,
	})
	n.NcpType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ncpType",
		isMultivalue: true,
	})
	n.ServerBaseIID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverBaseIID",
		isMultivalue: true,
	})
	n.ServerBaseIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverBaseIp",
		isMultivalue: true,
	})
	n.ServerDnsOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverDnsOptions",
		isMultivalue: true,
	})
	n.ServerIID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverIID",
		isMultivalue: true,
	})
	n.ServerIIDIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverIIDIncr",
		isMultivalue: true,
	})
	n.ServerIpIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverIpIncr",
		isMultivalue: true,
	})
	n.ServerNcpOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverNcpOptions",
		isMultivalue: true,
	})
	n.ServerNetmask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverNetmask",
		isMultivalue: true,
	})
	n.ServerNetmaskOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverNetmaskOptions",
		isMultivalue: true,
	})
	n.ServerPrimaryDnsAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverPrimaryDnsAddress",
		isMultivalue: true,
	})
	n.ServerSecondaryDnsAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverSecondaryDnsAddress",
		isMultivalue: true,
	})
	n.ServerSignalDslTypeTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverSignalDslTypeTlv",
		isMultivalue: true,
	})
	n.ServerSignalIWF.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverSignalIWF",
		isMultivalue: true,
	})
	n.ServerSignalLoopChar.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverSignalLoopChar",
		isMultivalue: true,
	})
	n.ServerSignalLoopEncapsulation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverSignalLoopEncapsulation",
		isMultivalue: true,
	})
	n.ServerSignalLoopId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverSignalLoopId",
		isMultivalue: true,
	})
	n.ServerSignalPonTypeTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverSignalPonTypeTlv",
		isMultivalue: true,
	})
	n.ServerV6NcpOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverV6NcpOptions",
		isMultivalue: true,
	})
	n.ServerWinsOptions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverWinsOptions",
		isMultivalue: true,
	})
	n.ServerWinsPrimaryAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverWinsPrimaryAddress",
		isMultivalue: true,
	})
	n.ServerWinsSecondaryAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serverWinsSecondaryAddress",
		isMultivalue: true,
	})
	n.ServiceName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "serviceName",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Bfdv6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv4Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv4Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.BgpIpv6Peer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bgpIpv6Peer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Dhcpv6server {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dhcpv6server",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRe {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRe",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ECpriRec {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "eCpriRec",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Geneve {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "geneve",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IgmpQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "igmpQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldHost {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldHost",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MldQuerier {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mldQuerier",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.MplsOam {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsOam",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfClient {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfClient",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NetconfServer {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "netconfServer",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv2 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv2",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pcc {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcc",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Pce {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pce",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PimV6Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pimV6Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.PppoxServerSessions.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pppoxServerSessions",
	})
	for i, o := range n.Vxlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vxlanv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vxlanv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPreEstablishedSrLsps: Pre-Established SR LSPs
type TopologyPreEstablishedSrLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// ActiveDataTrafficEndpoint: Specifies whether that specific Data Traffic Endpoint will generate data traffic
	ActiveDataTrafficEndpoint *Multivalue `json:"activeDataTrafficEndpoint,omitempty"`
	// AssociationId: The Association ID of this LSP.
	AssociationId *Multivalue `json:"associationId,omitempty"`
	// Bandwidth: Bandwidth (bits/sec)
	Bandwidth *Multivalue `json:"bandwidth,omitempty"`
	// BindingType: Indicates the type of binding included in the TLV. Types are as follows: 20bit MPLS Label 32bit MPLS Label. SRv6 SID Default value is 20bit MPLS Label.
	BindingType *Multivalue `json:"bindingType,omitempty"`
	// Bos: This bit is set to True for the last entry in the label stack i.e., for the bottom of the stack, and False for all other label stack entries. This control will be editable only if Binding Type is MPLS Label 32bit.
	Bos *Multivalue `json:"bos,omitempty"`
	// DestinationIpv4Address: Destination IPv4 Address
	DestinationIpv4Address *Multivalue `json:"destinationIpv4Address,omitempty"`
	// ExcludeAny: This is a type of Resource Affinity Procedure that is used to validate a link. This control accepts a link only if the link carries all of the attributes in the set.
	ExcludeAny *Multivalue `json:"excludeAny,omitempty"`
	// HoldingPriority: The priority of the LSP with respect to holding resources. The value 0 is the highest priority. Holding Priority is used in deciding whether this session can be preempted by another session.
	HoldingPriority *Multivalue `json:"holdingPriority,omitempty"`
	// IncludeAll: This is a type of Resource Affinity Procedure that is used to validate a link. This control excludes a link from consideration if the link carries any of the attributes in the set.
	IncludeAll *Multivalue `json:"includeAll,omitempty"`
	// IncludeAny: This is a type of Resource Affinity Procedure that is used to validate a link. This control accepts a link if the link carries any of the attributes in the set.
	IncludeAny *Multivalue `json:"includeAny,omitempty"`
	// IncludeBandwidth: Indicates whether Bandwidth will be included in a PCInitiate message. All other attributes in sub-tab-Bandwidth would be editable only if this checkbox is enabled.
	IncludeBandwidth *Multivalue `json:"includeBandwidth,omitempty"`
	// IncludeConfiguredERO: If this is enabled, entire ERO will go out in packet even if there is Binding SID, which means no SR-ERO/SRv6-ERO validation will be done.
	IncludeConfiguredERO *Multivalue `json:"includeConfiguredERO,omitempty"`
	// IncludeEro: Specifies whether ERO is active or inactive. All subsequent attributes of the sub-tab-ERO would be editable only if this is enabled.
	IncludeEro *Multivalue `json:"includeEro,omitempty"`
	// IncludeLsp: Indicates whether LSP will be included in a PCInitiate message. All other attributes in sub-tab-LSP would be editable only if this checkbox is enabled.
	IncludeLsp *Multivalue `json:"includeLsp,omitempty"`
	// IncludeLspa: Indicates whether LSPA will be included in a PCInitiate message. All other attributes in sub-tab-LSPA would be editable only if this checkbox is enabled.
	IncludeLspa *Multivalue `json:"includeLspa,omitempty"`
	// IncludeMetric: Indicates whether the PCInitiate message will have the metric list that is configured. All subsequent attributes of the sub-tab-Metric would be editable only if this is enabled.
	IncludeMetric *Multivalue `json:"includeMetric,omitempty"`
	// IncludePpag: Indicates whether Association will be included in a Sync PCReport message. All other attributes in sub-tab-PPAG would be editable only if this checkbox is enabled.
	IncludePpag *Multivalue `json:"includePpag,omitempty"`
	// IncludeSrp: Indicates whether SRP object will be included in a PCInitiate message. All other attributes in sub-tab-SRP would be editable only if this checkbox is enabled.
	IncludeSrp *Multivalue `json:"includeSrp,omitempty"`
	// IncludeSymbolicPathNameTlv: Indicates if Symbolic-Path-Name TLV is to be included in PCInitiate message.
	IncludeSymbolicPathNameTlv *Multivalue `json:"includeSymbolicPathNameTlv,omitempty"`
	// IncludeTEPathBindingTLV: Indicates if TE-PATH-BINDING TLV is to be included in PCC Sync LSP.
	IncludeTEPathBindingTLV *Multivalue `json:"includeTEPathBindingTLV,omitempty"`
	// InitialDelegation: Initial Delegation
	InitialDelegation *Multivalue `json:"initialDelegation,omitempty"`
	// InsertIpv6ExplicitNull: Insert IPv6 Explicit Null MPLS header if the traffic type is of type IPv6

	InsertIpv6ExplicitNull *bool `json:"insertIpv6ExplicitNull,omitempty"`
	// LocalProtection: When set, this means that the path must include links protected with Fast Reroute
	LocalProtection *Multivalue `json:"localProtection,omitempty"`
	// MplsLabel: This control will be editable if the Binding Type is set to either 20bit or 32bit MPLS-Label. This field will take the 20bit value of the MPLS-Label
	MplsLabel *Multivalue `json:"mplsLabel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfEroSubObjects: Value that indicates the number of ERO Sub Objects to be configured.

	NumberOfEroSubObjects *float32 `json:"numberOfEroSubObjects,omitempty"`
	// NumberOfMetricSubObject: Value that indicates the number of Metric Objects to be configured.

	NumberOfMetricSubObject *float32 `json:"numberOfMetricSubObject,omitempty"`
	// OverridePlspId: Indicates if PLSP-ID will be set by the state machine or user. If disabled user wont have the control and state machine will set it.

	OverridePlspId *bool `json:"overridePlspId,omitempty"`
	// PlspId: An identifier for the LSP. A PCC creates a unique PLSP-ID for each LSP that is constant for the lifetime of a PCEP session. The PCC will advertise the same PLSP-ID on all PCEP sessions it maintains at a given time.
	PlspId *Multivalue `json:"plspId,omitempty"`
	// ProtectionLspBit: Indicates whether Protection LSP Bit is On.
	ProtectionLspBit *Multivalue `json:"protectionLspBit,omitempty"`
	// RedelegationTimeoutInterval: The period of time a PCC waits for, when a PCEP session is terminated, before revoking LSP delegation to a PCE and attempting to redelegate LSPs associated with the terminated PCEP session to PCE.
	RedelegationTimeoutInterval *Multivalue `json:"redelegationTimeoutInterval,omitempty"`
	// SetupPriority: The priority of the LSP with respect to taking resources.The value 0 is the highest priority.The Setup Priority is used in deciding whether this session can preempt another session.
	SetupPriority *Multivalue `json:"setupPriority,omitempty"`
	// SrcEndPointIpv4: Source IPv4 address
	SrcEndPointIpv4 *Multivalue `json:"srcEndPointIpv4,omitempty"`
	// SrcEndPointIpv6: Source IPv6 address
	SrcEndPointIpv6 *Multivalue `json:"srcEndPointIpv6,omitempty"`
	// Srv6SID: SRv6 SID with a format of a 16 byte IPv6 address.
	Srv6SID *Multivalue `json:"srv6SID,omitempty"`
	// StandbyLspBit: Indicates whether Standby LSP Bit is On.
	StandbyLspBit *Multivalue `json:"standbyLspBit,omitempty"`
	// SymbolicPathName: Each LSP (path) must have a symbolic name that is unique in the PCC. It must remain constant throughout a path's lifetime, which may span across multiple consecutive PCEP sessions and/or PCC restarts.
	SymbolicPathName *Multivalue `json:"symbolicPathName,omitempty"`
	// Tc: This field is used to carry traffic class information. This control will be editable only if Binding Type is MPLS Label 32bit.
	Tc *Multivalue `json:"tc,omitempty"`
	// Ttl: This field is used to encode a time-to-live value. This control will be editable only if Binding Type is MPLS Label 32bit.
	Ttl                      *Multivalue                         `json:"ttl,omitempty"`
	PcepEroSubObjectsList    []*TopologyPcepEroSubObjectsList    `json:"pcepEroSubObjectsList"`
	PcepMetricSubObjectsList []*TopologyPcepMetricSubObjectsList `json:"pcepMetricSubObjectsList"`
	Tag                      []*TopologyTag                      `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPreEstablishedSrLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPreEstablishedSrLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPreEstablishedSrLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPreEstablishedSrLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActiveDataTrafficEndpoint.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeDataTrafficEndpoint",
		isMultivalue: true,
	})
	n.AssociationId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "associationId",
		isMultivalue: true,
	})
	n.Bandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidth",
		isMultivalue: true,
	})
	n.BindingType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bindingType",
		isMultivalue: true,
	})
	n.Bos.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bos",
		isMultivalue: true,
	})
	n.DestinationIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationIpv4Address",
		isMultivalue: true,
	})
	n.ExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAny",
		isMultivalue: true,
	})
	n.HoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdingPriority",
		isMultivalue: true,
	})
	n.IncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAll",
		isMultivalue: true,
	})
	n.IncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAny",
		isMultivalue: true,
	})
	n.IncludeBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeBandwidth",
		isMultivalue: true,
	})
	n.IncludeConfiguredERO.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeConfiguredERO",
		isMultivalue: true,
	})
	n.IncludeEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeEro",
		isMultivalue: true,
	})
	n.IncludeLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLsp",
		isMultivalue: true,
	})
	n.IncludeLspa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLspa",
		isMultivalue: true,
	})
	n.IncludeMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMetric",
		isMultivalue: true,
	})
	n.IncludePpag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includePpag",
		isMultivalue: true,
	})
	n.IncludeSrp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSrp",
		isMultivalue: true,
	})
	n.IncludeSymbolicPathNameTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSymbolicPathNameTlv",
		isMultivalue: true,
	})
	n.IncludeTEPathBindingTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeTEPathBindingTLV",
		isMultivalue: true,
	})
	n.InitialDelegation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initialDelegation",
		isMultivalue: true,
	})
	n.LocalProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localProtection",
		isMultivalue: true,
	})
	n.MplsLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabel",
		isMultivalue: true,
	})
	n.PlspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "plspId",
		isMultivalue: true,
	})
	n.ProtectionLspBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectionLspBit",
		isMultivalue: true,
	})
	n.RedelegationTimeoutInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redelegationTimeoutInterval",
		isMultivalue: true,
	})
	n.SetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setupPriority",
		isMultivalue: true,
	})
	n.SrcEndPointIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcEndPointIpv4",
		isMultivalue: true,
	})
	n.SrcEndPointIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcEndPointIpv6",
		isMultivalue: true,
	})
	n.Srv6SID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srv6SID",
		isMultivalue: true,
	})
	n.StandbyLspBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "standbyLspBit",
		isMultivalue: true,
	})
	n.SymbolicPathName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "symbolicPathName",
		isMultivalue: true,
	})
	n.Tc.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tc",
		isMultivalue: true,
	})
	n.Ttl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ttl",
		isMultivalue: true,
	})
	for i, o := range n.PcepEroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepEroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PcepMetricSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepMetricSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyPtp: Precision Time Protocol
type TopologyPtp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AllowedFaults: It is the number of faults, above which asCapableAcrossDomains is set to FALSE, i.e., a LinkPort is considered to be not capable of interoperating with its neighbor via the IEEE 802.1AS protocol.The Value should be between 1 and 255.
	AllowedFaults *Multivalue `json:"allowedFaults,omitempty"`
	// AllowedLostResponse: It is the number of Pdelay_Req messages for which a valid response is not received, above whicha Link Port is considered to be not exchanging peer delay messages with its neighbor.The Value should be between 1 and 255.
	AllowedLostResponse *Multivalue `json:"allowedLostResponse,omitempty"`
	// AlternateMasterFlag: Select this check box to set the 'Alternate Master flag' in all Announce and Sync messages.
	AlternateMasterFlag *Multivalue `json:"alternateMasterFlag,omitempty"`
	// AnnounceCurrentUtcOffsetValid: Select this check box to set the 'UTC Reasonable' flag in all Announce messages.
	AnnounceCurrentUtcOffsetValid *Multivalue `json:"announceCurrentUtcOffsetValid,omitempty"`
	// AnnounceDropRate: Percentage rate of the dropped Announce messages
	AnnounceDropRate *Multivalue `json:"announceDropRate,omitempty"`
	// AnnounceFrequencyTraceable: Select this check box to set the 'Frequency Traceable flag' in all Announce messages.
	AnnounceFrequencyTraceable *Multivalue `json:"announceFrequencyTraceable,omitempty"`
	// AnnounceLeap59: Select this check box to set the 'Announce leap59 flag' in all Announce messages.
	AnnounceLeap59 *Multivalue `json:"announceLeap59,omitempty"`
	// AnnounceLeap61: Select this check box to set the 'Announce leap61 flag' in all Announce messages.
	AnnounceLeap61 *Multivalue `json:"announceLeap61,omitempty"`
	// AnnouncePtpTimescale: Select this check box to set the 'PTP Timescale flag' in all Announce messages.
	AnnouncePtpTimescale *Multivalue `json:"announcePtpTimescale,omitempty"`
	// AnnounceReceiptTimeout: The number of Announce Intervals that have to pass without receipt of an Announce message to trigger timeout
	AnnounceReceiptTimeout *Multivalue `json:"announceReceiptTimeout,omitempty"`
	// AnnounceTimeTraceable: Select this check box to set the 'Time Traceable flag' in all Announce messages.
	AnnounceTimeTraceable *Multivalue `json:"announceTimeTraceable,omitempty"`
	// AtoiTlvCount: ATOI TLV Count

	AtoiTlvCount *float32 `json:"atoiTlvCount,omitempty"`
	// AvnuMode: AVNU Mode

	AvnuMode *string `json:"avnuMode,omitempty"`
	// Bmca: Run the Best Master Clock Algorithm for gPTP (if disabled can use a pre-defined Master or accept messages from any source)
	Bmca *Multivalue `json:"bmca,omitempty"`
	// ClockAccuracy: Master clock accuracy that need to be conveyed via Announce Message.
	ClockAccuracy *Multivalue `json:"clockAccuracy,omitempty"`
	// ClockClass: Traceability of the time or frequency distributed by the grandmaster clock
	ClockClass *Multivalue `json:"clockClass,omitempty"`
	// ClockIdentity: Defines the ClockIdentity to be used by this device
	ClockIdentity *Multivalue `json:"clockIdentity,omitempty"`
	// CommunicationMode: Option to choose PTP Protocol Communication mode (unicast/multicast/mixed).
	CommunicationMode *Multivalue `json:"communicationMode,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// CumulativeScaledRateOffset: Cumulative Scaled Rate Offset field set in the gPTP FollowUp TLV
	CumulativeScaledRateOffset *Multivalue `json:"cumulativeScaledRateOffset,omitempty"`
	// CurrentLocalOffset: Offset in seconds of Local Time from grandmaster PTP time.
	CurrentLocalOffset *Multivalue `json:"currentLocalOffset,omitempty"`
	// CurrentUtcOffset: Set Current UTC Offset (seconds) to be sent via Announce Message.
	CurrentUtcOffset *Multivalue `json:"currentUtcOffset,omitempty"`
	// CustomClockId: Use the ClockIdentity configured in the next column instead of MAC based generated one
	CustomClockId *Multivalue `json:"customClockId,omitempty"`
	// DaylightSaving: This filed will be used to encode Occurence of daylight saving.
	DaylightSaving *Multivalue `json:"daylightSaving,omitempty"`
	// DefaultSystemFrameRateDenominator: Default video frame rate of the slave system as a lowest term rational. The Denominator value of Default System Frame Rate.
	DefaultSystemFrameRateDenominator *Multivalue `json:"defaultSystemFrameRateDenominator,omitempty"`
	// DefaultSystemFrameRateNumerator: Default video frame rate of the slave system as a lowest term rational. The Numerator value of Default System Frame Rate.
	DefaultSystemFrameRateNumerator *Multivalue `json:"defaultSystemFrameRateNumerator,omitempty"`
	// DelayAsymmetry: Delay Asymmetry between path
	DelayAsymmetry *Multivalue `json:"delayAsymmetry,omitempty"`
	// DelayMechanism: Mechanism to measure path delay between two ptp port.
	DelayMechanism *Multivalue `json:"delayMechanism,omitempty"`
	// DelayReqDropRate: Percentage rate of the dropped (P)DelayReq messages
	DelayReqDropRate *Multivalue `json:"delayReqDropRate,omitempty"`
	// DelayReqOffset: Percentage of the agreed (P)DelayReq Inter-arrival time to schedule between two subsequent DelayReq messages
	DelayReqOffset *Multivalue `json:"delayReqOffset,omitempty"`
	// DelayReqResidenceTime: Residence time of (P)DelayReq messages through an associated one-step end-to-end transparent clock inserted in the correction field of (P)DelayReq messages sent by this clock
	DelayReqResidenceTime *Multivalue `json:"delayReqResidenceTime,omitempty"`
	// DelayReqSpread: Distribute (P)DelayReq messages in an interval around the targeted Inter-arrival mean time (expressed as a % of targeted mean)
	DelayReqSpread *Multivalue `json:"delayReqSpread,omitempty"`
	// DelayRespDropRate: Percentage rate of the dropped DelayResp messages
	DelayRespDropRate *Multivalue `json:"delayRespDropRate,omitempty"`
	// DelayRespReceiptTimeout: DelayResponse Receipt Timeout in seconds
	DelayRespReceiptTimeout *Multivalue `json:"delayRespReceiptTimeout,omitempty"`
	// DelayRespResidenceTime: Residence time of DelayReq messages through an associated two-step end-to-end transparent clock inserted in the correction field of DelayResp messages sent by this clock, or the residence time of PdelayResp messages through an associated one-step end-to-end transparent clock inserted in the correction field of PdelayResp messages sent by this clock.
	DelayRespResidenceTime *Multivalue `json:"delayRespResidenceTime,omitempty"`
	// DelayResponseDelay: Additional delay introduced in the DelayResp message (nanoseconds)
	DelayResponseDelay *Multivalue `json:"delayResponseDelay,omitempty"`
	// DelayResponseDelayInsertionRate: Percentage rate of the DelayResp messages in which the delay is introduced
	DelayResponseDelayInsertionRate *Multivalue `json:"delayResponseDelayInsertionRate,omitempty"`
	// Domain: PTP Domain
	Domain *Multivalue `json:"domain,omitempty"`
	// DropMalformed: Drop packets that for which fields like Domain, message rates, Clock Class, Clock Accuracy and Offset Scaled Log Variance are not respecting strict G8275.1 imposed intervals
	DropMalformed *Multivalue `json:"dropMalformed,omitempty"`
	// DropSignalReqAnnounce: Select this check box to drop any Signal Request that contains Announce TLV
	DropSignalReqAnnounce *Multivalue `json:"dropSignalReqAnnounce,omitempty"`
	// DropSignalReqDelayResp: Select this check box to drop any Signal Request that contains DelayResp TLV
	DropSignalReqDelayResp *Multivalue `json:"dropSignalReqDelayResp,omitempty"`
	// DropSignalReqSync: Select this check box to drop any Signal Request that contains Sync TLV
	DropSignalReqSync *Multivalue `json:"dropSignalReqSync,omitempty"`
	// EnableATOITlv: Enable ATOI TLV

	EnableATOITlv *bool `json:"enableATOITlv,omitempty"`
	// EnableCmlds: Enable Cmlds

	EnableCmlds *bool `json:"enableCmlds,omitempty"`
	// EnableNegativeTesting: Enable Negative Conformance Test

	EnableNegativeTesting *bool `json:"enableNegativeTesting,omitempty"`
	// FolderPath: Folder To Store Log Files
	FolderPath *Multivalue `json:"folderPath,omitempty"`
	// FollowUpBadCrcRate: Percentage rate of the bad crc FollowUp messages
	FollowUpBadCrcRate *Multivalue `json:"followUpBadCrcRate,omitempty"`
	// FollowUpDelay: Additional delay introduced in the FollowUp message timestamp (ns)
	FollowUpDelay *Multivalue `json:"followUpDelay,omitempty"`
	// FollowUpDelayInsertionRate: Percentage rate of the FollowUp messages in which the delay is introduced
	FollowUpDelayInsertionRate *Multivalue `json:"followUpDelayInsertionRate,omitempty"`
	// FollowUpDropRate: Percentage rate of the dropped FollowUp messages
	FollowUpDropRate *Multivalue `json:"followUpDropRate,omitempty"`
	// FollowUpResidenceTime: Master to slave residence of Sync messages through an associated two-step transparent clock inserted in the correction field of FollowUp messages sent by this clock
	FollowUpResidenceTime *Multivalue `json:"followUpResidenceTime,omitempty"`
	// Frequency: Frequency(N)

	Frequency *float32 `json:"frequency,omitempty"`
	// GPTPCapableReceiptTimeout: The number of gPTP Capable Message Intervals that have to pass without receipt of a gPTP Capable Message to trigger timeout
	GPTPCapableReceiptTimeout *Multivalue `json:"gPTPCapableReceiptTimeout,omitempty"`
	// GmTimeBaseIndicator: GM Time Base Indicator field set in the gPTP FollowUp TLV
	GmTimeBaseIndicator *Multivalue `json:"gmTimeBaseIndicator,omitempty"`
	// GrandmasterID: Tester should allow [0x0000 - 0xFFFF] value to be configured for grandmasterID.
	GrandmasterID *Multivalue `json:"grandmasterID,omitempty"`
	// GrandmasterIdentity: Defines the ClockIdentity of the Grandmaster behind this device
	GrandmasterIdentity *Multivalue `json:"grandmasterIdentity,omitempty"`
	// GrantDelayRespDurationInterval: Value of DurationField in REQUEST_UNICAST_TRANSMISSION_TLV for DelayResp messages
	GrantDelayRespDurationInterval *Multivalue `json:"grantDelayRespDurationInterval,omitempty"`
	// GrantSyncDurationInterval: Value of DurationField in REQUEST_UNICAST_TRANSMISSION_TLV for Sync messages
	GrantSyncDurationInterval *Multivalue `json:"grantSyncDurationInterval,omitempty"`
	// GrantUnicastDurationInterval: Value of DurationField in REQUEST_UNICAST_TRANSMISSION_TLV
	GrantUnicastDurationInterval *Multivalue `json:"grantUnicastDurationInterval,omitempty"`
	// HandleAnnounceTlv: Send and respond to Announce TLV unicast requests in signal messages.
	HandleAnnounceTlv *Multivalue `json:"handleAnnounceTlv,omitempty"`
	// HandleCancelTlv: Send and respond to Cancel TLV unicast requests in signal messages
	HandleCancelTlv *Multivalue `json:"handleCancelTlv,omitempty"`
	// JumpSeconds: The size of the next discontinuity, in seconds, of Local Time. A value of zero indicates that no discontinuity is expected.A positive value indicates that the discontinuity will cause the currentLocalOffset to increase.
	JumpSeconds *Multivalue `json:"jumpSeconds,omitempty"`
	// LastGmPhaseChange: Last GM Phase Change nanoseconds set in the gPTP FollowUp TLV
	LastGmPhaseChange *Multivalue `json:"lastGmPhaseChange,omitempty"`
	// LeapSecondJump: The reason for the forthcoming discontinuity of currentLocalOffset indicated by timeOfNextJump.
	LeapSecondJump *Multivalue `json:"leapSecondJump,omitempty"`
	// LearnPortId: Slave learns Master Port ID
	LearnPortId *Multivalue `json:"learnPortId,omitempty"`
	// LogAnnounceInterval: The log mean time interval between successive Announce messages
	LogAnnounceInterval *Multivalue `json:"logAnnounceInterval,omitempty"`
	// LogCleanUpOption: Debug Log Clean Up

	LogCleanUpOption *string `json:"logCleanUpOption,omitempty"`
	// LogDelayReqInterval: The log mean time interval between successive (P)DelayReq messages
	LogDelayReqInterval *Multivalue `json:"logDelayReqInterval,omitempty"`
	// LogFileAge: This field determines how old logs to be deleted.

	LogFileAge *float32 `json:"logFileAge,omitempty"`
	// LogFuturePacketInfo: If this option is enabled PTP will write next packet information if a user defined offset limit crosses
	LogFuturePacketInfo *Multivalue `json:"logFuturePacketInfo,omitempty"`
	// LogManagementMsgInterval: The log mean time interval between successive Management messages
	LogManagementMsgInterval *Multivalue `json:"logManagementMsgInterval,omitempty"`
	// LogSignallingInterval: The log mean time interval between successive Signaling messages.
	LogSignallingInterval *Multivalue `json:"logSignallingInterval,omitempty"`
	// LogSyncInterval: The log mean time interval between successive Sync messages
	LogSyncInterval *Multivalue `json:"logSyncInterval,omitempty"`
	// MasterCount: The total number of Unicast masters to be used for this slave (at max 500).
	MasterCount *Multivalue `json:"masterCount,omitempty"`
	// MasterIpAddress: Defines the base address to be used for enumerating all the addresses for this slave
	MasterIpAddress *Multivalue `json:"masterIpAddress,omitempty"`
	// MasterIpIncrementBy: Defines the increment to be used for enumerating all the addresses for this slave
	MasterIpIncrementBy *Multivalue `json:"masterIpIncrementBy,omitempty"`
	// MasterIpv6Address: Defines the base address to be used for enumerating all the addresses for this slave
	MasterIpv6Address *Multivalue `json:"masterIpv6Address,omitempty"`
	// MasterIpv6IncrementBy: Defines the increment to be used for enumerating all the addresses for this slave
	MasterIpv6IncrementBy *Multivalue `json:"masterIpv6IncrementBy,omitempty"`
	// MasterLockingStatus: Complementary information to clockClass
	MasterLockingStatus *Multivalue `json:"masterLockingStatus,omitempty"`
	// MasterMacAddress: Defines the base address to be used for enumerating all the addresses for this slave
	MasterMacAddress *Multivalue `json:"masterMacAddress,omitempty"`
	// MasterMacIncrementBy: Defines the increment to be used for enumerating all the addresses for this slave
	MasterMacIncrementBy *Multivalue `json:"masterMacIncrementBy,omitempty"`
	// MeanLinkDelayThreshold: The propagation time threshold, above which a port is not considered capable of participating in the IEEE 802.1AS protocol.The Value should be between 0 and 9223372036854775807.
	MeanLinkDelayThreshold *Multivalue `json:"meanLinkDelayThreshold,omitempty"`
	// MulticastAddress: The destination multicast address for G8275.1: non-forwardable (01:80:C2:00:00:0E, recommended) or forwardable (01:1B:19:00:00:00)
	MulticastAddress *Multivalue `json:"multicastAddress,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NanosecondsPerSecond: The number of nanoseconds the emulated clock should effectively count for one second of hardware ticks
	NanosecondsPerSecond *Multivalue `json:"nanosecondsPerSecond,omitempty"`
	// NotSlave: When enabled for Master clocks it prevents a G8275.1 port from going into Slave state, by ignoring Announce messages
	NotSlave *Multivalue `json:"notSlave,omitempty"`
	// NumRecords: Number Of Records To Be Logged if user defined offset limit is crossed.
	NumRecords *Multivalue `json:"numRecords,omitempty"`
	// NumberOFMsgs: Messages Count

	NumberOFMsgs *float32 `json:"numberOFMsgs,omitempty"`
	// OffsetBaseddebuggabilityEnabled: If this option is enabled PTP will write log if a user defined offset limit crosses
	OffsetBaseddebuggabilityEnabled *Multivalue `json:"offsetBaseddebuggabilityEnabled,omitempty"`
	// OffsetLimit: User defined offset limit in nanosecond. When offset crosses this limit PTP will generate a Log
	OffsetLimit *Multivalue `json:"offsetLimit,omitempty"`
	// OffsetScaledLogVariance: Static Offset Scaled Log Variance of this clock
	OffsetScaledLogVariance *Multivalue `json:"offsetScaledLogVariance,omitempty"`
	// OneWay: Do not send Delay Requests
	OneWay *Multivalue `json:"oneWay,omitempty"`
	// PDelayFollowUpDelay: Additional delay introduced in the PdelayResp FollowUp message (ns)
	PDelayFollowUpDelay *Multivalue `json:"pDelayFollowUpDelay,omitempty"`
	// PDelayFollowUpDelayInsertionRate: Percentage rate of the PdelayResp FollowUp messages in which the delay is introduced
	PDelayFollowUpDelayInsertionRate *Multivalue `json:"pDelayFollowUpDelayInsertionRate,omitempty"`
	// PDelayFollowUpDropRate: Percentage rate of the dropped PdelayResp FollowUp messages
	PDelayFollowUpDropRate *Multivalue `json:"pDelayFollowUpDropRate,omitempty"`
	// PDelayFollowUpResidenceTime: Total residence time of PdelayReq and PdelayResp messages through an associated two-step end-to-end transparent clock inserted in the correction field of PdelayRespFollowUp messages sent by this clock.
	PDelayFollowUpResidenceTime *Multivalue `json:"pDelayFollowUpResidenceTime,omitempty"`
	// PathTraceTLV: If selected, the master will append a Path Trace TLV to Announce messages
	PathTraceTLV *Multivalue `json:"pathTraceTLV,omitempty"`
	// PortNumber: The value of the portNumber for a port on a PTP node supporting a single PTP port shall be 1. The values of the port numbers for the N ports on a PTP node supporting N PTP ports shall be 1, 2, N, respectively.
	PortNumber *Multivalue `json:"portNumber,omitempty"`
	// PreviousJamLocalOffset: The value of currentLocalOffset at the time of the previous Daily Jam event.If a discontinuity of Local Time occurs at the jam time, this parameter reflects the offset after the discontinuity.The default value shall be the current value of currentLocalOffset.
	PreviousJamLocalOffset *Multivalue `json:"previousJamLocalOffset,omitempty"`
	// Priority1: PTP priority1.
	Priority1 *Multivalue `json:"priority1,omitempty"`
	// Priority2: PTP priority2
	Priority2 *Multivalue `json:"priority2,omitempty"`
	// Profile: The profile used by this clock
	Profile *Multivalue `json:"profile,omitempty"`
	// RenewalInvited: Set the Renewal Invited flag in Grant Unicast Transmission TLV
	RenewalInvited *Multivalue `json:"renewalInvited,omitempty"`
	// RequestAttempts: The number of succesive requests a slave can request before entering into holddown.
	RequestAttempts *Multivalue `json:"requestAttempts,omitempty"`
	// RequestHolddown: Time between succesive requests if denied/timeout for Signal Request
	RequestHolddown *Multivalue `json:"requestHolddown,omitempty"`
	// RequestInterval: Time between succesive requests if denied/timeout for Signal Request
	RequestInterval *Multivalue `json:"requestInterval,omitempty"`
	// Reserved: IEEE_C37_238 TLV Reserved
	Reserved *Multivalue `json:"reserved,omitempty"`
	// ReverseSync: As a slave, periodically send Reverse Sync messages with recovered clock. As a master, calculate the Offset of the Slave reported time to master time
	ReverseSync *Multivalue `json:"reverseSync,omitempty"`
	// ReverseSyncIntervalPercent: The percentage of incoming Sync interval to use for Reverse Sync interval
	ReverseSyncIntervalPercent *Multivalue `json:"reverseSyncIntervalPercent,omitempty"`
	// Role: The desired role of this clock (Masters may become Slave as per BMCA)
	Role *Multivalue `json:"role,omitempty"`
	// RxCalibration: The amount of time (in ns) that the Receive side timestamp needs to be offset to allow for error
	RxCalibration *Multivalue `json:"rxCalibration,omitempty"`
	// ScaledLastGmFreqChange: Scaled Last GM Freq Change field set in the gPTP FollowUp TLV
	ScaledLastGmFreqChange *Multivalue `json:"scaledLastGmFreqChange,omitempty"`
	// SendMulticastAnnounce: Send multicast Announce messages
	SendMulticastAnnounce *Multivalue `json:"sendMulticastAnnounce,omitempty"`
	// SignalInterval: Time between Signal Request messages, in seconds
	SignalInterval *Multivalue `json:"signalInterval,omitempty"`
	// SignalUnicastHandling: Specifies how signal messages are exchanged when unicast communication mode is in effect.
	SignalUnicastHandling *Multivalue `json:"signalUnicastHandling,omitempty"`
	// SignallingDropRate: Percentage rate of the dropped Signalling messages
	SignallingDropRate *Multivalue `json:"signallingDropRate,omitempty"`
	// SimulateBoundary: Simulate a Grandmaster port behind this clock acting as a Boundary clock
	SimulateBoundary *Multivalue `json:"simulateBoundary,omitempty"`
	// SimulateTransparent: Simulate a transparent clock in front of this master clock.
	SimulateTransparent *Multivalue `json:"simulateTransparent,omitempty"`
	// SlaveCount: The total number of Unicast slaves to be used for this master.
	SlaveCount *Multivalue `json:"slaveCount,omitempty"`
	// SlaveIpAddress: Defines the base address to be used for enumerating all the addresses for this master
	SlaveIpAddress *Multivalue `json:"slaveIpAddress,omitempty"`
	// SlaveIpIncrementBy: Defines the increment to be used for enumerating all the addresses for this master
	SlaveIpIncrementBy *Multivalue `json:"slaveIpIncrementBy,omitempty"`
	// SlaveIpv6Address: Defines the base address to be used for enumerating all the addresses for this master
	SlaveIpv6Address *Multivalue `json:"slaveIpv6Address,omitempty"`
	// SlaveIpv6IncrementBy: Defines the increment to be used for enumerating all the addresses for this master
	SlaveIpv6IncrementBy *Multivalue `json:"slaveIpv6IncrementBy,omitempty"`
	// SlaveMacAddress: Defines the base address to be used for enumerating all the addresses for this master
	SlaveMacAddress *Multivalue `json:"slaveMacAddress,omitempty"`
	// SlaveMacIncrementBy: Defines the increment to be used for enumerating all the addresses for this master
	SlaveMacIncrementBy *Multivalue `json:"slaveMacIncrementBy,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StepMode: Clock step mode
	StepMode *Multivalue `json:"stepMode,omitempty"`
	// StepsRemoved: The Steps Removed field advertised in Announce Messages, representing the number of hops between this emulated Boundary clock and the Grandmaster clock (including it). Valid values: 0 to 65,535.
	StepsRemoved *Multivalue `json:"stepsRemoved,omitempty"`
	// StrictGrant: If selected, the master will not grant values that are above maximum offered values
	StrictGrant *Multivalue `json:"strictGrant,omitempty"`
	// SyncDropRate: Percentage rate of the dropped Sync messages
	SyncDropRate *Multivalue `json:"syncDropRate,omitempty"`
	// SyncReceiptTimeout: The number of seconds that have to pass without receipt of a Sync message to trigger timeout.
	SyncReceiptTimeout *Multivalue `json:"syncReceiptTimeout,omitempty"`
	// SyncReceiptTimeoutgPTP: The number of Sync Intervals that have to pass without receipt of a Sync message to trigger timeout.
	SyncReceiptTimeoutgPTP *Multivalue `json:"syncReceiptTimeoutgPTP,omitempty"`
	// SyncResidenceTime: Master to slave residence time of Sync messages through an associated one-step transparent clock inserted in the correction field of Sync messages sent by this clock
	SyncResidenceTime *Multivalue `json:"syncResidenceTime,omitempty"`
	// TimeAddressFlags: Indicates the intended SMPTE ST 12-1 flags.
	TimeAddressFlags *Multivalue `json:"timeAddressFlags,omitempty"`
	// TimeOfNextJam: The value of the second portion of the PTP time corresponding to the next scheduled occurrence of the Daily Jam.If no Daily Jam is scheduled, the value of timeOfNextJam shall be zero.
	TimeOfNextJam *Multivalue `json:"timeOfNextJam,omitempty"`
	// TimeOfNextJump: The value of the second portion of the grandmaster PTP time at the time when the next discontinuity of the currentLocalOffset will occur.The discontinuity occurs at the start of the second indicated.
	TimeOfNextJump *Multivalue `json:"timeOfNextJump,omitempty"`
	// TimeOfPreviousJam: The value of the second portion of the PTP time corresponding to the previous occurrence of the Daily Jam.
	TimeOfPreviousJam *Multivalue `json:"timeOfPreviousJam,omitempty"`
	// TimeSource: Time source for the PTP device
	TimeSource *Multivalue `json:"timeSource,omitempty"`
	// TimestampOffset: The initial offset added to the local clock when starting the session
	TimestampOffset *Multivalue `json:"timestampOffset,omitempty"`
	// TotalTimeInaccuracy: Total Time Inaccuracy
	TotalTimeInaccuracy *Multivalue `json:"totalTimeInaccuracy,omitempty"`
	// TxCalibration: The amount of time (in ns) that the transmit timestamp of one step messages (Sync, PdelayResp) needs to be adjusted for error
	TxCalibration *Multivalue `json:"txCalibration,omitempty"`
	// TxTwoStepCalibration: The amount of time (in ns) that the read transmit timestamp of sent messages (two-step Sync, DelayReq, PdelayReq, two-step PdelayResp) needs to be adjusted for error
	TxTwoStepCalibration *Multivalue `json:"txTwoStepCalibration,omitempty"`
	// UpdateTime: Clocks in Slave role will correct their time based on received Sync messages
	UpdateTime *Multivalue `json:"updateTime,omitempty"`

	AtoiTLVList *TopologyAtoiTlvList `json:"atoiTLVList,omitempty"`

	PtpNegBehaveList *TopologyPtpNegBehaveList `json:"ptpNegBehaveList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPtp) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPtp) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPtp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPtp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AllowedFaults.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allowedFaults",
		isMultivalue: true,
	})
	n.AllowedLostResponse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "allowedLostResponse",
		isMultivalue: true,
	})
	n.AlternateMasterFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "alternateMasterFlag",
		isMultivalue: true,
	})
	n.AnnounceCurrentUtcOffsetValid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announceCurrentUtcOffsetValid",
		isMultivalue: true,
	})
	n.AnnounceDropRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announceDropRate",
		isMultivalue: true,
	})
	n.AnnounceFrequencyTraceable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announceFrequencyTraceable",
		isMultivalue: true,
	})
	n.AnnounceLeap59.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announceLeap59",
		isMultivalue: true,
	})
	n.AnnounceLeap61.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announceLeap61",
		isMultivalue: true,
	})
	n.AnnouncePtpTimescale.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announcePtpTimescale",
		isMultivalue: true,
	})
	n.AnnounceReceiptTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announceReceiptTimeout",
		isMultivalue: true,
	})
	n.AnnounceTimeTraceable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "announceTimeTraceable",
		isMultivalue: true,
	})
	n.Bmca.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bmca",
		isMultivalue: true,
	})
	n.ClockAccuracy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clockAccuracy",
		isMultivalue: true,
	})
	n.ClockClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clockClass",
		isMultivalue: true,
	})
	n.ClockIdentity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "clockIdentity",
		isMultivalue: true,
	})
	n.CommunicationMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "communicationMode",
		isMultivalue: true,
	})
	n.CumulativeScaledRateOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cumulativeScaledRateOffset",
		isMultivalue: true,
	})
	n.CurrentLocalOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "currentLocalOffset",
		isMultivalue: true,
	})
	n.CurrentUtcOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "currentUtcOffset",
		isMultivalue: true,
	})
	n.CustomClockId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "customClockId",
		isMultivalue: true,
	})
	n.DaylightSaving.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "daylightSaving",
		isMultivalue: true,
	})
	n.DefaultSystemFrameRateDenominator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "defaultSystemFrameRateDenominator",
		isMultivalue: true,
	})
	n.DefaultSystemFrameRateNumerator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "defaultSystemFrameRateNumerator",
		isMultivalue: true,
	})
	n.DelayAsymmetry.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayAsymmetry",
		isMultivalue: true,
	})
	n.DelayMechanism.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayMechanism",
		isMultivalue: true,
	})
	n.DelayReqDropRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayReqDropRate",
		isMultivalue: true,
	})
	n.DelayReqOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayReqOffset",
		isMultivalue: true,
	})
	n.DelayReqResidenceTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayReqResidenceTime",
		isMultivalue: true,
	})
	n.DelayReqSpread.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayReqSpread",
		isMultivalue: true,
	})
	n.DelayRespDropRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayRespDropRate",
		isMultivalue: true,
	})
	n.DelayRespReceiptTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayRespReceiptTimeout",
		isMultivalue: true,
	})
	n.DelayRespResidenceTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayRespResidenceTime",
		isMultivalue: true,
	})
	n.DelayResponseDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayResponseDelay",
		isMultivalue: true,
	})
	n.DelayResponseDelayInsertionRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "delayResponseDelayInsertionRate",
		isMultivalue: true,
	})
	n.Domain.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "domain",
		isMultivalue: true,
	})
	n.DropMalformed.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dropMalformed",
		isMultivalue: true,
	})
	n.DropSignalReqAnnounce.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dropSignalReqAnnounce",
		isMultivalue: true,
	})
	n.DropSignalReqDelayResp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dropSignalReqDelayResp",
		isMultivalue: true,
	})
	n.DropSignalReqSync.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dropSignalReqSync",
		isMultivalue: true,
	})
	n.FolderPath.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "folderPath",
		isMultivalue: true,
	})
	n.FollowUpBadCrcRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "followUpBadCrcRate",
		isMultivalue: true,
	})
	n.FollowUpDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "followUpDelay",
		isMultivalue: true,
	})
	n.FollowUpDelayInsertionRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "followUpDelayInsertionRate",
		isMultivalue: true,
	})
	n.FollowUpDropRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "followUpDropRate",
		isMultivalue: true,
	})
	n.FollowUpResidenceTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "followUpResidenceTime",
		isMultivalue: true,
	})
	n.GPTPCapableReceiptTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gPTPCapableReceiptTimeout",
		isMultivalue: true,
	})
	n.GmTimeBaseIndicator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "gmTimeBaseIndicator",
		isMultivalue: true,
	})
	n.GrandmasterID.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "grandmasterID",
		isMultivalue: true,
	})
	n.GrandmasterIdentity.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "grandmasterIdentity",
		isMultivalue: true,
	})
	n.GrantDelayRespDurationInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "grantDelayRespDurationInterval",
		isMultivalue: true,
	})
	n.GrantSyncDurationInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "grantSyncDurationInterval",
		isMultivalue: true,
	})
	n.GrantUnicastDurationInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "grantUnicastDurationInterval",
		isMultivalue: true,
	})
	n.HandleAnnounceTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "handleAnnounceTlv",
		isMultivalue: true,
	})
	n.HandleCancelTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "handleCancelTlv",
		isMultivalue: true,
	})
	n.JumpSeconds.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "jumpSeconds",
		isMultivalue: true,
	})
	n.LastGmPhaseChange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lastGmPhaseChange",
		isMultivalue: true,
	})
	n.LeapSecondJump.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leapSecondJump",
		isMultivalue: true,
	})
	n.LearnPortId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "learnPortId",
		isMultivalue: true,
	})
	n.LogAnnounceInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logAnnounceInterval",
		isMultivalue: true,
	})
	n.LogDelayReqInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logDelayReqInterval",
		isMultivalue: true,
	})
	n.LogFuturePacketInfo.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logFuturePacketInfo",
		isMultivalue: true,
	})
	n.LogManagementMsgInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logManagementMsgInterval",
		isMultivalue: true,
	})
	n.LogSignallingInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logSignallingInterval",
		isMultivalue: true,
	})
	n.LogSyncInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "logSyncInterval",
		isMultivalue: true,
	})
	n.MasterCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterCount",
		isMultivalue: true,
	})
	n.MasterIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterIpAddress",
		isMultivalue: true,
	})
	n.MasterIpIncrementBy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterIpIncrementBy",
		isMultivalue: true,
	})
	n.MasterIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterIpv6Address",
		isMultivalue: true,
	})
	n.MasterIpv6IncrementBy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterIpv6IncrementBy",
		isMultivalue: true,
	})
	n.MasterLockingStatus.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterLockingStatus",
		isMultivalue: true,
	})
	n.MasterMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterMacAddress",
		isMultivalue: true,
	})
	n.MasterMacIncrementBy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "masterMacIncrementBy",
		isMultivalue: true,
	})
	n.MeanLinkDelayThreshold.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "meanLinkDelayThreshold",
		isMultivalue: true,
	})
	n.MulticastAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "multicastAddress",
		isMultivalue: true,
	})
	n.NanosecondsPerSecond.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nanosecondsPerSecond",
		isMultivalue: true,
	})
	n.NotSlave.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "notSlave",
		isMultivalue: true,
	})
	n.NumRecords.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numRecords",
		isMultivalue: true,
	})
	n.OffsetBaseddebuggabilityEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetBaseddebuggabilityEnabled",
		isMultivalue: true,
	})
	n.OffsetLimit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetLimit",
		isMultivalue: true,
	})
	n.OffsetScaledLogVariance.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "offsetScaledLogVariance",
		isMultivalue: true,
	})
	n.OneWay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oneWay",
		isMultivalue: true,
	})
	n.PDelayFollowUpDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pDelayFollowUpDelay",
		isMultivalue: true,
	})
	n.PDelayFollowUpDelayInsertionRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pDelayFollowUpDelayInsertionRate",
		isMultivalue: true,
	})
	n.PDelayFollowUpDropRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pDelayFollowUpDropRate",
		isMultivalue: true,
	})
	n.PDelayFollowUpResidenceTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pDelayFollowUpResidenceTime",
		isMultivalue: true,
	})
	n.PathTraceTLV.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pathTraceTLV",
		isMultivalue: true,
	})
	n.PortNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portNumber",
		isMultivalue: true,
	})
	n.PreviousJamLocalOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "previousJamLocalOffset",
		isMultivalue: true,
	})
	n.Priority1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority1",
		isMultivalue: true,
	})
	n.Priority2.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority2",
		isMultivalue: true,
	})
	n.Profile.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "profile",
		isMultivalue: true,
	})
	n.RenewalInvited.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "renewalInvited",
		isMultivalue: true,
	})
	n.RequestAttempts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requestAttempts",
		isMultivalue: true,
	})
	n.RequestHolddown.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requestHolddown",
		isMultivalue: true,
	})
	n.RequestInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requestInterval",
		isMultivalue: true,
	})
	n.Reserved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reserved",
		isMultivalue: true,
	})
	n.ReverseSync.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reverseSync",
		isMultivalue: true,
	})
	n.ReverseSyncIntervalPercent.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reverseSyncIntervalPercent",
		isMultivalue: true,
	})
	n.Role.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "role",
		isMultivalue: true,
	})
	n.RxCalibration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxCalibration",
		isMultivalue: true,
	})
	n.ScaledLastGmFreqChange.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "scaledLastGmFreqChange",
		isMultivalue: true,
	})
	n.SendMulticastAnnounce.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendMulticastAnnounce",
		isMultivalue: true,
	})
	n.SignalInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "signalInterval",
		isMultivalue: true,
	})
	n.SignalUnicastHandling.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "signalUnicastHandling",
		isMultivalue: true,
	})
	n.SignallingDropRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "signallingDropRate",
		isMultivalue: true,
	})
	n.SimulateBoundary.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "simulateBoundary",
		isMultivalue: true,
	})
	n.SimulateTransparent.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "simulateTransparent",
		isMultivalue: true,
	})
	n.SlaveCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "slaveCount",
		isMultivalue: true,
	})
	n.SlaveIpAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "slaveIpAddress",
		isMultivalue: true,
	})
	n.SlaveIpIncrementBy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "slaveIpIncrementBy",
		isMultivalue: true,
	})
	n.SlaveIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "slaveIpv6Address",
		isMultivalue: true,
	})
	n.SlaveIpv6IncrementBy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "slaveIpv6IncrementBy",
		isMultivalue: true,
	})
	n.SlaveMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "slaveMacAddress",
		isMultivalue: true,
	})
	n.SlaveMacIncrementBy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "slaveMacIncrementBy",
		isMultivalue: true,
	})
	n.StepMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stepMode",
		isMultivalue: true,
	})
	n.StepsRemoved.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "stepsRemoved",
		isMultivalue: true,
	})
	n.StrictGrant.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "strictGrant",
		isMultivalue: true,
	})
	n.SyncDropRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "syncDropRate",
		isMultivalue: true,
	})
	n.SyncReceiptTimeout.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "syncReceiptTimeout",
		isMultivalue: true,
	})
	n.SyncReceiptTimeoutgPTP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "syncReceiptTimeoutgPTP",
		isMultivalue: true,
	})
	n.SyncResidenceTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "syncResidenceTime",
		isMultivalue: true,
	})
	n.TimeAddressFlags.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeAddressFlags",
		isMultivalue: true,
	})
	n.TimeOfNextJam.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeOfNextJam",
		isMultivalue: true,
	})
	n.TimeOfNextJump.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeOfNextJump",
		isMultivalue: true,
	})
	n.TimeOfPreviousJam.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeOfPreviousJam",
		isMultivalue: true,
	})
	n.TimeSource.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeSource",
		isMultivalue: true,
	})
	n.TimestampOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timestampOffset",
		isMultivalue: true,
	})
	n.TotalTimeInaccuracy.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "totalTimeInaccuracy",
		isMultivalue: true,
	})
	n.TxCalibration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txCalibration",
		isMultivalue: true,
	})
	n.TxTwoStepCalibration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txTwoStepCalibration",
		isMultivalue: true,
	})
	n.UpdateTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "updateTime",
		isMultivalue: true,
	})
	n.AtoiTLVList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "atoiTLVList",
	})
	n.PtpNegBehaveList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ptpNegBehaveList",
	})
}

// TopologyPtpNegBehaveList: Ptp Negative Behaviour Related Configuration
type TopologyPtpNegBehaveList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// MvActive: Activate/Deactivate Configuration
	MvActive *Multivalue `json:"mvActive,omitempty"`
	// MvDelay: Delay To Follow in this message (ns)
	MvDelay *Multivalue `json:"mvDelay,omitempty"`
	// MvFieldValue: Value
	MvFieldValue *Multivalue `json:"mvFieldValue,omitempty"`
	// MvFieldValue1: Value1
	MvFieldValue1 *Multivalue `json:"mvFieldValue1,omitempty"`
	// MvMsgAction: Action On The Message Type
	MvMsgAction *Multivalue `json:"mvMsgAction,omitempty"`
	// MvPtpMsgField: PTP Msg Field
	MvPtpMsgField *Multivalue `json:"mvPtpMsgField,omitempty"`
	// MvPtpMsgField1: PTP Msg Field1
	MvPtpMsgField1 *Multivalue `json:"mvPtpMsgField1,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PtpMsgType: Displays the current PTP Msg
	PtpMsgType *Multivalue `json:"ptpMsgType,omitempty"`
	// PtpValueDisPattern: Pattern For Value Field
	PtpValueDisPattern *Multivalue `json:"ptpValueDisPattern,omitempty"`
	// PtpValueDisPattern1: Pattern For Value Field
	PtpValueDisPattern1 *Multivalue `json:"ptpValueDisPattern1,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyPtpNegBehaveList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyPtpNegBehaveList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyPtpNegBehaveList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyPtpNegBehaveList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.MvActive.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvActive",
		isMultivalue: true,
	})
	n.MvDelay.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvDelay",
		isMultivalue: true,
	})
	n.MvFieldValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvFieldValue",
		isMultivalue: true,
	})
	n.MvFieldValue1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvFieldValue1",
		isMultivalue: true,
	})
	n.MvMsgAction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvMsgAction",
		isMultivalue: true,
	})
	n.MvPtpMsgField.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvPtpMsgField",
		isMultivalue: true,
	})
	n.MvPtpMsgField1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvPtpMsgField1",
		isMultivalue: true,
	})
	n.PtpMsgType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ptpMsgType",
		isMultivalue: true,
	})
	n.PtpValueDisPattern.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ptpValueDisPattern",
		isMultivalue: true,
	})
	n.PtpValueDisPattern1.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ptpValueDisPattern1",
		isMultivalue: true,
	})
}

// TopologyRemoteInterfaceId: TBD
type TopologyRemoteInterfaceId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRemoteInterfaceId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRemoteInterfaceId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRemoteInterfaceId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRemoteInterfaceId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyRemoteIpv4Address: TBD
type TopologyRemoteIpv4Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRemoteIpv4Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRemoteIpv4Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRemoteIpv4Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRemoteIpv4Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyRemoteIpv6Address: TBD
type TopologyRemoteIpv6Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRemoteIpv6Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRemoteIpv6Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRemoteIpv6Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRemoteIpv6Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyRemoteNodeId: TBD
type TopologyRemoteNodeId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRemoteNodeId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRemoteNodeId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRemoteNodeId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRemoteNodeId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyRepeatableContainer: Tlv repeatable field container used to group multiple fields
type TopologyRepeatableContainer struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsEnabled: Enables/disables this field

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Name: Name of the tlv

	Name   *string           `json:"name,omitempty"`
	Object []*TopologyObject `json:"object"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRepeatableContainer) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRepeatableContainer) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRepeatableContainer) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRepeatableContainer) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Object {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "object",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRequestId: TBD
type TopologyRequestId struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRequestId) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRequestId) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRequestId) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRequestId) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyRequestedLsps: Requested LSPs
type TopologyRequestedLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// ActiveDataTrafficEndPoints: Specifies whether that specific Data Traffic Endpoint will generate data traffic
	ActiveDataTrafficEndPoints *Multivalue `json:"activeDataTrafficEndPoints,omitempty"`
	// Bandwidth: Bandwidth (bits/sec)
	Bandwidth *Multivalue `json:"bandwidth,omitempty"`
	// BiDirectional: Bi-directional
	BiDirectional *Multivalue `json:"biDirectional,omitempty"`
	// DestinationIpv4Address: Destination IPv4 Address
	DestinationIpv4Address *Multivalue `json:"destinationIpv4Address,omitempty"`
	// DestinationIpv6Address: Destination IPv6 Address
	DestinationIpv6Address *Multivalue `json:"destinationIpv6Address,omitempty"`
	// ExcludeAny: Exclude Any
	ExcludeAny *Multivalue `json:"excludeAny,omitempty"`
	// FailBit: Fail Bit
	FailBit *Multivalue `json:"failBit,omitempty"`
	// HoldingPriority: Holding Priority
	HoldingPriority *Multivalue `json:"holdingPriority,omitempty"`
	// IncludeAll: Include All
	IncludeAll *Multivalue `json:"includeAll,omitempty"`
	// IncludeAny: Include Any
	IncludeAny *Multivalue `json:"includeAny,omitempty"`
	// IncludeBandwidth: Include Bandwidth
	IncludeBandwidth *Multivalue `json:"includeBandwidth,omitempty"`
	// IncludeEndPoints: Include End Points
	IncludeEndPoints *Multivalue `json:"includeEndPoints,omitempty"`
	// IncludeIro: Include IRO
	IncludeIro *Multivalue `json:"includeIro,omitempty"`
	// IncludeLsp: Include LSP
	IncludeLsp *Multivalue `json:"includeLsp,omitempty"`
	// IncludeLspa: Include LSPA
	IncludeLspa *Multivalue `json:"includeLspa,omitempty"`
	// IncludeMetric: Include Metric
	IncludeMetric *Multivalue `json:"includeMetric,omitempty"`
	// IncludeRp: Include RP
	IncludeRp *Multivalue `json:"includeRp,omitempty"`
	// IncludeSymbolicPathNameTlv: Include Symbolic Path Name TLV
	IncludeSymbolicPathNameTlv *Multivalue `json:"includeSymbolicPathNameTlv,omitempty"`
	// IncludeXro: Include XRO
	IncludeXro *Multivalue `json:"includeXro,omitempty"`
	// InitialDelegation: Initial Delegation
	InitialDelegation *Multivalue `json:"initialDelegation,omitempty"`
	// InsertIpv6ExplicitNull: Insert IPv6 Explicit Null MPLS header if the traffic type is of type IPv6

	InsertIpv6ExplicitNull *bool `json:"insertIpv6ExplicitNull,omitempty"`
	// IpVersion: IP Version
	IpVersion *Multivalue `json:"ipVersion,omitempty"`
	// LocalProtection: Local Protection
	LocalProtection *Multivalue `json:"localProtection,omitempty"`
	// Loose: Loose
	Loose *Multivalue `json:"loose,omitempty"`
	// MaxExpectedSegmentCount: This control is used to set the maximum Segment count/ MPLS labels that would be present in the generted traffic.

	MaxExpectedSegmentCount *float32 `json:"maxExpectedSegmentCount,omitempty"`
	// MaxNoOfIroSubObjects: Max Number of IRO Sub Objects

	MaxNoOfIroSubObjects *float32 `json:"maxNoOfIroSubObjects,omitempty"`
	// MaxNoOfXroSubObjects: Max Number of XRO Sub Objects

	MaxNoOfXroSubObjects *float32 `json:"maxNoOfXroSubObjects,omitempty"`
	// MaxNumberOfMetrics: Max Number of Metrics

	MaxNumberOfMetrics *float32 `json:"maxNumberOfMetrics,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OverridePlspId: Override PLSP-ID

	OverridePlspId *bool `json:"overridePlspId,omitempty"`
	// OverrideRequestId: Override Request ID

	OverrideRequestId *bool `json:"overrideRequestId,omitempty"`
	// OverrideSourceAddress: Override Source Address
	OverrideSourceAddress *Multivalue `json:"overrideSourceAddress,omitempty"`
	// PFlagBandwidth: Bandwidth P Flag
	PFlagBandwidth *Multivalue `json:"pFlagBandwidth,omitempty"`
	// PFlagIro: IRO P Flag
	PFlagIro *Multivalue `json:"pFlagIro,omitempty"`
	// PFlagLsp: LSP P Flag
	PFlagLsp *Multivalue `json:"pFlagLsp,omitempty"`
	// PFlagLspa: LSPA P Flag
	PFlagLspa *Multivalue `json:"pFlagLspa,omitempty"`
	// PFlagRp: RP P Flag
	PFlagRp *Multivalue `json:"pFlagRp,omitempty"`
	// PFlagXro: XRO P Flag
	PFlagXro *Multivalue `json:"pFlagXro,omitempty"`
	// PflagEndpoints: End Points P Flag
	PflagEndpoints *Multivalue `json:"pflagEndpoints,omitempty"`
	// PlspId: An identifier for the LSP. A PCC creates a unique PLSP-ID for each LSP that is constant for the lifetime of a PCEP session. The PCC will advertise the same PLSP-ID on all PCEP sessions it maintains at a given time.
	PlspId *Multivalue `json:"plspId,omitempty"`
	// Priority: Priority
	Priority *Multivalue `json:"priority,omitempty"`
	// ReOptimization: Re-optimization
	ReOptimization *Multivalue `json:"reOptimization,omitempty"`
	// RedelegationTimeoutInterval: The period of time a PCC waits for, when a PCEP session is terminated, before revoking LSP delegation to a PCE and attempting to redelegate LSPs associated with the terminated PCEP session to PCE.
	RedelegationTimeoutInterval *Multivalue `json:"redelegationTimeoutInterval,omitempty"`
	// RequestId: Request ID
	RequestId *Multivalue `json:"requestId,omitempty"`
	// SetupPriority: Setup Priority
	SetupPriority *Multivalue `json:"setupPriority,omitempty"`
	// SourceEndPointIPv4: Source IPv4 Address
	SourceEndPointIPv4 *Multivalue `json:"sourceEndPointIPv4,omitempty"`
	// SourceEndPointIPv6: Source IPv6 Address
	SourceEndPointIPv6 *Multivalue `json:"sourceEndPointIPv6,omitempty"`
	// SourceIpv4Address: Source IPv4 Address
	SourceIpv4Address *Multivalue `json:"sourceIpv4Address,omitempty"`
	// SourceIpv6Address: Source IPv6 Address
	SourceIpv6Address *Multivalue `json:"sourceIpv6Address,omitempty"`
	// SymbolicPathName: Symbolic Path Name
	SymbolicPathName                 *Multivalue                                 `json:"symbolicPathName,omitempty"`
	PccRequestedMetricSubObjectsList []*TopologyPccRequestedMetricSubObjectsList `json:"pccRequestedMetricSubObjectsList"`
	PcepIroSubObjectsList            []*TopologyPcepIroSubObjectsList            `json:"pcepIroSubObjectsList"`
	PcepXroSubObjectsList            []*TopologyPcepXroSubObjectsList            `json:"pcepXroSubObjectsList"`
	Tag                              []*TopologyTag                              `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRequestedLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRequestedLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRequestedLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRequestedLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActiveDataTrafficEndPoints.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeDataTrafficEndPoints",
		isMultivalue: true,
	})
	n.Bandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidth",
		isMultivalue: true,
	})
	n.BiDirectional.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "biDirectional",
		isMultivalue: true,
	})
	n.DestinationIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationIpv4Address",
		isMultivalue: true,
	})
	n.DestinationIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationIpv6Address",
		isMultivalue: true,
	})
	n.ExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAny",
		isMultivalue: true,
	})
	n.FailBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "failBit",
		isMultivalue: true,
	})
	n.HoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdingPriority",
		isMultivalue: true,
	})
	n.IncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAll",
		isMultivalue: true,
	})
	n.IncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAny",
		isMultivalue: true,
	})
	n.IncludeBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeBandwidth",
		isMultivalue: true,
	})
	n.IncludeEndPoints.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeEndPoints",
		isMultivalue: true,
	})
	n.IncludeIro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeIro",
		isMultivalue: true,
	})
	n.IncludeLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLsp",
		isMultivalue: true,
	})
	n.IncludeLspa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLspa",
		isMultivalue: true,
	})
	n.IncludeMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeMetric",
		isMultivalue: true,
	})
	n.IncludeRp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeRp",
		isMultivalue: true,
	})
	n.IncludeSymbolicPathNameTlv.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSymbolicPathNameTlv",
		isMultivalue: true,
	})
	n.IncludeXro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeXro",
		isMultivalue: true,
	})
	n.InitialDelegation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initialDelegation",
		isMultivalue: true,
	})
	n.IpVersion.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipVersion",
		isMultivalue: true,
	})
	n.LocalProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localProtection",
		isMultivalue: true,
	})
	n.Loose.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "loose",
		isMultivalue: true,
	})
	n.OverrideSourceAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideSourceAddress",
		isMultivalue: true,
	})
	n.PFlagBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagBandwidth",
		isMultivalue: true,
	})
	n.PFlagIro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagIro",
		isMultivalue: true,
	})
	n.PFlagLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagLsp",
		isMultivalue: true,
	})
	n.PFlagLspa.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagLspa",
		isMultivalue: true,
	})
	n.PFlagRp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagRp",
		isMultivalue: true,
	})
	n.PFlagXro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pFlagXro",
		isMultivalue: true,
	})
	n.PflagEndpoints.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pflagEndpoints",
		isMultivalue: true,
	})
	n.PlspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "plspId",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.ReOptimization.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reOptimization",
		isMultivalue: true,
	})
	n.RedelegationTimeoutInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redelegationTimeoutInterval",
		isMultivalue: true,
	})
	n.RequestId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "requestId",
		isMultivalue: true,
	})
	n.SetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setupPriority",
		isMultivalue: true,
	})
	n.SourceEndPointIPv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceEndPointIPv4",
		isMultivalue: true,
	})
	n.SourceEndPointIPv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceEndPointIPv6",
		isMultivalue: true,
	})
	n.SourceIpv4Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv4Address",
		isMultivalue: true,
	})
	n.SourceIpv6Address.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv6Address",
		isMultivalue: true,
	})
	n.SymbolicPathName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "symbolicPathName",
		isMultivalue: true,
	})
	for i, o := range n.PccRequestedMetricSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pccRequestedMetricSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PcepIroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepIroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.PcepXroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "pcepXroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRestriction: Choices for field value
type TopologyRestriction struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enum: Internal enumeration type to be used as value options

	Enum *string `json:"enum,omitempty"`
	// SingleValue: Restricts the field to single value pattern without overlays

	SingleValue *bool `json:"singleValue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRestriction) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRestriction) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRestriction) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRestriction) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyRfc8277LabelStack: Rfc 8277 Label Stack
type TopologyRfc8277LabelStack struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// MplsLabelEnd: MPLS Label End
	MplsLabelEnd *Multivalue `json:"mplsLabelEnd,omitempty"`
	// MplsLabelStart: MPLS Label Start
	MplsLabelStart *Multivalue `json:"mplsLabelStart,omitempty"`
	// MplsLabelStep: MPLS Label Step
	MplsLabelStep *Multivalue `json:"mplsLabelStep,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRfc8277LabelStack) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRfc8277LabelStack) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRfc8277LabelStack) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRfc8277LabelStack) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.MplsLabelEnd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabelEnd",
		isMultivalue: true,
	})
	n.MplsLabelStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabelStart",
		isMultivalue: true,
	})
	n.MplsLabelStep.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mplsLabelStep",
		isMultivalue: true,
	})
}

// TopologyRouterData: Router related configuration settings.
type TopologyRouterData struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RouterId: 4 Byte Router Id in dotted decimal format.
	RouterId *Multivalue `json:"routerId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRouterData) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRouterData) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRouterData) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRouterData) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.RouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerId",
		isMultivalue: true,
	})
}

// TopologyRow: A row view of learned information.
type TopologyRow struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRow) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRow) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRow) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRow) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyRsvpDetourSubObjectsList: Rsvp Detour Sub-Objects
type TopologyRsvpDetourSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AvoidNodeId: Avoid Node ID
	AvoidNodeId *Multivalue `json:"avoidNodeId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PlrId: PLR ID
	PlrId *Multivalue `json:"plrId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpDetourSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpDetourSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpDetourSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpDetourSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AvoidNodeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "avoidNodeId",
		isMultivalue: true,
	})
	n.PlrId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "plrId",
		isMultivalue: true,
	})
}

// TopologyRsvpEroSubObjectsList: Rsvp ERO Sub-Objects
type TopologyRsvpEroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AsNumber: AS
	AsNumber *Multivalue `json:"asNumber,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// LooseFlag: Loose Flag
	LooseFlag *Multivalue `json:"looseFlag,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// Type_: Type: IP or AS
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpEroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpEroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpEroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpEroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "asNumber",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.LooseFlag.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "looseFlag",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyRsvpIngressRroSubObjectsList: Rsvp Ingress RRO Sub-Objects
type TopologyRsvpIngressRroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BandwidthProtection: Bandwidth Protection
	BandwidthProtection *Multivalue `json:"bandwidthProtection,omitempty"`
	// CType: C-Type
	CType *Multivalue `json:"cType,omitempty"`
	// GlobalLabel: Global Label
	GlobalLabel *Multivalue `json:"globalLabel,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// Label: Label
	Label *Multivalue `json:"label,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NodeProtection: Node Protection
	NodeProtection *Multivalue `json:"nodeProtection,omitempty"`
	// ProtectionAvailable: Protection Available
	ProtectionAvailable *Multivalue `json:"protectionAvailable,omitempty"`
	// ProtectionInUse: Protection In Use
	ProtectionInUse *Multivalue `json:"protectionInUse,omitempty"`
	// Type_: Reservation Style
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpIngressRroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpIngressRroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpIngressRroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpIngressRroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BandwidthProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthProtection",
		isMultivalue: true,
	})
	n.CType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cType",
		isMultivalue: true,
	})
	n.GlobalLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "globalLabel",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.Label.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "label",
		isMultivalue: true,
	})
	n.NodeProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeProtection",
		isMultivalue: true,
	})
	n.ProtectionAvailable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectionAvailable",
		isMultivalue: true,
	})
	n.ProtectionInUse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectionInUse",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyRsvpP2PEgressLsps: RSVP-TE p2p Tail (Egress) LSPs
type TopologyRsvpP2PEgressLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// EnableFixedLabelForReservations: Enable Fixed Label For Reservations
	EnableFixedLabelForReservations *Multivalue `json:"enableFixedLabelForReservations,omitempty"`
	// EnableReplyingLspPing: Enable Replying To Lsp Ping
	EnableReplyingLspPing *Multivalue `json:"enableReplyingLspPing,omitempty"`
	// EndPointIpv6: Destination IPv6
	EndPointIpv6 *Multivalue `json:"endPointIpv6,omitempty"`
	// ForwardLspSelfPing: Forward LSP Self Ping
	ForwardLspSelfPing *Multivalue `json:"forwardLspSelfPing,omitempty"`
	// InitialLspSelfPingDropCount: Initial LSP Self Ping Drop Count. Number of times Egress LSP will drop LSP Self Ping Message before forwarding it back.
	InitialLspSelfPingDropCount *Multivalue `json:"initialLspSelfPingDropCount,omitempty"`
	// IpTTLDecrementCount: IP TTL Decrement Count. IP TTL limits the lifespan or lifetime of IP Packet in a network.
	IpTTLDecrementCount *Multivalue `json:"ipTTLDecrementCount,omitempty"`
	// LabelValue: Label Value
	LabelValue *Multivalue `json:"labelValue,omitempty"`
	// LspSelfPingIPDSCP: LSP Self Ping IP DSCP. IP DSCP classifies the way an IP packet is routed in a network.
	LspSelfPingIPDSCP *Multivalue `json:"lspSelfPingIPDSCP,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfRroSubObjects: Number Of RRO Sub-Objects

	NumberOfRroSubObjects *float32 `json:"numberOfRroSubObjects,omitempty"`
	// ReflectRro: Reflect RRO
	ReflectRro *Multivalue `json:"reflectRro,omitempty"`
	// RefreshInterval: Refresh Interval (ms)
	RefreshInterval *Multivalue `json:"refreshInterval,omitempty"`
	// ReservationStyle: Reservation Style
	ReservationStyle *Multivalue `json:"reservationStyle,omitempty"`
	// RetainLspSelfPingDSCP: Retain LSP Self Ping DSCP
	RetainLspSelfPingDSCP *Multivalue `json:"retainLspSelfPingDSCP,omitempty"`
	// SendReservationConfirmation: Send Reservation Confirmation
	SendReservationConfirmation *Multivalue `json:"sendReservationConfirmation,omitempty"`
	// TimeoutMultiplier: Timeout Multiplier
	TimeoutMultiplier     *Multivalue                      `json:"timeoutMultiplier,omitempty"`
	RsvpRROSubObjectsList []*TopologyRsvpRroSubObjectsList `json:"rsvpRROSubObjectsList"`
	Tag                   []*TopologyTag                   `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpP2PEgressLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpP2PEgressLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpP2PEgressLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpP2PEgressLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableFixedLabelForReservations.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFixedLabelForReservations",
		isMultivalue: true,
	})
	n.EnableReplyingLspPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableReplyingLspPing",
		isMultivalue: true,
	})
	n.EndPointIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointIpv6",
		isMultivalue: true,
	})
	n.ForwardLspSelfPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "forwardLspSelfPing",
		isMultivalue: true,
	})
	n.InitialLspSelfPingDropCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initialLspSelfPingDropCount",
		isMultivalue: true,
	})
	n.IpTTLDecrementCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipTTLDecrementCount",
		isMultivalue: true,
	})
	n.LabelValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValue",
		isMultivalue: true,
	})
	n.LspSelfPingIPDSCP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspSelfPingIPDSCP",
		isMultivalue: true,
	})
	n.ReflectRro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reflectRro",
		isMultivalue: true,
	})
	n.RefreshInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "refreshInterval",
		isMultivalue: true,
	})
	n.ReservationStyle.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservationStyle",
		isMultivalue: true,
	})
	n.RetainLspSelfPingDSCP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "retainLspSelfPingDSCP",
		isMultivalue: true,
	})
	n.SendReservationConfirmation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendReservationConfirmation",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	for i, o := range n.RsvpRROSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpRROSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRsvpP2PIngressLsps: RSVP-TE p2p Head ( Ingress ) LSPs
type TopologyRsvpP2PIngressLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AssociationId: The Association ID of this LSP.
	AssociationId *Multivalue `json:"associationId,omitempty"`
	// AutoGenerateSessionName: Auto Generate Session Name
	AutoGenerateSessionName *Multivalue `json:"autoGenerateSessionName,omitempty"`
	// AutorouteTraffic: Autoroute Traffic
	AutorouteTraffic *Multivalue `json:"autorouteTraffic,omitempty"`
	// BackupLspEnableEro: Enable ERO
	BackupLspEnableEro *Multivalue `json:"backupLspEnableEro,omitempty"`
	// BackupLspId: Backup LSP Id Pool Start
	BackupLspId *Multivalue `json:"backupLspId,omitempty"`
	// BackupLspMaximumPacketSize: Maximum Packet Size
	BackupLspMaximumPacketSize *Multivalue `json:"backupLspMaximumPacketSize,omitempty"`
	// BackupLspMinimumPolicedUnit: Minimum Policed Unit
	BackupLspMinimumPolicedUnit *Multivalue `json:"backupLspMinimumPolicedUnit,omitempty"`
	// BackupLspNumberOfEroSubObjects: Number Of ERO Sub-Objects

	BackupLspNumberOfEroSubObjects *float32 `json:"backupLspNumberOfEroSubObjects,omitempty"`
	// BackupLspPeakDataRate: Peak Data Rate
	BackupLspPeakDataRate *Multivalue `json:"backupLspPeakDataRate,omitempty"`
	// BackupLspPrefixLength: Prefix Length
	BackupLspPrefixLength *Multivalue `json:"backupLspPrefixLength,omitempty"`
	// BackupLspPrependDutToEro: Prepend DUT to ERO
	BackupLspPrependDutToEro *Multivalue `json:"backupLspPrependDutToEro,omitempty"`
	// BackupLspSessionId: Backup LSP Session Id
	BackupLspSessionId *Multivalue `json:"backupLspSessionId,omitempty"`
	// BackupLspTokenBucketRate: Token Bucket Rate
	BackupLspTokenBucketRate *Multivalue `json:"backupLspTokenBucketRate,omitempty"`
	// BackupLspTokenBucketSize: Token Bucket Size
	BackupLspTokenBucketSize *Multivalue `json:"backupLspTokenBucketSize,omitempty"`
	// Bandwidth: Bandwidth (bps)
	Bandwidth *Multivalue `json:"bandwidth,omitempty"`
	// BandwidthProtectionDesired: Bandwidth Protection Desired
	BandwidthProtectionDesired *Multivalue `json:"bandwidthProtectionDesired,omitempty"`
	// ConfigureSyncLspObject: Include Objects
	ConfigureSyncLspObject *Multivalue `json:"configureSyncLspObject,omitempty"`
	// DelayLspSwitchOver: Delay LSP switch over

	DelayLspSwitchOver *bool `json:"delayLspSwitchOver,omitempty"`
	// DoMBBOnApplyChanges: Do Make Before Break on Apply Changes

	DoMBBOnApplyChanges *bool `json:"doMBBOnApplyChanges,omitempty"`
	// EnableBfdMpls: If selected, BFD MPLS is enabled.
	EnableBfdMpls *Multivalue `json:"enableBfdMpls,omitempty"`
	// EnableEro: Enable ERO
	EnableEro *Multivalue `json:"enableEro,omitempty"`
	// EnableFastReroute: Enable Fast Reroute
	EnableFastReroute *Multivalue `json:"enableFastReroute,omitempty"`
	// EnableLspPing: If selected, LSP Ping is enabled for learned LSPs.
	EnableLspPing *Multivalue `json:"enableLspPing,omitempty"`
	// EnableLspSelfPing: If enabled, Ingress LSP will use LSP Self Ping procedure to verify that forwarding state has been installed on all downstream nodes.
	EnableLspSelfPing *Multivalue `json:"enableLspSelfPing,omitempty"`
	// EnablePathReOptimization: Enable Path Re-Optimization
	EnablePathReOptimization *Multivalue `json:"enablePathReOptimization,omitempty"`
	// EnablePeriodicReEvaluationRequest: Enable Periodic Re-Evaluation Request
	EnablePeriodicReEvaluationRequest *Multivalue `json:"enablePeriodicReEvaluationRequest,omitempty"`
	// EroSameAsPrimary: ERO Same As Primary

	EroSameAsPrimary *bool `json:"eroSameAsPrimary,omitempty"`
	// ExcludeAny: Exclude Any
	ExcludeAny *Multivalue `json:"excludeAny,omitempty"`
	// FacilityBackupDesired: Facility Backup Desired
	FacilityBackupDesired *Multivalue `json:"facilityBackupDesired,omitempty"`
	// FastRerouteBandwidth: Bandwidth (bps)
	FastRerouteBandwidth *Multivalue `json:"fastRerouteBandwidth,omitempty"`
	// FastRerouteExcludeAny: Exclude Any
	FastRerouteExcludeAny *Multivalue `json:"fastRerouteExcludeAny,omitempty"`
	// FastRerouteHoldingPriority: Holding Priority
	FastRerouteHoldingPriority *Multivalue `json:"fastRerouteHoldingPriority,omitempty"`
	// FastRerouteIncludeAll: Include All
	FastRerouteIncludeAll *Multivalue `json:"fastRerouteIncludeAll,omitempty"`
	// FastRerouteIncludeAny: Include Any
	FastRerouteIncludeAny *Multivalue `json:"fastRerouteIncludeAny,omitempty"`
	// FastRerouteSetupPriority: Setup Priority
	FastRerouteSetupPriority *Multivalue `json:"fastRerouteSetupPriority,omitempty"`
	// HoldingPriority: Holding Priority
	HoldingPriority *Multivalue `json:"holdingPriority,omitempty"`
	// HopLimit: Hop Limit
	HopLimit *Multivalue `json:"hopLimit,omitempty"`
	// IncludeAll: Include All
	IncludeAll *Multivalue `json:"includeAll,omitempty"`
	// IncludeAny: Include Any
	IncludeAny *Multivalue `json:"includeAny,omitempty"`
	// IncludeAssociation: Indicates whether Association will be included in a RSVP Sync LSP. All other attributes in sub-tab-PPAG would be editable only if this checkbox is enabled.
	IncludeAssociation *Multivalue `json:"includeAssociation,omitempty"`
	// InitialDelegation: Initial Delegation
	InitialDelegation *Multivalue `json:"initialDelegation,omitempty"`
	// InsertIPv6ExplicitNull: Insert IPv6 explicit NULL
	InsertIPv6ExplicitNull *Multivalue `json:"insertIPv6ExplicitNull,omitempty"`
	// IpDSCPofLspSelfPing: IP DSCP of LSP Self Ping. IP DSCP classifies the way an IP packet is routed in a network.
	IpDSCPofLspSelfPing *Multivalue `json:"ipDSCPofLspSelfPing,omitempty"`
	// IpTTLofLspSelfPing: IP TTL of LSP Self Ping. IP TTL limits the lifespan or lifetime of IP Packet in a network.
	IpTTLofLspSelfPing *Multivalue `json:"ipTTLofLspSelfPing,omitempty"`
	// LabelRecordingDesired: Label Recording Desired
	LabelRecordingDesired *Multivalue `json:"labelRecordingDesired,omitempty"`
	// LocalProtectionDesired: Local Protection Desired
	LocalProtectionDesired *Multivalue `json:"localProtectionDesired,omitempty"`
	// LspCount: LSP#
	LspCount *Multivalue `json:"lspCount,omitempty"`
	// LspId: LSP Id
	LspId *Multivalue `json:"lspId,omitempty"`
	// LspOperativeMode: The mode of LSP in which it is currently behaving.
	LspOperativeMode *Multivalue `json:"lspOperativeMode,omitempty"`
	// LspSelfPingRetryCount: LSP Self Ping Retry Count. Maximum number of times LSP Self Ping Message will be Transmitted.
	LspSelfPingRetryCount *Multivalue `json:"lspSelfPingRetryCount,omitempty"`
	// LspSelfPingRetryInterval: LSP Self Ping Retry Interval (ms).
	LspSelfPingRetryInterval *Multivalue `json:"lspSelfPingRetryInterval,omitempty"`
	// LspSelfPingSessionId: LSP Self Ping Session Id.
	LspSelfPingSessionId *Multivalue `json:"lspSelfPingSessionId,omitempty"`
	// LspSwitchOverDelayTime: LSP Switch Over Delay timer (sec)

	LspSwitchOverDelayTime *float32 `json:"lspSwitchOverDelayTime,omitempty"`
	// MaximumPacketSize: Maximum Packet Size (in Bytes)
	MaximumPacketSize *Multivalue `json:"maximumPacketSize,omitempty"`
	// MinimumPolicedUnit: Minimum Policed Unit (in Bytes)
	MinimumPolicedUnit *Multivalue `json:"minimumPolicedUnit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NodeProtectionDesired: Node Protection Desired
	NodeProtectionDesired *Multivalue `json:"nodeProtectionDesired,omitempty"`
	// NumberOfDetourSubObjects: Number Of Detour Sub-Objects

	NumberOfDetourSubObjects *float32 `json:"numberOfDetourSubObjects,omitempty"`
	// NumberOfEroSubObjects: Number Of ERO Sub-Objects

	NumberOfEroSubObjects *float32 `json:"numberOfEroSubObjects,omitempty"`
	// NumberOfRroSubObjects: Number Of RRO Sub-Objects

	NumberOfRroSubObjects *float32 `json:"numberOfRroSubObjects,omitempty"`
	// OneToOneBackupDesired: One To One Backup Desired
	OneToOneBackupDesired *Multivalue `json:"oneToOneBackupDesired,omitempty"`
	// PeakDataRate: Peak Data Rate (in Bytes per seconds)
	PeakDataRate *Multivalue `json:"peakDataRate,omitempty"`
	// PpagTLVType: PPAG TLV Type
	PpagTLVType *Multivalue `json:"ppagTLVType,omitempty"`
	// PrefixLength: Prefix Length
	PrefixLength *Multivalue `json:"prefixLength,omitempty"`
	// PrependDutToEro: Prepend DUT to ERO
	PrependDutToEro *Multivalue `json:"prependDutToEro,omitempty"`
	// ProtectionLsp: Indicates whether Protection LSP Bit is On.
	ProtectionLsp *Multivalue `json:"protectionLsp,omitempty"`
	// ReEvaluationRequestInterval: Re-Evaluation Request Interval
	ReEvaluationRequestInterval *Multivalue `json:"reEvaluationRequestInterval,omitempty"`
	// RedelegationTimeoutInterval: The period of time a PCC waits for, when a PCEP session is terminated, before revoking LSP delegation to a PCE and attempting to redelegate LSPs associated with the terminated PCEP session to PCE.
	RedelegationTimeoutInterval *Multivalue `json:"redelegationTimeoutInterval,omitempty"`
	// RefreshInterval: Refresh Interval (ms)
	RefreshInterval *Multivalue `json:"refreshInterval,omitempty"`
	// RemoteIp: Remote IP Address
	RemoteIp *Multivalue `json:"remoteIp,omitempty"`
	// ResourceAffinities: Resource Affinities
	ResourceAffinities *Multivalue `json:"resourceAffinities,omitempty"`
	// SeStyleDesired: SE Style Desired
	SeStyleDesired *Multivalue `json:"seStyleDesired,omitempty"`
	// SendDetour: Send Detour
	SendDetour *Multivalue `json:"sendDetour,omitempty"`
	// SendRro: Send RRO
	SendRro *Multivalue `json:"sendRro,omitempty"`
	// SessionName: Session Name
	SessionName *Multivalue `json:"sessionName,omitempty"`
	// SetupPriority: Setup Priority
	SetupPriority *Multivalue `json:"setupPriority,omitempty"`
	// SourceIp: Source IP
	SourceIp *Multivalue `json:"sourceIp,omitempty"`
	// SourceIpv6: Source IPv6
	SourceIpv6 *Multivalue `json:"sourceIpv6,omitempty"`
	// StandbyMode: Indicates whether Standby LSP Bit is On.
	StandbyMode *Multivalue `json:"standbyMode,omitempty"`
	// TSpecSameAsPrimary: TSpec Same As Primary

	TSpecSameAsPrimary *bool `json:"tSpecSameAsPrimary,omitempty"`
	// TimeoutMultiplier: Timeout Multiplier
	TimeoutMultiplier *Multivalue `json:"timeoutMultiplier,omitempty"`
	// TokenBucketRate: Token Bucket Rate (in Bytes per seconds)
	TokenBucketRate *Multivalue `json:"tokenBucketRate,omitempty"`
	// TokenBucketSize: Token Bucket Size (in Bytes)
	TokenBucketSize *Multivalue `json:"tokenBucketSize,omitempty"`
	// TunnelId: Tunnel ID
	TunnelId *Multivalue `json:"tunnelId,omitempty"`
	// UsingHeadendIp: Using Headend IP
	UsingHeadendIp               *Multivalue                             `json:"usingHeadendIp,omitempty"`
	BackupLspEROSubObjectsList   []*TopologyBackupLspEroSubObjectsList   `json:"backupLspEROSubObjectsList"`
	RsvpDetourSubObjectsList     []*TopologyRsvpDetourSubObjectsList     `json:"rsvpDetourSubObjectsList"`
	RsvpEROSubObjectsList        []*TopologyRsvpEroSubObjectsList        `json:"rsvpEROSubObjectsList"`
	RsvpIngressRROSubObjectsList []*TopologyRsvpIngressRroSubObjectsList `json:"rsvpIngressRROSubObjectsList"`
	Tag                          []*TopologyTag                          `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpP2PIngressLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpP2PIngressLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpP2PIngressLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpP2PIngressLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AssociationId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "associationId",
		isMultivalue: true,
	})
	n.AutoGenerateSessionName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoGenerateSessionName",
		isMultivalue: true,
	})
	n.AutorouteTraffic.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autorouteTraffic",
		isMultivalue: true,
	})
	n.BackupLspEnableEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspEnableEro",
		isMultivalue: true,
	})
	n.BackupLspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspId",
		isMultivalue: true,
	})
	n.BackupLspMaximumPacketSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspMaximumPacketSize",
		isMultivalue: true,
	})
	n.BackupLspMinimumPolicedUnit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspMinimumPolicedUnit",
		isMultivalue: true,
	})
	n.BackupLspPeakDataRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspPeakDataRate",
		isMultivalue: true,
	})
	n.BackupLspPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspPrefixLength",
		isMultivalue: true,
	})
	n.BackupLspPrependDutToEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspPrependDutToEro",
		isMultivalue: true,
	})
	n.BackupLspSessionId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspSessionId",
		isMultivalue: true,
	})
	n.BackupLspTokenBucketRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspTokenBucketRate",
		isMultivalue: true,
	})
	n.BackupLspTokenBucketSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspTokenBucketSize",
		isMultivalue: true,
	})
	n.Bandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidth",
		isMultivalue: true,
	})
	n.BandwidthProtectionDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthProtectionDesired",
		isMultivalue: true,
	})
	n.ConfigureSyncLspObject.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "configureSyncLspObject",
		isMultivalue: true,
	})
	n.EnableBfdMpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdMpls",
		isMultivalue: true,
	})
	n.EnableEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEro",
		isMultivalue: true,
	})
	n.EnableFastReroute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFastReroute",
		isMultivalue: true,
	})
	n.EnableLspPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLspPing",
		isMultivalue: true,
	})
	n.EnableLspSelfPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLspSelfPing",
		isMultivalue: true,
	})
	n.EnablePathReOptimization.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePathReOptimization",
		isMultivalue: true,
	})
	n.EnablePeriodicReEvaluationRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePeriodicReEvaluationRequest",
		isMultivalue: true,
	})
	n.ExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAny",
		isMultivalue: true,
	})
	n.FacilityBackupDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "facilityBackupDesired",
		isMultivalue: true,
	})
	n.FastRerouteBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteBandwidth",
		isMultivalue: true,
	})
	n.FastRerouteExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteExcludeAny",
		isMultivalue: true,
	})
	n.FastRerouteHoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteHoldingPriority",
		isMultivalue: true,
	})
	n.FastRerouteIncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteIncludeAll",
		isMultivalue: true,
	})
	n.FastRerouteIncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteIncludeAny",
		isMultivalue: true,
	})
	n.FastRerouteSetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteSetupPriority",
		isMultivalue: true,
	})
	n.HoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdingPriority",
		isMultivalue: true,
	})
	n.HopLimit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hopLimit",
		isMultivalue: true,
	})
	n.IncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAll",
		isMultivalue: true,
	})
	n.IncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAny",
		isMultivalue: true,
	})
	n.IncludeAssociation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAssociation",
		isMultivalue: true,
	})
	n.InitialDelegation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initialDelegation",
		isMultivalue: true,
	})
	n.InsertIPv6ExplicitNull.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "insertIPv6ExplicitNull",
		isMultivalue: true,
	})
	n.IpDSCPofLspSelfPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipDSCPofLspSelfPing",
		isMultivalue: true,
	})
	n.IpTTLofLspSelfPing.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipTTLofLspSelfPing",
		isMultivalue: true,
	})
	n.LabelRecordingDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelRecordingDesired",
		isMultivalue: true,
	})
	n.LocalProtectionDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localProtectionDesired",
		isMultivalue: true,
	})
	n.LspCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspCount",
		isMultivalue: true,
	})
	n.LspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspId",
		isMultivalue: true,
	})
	n.LspOperativeMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspOperativeMode",
		isMultivalue: true,
	})
	n.LspSelfPingRetryCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspSelfPingRetryCount",
		isMultivalue: true,
	})
	n.LspSelfPingRetryInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspSelfPingRetryInterval",
		isMultivalue: true,
	})
	n.LspSelfPingSessionId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspSelfPingSessionId",
		isMultivalue: true,
	})
	n.MaximumPacketSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maximumPacketSize",
		isMultivalue: true,
	})
	n.MinimumPolicedUnit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minimumPolicedUnit",
		isMultivalue: true,
	})
	n.NodeProtectionDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeProtectionDesired",
		isMultivalue: true,
	})
	n.OneToOneBackupDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oneToOneBackupDesired",
		isMultivalue: true,
	})
	n.PeakDataRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peakDataRate",
		isMultivalue: true,
	})
	n.PpagTLVType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ppagTLVType",
		isMultivalue: true,
	})
	n.PrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLength",
		isMultivalue: true,
	})
	n.PrependDutToEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prependDutToEro",
		isMultivalue: true,
	})
	n.ProtectionLsp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectionLsp",
		isMultivalue: true,
	})
	n.ReEvaluationRequestInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reEvaluationRequestInterval",
		isMultivalue: true,
	})
	n.RedelegationTimeoutInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "redelegationTimeoutInterval",
		isMultivalue: true,
	})
	n.RefreshInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "refreshInterval",
		isMultivalue: true,
	})
	n.RemoteIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteIp",
		isMultivalue: true,
	})
	n.ResourceAffinities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "resourceAffinities",
		isMultivalue: true,
	})
	n.SeStyleDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "seStyleDesired",
		isMultivalue: true,
	})
	n.SendDetour.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendDetour",
		isMultivalue: true,
	})
	n.SendRro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendRro",
		isMultivalue: true,
	})
	n.SessionName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionName",
		isMultivalue: true,
	})
	n.SetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setupPriority",
		isMultivalue: true,
	})
	n.SourceIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIp",
		isMultivalue: true,
	})
	n.SourceIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv6",
		isMultivalue: true,
	})
	n.StandbyMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "standbyMode",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	n.TokenBucketRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tokenBucketRate",
		isMultivalue: true,
	})
	n.TokenBucketSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tokenBucketSize",
		isMultivalue: true,
	})
	n.TunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelId",
		isMultivalue: true,
	})
	n.UsingHeadendIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "usingHeadendIp",
		isMultivalue: true,
	})
	for i, o := range n.BackupLspEROSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "backupLspEROSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpDetourSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpDetourSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpEROSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpEROSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpIngressRROSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpIngressRROSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRsvpP2mpEgressLsps: RSVP-TE P2MP Tail (Egress) Tunnels
type TopologyRsvpP2mpEgressLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// DestinationIpv4GroupAddress: Destination IPv4 Group Address
	DestinationIpv4GroupAddress *Multivalue `json:"destinationIpv4GroupAddress,omitempty"`
	// EnableFixedLabelForReservations: Enable Fixed Label For Reservations
	EnableFixedLabelForReservations *Multivalue `json:"enableFixedLabelForReservations,omitempty"`
	// EndPointIpv6: Destination IPv6 Group Address
	EndPointIpv6 *Multivalue `json:"endPointIpv6,omitempty"`
	// IncludeConnectedIpOnTop: Include connected IP on top
	IncludeConnectedIpOnTop *Multivalue `json:"includeConnectedIpOnTop,omitempty"`
	// IncludeLeafIpAtBottom: Include Leaf IP at bottom
	IncludeLeafIpAtBottom *Multivalue `json:"includeLeafIpAtBottom,omitempty"`
	// LabelValue: Label Value
	LabelValue *Multivalue `json:"labelValue,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfRroSubObjects: Number Of RRO Sub-Objects

	NumberOfRroSubObjects *float32 `json:"numberOfRroSubObjects,omitempty"`
	// P2mpIdAsNumber: P2MP ID displayed in Integer format
	P2mpIdAsNumber *Multivalue `json:"p2mpIdAsNumber,omitempty"`
	// P2mpIdIp: P2MP ID displayed in IP Address format
	P2mpIdIp *Multivalue `json:"p2mpIdIp,omitempty"`
	// ReflectRro: Reflect RRO
	ReflectRro *Multivalue `json:"reflectRro,omitempty"`
	// RefreshInterval: Refresh Interval (ms)
	RefreshInterval *Multivalue `json:"refreshInterval,omitempty"`
	// ReservationStyle: Reservation Style
	ReservationStyle *Multivalue `json:"reservationStyle,omitempty"`
	// SendAsRro: Send As RRO
	SendAsRro *Multivalue `json:"sendAsRro,omitempty"`
	// SendAsSrro: Send As SRRO
	SendAsSrro *Multivalue `json:"sendAsSrro,omitempty"`
	// SendReservationConfirmation: Send Reservation Confirmation
	SendReservationConfirmation *Multivalue `json:"sendReservationConfirmation,omitempty"`
	// SubLspsDown: Sub LSPs Down
	SubLspsDown *Multivalue `json:"subLspsDown,omitempty"`
	// TimeoutMultiplier: Timeout Multiplier
	TimeoutMultiplier *Multivalue `json:"timeoutMultiplier,omitempty"`
	// TypeP2mpId: P2MP ID Type

	TypeP2mpId            *string                          `json:"typeP2mpId,omitempty"`
	RsvpRroSubObjectsList []*TopologyRsvpRroSubObjectsList `json:"rsvpRroSubObjectsList"`
	Tag                   []*TopologyTag                   `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpP2mpEgressLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpP2mpEgressLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpP2mpEgressLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpP2mpEgressLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DestinationIpv4GroupAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationIpv4GroupAddress",
		isMultivalue: true,
	})
	n.EnableFixedLabelForReservations.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFixedLabelForReservations",
		isMultivalue: true,
	})
	n.EndPointIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endPointIpv6",
		isMultivalue: true,
	})
	n.IncludeConnectedIpOnTop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeConnectedIpOnTop",
		isMultivalue: true,
	})
	n.IncludeLeafIpAtBottom.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeLeafIpAtBottom",
		isMultivalue: true,
	})
	n.LabelValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelValue",
		isMultivalue: true,
	})
	n.P2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "p2mpIdAsNumber",
		isMultivalue: true,
	})
	n.P2mpIdIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "p2mpIdIp",
		isMultivalue: true,
	})
	n.ReflectRro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reflectRro",
		isMultivalue: true,
	})
	n.RefreshInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "refreshInterval",
		isMultivalue: true,
	})
	n.ReservationStyle.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reservationStyle",
		isMultivalue: true,
	})
	n.SendAsRro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendAsRro",
		isMultivalue: true,
	})
	n.SendAsSrro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendAsSrro",
		isMultivalue: true,
	})
	n.SendReservationConfirmation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendReservationConfirmation",
		isMultivalue: true,
	})
	n.SubLspsDown.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subLspsDown",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	for i, o := range n.RsvpRroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpRroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRsvpP2mpIngressLsps: RSVP-TE P2MP Head (Ingress) LSPs
type TopologyRsvpP2mpIngressLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AutoGenerateSessionName: Auto Generate Session Name
	AutoGenerateSessionName *Multivalue `json:"autoGenerateSessionName,omitempty"`
	// BackupLspId: Backup LSP Id Pool Start
	BackupLspId *Multivalue `json:"backupLspId,omitempty"`
	// BandwidthProtectionDesired: Bandwidth Protection Desired
	BandwidthProtectionDesired *Multivalue `json:"bandwidthProtectionDesired,omitempty"`
	// DelayLspSwitchOver: Delay LSP switch over

	DelayLspSwitchOver *bool `json:"delayLspSwitchOver,omitempty"`
	// EnableFastReroute: Enable Fast Reroute
	EnableFastReroute *Multivalue `json:"enableFastReroute,omitempty"`
	// EnablePathReOptimization: Enable Path Re-Optimization
	EnablePathReOptimization *Multivalue `json:"enablePathReOptimization,omitempty"`
	// EnablePeriodicReEvaluationRequest: Enable Periodic Re-Evaluation Request
	EnablePeriodicReEvaluationRequest *Multivalue `json:"enablePeriodicReEvaluationRequest,omitempty"`
	// ExcludeAny: Exclude Any
	ExcludeAny *Multivalue `json:"excludeAny,omitempty"`
	// FacilityBackupDesired: Facility Backup Desired
	FacilityBackupDesired *Multivalue `json:"facilityBackupDesired,omitempty"`
	// FastRerouteBandwidth: Bandwidth (bps)
	FastRerouteBandwidth *Multivalue `json:"fastRerouteBandwidth,omitempty"`
	// FastRerouteExcludeAny: Exclude Any
	FastRerouteExcludeAny *Multivalue `json:"fastRerouteExcludeAny,omitempty"`
	// FastRerouteHoldingPriority: Holding Priority
	FastRerouteHoldingPriority *Multivalue `json:"fastRerouteHoldingPriority,omitempty"`
	// FastRerouteIncludeAll: Include All
	FastRerouteIncludeAll *Multivalue `json:"fastRerouteIncludeAll,omitempty"`
	// FastRerouteIncludeAny: Include Any
	FastRerouteIncludeAny *Multivalue `json:"fastRerouteIncludeAny,omitempty"`
	// FastRerouteSetupPriority: Setup Priority
	FastRerouteSetupPriority *Multivalue `json:"fastRerouteSetupPriority,omitempty"`
	// HoldingPriority: Holding Priority
	HoldingPriority *Multivalue `json:"holdingPriority,omitempty"`
	// HopLimit: Hop Limit
	HopLimit *Multivalue `json:"hopLimit,omitempty"`
	// IncludeAll: Include All
	IncludeAll *Multivalue `json:"includeAll,omitempty"`
	// IncludeAny: Include Any
	IncludeAny *Multivalue `json:"includeAny,omitempty"`
	// IncludeConnectedIpOnTop: Include connected IP on top
	IncludeConnectedIpOnTop *Multivalue `json:"includeConnectedIpOnTop,omitempty"`
	// IncludeHeadIpAtBottom: Include Head IP at bottom
	IncludeHeadIpAtBottom *Multivalue `json:"includeHeadIpAtBottom,omitempty"`
	// IngressP2mpSubLspRanges: Number of P2MP Ingress Sub LSPs configured per RSVP-TE P2MP Ingress LSP

	IngressP2mpSubLspRanges *float32 `json:"ingressP2mpSubLspRanges,omitempty"`
	// InsertIPv6ExplicitNull: Insert IPv6 explicit NULL
	InsertIPv6ExplicitNull *Multivalue `json:"insertIPv6ExplicitNull,omitempty"`
	// LabelRecordingDesired: Label Recording Desired
	LabelRecordingDesired *Multivalue `json:"labelRecordingDesired,omitempty"`
	// LocalProtectionDesired: Local Protection Desired
	LocalProtectionDesired *Multivalue `json:"localProtectionDesired,omitempty"`
	// LspId: LSP Id
	LspId *Multivalue `json:"lspId,omitempty"`
	// LspSwitchOverDelayTime: LSP Switch Over Delay timer (sec)

	LspSwitchOverDelayTime *float32 `json:"lspSwitchOverDelayTime,omitempty"`
	// MaximumPacketSize: Maximum Packet Size (in Bytes)
	MaximumPacketSize *Multivalue `json:"maximumPacketSize,omitempty"`
	// MinimumPolicedUnit: Minimum Policed Unit (in Bytes)
	MinimumPolicedUnit *Multivalue `json:"minimumPolicedUnit,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NodeProtectionDesired: Node Protection Desired
	NodeProtectionDesired *Multivalue `json:"nodeProtectionDesired,omitempty"`
	// NumberOfDetourSubObjects: Number Of Detour Sub-Objects

	NumberOfDetourSubObjects *float32 `json:"numberOfDetourSubObjects,omitempty"`
	// NumberOfRroSubObjects: Number Of RRO Sub-Objects

	NumberOfRroSubObjects *float32 `json:"numberOfRroSubObjects,omitempty"`
	// OneToOneBackupDesired: One To One Backup Desired
	OneToOneBackupDesired *Multivalue `json:"oneToOneBackupDesired,omitempty"`
	// P2mpIdAsNumber: P2MP ID displayed in Integer format
	P2mpIdAsNumber *Multivalue `json:"p2mpIdAsNumber,omitempty"`
	// P2mpIdIp: P2MP ID displayed in IP Address format
	P2mpIdIp *Multivalue `json:"p2mpIdIp,omitempty"`
	// PeakDataRate: Peak Data Rate (in Bytes per seconds)
	PeakDataRate *Multivalue `json:"peakDataRate,omitempty"`
	// ReEvaluationRequestInterval: Re-Evaluation Request Interval
	ReEvaluationRequestInterval *Multivalue `json:"reEvaluationRequestInterval,omitempty"`
	// RefreshInterval: Refresh Interval (ms)
	RefreshInterval *Multivalue `json:"refreshInterval,omitempty"`
	// ResourceAffinities: Resource Affinities
	ResourceAffinities *Multivalue `json:"resourceAffinities,omitempty"`
	// SeStyleDesired: SE Style Desired
	SeStyleDesired *Multivalue `json:"seStyleDesired,omitempty"`
	// SendDetour: Send Detour
	SendDetour *Multivalue `json:"sendDetour,omitempty"`
	// SendRro: Send RRO
	SendRro *Multivalue `json:"sendRro,omitempty"`
	// SessionName: Session Name
	SessionName *Multivalue `json:"sessionName,omitempty"`
	// SetupPriority: Setup Priority
	SetupPriority *Multivalue `json:"setupPriority,omitempty"`
	// SourceIpv4: Source IPv4
	SourceIpv4 *Multivalue `json:"sourceIpv4,omitempty"`
	// SourceIpv6: Source IPv6
	SourceIpv6 *Multivalue `json:"sourceIpv6,omitempty"`
	// TimeoutMultiplier: Timeout Multiplier
	TimeoutMultiplier *Multivalue `json:"timeoutMultiplier,omitempty"`
	// TokenBucketRate: Token Bucket Rate (in Bytes per seconds)
	TokenBucketRate *Multivalue `json:"tokenBucketRate,omitempty"`
	// TokenBucketSize: Token Bucket Size (in Bytes)
	TokenBucketSize *Multivalue `json:"tokenBucketSize,omitempty"`
	// TunnelId: Tunnel ID
	TunnelId *Multivalue `json:"tunnelId,omitempty"`
	// TypeP2mpId: P2MP ID Type

	TypeP2mpId *string `json:"typeP2mpId,omitempty"`
	// UsingHeadendIp: Using Headend IP
	UsingHeadendIp               *Multivalue                             `json:"usingHeadendIp,omitempty"`
	RsvpDetourSubObjectsList     []*TopologyRsvpDetourSubObjectsList     `json:"rsvpDetourSubObjectsList"`
	RsvpIngressRroSubObjectsList []*TopologyRsvpIngressRroSubObjectsList `json:"rsvpIngressRroSubObjectsList"`

	RsvpP2mpIngressSubLsps *TopologyRsvpP2mpIngressSubLsps `json:"rsvpP2mpIngressSubLsps,omitempty"`
	Tag                    []*TopologyTag                  `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpP2mpIngressLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpP2mpIngressLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpP2mpIngressLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpP2mpIngressLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AutoGenerateSessionName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoGenerateSessionName",
		isMultivalue: true,
	})
	n.BackupLspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspId",
		isMultivalue: true,
	})
	n.BandwidthProtectionDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthProtectionDesired",
		isMultivalue: true,
	})
	n.EnableFastReroute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableFastReroute",
		isMultivalue: true,
	})
	n.EnablePathReOptimization.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePathReOptimization",
		isMultivalue: true,
	})
	n.EnablePeriodicReEvaluationRequest.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePeriodicReEvaluationRequest",
		isMultivalue: true,
	})
	n.ExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "excludeAny",
		isMultivalue: true,
	})
	n.FacilityBackupDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "facilityBackupDesired",
		isMultivalue: true,
	})
	n.FastRerouteBandwidth.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteBandwidth",
		isMultivalue: true,
	})
	n.FastRerouteExcludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteExcludeAny",
		isMultivalue: true,
	})
	n.FastRerouteHoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteHoldingPriority",
		isMultivalue: true,
	})
	n.FastRerouteIncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteIncludeAll",
		isMultivalue: true,
	})
	n.FastRerouteIncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteIncludeAny",
		isMultivalue: true,
	})
	n.FastRerouteSetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fastRerouteSetupPriority",
		isMultivalue: true,
	})
	n.HoldingPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "holdingPriority",
		isMultivalue: true,
	})
	n.HopLimit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "hopLimit",
		isMultivalue: true,
	})
	n.IncludeAll.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAll",
		isMultivalue: true,
	})
	n.IncludeAny.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeAny",
		isMultivalue: true,
	})
	n.IncludeConnectedIpOnTop.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeConnectedIpOnTop",
		isMultivalue: true,
	})
	n.IncludeHeadIpAtBottom.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeHeadIpAtBottom",
		isMultivalue: true,
	})
	n.InsertIPv6ExplicitNull.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "insertIPv6ExplicitNull",
		isMultivalue: true,
	})
	n.LabelRecordingDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelRecordingDesired",
		isMultivalue: true,
	})
	n.LocalProtectionDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "localProtectionDesired",
		isMultivalue: true,
	})
	n.LspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lspId",
		isMultivalue: true,
	})
	n.MaximumPacketSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maximumPacketSize",
		isMultivalue: true,
	})
	n.MinimumPolicedUnit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minimumPolicedUnit",
		isMultivalue: true,
	})
	n.NodeProtectionDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeProtectionDesired",
		isMultivalue: true,
	})
	n.OneToOneBackupDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "oneToOneBackupDesired",
		isMultivalue: true,
	})
	n.P2mpIdAsNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "p2mpIdAsNumber",
		isMultivalue: true,
	})
	n.P2mpIdIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "p2mpIdIp",
		isMultivalue: true,
	})
	n.PeakDataRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peakDataRate",
		isMultivalue: true,
	})
	n.ReEvaluationRequestInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "reEvaluationRequestInterval",
		isMultivalue: true,
	})
	n.RefreshInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "refreshInterval",
		isMultivalue: true,
	})
	n.ResourceAffinities.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "resourceAffinities",
		isMultivalue: true,
	})
	n.SeStyleDesired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "seStyleDesired",
		isMultivalue: true,
	})
	n.SendDetour.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendDetour",
		isMultivalue: true,
	})
	n.SendRro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendRro",
		isMultivalue: true,
	})
	n.SessionName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sessionName",
		isMultivalue: true,
	})
	n.SetupPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setupPriority",
		isMultivalue: true,
	})
	n.SourceIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv4",
		isMultivalue: true,
	})
	n.SourceIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIpv6",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	n.TokenBucketRate.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tokenBucketRate",
		isMultivalue: true,
	})
	n.TokenBucketSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tokenBucketSize",
		isMultivalue: true,
	})
	n.TunnelId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tunnelId",
		isMultivalue: true,
	})
	n.UsingHeadendIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "usingHeadendIp",
		isMultivalue: true,
	})
	for i, o := range n.RsvpDetourSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpDetourSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RsvpIngressRroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpIngressRroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.RsvpP2mpIngressSubLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpP2mpIngressSubLsps",
	})
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRsvpP2mpIngressSubLsps: RSVP-TE P2MP Head (Ingress) Sub LSPs
type TopologyRsvpP2mpIngressSubLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AppendLeaf: Append Leaf
	AppendLeaf *Multivalue `json:"appendLeaf,omitempty"`
	// EnableEro: Enable ERO
	EnableEro *Multivalue `json:"enableEro,omitempty"`
	// LeafIp: Leaf IP
	LeafIp *Multivalue `json:"leafIp,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfEroSubObjects: Number Of ERO Sub-Objects

	NumberOfEroSubObjects *float32 `json:"numberOfEroSubObjects,omitempty"`
	// PrefixLengthOfDut: Prefix Length of DUT
	PrefixLengthOfDut *Multivalue `json:"prefixLengthOfDut,omitempty"`
	// PrefixLengthOfLeaf: Prefix Length of Leaf
	PrefixLengthOfLeaf *Multivalue `json:"prefixLengthOfLeaf,omitempty"`
	// PrependDut: Prepend DUT
	PrependDut *Multivalue `json:"prependDut,omitempty"`
	// SendAsEro: Send As ERO
	SendAsEro *Multivalue `json:"sendAsEro,omitempty"`
	// SendAsSero: Send As SERO
	SendAsSero            *Multivalue                      `json:"sendAsSero,omitempty"`
	RsvpEroSubObjectsList []*TopologyRsvpEroSubObjectsList `json:"rsvpEroSubObjectsList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpP2mpIngressSubLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpP2mpIngressSubLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpP2mpIngressSubLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpP2mpIngressSubLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AppendLeaf.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "appendLeaf",
		isMultivalue: true,
	})
	n.EnableEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEro",
		isMultivalue: true,
	})
	n.LeafIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "leafIp",
		isMultivalue: true,
	})
	n.PrefixLengthOfDut.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLengthOfDut",
		isMultivalue: true,
	})
	n.PrefixLengthOfLeaf.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prefixLengthOfLeaf",
		isMultivalue: true,
	})
	n.PrependDut.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "prependDut",
		isMultivalue: true,
	})
	n.SendAsEro.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendAsEro",
		isMultivalue: true,
	})
	n.SendAsSero.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sendAsSero",
		isMultivalue: true,
	})
	for i, o := range n.RsvpEroSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpEroSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRsvpPcepExpectedInitiatedLsps: RSVP-TE PCEP Expected Initiated LSPs
type TopologyRsvpPcepExpectedInitiatedLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// BackupLspId: TBD
	BackupLspId *Multivalue `json:"backupLspId,omitempty"`
	// EnableRRO: Enable RRO
	EnableRRO *Multivalue `json:"enableRRO,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfRroSubObjects: Number Of RRO Sub-Objects

	NumberOfRroSubObjects *float32 `json:"numberOfRroSubObjects,omitempty"`
	// SymbolicPathName: This is used for generating the traffic for those LSPs from PCE for which the Symbolic Path Name is configured and matches the value.
	SymbolicPathName             *Multivalue                             `json:"symbolicPathName,omitempty"`
	RsvpIngressRROSubObjectsList []*TopologyRsvpIngressRroSubObjectsList `json:"rsvpIngressRROSubObjectsList"`
	Tag                          []*TopologyTag                          `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpPcepExpectedInitiatedLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpPcepExpectedInitiatedLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpPcepExpectedInitiatedLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpPcepExpectedInitiatedLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BackupLspId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "backupLspId",
		isMultivalue: true,
	})
	n.EnableRRO.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRRO",
		isMultivalue: true,
	})
	n.SymbolicPathName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "symbolicPathName",
		isMultivalue: true,
	})
	for i, o := range n.RsvpIngressRROSubObjectsList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rsvpIngressRROSubObjectsList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRsvpRroSubObjectsList: Rsvp RRO Sub-Objects
type TopologyRsvpRroSubObjectsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BandwidthProtection: Bandwidth Protection
	BandwidthProtection *Multivalue `json:"bandwidthProtection,omitempty"`
	// CType: C-Type
	CType *Multivalue `json:"cType,omitempty"`
	// GlobalLabel: Global Label
	GlobalLabel *Multivalue `json:"globalLabel,omitempty"`
	// Ip: IP
	Ip *Multivalue `json:"ip,omitempty"`
	// Label: Label
	Label *Multivalue `json:"label,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NodeProtection: Node Protection
	NodeProtection *Multivalue `json:"nodeProtection,omitempty"`
	// ProtectionAvailable: Protection Available
	ProtectionAvailable *Multivalue `json:"protectionAvailable,omitempty"`
	// ProtectionInUse: Protection In Use
	ProtectionInUse *Multivalue `json:"protectionInUse,omitempty"`
	// Type_: Reservation Style
	Type_ *Multivalue `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpRroSubObjectsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpRroSubObjectsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpRroSubObjectsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpRroSubObjectsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.BandwidthProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bandwidthProtection",
		isMultivalue: true,
	})
	n.CType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cType",
		isMultivalue: true,
	})
	n.GlobalLabel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "globalLabel",
		isMultivalue: true,
	})
	n.Ip.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ip",
		isMultivalue: true,
	})
	n.Label.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "label",
		isMultivalue: true,
	})
	n.NodeProtection.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeProtection",
		isMultivalue: true,
	})
	n.ProtectionAvailable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectionAvailable",
		isMultivalue: true,
	})
	n.ProtectionInUse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "protectionInUse",
		isMultivalue: true,
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "type",
		isMultivalue: true,
	})
}

// TopologyRsvpteIf: Rsvp Neighbor (Device) level Configuration
type TopologyRsvpteIf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ActualRestartTime: Actual Restart Time (ms)
	ActualRestartTime *Multivalue `json:"actualRestartTime,omitempty"`
	// AdvertisedRestartTime: Advertised Restart Time (ms)
	AdvertisedRestartTime *Multivalue `json:"advertisedRestartTime,omitempty"`
	// AuthenticationAlgorithm: Authentication Algorithm
	AuthenticationAlgorithm *Multivalue `json:"authenticationAlgorithm,omitempty"`
	// AuthenticationKeyForReceivedPackets: Authentication Key for Received Packets
	AuthenticationKeyForReceivedPackets *Multivalue `json:"authenticationKeyForReceivedPackets,omitempty"`
	// AuthenticationKeyForSentPackets: Authentication Key for Sent Packets
	AuthenticationKeyForSentPackets *Multivalue `json:"authenticationKeyForSentPackets,omitempty"`
	// AuthenticationKeyIdentifier: Authentication Key Identifier
	AuthenticationKeyIdentifier *Multivalue `json:"authenticationKeyIdentifier,omitempty"`
	// AutoGenerateAuthenticationKeyIdentifier: Auto Generate Authentication Key Identifier
	AutoGenerateAuthenticationKeyIdentifier *Multivalue `json:"autoGenerateAuthenticationKeyIdentifier,omitempty"`
	// BundleMessageThresholdTime: Bundle Message Threshold Time (ms)
	BundleMessageThresholdTime *Multivalue `json:"bundleMessageThresholdTime,omitempty"`
	// CheckIntegrityForReceivedPackets: Check Integrity for Received Packets
	CheckIntegrityForReceivedPackets *Multivalue `json:"checkIntegrityForReceivedPackets,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DutIp: DUT IP
	DutIp *Multivalue `json:"dutIp,omitempty"`
	// EnableBfdRegistration: Enable BFD Registration
	EnableBfdRegistration *Multivalue `json:"enableBfdRegistration,omitempty"`
	// EnableBundleMessageSending: Enable Bundle Message Sending
	EnableBundleMessageSending *Multivalue `json:"enableBundleMessageSending,omitempty"`
	// EnableBundleMessageThresholdTimer: Enable Bundle Message Threshold Timer
	EnableBundleMessageThresholdTimer *Multivalue `json:"enableBundleMessageThresholdTimer,omitempty"`
	// EnableGracefulRestartHelperMode: Enable Helper-Mode
	EnableGracefulRestartHelperMode *Multivalue `json:"enableGracefulRestartHelperMode,omitempty"`
	// EnableGracefulRestartRestartingMode: Enable Restarting-Mode
	EnableGracefulRestartRestartingMode *Multivalue `json:"enableGracefulRestartRestartingMode,omitempty"`
	// EnableHelloExtension: Enable Hello Extension
	EnableHelloExtension *Multivalue `json:"enableHelloExtension,omitempty"`
	// EnableRefreshReduction: Enable Refresh Reduction
	EnableRefreshReduction *Multivalue `json:"enableRefreshReduction,omitempty"`
	// GenerateSequenceNumberBasedOnRealTime: Generate Sequence Number Based on Real Time
	GenerateSequenceNumberBasedOnRealTime *Multivalue `json:"generateSequenceNumberBasedOnRealTime,omitempty"`
	// HandshakeRequired: Handshake Required
	HandshakeRequired *Multivalue `json:"handshakeRequired,omitempty"`
	// HelloInterval: Hello Interval (ms)
	HelloInterval *Multivalue `json:"helloInterval,omitempty"`
	// HelloTimeoutMultiplier: Hello Timeout Multiplier
	HelloTimeoutMultiplier *Multivalue `json:"helloTimeoutMultiplier,omitempty"`
	// InitialSequenceNumber: Initial Sequence Number
	InitialSequenceNumber *Multivalue `json:"initialSequenceNumber,omitempty"`
	// LabelReqRefCount: Number of Label Req in RSVP-TE DG

	LabelReqRefCount *float32 `json:"labelReqRefCount,omitempty"`
	// LabelSpaceEnd: Label Space End
	LabelSpaceEnd *Multivalue `json:"labelSpaceEnd,omitempty"`
	// LabelSpaceStart: Label Space Start
	LabelSpaceStart *Multivalue `json:"labelSpaceStart,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfRestarts: Number of Restarts
	NumberOfRestarts *Multivalue `json:"numberOfRestarts,omitempty"`
	// RecoveryTime: Recovery Time (ms)
	RecoveryTime *Multivalue `json:"recoveryTime,omitempty"`
	// RestartStartTime: Restart Start Time (ms)
	RestartStartTime *Multivalue `json:"restartStartTime,omitempty"`
	// RestartUpTime: Restart Up Time (ms)
	RestartUpTime *Multivalue `json:"restartUpTime,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SummaryRefreshInterval: Summary Refresh Interval (ms)
	SummaryRefreshInterval *Multivalue `json:"summaryRefreshInterval,omitempty"`
	// UseSameAuthenticationKeyForPeer: Use Same Authentication Key for Peer
	UseSameAuthenticationKeyForPeer *Multivalue `json:"useSameAuthenticationKeyForPeer,omitempty"`
	// UsingGatewayIp: Using Gateway IP
	UsingGatewayIp *Multivalue            `json:"usingGatewayIp,omitempty"`
	LearnedInfo    []*TopologyLearnedInfo `json:"learnedInfo"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpteIf) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpteIf) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpteIf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpteIf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ActualRestartTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "actualRestartTime",
		isMultivalue: true,
	})
	n.AdvertisedRestartTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "advertisedRestartTime",
		isMultivalue: true,
	})
	n.AuthenticationAlgorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authenticationAlgorithm",
		isMultivalue: true,
	})
	n.AuthenticationKeyForReceivedPackets.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authenticationKeyForReceivedPackets",
		isMultivalue: true,
	})
	n.AuthenticationKeyForSentPackets.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authenticationKeyForSentPackets",
		isMultivalue: true,
	})
	n.AuthenticationKeyIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "authenticationKeyIdentifier",
		isMultivalue: true,
	})
	n.AutoGenerateAuthenticationKeyIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoGenerateAuthenticationKeyIdentifier",
		isMultivalue: true,
	})
	n.BundleMessageThresholdTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bundleMessageThresholdTime",
		isMultivalue: true,
	})
	n.CheckIntegrityForReceivedPackets.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "checkIntegrityForReceivedPackets",
		isMultivalue: true,
	})
	n.DutIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutIp",
		isMultivalue: true,
	})
	n.EnableBfdRegistration.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBfdRegistration",
		isMultivalue: true,
	})
	n.EnableBundleMessageSending.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBundleMessageSending",
		isMultivalue: true,
	})
	n.EnableBundleMessageThresholdTimer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableBundleMessageThresholdTimer",
		isMultivalue: true,
	})
	n.EnableGracefulRestartHelperMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestartHelperMode",
		isMultivalue: true,
	})
	n.EnableGracefulRestartRestartingMode.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableGracefulRestartRestartingMode",
		isMultivalue: true,
	})
	n.EnableHelloExtension.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableHelloExtension",
		isMultivalue: true,
	})
	n.EnableRefreshReduction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableRefreshReduction",
		isMultivalue: true,
	})
	n.GenerateSequenceNumberBasedOnRealTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "generateSequenceNumberBasedOnRealTime",
		isMultivalue: true,
	})
	n.HandshakeRequired.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "handshakeRequired",
		isMultivalue: true,
	})
	n.HelloInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloInterval",
		isMultivalue: true,
	})
	n.HelloTimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "helloTimeoutMultiplier",
		isMultivalue: true,
	})
	n.InitialSequenceNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "initialSequenceNumber",
		isMultivalue: true,
	})
	n.LabelSpaceEnd.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceEnd",
		isMultivalue: true,
	})
	n.LabelSpaceStart.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "labelSpaceStart",
		isMultivalue: true,
	})
	n.NumberOfRestarts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfRestarts",
		isMultivalue: true,
	})
	n.RecoveryTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "recoveryTime",
		isMultivalue: true,
	})
	n.RestartStartTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "restartStartTime",
		isMultivalue: true,
	})
	n.RestartUpTime.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "restartUpTime",
		isMultivalue: true,
	})
	n.SummaryRefreshInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "summaryRefreshInterval",
		isMultivalue: true,
	})
	n.UseSameAuthenticationKeyForPeer.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useSameAuthenticationKeyForPeer",
		isMultivalue: true,
	})
	n.UsingGatewayIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "usingGatewayIp",
		isMultivalue: true,
	})
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyRsvpteLsps: Rsvp LSP Configuration
type TopologyRsvpteLsps struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableP2PEgress: Enable to configure P2P Egress LSPs

	EnableP2PEgress *bool `json:"enableP2PEgress,omitempty"`
	// ExpectedPceInitiatedLspsCount: Number of Expected PCE Initiated RSVP-TE LSPs

	ExpectedPceInitiatedLspsCount *float32 `json:"expectedPceInitiatedLspsCount,omitempty"`
	// IngressP2PLsps: Number of P2P Ingress LSPs configured per IPv4 Loopback

	IngressP2PLsps *float32 `json:"ingressP2PLsps,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// P2mpEgressTunnelCount: Number of P2MP Egress Tunnels configured per IPv4 Loopback

	P2mpEgressTunnelCount *float32 `json:"p2mpEgressTunnelCount,omitempty"`
	// P2mpIngressLspCount: Number of P2MP Ingress LSPs configured per IPv4 Loopback

	P2mpIngressLspCount *float32 `json:"p2mpIngressLspCount,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`

	RsvpP2PEgressLsps *TopologyRsvpP2PEgressLsps `json:"rsvpP2PEgressLsps,omitempty"`

	RsvpP2PIngressLsps *TopologyRsvpP2PIngressLsps `json:"rsvpP2PIngressLsps,omitempty"`

	RsvpP2mpEgressLsps *TopologyRsvpP2mpEgressLsps `json:"rsvpP2mpEgressLsps,omitempty"`

	RsvpP2mpIngressLsps *TopologyRsvpP2mpIngressLsps `json:"rsvpP2mpIngressLsps,omitempty"`

	RsvpPcepExpectedInitiatedLsps *TopologyRsvpPcepExpectedInitiatedLsps `json:"rsvpPcepExpectedInitiatedLsps,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRsvpteLsps) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRsvpteLsps) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRsvpteLsps) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRsvpteLsps) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.RsvpP2PEgressLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpP2PEgressLsps",
	})
	n.RsvpP2PIngressLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpP2PIngressLsps",
	})
	n.RsvpP2mpEgressLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpP2mpEgressLsps",
	})
	n.RsvpP2mpIngressLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpP2mpIngressLsps",
	})
	n.RsvpPcepExpectedInitiatedLsps.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rsvpPcepExpectedInitiatedLsps",
	})
}

// TopologyRxSakPool: Rx Channels configuration.
type TopologyRxSakPool struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RxSak128: 128 bit value of Secure Association Key with which DUT is expected to encrypt MACsec packets.
	RxSak128 *Multivalue `json:"rxSak128,omitempty"`
	// RxSak256: 256 bit value of Secure Association Key with which DUT is expected to encrypt MACsec packets.
	RxSak256 *Multivalue `json:"rxSak256,omitempty"`
	// RxSalt: 12 bytes Salt value for XPN cipher suites.
	RxSalt *Multivalue `json:"rxSalt,omitempty"`
	// RxSsci: 4 bytes Short SCI for XPN cipher suites.
	RxSsci *Multivalue `json:"rxSsci,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyRxSakPool) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyRxSakPool) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyRxSakPool) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyRxSakPool) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.RxSak128.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxSak128",
		isMultivalue: true,
	})
	n.RxSak256.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxSak256",
		isMultivalue: true,
	})
	n.RxSalt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxSalt",
		isMultivalue: true,
	})
	n.RxSsci.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rxSsci",
		isMultivalue: true,
	})
}

// TopologySbfdInitiator: TBD
type TopologySbfdInitiator struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// DestIPAddr: Destination IP address in SBFD Packet,which is sent to Responder. Should be in 127 subnet as defined in specification.
	DestIPAddr *Multivalue `json:"destIPAddr,omitempty"`
	// MplsLabelCount: Number of MPLS Labels.

	MplsLabelCount *float32 `json:"mplsLabelCount,omitempty"`
	// MyDiscriminator: The value to be used for My Discriminator in S-BFD packets sent to the Responder by this Initiator. Should be unique in sessions from a single Initiator.
	MyDiscriminator *Multivalue `json:"myDiscriminator,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PeerDiscriminator: Configured Peer Discriminator which should match the configured Local or My Discriminator on the target Responder.
	PeerDiscriminator *Multivalue `json:"peerDiscriminator,omitempty"`
	// TimeoutMultiplier: If packets are not recieved within the negotiated transmit Interval * this value , session is brought down and Flap Count is increased in statistics.
	TimeoutMultiplier *Multivalue `json:"timeoutMultiplier,omitempty"`
	// TxInterval: Tx Interval in Milli Seconds. Note: Initial transmission interval is set to maximum of 1s and configured Tx Interval. Once session comes up, the timer will auto-transition to the negotiated value i.e. maximum of local Tx Interval and recieved Rx Interval from Responder.
	TxInterval    *Multivalue              `json:"txInterval,omitempty"`
	MplsLabelList []*TopologyMplsLabelList `json:"mplsLabelList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySbfdInitiator) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySbfdInitiator) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySbfdInitiator) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySbfdInitiator) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.DestIPAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destIPAddr",
		isMultivalue: true,
	})
	n.MyDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "myDiscriminator",
		isMultivalue: true,
	})
	n.PeerDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "peerDiscriminator",
		isMultivalue: true,
	})
	n.TimeoutMultiplier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "timeoutMultiplier",
		isMultivalue: true,
	})
	n.TxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txInterval",
		isMultivalue: true,
	})
	for i, o := range n.MplsLabelList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "mplsLabelList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologySbfdResponder: This tab can be used to configure S-BFD Responder as per RFC7880
type TopologySbfdResponder struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// EnableLearnedInformation: If enabled, the Responder will store all S-BFD sessions responded to based on requests from remote Initiators. Selected sessions can be paused and resumed by user. Enabling this will reduce supported scale by some amount.
	EnableLearnedInformation *Multivalue `json:"enableLearnedInformation,omitempty"`
	// MinRxInterval: Minimum Rx Interval in ms supported by the Responder.
	MinRxInterval *Multivalue `json:"minRxInterval,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SBFDDiscriminator: Configures the local S-BFD discriminator.
	SBFDDiscriminator *Multivalue `json:"sBFDDiscriminator,omitempty"`
	// SBFDState: Configures the S-BFD session state to be sent in Response Packets.
	SBFDState *Multivalue `json:"sBFDState,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySbfdResponder) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySbfdResponder) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySbfdResponder) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySbfdResponder) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableLearnedInformation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableLearnedInformation",
		isMultivalue: true,
	})
	n.MinRxInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "minRxInterval",
		isMultivalue: true,
	})
	n.SBFDDiscriminator.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sBFDDiscriminator",
		isMultivalue: true,
	})
	n.SBFDState.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sBFDState",
		isMultivalue: true,
	})
}

// TopologySid: TBD
type TopologySid struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySid) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySid) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySid) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySid) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologySidType: TBD
type TopologySidType struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySidType) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySidType) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySidType) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySidType) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologySimInterface: Simulated Interface specific configuration inside a Network Topology
type TopologySimInterface struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// FromNodeIndex: From Node
	FromNodeIndex *Multivalue `json:"fromNodeIndex,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ToNetworkTopology: Network Topology this link is pointing to
	ToNetworkTopology *Multivalue `json:"toNetworkTopology,omitempty"`
	// ToNodeIndex: To Node
	ToNodeIndex                *Multivalue                           `json:"toNodeIndex,omitempty"`
	IsisL3PseudoInterface      []*TopologyIsisL3PseudoInterface      `json:"isisL3PseudoInterface"`
	IsisPseudoInterface        []*TopologyIsisPseudoInterface        `json:"isisPseudoInterface"`
	SimInterfaceEthernetConfig []*TopologySimInterfaceEthernetConfig `json:"simInterfaceEthernetConfig"`
	SimInterfaceIPv4Config     []*TopologySimInterfaceIPv4Config     `json:"simInterfaceIPv4Config"`
	SimInterfaceIPv6Config     []*TopologySimInterfaceIPv6Config     `json:"simInterfaceIPv6Config"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySimInterface) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySimInterface) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySimInterface) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySimInterface) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FromNodeIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fromNodeIndex",
		isMultivalue: true,
	})
	n.ToNetworkTopology.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "toNetworkTopology",
		isMultivalue: true,
	})
	n.ToNodeIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "toNodeIndex",
		isMultivalue: true,
	})
	for i, o := range n.IsisL3PseudoInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3PseudoInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisPseudoInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisPseudoInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SimInterfaceEthernetConfig {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "simInterfaceEthernetConfig",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SimInterfaceIPv4Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "simInterfaceIPv4Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.SimInterfaceIPv6Config {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "simInterfaceIPv6Config",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologySimInterfaceEthernetConfig: Data associated with simulated interface Ethernet link configuration inside a Network Topology.
type TopologySimInterfaceEthernetConfig struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// FromMac: MAC address of endpoing-1
	FromMac *Multivalue `json:"fromMac,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// ToMac: MAC address of endpoing-2
	ToMac *Multivalue `json:"toMac,omitempty"`
	// VlanCount: number of active VLANs
	VlanCount         *Multivalue                  `json:"vlanCount,omitempty"`
	CfmSimulatedLinks []*TopologyCfmSimulatedLinks `json:"cfmSimulatedLinks"`
	Vlan              []*TopologyVlan              `json:"vlan"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySimInterfaceEthernetConfig) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySimInterfaceEthernetConfig) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySimInterfaceEthernetConfig) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySimInterfaceEthernetConfig) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FromMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fromMac",
		isMultivalue: true,
	})
	n.ToMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "toMac",
		isMultivalue: true,
	})
	n.VlanCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanCount",
		isMultivalue: true,
	})
	for i, o := range n.CfmSimulatedLinks {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmSimulatedLinks",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Vlan {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "vlan",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologySimInterfaceIPv4Config: Data associated with simulated IPv4 interface link configuration inside a Network Topology.
type TopologySimInterfaceIPv4Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableIp: Enable IPv4
	EnableIp *Multivalue `json:"enableIp,omitempty"`
	// FromIP: 4 Byte IP address in dotted decimal format.
	FromIP *Multivalue `json:"fromIP,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SubnetPrefixLength: Subnet Prefix Length
	SubnetPrefixLength *Multivalue `json:"subnetPrefixLength,omitempty"`
	// ToIP: 4 Byte IP address in dotted decimal format.
	ToIP                *Multivalue                    `json:"toIP,omitempty"`
	OspfPseudoInterface []*TopologyOspfPseudoInterface `json:"ospfPseudoInterface"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySimInterfaceIPv4Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySimInterfaceIPv4Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySimInterfaceIPv4Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySimInterfaceIPv4Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIp",
		isMultivalue: true,
	})
	n.FromIP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fromIP",
		isMultivalue: true,
	})
	n.SubnetPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subnetPrefixLength",
		isMultivalue: true,
	})
	n.ToIP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "toIP",
		isMultivalue: true,
	})
	for i, o := range n.OspfPseudoInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfPseudoInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologySimInterfaceIPv6Config: Data associated with simulated IPv6 interface link configuration inside a Network Topology.
type TopologySimInterfaceIPv6Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableIp: Enable IPv6
	EnableIp *Multivalue `json:"enableIp,omitempty"`
	// FromIP: 128 Bits IPv6 address.
	FromIP *Multivalue `json:"fromIP,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SubnetPrefixLength: Subnet Prefix Length
	SubnetPrefixLength *Multivalue `json:"subnetPrefixLength,omitempty"`
	// ToIP: 128 Bits IPv6 address.
	ToIP                  *Multivalue                      `json:"toIP,omitempty"`
	Ospfv3PseudoInterface []*TopologyOspfv3PseudoInterface `json:"ospfv3PseudoInterface"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySimInterfaceIPv6Config) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySimInterfaceIPv6Config) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySimInterfaceIPv6Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySimInterfaceIPv6Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnableIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableIp",
		isMultivalue: true,
	})
	n.FromIP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "fromIP",
		isMultivalue: true,
	})
	n.SubnetPrefixLength.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "subnetPrefixLength",
		isMultivalue: true,
	})
	n.ToIP.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "toIP",
		isMultivalue: true,
	})
	for i, o := range n.Ospfv3PseudoInterface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3PseudoInterface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologySimRouter: Simulated router specific configuration inside a Network Topology.
type TopologySimRouter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NodeIndex: Node index (starting from index-1)
	NodeIndex *Multivalue `json:"nodeIndex,omitempty"`
	// RouterId: 4 Byte Router Id in dotted decimal format.
	RouterId *Multivalue `json:"routerId,omitempty"`
	// SystemId: 6 Byte System Id in hex format.
	SystemId *Multivalue `json:"systemId,omitempty"`

	Connector          *TopologyConnector            `json:"connector,omitempty"`
	IsisL3PseudoRouter []*TopologyIsisL3PseudoRouter `json:"isisL3PseudoRouter"`
	LdpPseudoRouter    []*TopologyLdpPseudoRouter    `json:"ldpPseudoRouter"`
	OspfPseudoRouter   []*TopologyOspfPseudoRouter   `json:"ospfPseudoRouter"`
	Ospfv3PseudoRouter []*TopologyOspfv3PseudoRouter `json:"ospfv3PseudoRouter"`
	Tag                []*TopologyTag                `json:"tag"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySimRouter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySimRouter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySimRouter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySimRouter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.NodeIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeIndex",
		isMultivalue: true,
	})
	n.RouterId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "routerId",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.IsisL3PseudoRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisL3PseudoRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpPseudoRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpPseudoRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.OspfPseudoRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfPseudoRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ospfv3PseudoRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ospfv3PseudoRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tag {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tag",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologySimRouterBridge: Simulated Bridge specific configuration inside a Network Topology.
type TopologySimRouterBridge struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NodeIndex: Node index (starting from index-1)
	NodeIndex *Multivalue `json:"nodeIndex,omitempty"`
	// SystemId: 6 Byte System Id in hex format.
	SystemId *Multivalue `json:"systemId,omitempty"`
	// SystemMAC: 6 Byte System MAC Address
	SystemMAC      *Multivalue               `json:"systemMAC,omitempty"`
	CfmSimulatedMp []*TopologyCfmSimulatedMp `json:"cfmSimulatedMp"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	IsisDcePseudoNode   []*TopologyIsisDcePseudoNode   `json:"isisDcePseudoNode"`
	IsisSpbPseudoNode   []*TopologyIsisSpbPseudoNode   `json:"isisSpbPseudoNode"`
	IsisTrillPseudoNode []*TopologyIsisTrillPseudoNode `json:"isisTrillPseudoNode"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySimRouterBridge) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySimRouterBridge) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySimRouterBridge) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySimRouterBridge) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.NodeIndex.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nodeIndex",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
	n.SystemMAC.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemMAC",
		isMultivalue: true,
	})
	for i, o := range n.CfmSimulatedMp {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "cfmSimulatedMp",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.IsisDcePseudoNode {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisDcePseudoNode",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisSpbPseudoNode {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisSpbPseudoNode",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.IsisTrillPseudoNode {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "isisTrillPseudoNode",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologySourceIpv4Address: TBD
type TopologySourceIpv4Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySourceIpv4Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySourceIpv4Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySourceIpv4Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySourceIpv4Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologySourceIpv6Address: TBD
type TopologySourceIpv6Address struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySourceIpv6Address) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySourceIpv6Address) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySourceIpv6Address) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySourceIpv6Address) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologySpbNodeTopologyList: SPB Node Topology
type TopologySpbNodeTopologyList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BaseVIDCount: Base VID Count(multiplier)

	BaseVIDCount *float32 `json:"baseVIDCount,omitempty"`
	// CistExternalRootCost: CIST External Root Cost
	CistExternalRootCost *Multivalue `json:"cistExternalRootCost,omitempty"`
	// CistRootId: CIST Root Identifier
	CistRootId *Multivalue `json:"cistRootId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfPorts: Number of Ports
	NumberOfPorts *Multivalue `json:"numberOfPorts,omitempty"`
	// PortIdentifier: Port Identifier
	PortIdentifier *Multivalue `json:"portIdentifier,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// Vbit: Enable V Bit
	Vbit *Multivalue `json:"vbit,omitempty"`

	BaseVidList *TopologySpbNodeTopologyListBaseVidList `json:"baseVidList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySpbNodeTopologyList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySpbNodeTopologyList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySpbNodeTopologyList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySpbNodeTopologyList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CistExternalRootCost.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cistExternalRootCost",
		isMultivalue: true,
	})
	n.CistRootId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cistRootId",
		isMultivalue: true,
	})
	n.NumberOfPorts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfPorts",
		isMultivalue: true,
	})
	n.PortIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portIdentifier",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.Vbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vbit",
		isMultivalue: true,
	})
	n.BaseVidList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "baseVidList",
	})
}

// TopologySpbNodeTopologyListBaseVidList: ISIS SPB Node BaseVID Configuration
type TopologySpbNodeTopologyListBaseVidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BaseVid: Base VID
	BaseVid *Multivalue `json:"baseVid,omitempty"`
	// BaseVlanPriority: B-VLAN Priority
	BaseVlanPriority *Multivalue `json:"baseVlanPriority,omitempty"`
	// BvlanTpid: B-VLAN TPID
	BvlanTpid *Multivalue `json:"bvlanTpid,omitempty"`
	// EctAlgorithm: ECT AlgorithmType
	EctAlgorithm *Multivalue `json:"ectAlgorithm,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UseFlagBit: Use Flag Bit
	UseFlagBit *Multivalue `json:"useFlagBit,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySpbNodeTopologyListBaseVidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySpbNodeTopologyListBaseVidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySpbNodeTopologyListBaseVidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySpbNodeTopologyListBaseVidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BaseVid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseVid",
		isMultivalue: true,
	})
	n.BaseVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseVlanPriority",
		isMultivalue: true,
	})
	n.BvlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bvlanTpid",
		isMultivalue: true,
	})
	n.EctAlgorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ectAlgorithm",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UseFlagBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useFlagBit",
		isMultivalue: true,
	})
}

// TopologySpbSimEdgeBaseVidList: ISIS SPB Simulated Edge BaseVID Configuration
type TopologySpbSimEdgeBaseVidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BaseVid: Base VID
	BaseVid *Multivalue `json:"baseVid,omitempty"`
	// BaseVlanPriority: B-VLAN Priority
	BaseVlanPriority *Multivalue `json:"baseVlanPriority,omitempty"`
	// BvlanTpid: B-VLAN TPID
	BvlanTpid *Multivalue `json:"bvlanTpid,omitempty"`
	// EctAlgorithm: ECT AlgorithmType
	EctAlgorithm *Multivalue `json:"ectAlgorithm,omitempty"`
	// IsidCount: ISID Count(multiplier)

	IsidCount *float32 `json:"isidCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// UseFlagBit: Use Flag Bit
	UseFlagBit *Multivalue `json:"useFlagBit,omitempty"`

	SpbSimEdgeIsidList *TopologySpbSimEdgeIsidList `json:"spbSimEdgeIsidList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySpbSimEdgeBaseVidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySpbSimEdgeBaseVidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySpbSimEdgeBaseVidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySpbSimEdgeBaseVidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BaseVid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseVid",
		isMultivalue: true,
	})
	n.BaseVlanPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "baseVlanPriority",
		isMultivalue: true,
	})
	n.BvlanTpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bvlanTpid",
		isMultivalue: true,
	})
	n.EctAlgorithm.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ectAlgorithm",
		isMultivalue: true,
	})
	n.UseFlagBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "useFlagBit",
		isMultivalue: true,
	})
	n.SpbSimEdgeIsidList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "spbSimEdgeIsidList",
	})
}

// TopologySpbSimEdgeIsidList: ISIS SPB Simulated Edge ISID Configuration
type TopologySpbSimEdgeIsidList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Isid: I-SID
	Isid *Multivalue `json:"isid,omitempty"`
	// ItagEthernetType: I-Tag Ethernet Type
	ItagEthernetType *Multivalue `json:"itagEthernetType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Rbit: R Bit
	Rbit *Multivalue `json:"rbit,omitempty"`
	// Tbit: T Bit
	Tbit *Multivalue `json:"tbit,omitempty"`
	// TransmissionType: Transmission Type
	TransmissionType *Multivalue `json:"transmissionType,omitempty"`

	Connector *TopologyConnector `json:"connector,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySpbSimEdgeIsidList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySpbSimEdgeIsidList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySpbSimEdgeIsidList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySpbSimEdgeIsidList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.Isid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "isid",
		isMultivalue: true,
	})
	n.ItagEthernetType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "itagEthernetType",
		isMultivalue: true,
	})
	n.Rbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rbit",
		isMultivalue: true,
	})
	n.Tbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tbit",
		isMultivalue: true,
	})
	n.TransmissionType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "transmissionType",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
}

// TopologySpbSimEdgeTopologyList: SPB Simulated Edge Topology Configuration
type TopologySpbSimEdgeTopologyList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// CistExternalRootCost: CIST External Root Cost
	CistExternalRootCost *Multivalue `json:"cistExternalRootCost,omitempty"`
	// CistRootId: CIST Root Identifier
	CistRootId *Multivalue `json:"cistRootId,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfPorts: Number of Ports
	NumberOfPorts *Multivalue `json:"numberOfPorts,omitempty"`
	// PortIdentifier: Port Identifier
	PortIdentifier *Multivalue `json:"portIdentifier,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// Vbit: Enable V Bit
	Vbit *Multivalue `json:"vbit,omitempty"`

	SpbSimEdgeBaseVidList *TopologySpbSimEdgeBaseVidList `json:"spbSimEdgeBaseVidList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySpbSimEdgeTopologyList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySpbSimEdgeTopologyList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySpbSimEdgeTopologyList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySpbSimEdgeTopologyList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.CistExternalRootCost.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cistExternalRootCost",
		isMultivalue: true,
	})
	n.CistRootId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cistRootId",
		isMultivalue: true,
	})
	n.NumberOfPorts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfPorts",
		isMultivalue: true,
	})
	n.PortIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portIdentifier",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.Vbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vbit",
		isMultivalue: true,
	})
	n.SpbSimEdgeBaseVidList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "spbSimEdgeBaseVidList",
	})
}

// TopologySpbTopologyList: ISIS SPB Topology Range Configuration
type TopologySpbTopologyList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// AuxMcidConfName: Aux MCID Config Name
	AuxMcidConfName *Multivalue `json:"auxMcidConfName,omitempty"`
	// AuxMcidSignature: Aux MCID Signature
	AuxMcidSignature *Multivalue `json:"auxMcidSignature,omitempty"`
	// BaseVidCount: Base VID Count(multiplier)

	BaseVidCount *float32 `json:"baseVidCount,omitempty"`
	// BridgePriority: Bridge Priority
	BridgePriority *Multivalue `json:"bridgePriority,omitempty"`
	// CistExternalRootCost: CIST External Root Cost
	CistExternalRootCost *Multivalue `json:"cistExternalRootCost,omitempty"`
	// CistRootId: CIST Root Identifier
	CistRootId *Multivalue `json:"cistRootId,omitempty"`
	// LinkMetric: Link Metric
	LinkMetric *Multivalue `json:"linkMetric,omitempty"`
	// McidConfName: MCID Config Name
	McidConfName *Multivalue `json:"mcidConfName,omitempty"`
	// McidSignature: MCID Signature
	McidSignature *Multivalue `json:"mcidSignature,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfPorts: Number of Ports
	NumberOfPorts *Multivalue `json:"numberOfPorts,omitempty"`
	// PortIdentifier: Port Identifier
	PortIdentifier *Multivalue `json:"portIdentifier,omitempty"`
	// SpSourceId: SP Source ID
	SpSourceId *Multivalue `json:"spSourceId,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// Vbit: Enable V Bit
	Vbit *Multivalue `json:"vbit,omitempty"`

	BaseVidList *TopologyBaseVidList `json:"baseVidList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySpbTopologyList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySpbTopologyList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySpbTopologyList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySpbTopologyList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AuxMcidConfName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxMcidConfName",
		isMultivalue: true,
	})
	n.AuxMcidSignature.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "auxMcidSignature",
		isMultivalue: true,
	})
	n.BridgePriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "bridgePriority",
		isMultivalue: true,
	})
	n.CistExternalRootCost.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cistExternalRootCost",
		isMultivalue: true,
	})
	n.CistRootId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cistRootId",
		isMultivalue: true,
	})
	n.LinkMetric.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "linkMetric",
		isMultivalue: true,
	})
	n.McidConfName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcidConfName",
		isMultivalue: true,
	})
	n.McidSignature.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcidSignature",
		isMultivalue: true,
	})
	n.NumberOfPorts.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "numberOfPorts",
		isMultivalue: true,
	})
	n.PortIdentifier.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portIdentifier",
		isMultivalue: true,
	})
	n.SpSourceId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "spSourceId",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.Vbit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vbit",
		isMultivalue: true,
	})
	n.BaseVidList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "baseVidList",
	})
}

// TopologySrlgValueList: Isis SRLG Value
type TopologySrlgValueList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrlgValue: This is the SRLG Value for the link between two mentioned interfaces.
	SrlgValue *Multivalue `json:"srlgValue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySrlgValueList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySrlgValueList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySrlgValueList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySrlgValueList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SrlgValue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srlgValue",
		isMultivalue: true,
	})
}

// TopologyStartCcmEmulatedMpParams: Start CCM PDU Transmission
type TopologyStartCcmEmulatedMpParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyStartCcmEmulatedMpParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyStartCcmEmulatedMpParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyStartCcmEmulatedMpParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyStartCcmEmulatedMpParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyStartCcmSimmulatedMpParams: Start CCM PDU Transmission
type TopologyStartCcmSimmulatedMpParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyStartCcmSimmulatedMpParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyStartCcmSimmulatedMpParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyStartCcmSimmulatedMpParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyStartCcmSimmulatedMpParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyStaticLag: TBD
type TopologyStaticLag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// LagId: LAG ID
	LagId *Multivalue `json:"lagId,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyStaticLag) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyStaticLag) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyStaticLag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyStaticLag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.LagId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "lagId",
		isMultivalue: true,
	})
}

// TopologyStaticMacsec: Static MACsec
type TopologyStaticMacsec struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ActiveDevice: Determines whether a MACsec device is active or not. If disabled, MACsec will not be started on the device.
	ActiveDevice *Multivalue `json:"activeDevice,omitempty"`
	// CipherSuite: The type of cipher suite. Options include: 1) GCM-AES-128 2) GCM-AES-256 3) GCM-AES-XPN-128 4) GCM-AES-XPN-256
	CipherSuite *Multivalue `json:"cipherSuite,omitempty"`
	// ConfidentialityOffset: Determines the confidentiality offset for both transmit and receive channel.
	ConfidentialityOffset *Multivalue `json:"confidentialityOffset,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DutMac: MAC address of the connected interface of the DUT to be used as Gateway MAC for IP traffic.
	DutMac *Multivalue `json:"dutMac,omitempty"`
	// DutMsbOfXpn: The 32 most significant bits of the XPN that DUT will be using to construct the 64 bits XPN value when test starts.
	DutMsbOfXpn *Multivalue `json:"dutMsbOfXpn,omitempty"`
	// DutSciMac: MAC component of SCI with which MACsec traffic is expected from the DUT.
	DutSciMac *Multivalue `json:"dutSciMac,omitempty"`
	// DutSciPortId: Port ID component of SCI with which MACsec traffic is expected from the DUT.
	DutSciPortId *Multivalue `json:"dutSciPortId,omitempty"`
	// EnableConfidentiality: Determines whether transmitted MACsec payload is encrypted or not.
	EnableConfidentiality *Multivalue `json:"enableConfidentiality,omitempty"`
	// EnableEncryptedVlan: Determines if VLAN data is to be encrypted or not.
	EnableEncryptedVlan *Multivalue `json:"enableEncryptedVlan,omitempty"`
	// EnableEncryptedVlans: Enables VLANs for the sessions.
	EnableEncryptedVlans *Multivalue `json:"enableEncryptedVlans,omitempty"`
	// EncryptedTrafficType: Determines the set of MACsec functionalities supported by a Device Group. Stateless L2-3 enables encryption of stateless L2-3 traffic at line rate, Stateful L4-7 enables encryption and live decryption of stateful L4-7 traffic at lower throughput. Separate Device Groups need to be configured to get both the options on the same port.

	EncryptedTrafficType *string `json:"encryptedTrafficType,omitempty"`
	// EncryptedVlanCount: Determines if VLAN information to be encrypted or not. Maximum 6 VLANs can be added in the encrypted payload.

	EncryptedVlanCount *float32 `json:"encryptedVlanCount,omitempty"`
	// EncryptionEngine: Obsolete field. Replaced by Encrypted Traffic Type. Value is always same as Encrypted Traffic Type.

	EncryptionEngine *string `json:"encryptionEngine,omitempty"`
	// EndStation: Determines whether this device should act as the End Station.
	EndStation *Multivalue `json:"endStation,omitempty"`
	// FixedPn: Packet Number with which all MACsec packets will be sent out by all the devices of the Device Group.

	FixedPn *float32 `json:"fixedPn,omitempty"`
	// IncludeSci: Determines whether SCI should be included in the SecTAG of the transmitted MACsec traffic.
	IncludeSci *Multivalue `json:"includeSci,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// MvFixedXpn: 8 bytes PN with which all packets will be sent out.
	MvFixedXpn *Multivalue `json:"mvFixedXpn,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OverrideTciSetting: If enabled, the default TCI settings as per configuration will be allowed for overwriting. Used to simulate mal-configured SecTAG for negative testing.
	OverrideTciSetting *Multivalue `json:"overrideTciSetting,omitempty"`
	// PeriodicRekeyAttempts: Determines the number of times Rekey will happen after MACsec is started.

	PeriodicRekeyAttempts *float32 `json:"periodicRekeyAttempts,omitempty"`
	// PeriodicRekeyInterval: Determines the time interval between two subsequent Rekey events. The timer starts with the first MACsec packet transmission from a device.

	PeriodicRekeyInterval *float32 `json:"periodicRekeyInterval,omitempty"`
	// PortId: Port ID component of SCI with which MACsec traffic is transmitted.
	PortId *Multivalue `json:"portId,omitempty"`
	// RekeyBehaviour: Determines the Rekey behavior.

	RekeyBehaviour *string `json:"rekeyBehaviour,omitempty"`
	// RxSakPoolSize: Determines the number of SAKs configured for each device for the Rx secure channel. Multiple SAKs are needed if DUT is expected to trigger Rekey during the test.

	RxSakPoolSize *float32 `json:"rxSakPoolSize,omitempty"`
	// SendGratArp: Determines whether Grat ARP should be sent out by each device with the configured MAC-IP mapping if encryption engine is Hardware Based. If Grap ARP is disabled then static ARP entries need to be created at the DUT to avoid traffic loss.

	SendGratArp *bool `json:"sendGratArp,omitempty"`
	// SourceIp: IP address of the MACsec device. Used as the source IP of the MACsec traffic generated by the device.
	SourceIp *Multivalue `json:"sourceIp,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// SystemId: System Identifier component of the SCI field with which MACsec traffic is transmitted.
	SystemId *Multivalue `json:"systemId,omitempty"`
	// TciCBit: Determines the C bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciCBit *Multivalue `json:"tciCBit,omitempty"`
	// TciEBit: Determines the E bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciEBit *Multivalue `json:"tciEBit,omitempty"`
	// TciEsBit: Determines the ES bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciEsBit *Multivalue `json:"tciEsBit,omitempty"`
	// TciScBit: Determines the SC bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciScBit *Multivalue `json:"tciScBit,omitempty"`
	// TciScbBit: Determines the SCB bit in TCI field of SecTAG if Override TCI Settings is enabled.
	TciScbBit *Multivalue `json:"tciScbBit,omitempty"`
	// TxSakPoolSize: Determines the number of SAKs configured for each device for the Tx secure channel. Multiple SAKs are needed if Rekey scenario is to be simulated.

	TxSakPoolSize *float32 `json:"txSakPoolSize,omitempty"`
	// Version: Version bit in TCI field of SecTAG if Override TCI Settings is enabled.
	Version *Multivalue `json:"version,omitempty"`

	Connector     *TopologyConnector       `json:"connector,omitempty"`
	InnerVlanList []*TopologyInnerVlanList `json:"innerVlanList"`
	Ipv4          []*TopologyIpv4          `json:"ipv4"`
	Ipv6          []*TopologyIpv6          `json:"ipv6"`

	RxSakPool *TopologyRxSakPool `json:"rxSakPool,omitempty"`

	TxSakPool *TopologyTxSakPool `json:"txSakPool,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyStaticMacsec) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyStaticMacsec) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyStaticMacsec) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyStaticMacsec) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActiveDevice.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeDevice",
		isMultivalue: true,
	})
	n.CipherSuite.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "cipherSuite",
		isMultivalue: true,
	})
	n.ConfidentialityOffset.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "confidentialityOffset",
		isMultivalue: true,
	})
	n.DutMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutMac",
		isMultivalue: true,
	})
	n.DutMsbOfXpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutMsbOfXpn",
		isMultivalue: true,
	})
	n.DutSciMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutSciMac",
		isMultivalue: true,
	})
	n.DutSciPortId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dutSciPortId",
		isMultivalue: true,
	})
	n.EnableConfidentiality.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableConfidentiality",
		isMultivalue: true,
	})
	n.EnableEncryptedVlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEncryptedVlan",
		isMultivalue: true,
	})
	n.EnableEncryptedVlans.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableEncryptedVlans",
		isMultivalue: true,
	})
	n.EndStation.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "endStation",
		isMultivalue: true,
	})
	n.IncludeSci.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "includeSci",
		isMultivalue: true,
	})
	n.MvFixedXpn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mvFixedXpn",
		isMultivalue: true,
	})
	n.OverrideTciSetting.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "overrideTciSetting",
		isMultivalue: true,
	})
	n.PortId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portId",
		isMultivalue: true,
	})
	n.SourceIp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceIp",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
	n.TciCBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciCBit",
		isMultivalue: true,
	})
	n.TciEBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciEBit",
		isMultivalue: true,
	})
	n.TciEsBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciEsBit",
		isMultivalue: true,
	})
	n.TciScBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciScBit",
		isMultivalue: true,
	})
	n.TciScbBit.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tciScbBit",
		isMultivalue: true,
	})
	n.Version.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "version",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.InnerVlanList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "innerVlanList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.RxSakPool.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rxSakPool",
	})
	n.TxSakPool.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txSakPool",
	})
}

// TopologyStopCcmEmulatedMpParams: Stop CCM PDU Transmission
type TopologyStopCcmEmulatedMpParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyStopCcmEmulatedMpParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyStopCcmEmulatedMpParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyStopCcmEmulatedMpParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyStopCcmEmulatedMpParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyStopCcmSimmulatedMpParams: Stop CCM PDU Transmission
type TopologyStopCcmSimmulatedMpParams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyStopCcmSimmulatedMpParams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyStopCcmSimmulatedMpParams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyStopCcmSimmulatedMpParams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyStopCcmSimmulatedMpParams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyStreams: MSRP Talker level Configuration
type TopologyStreams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ClassMeasurementInterval: Class Measurement Interval (us)
	ClassMeasurementInterval *Multivalue `json:"classMeasurementInterval,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// DataFramePriority: data frame priority of tagged data stream
	DataFramePriority *Multivalue `json:"dataFramePriority,omitempty"`
	// DestinationMac: Destination MAC
	DestinationMac *Multivalue `json:"destinationMac,omitempty"`
	// MaxFrameSize: maximum frame size that talker will produce
	MaxFrameSize *Multivalue `json:"maxFrameSize,omitempty"`
	// MaxIntervalFrames: Maximum number of frames that the talker may transmit in one class measurement interval
	MaxIntervalFrames *Multivalue `json:"maxIntervalFrames,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PerFrameOverhead: Per Frame Overhead (Bytes)
	PerFrameOverhead *Multivalue `json:"perFrameOverhead,omitempty"`
	// PortTcMaxLatency: maximum latency that is introduced by talker
	PortTcMaxLatency *Multivalue `json:"portTcMaxLatency,omitempty"`
	// Rank: Rank of the stream
	Rank *Multivalue `json:"rank,omitempty"`
	// SourceMac: Source MAC
	SourceMac *Multivalue `json:"sourceMac,omitempty"`
	// SrClass: Derived SR Class
	SrClass *Multivalue `json:"srClass,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StreamId: 64 bit stream ID after concatenation of 48 bit source MAC and 16 bit Unique ID
	StreamId *Multivalue `json:"streamId,omitempty"`
	// StreamName: User friendly name for 64 bit stream ID
	StreamName *Multivalue `json:"streamName,omitempty"`
	// UniqueId: 16 bit unsigned integer value to distinguish among multiple streams sourced by same talker
	UniqueId *Multivalue `json:"uniqueId,omitempty"`
	// VlanId: VLAN ID
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyStreams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyStreams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyStreams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyStreams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ClassMeasurementInterval.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "classMeasurementInterval",
		isMultivalue: true,
	})
	n.DataFramePriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "dataFramePriority",
		isMultivalue: true,
	})
	n.DestinationMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "destinationMac",
		isMultivalue: true,
	})
	n.MaxFrameSize.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxFrameSize",
		isMultivalue: true,
	})
	n.MaxIntervalFrames.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxIntervalFrames",
		isMultivalue: true,
	})
	n.PerFrameOverhead.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "perFrameOverhead",
		isMultivalue: true,
	})
	n.PortTcMaxLatency.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portTcMaxLatency",
		isMultivalue: true,
	})
	n.Rank.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "rank",
		isMultivalue: true,
	})
	n.SourceMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "sourceMac",
		isMultivalue: true,
	})
	n.SrClass.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srClass",
		isMultivalue: true,
	})
	n.StreamId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "streamId",
		isMultivalue: true,
	})
	n.StreamName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "streamName",
		isMultivalue: true,
	})
	n.UniqueId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "uniqueId",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologySubTlv: Sub Tlv container
type TopologySubTlv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// EnablePerSession: Enable TLV per session
	EnablePerSession *Multivalue `json:"enablePerSession,omitempty"`
	// IsEnabled: Enables/disables this tlv

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`

	Value *TopologyValue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySubTlv) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySubTlv) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySubTlv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySubTlv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnablePerSession.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePerSession",
		isMultivalue: true,
	})
	n.Value.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "value",
	})
}

// TopologySubscribedStreams: Subscribed SRP Stream ID
type TopologySubscribedStreams struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration.
	Active *Multivalue `json:"active,omitempty"`
	// AttributeType: Attribute Type
	AttributeType *Multivalue `json:"attributeType,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StreamId: Stream ID to which the listener wants to subscribe to
	StreamId *Multivalue `json:"streamId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySubscribedStreams) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySubscribedStreams) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySubscribedStreams) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySubscribedStreams) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.AttributeType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "attributeType",
		isMultivalue: true,
	})
	n.StreamId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "streamId",
		isMultivalue: true,
	})
}

// TopologySwitchGroupsList: Openflow Switch Groups level Configuration
type TopologySwitchGroupsList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Checked or Unchecked based on the Group Type selections in Groups tab under OF Switch tab-page.
	Active *Multivalue `json:"active,omitempty"`
	// ApplyGroup: Group Action:Apply Group.
	ApplyGroup *Multivalue `json:"applyGroup,omitempty"`
	// CopyTtlIn: Group Action:Copy TTL inwards from outermost to next-to-outermost.
	CopyTtlIn *Multivalue `json:"copyTtlIn,omitempty"`
	// CopyTtlOut: Group Action:Copy TTL outwards from next-to-outermost to outermost.
	CopyTtlOut *Multivalue `json:"copyTtlOut,omitempty"`
	// DecrementMplsTtl: Group Action:Decrement MPLS TTL.
	DecrementMplsTtl *Multivalue `json:"decrementMplsTtl,omitempty"`
	// DecrementNetwork: Group Action:Decrement IP TTL.
	DecrementNetwork *Multivalue `json:"decrementNetwork,omitempty"`
	// GroupType: Can be of the following types per switch: 1)All: Execute all buckets in the group. 2)Select:Execute one bucket in the group. 3)Indirect:Execute the one defined bucket in this group. 4)Fast Failover:Execute the first live bucket.
	GroupType *Multivalue `json:"groupType,omitempty"`
	// MaxNumberOfGroups: Maximum number of groups for each group type.
	MaxNumberOfGroups *Multivalue `json:"maxNumberOfGroups,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Output: Group Action:Output to switch port.
	Output *Multivalue `json:"output,omitempty"`
	// PopMpls: Group Action:Pop the outer MPLS tag.
	PopMpls *Multivalue `json:"popMpls,omitempty"`
	// PopPbb: Group Action:Pop the outer PBB service tag (I-TAG).
	PopPbb *Multivalue `json:"popPbb,omitempty"`
	// PopVlan: Group Action:Pop the outer VLAN tag.
	PopVlan *Multivalue `json:"popVlan,omitempty"`
	// PushMpls: Group Action:Push a new MPLS tag.
	PushMpls *Multivalue `json:"pushMpls,omitempty"`
	// PushPbb: Group Action:Push a new PBB service tag (I-TAG).
	PushPbb *Multivalue `json:"pushPbb,omitempty"`
	// PushVlan: Group Action:Push a new VLAN tag.
	PushVlan *Multivalue `json:"pushVlan,omitempty"`
	// SetField: Group Action:Set a header field using OXM TLV format.
	SetField *Multivalue `json:"setField,omitempty"`
	// SetMplsTtl: Group Action:Set MPLS TTL.
	SetMplsTtl *Multivalue `json:"setMplsTtl,omitempty"`
	// SetNetwork: Group Action:Set IP TTL.
	SetNetwork *Multivalue `json:"setNetwork,omitempty"`
	// SetQueue: Group Action:Set queue id when outputting to a port.
	SetQueue *Multivalue `json:"setQueue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySwitchGroupsList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySwitchGroupsList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySwitchGroupsList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySwitchGroupsList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ApplyGroup.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "applyGroup",
		isMultivalue: true,
	})
	n.CopyTtlIn.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "copyTtlIn",
		isMultivalue: true,
	})
	n.CopyTtlOut.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "copyTtlOut",
		isMultivalue: true,
	})
	n.DecrementMplsTtl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "decrementMplsTtl",
		isMultivalue: true,
	})
	n.DecrementNetwork.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "decrementNetwork",
		isMultivalue: true,
	})
	n.GroupType.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "groupType",
		isMultivalue: true,
	})
	n.MaxNumberOfGroups.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxNumberOfGroups",
		isMultivalue: true,
	})
	n.Output.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "output",
		isMultivalue: true,
	})
	n.PopMpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "popMpls",
		isMultivalue: true,
	})
	n.PopPbb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "popPbb",
		isMultivalue: true,
	})
	n.PopVlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "popVlan",
		isMultivalue: true,
	})
	n.PushMpls.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pushMpls",
		isMultivalue: true,
	})
	n.PushPbb.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pushPbb",
		isMultivalue: true,
	})
	n.PushVlan.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "pushVlan",
		isMultivalue: true,
	})
	n.SetField.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setField",
		isMultivalue: true,
	})
	n.SetMplsTtl.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setMplsTtl",
		isMultivalue: true,
	})
	n.SetNetwork.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setNetwork",
		isMultivalue: true,
	})
	n.SetQueue.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "setQueue",
		isMultivalue: true,
	})
}

// TopologySwitchTablesList: Openflow Switch Tables level Configuration
type TopologySwitchTablesList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// ApplyActions: Select the type of apply action capability that the table will support. The selected actions associated with a flow are applied immediately
	ApplyActions *Multivalue `json:"applyActions,omitempty"`
	// ApplyActionsMiss: Select the type of apply action miss capability that the table miss flow entry will support
	ApplyActionsMiss *Multivalue `json:"applyActionsMiss,omitempty"`
	// ApplySetField: Select the type of Apply Set Field capability that the table will support
	ApplySetField *Multivalue `json:"applySetField,omitempty"`
	// ApplySetFieldMask: Select the type of Apply Set Field Mask capability that the table will support
	ApplySetFieldMask *Multivalue `json:"applySetFieldMask,omitempty"`
	// ApplySetFieldMiss: Select the type of Apply Set Field Miss capability that the table miss flow entry will support
	ApplySetFieldMiss *Multivalue `json:"applySetFieldMiss,omitempty"`
	// ApplySetFieldMissMask: Select the type of Apply Set Field Miss capability that the table miss flow entry will support
	ApplySetFieldMissMask *Multivalue `json:"applySetFieldMissMask,omitempty"`
	// AutoConfigNextTable: If selected, the Next Table and Next Table Miss are automatically configured
	AutoConfigNextTable *Multivalue `json:"autoConfigNextTable,omitempty"`
	// FeaturesSupported: Select the table feature properties to enable them
	FeaturesSupported *Multivalue `json:"featuresSupported,omitempty"`
	// Instruction: Select the type of Instructions that the table flow entry will support
	Instruction *Multivalue `json:"instruction,omitempty"`
	// InstructionMiss: Select the type of Instruction miss capabilities that the table miss flow entry will support
	InstructionMiss *Multivalue `json:"instructionMiss,omitempty"`
	// Match: Select the type of match capability that the table will support
	Match *Multivalue `json:"match,omitempty"`
	// MatchMask: Select the type of match mask capability that the table will support.
	MatchMask *Multivalue `json:"matchMask,omitempty"`
	// MaxTableEntries: Specify Maximum Entries per Table.
	MaxTableEntries *Multivalue `json:"maxTableEntries,omitempty"`
	// MetadataMatch: Specify the bits of Metadata which the table can match
	MetadataMatch *Multivalue `json:"metadataMatch,omitempty"`
	// MetadataWrite: Specify the bits of Metadata which the table can write
	MetadataWrite *Multivalue `json:"metadataWrite,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NextTable: Specify the next table property (in incrementing order) seperated by , or - (for range) Eg: 1,2,3,4 or 1-4 or 1, 10-20.
	NextTable *Multivalue `json:"nextTable,omitempty"`
	// NextTableMiss: Specify the next table miss property (in incrementing order) seperated by , or - (for range) Eg: 1,2,3,4 or 1-4 or 1, 10-20.
	NextTableMiss *Multivalue `json:"nextTableMiss,omitempty"`
	// TableId: Specify the Table Id, {0 - 254}
	TableId *Multivalue `json:"tableId,omitempty"`
	// TableName: Specify the name of the Table.
	TableName *Multivalue `json:"tableName,omitempty"`
	// WildcardFeature: Select the type of wildcard capability that the table will support
	WildcardFeature *Multivalue `json:"wildcardFeature,omitempty"`
	// WildcardFeatureMask: Select the type of wildcard mask capability that the table will support
	WildcardFeatureMask *Multivalue `json:"wildcardFeatureMask,omitempty"`
	// WriteActions: Select the type of write action capability that the table will support. The selected actions are appended to the existing action set of the packet
	WriteActions *Multivalue `json:"writeActions,omitempty"`
	// WriteActionsMiss: Select the type of write action miss capability that the table miss flow entry will support
	WriteActionsMiss *Multivalue `json:"writeActionsMiss,omitempty"`
	// WriteSetField: Select the type of Write Set Field capability that the table will support
	WriteSetField *Multivalue `json:"writeSetField,omitempty"`
	// WriteSetFieldMask: Select the type of Write Set Field Mask capability that the table will support
	WriteSetFieldMask *Multivalue `json:"writeSetFieldMask,omitempty"`
	// WriteSetFieldMiss: Select the type of Write Set Field Miss capability that the table miss flow entry will support
	WriteSetFieldMiss *Multivalue `json:"writeSetFieldMiss,omitempty"`
	// WriteSetFieldMissMask: Select the type of Write Set Field Miss mask capability that the table will support
	WriteSetFieldMissMask *Multivalue `json:"writeSetFieldMissMask,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySwitchTablesList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySwitchTablesList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySwitchTablesList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySwitchTablesList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.ApplyActions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "applyActions",
		isMultivalue: true,
	})
	n.ApplyActionsMiss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "applyActionsMiss",
		isMultivalue: true,
	})
	n.ApplySetField.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "applySetField",
		isMultivalue: true,
	})
	n.ApplySetFieldMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "applySetFieldMask",
		isMultivalue: true,
	})
	n.ApplySetFieldMiss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "applySetFieldMiss",
		isMultivalue: true,
	})
	n.ApplySetFieldMissMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "applySetFieldMissMask",
		isMultivalue: true,
	})
	n.AutoConfigNextTable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "autoConfigNextTable",
		isMultivalue: true,
	})
	n.FeaturesSupported.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "featuresSupported",
		isMultivalue: true,
	})
	n.Instruction.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "instruction",
		isMultivalue: true,
	})
	n.InstructionMiss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "instructionMiss",
		isMultivalue: true,
	})
	n.Match.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "match",
		isMultivalue: true,
	})
	n.MatchMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "matchMask",
		isMultivalue: true,
	})
	n.MaxTableEntries.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "maxTableEntries",
		isMultivalue: true,
	})
	n.MetadataMatch.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metadataMatch",
		isMultivalue: true,
	})
	n.MetadataWrite.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "metadataWrite",
		isMultivalue: true,
	})
	n.NextTable.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextTable",
		isMultivalue: true,
	})
	n.NextTableMiss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nextTableMiss",
		isMultivalue: true,
	})
	n.TableId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tableId",
		isMultivalue: true,
	})
	n.TableName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tableName",
		isMultivalue: true,
	})
	n.WildcardFeature.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "wildcardFeature",
		isMultivalue: true,
	})
	n.WildcardFeatureMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "wildcardFeatureMask",
		isMultivalue: true,
	})
	n.WriteActions.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "writeActions",
		isMultivalue: true,
	})
	n.WriteActionsMiss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "writeActionsMiss",
		isMultivalue: true,
	})
	n.WriteSetField.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "writeSetField",
		isMultivalue: true,
	})
	n.WriteSetFieldMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "writeSetFieldMask",
		isMultivalue: true,
	})
	n.WriteSetFieldMiss.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "writeSetFieldMiss",
		isMultivalue: true,
	})
	n.WriteSetFieldMissMask.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "writeSetFieldMissMask",
		isMultivalue: true,
	})
}

// TopologySymbolicPathName: TBD
type TopologySymbolicPathName struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologySymbolicPathName) XPath() *XPath {
	return n.Xpath
}

func (n *TopologySymbolicPathName) setRestID(id string) {
	n.RestID = id
}

func (n *TopologySymbolicPathName) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologySymbolicPathName) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TopologyTable: The node where learned information is grouped into tables or columns and rows.
type TopologyTable struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath         `json:"xpath,omitempty"`
	Col   []*TopologyCol `json:"col"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTable) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTable) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTable) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTable) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Col {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "col",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyTables: Openflow Controller Table Configuration
type TopologyTables struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NumberOfFlowSet: Specify the number of Flow Set for this controller configuration.

	NumberOfFlowSet *float32 `json:"numberOfFlowSet,omitempty"`
	// TableId: Specify the controller table identifier. Lower numbered tables are consulted first.
	TableId *Multivalue `json:"tableId,omitempty"`
	// TableName: Specify the name of the controller table.
	TableName *Multivalue        `json:"tableName,omitempty"`
	FlowSet   []*TopologyFlowSet `json:"flowSet"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTables) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTables) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTables) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTables) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.TableId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tableId",
		isMultivalue: true,
	})
	n.TableName.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tableName",
		isMultivalue: true,
	})
	for i, o := range n.FlowSet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "flowSet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyTag: Tag configuration
type TopologyTag struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Id_: the tag ids that this entity will use/publish
	Id_ *Multivalue `json:"__id__,omitempty"`
	// Enabled: Enables/disables tags

	Enabled *bool `json:"enabled,omitempty"`
	// Name: specifies the name of the tag the entity will be part of

	Name *string `json:"name,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTag) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTag) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTag) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTag) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Id_.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "__id__",
		isMultivalue: true,
	})
}

// TopologyTlv: Tlv container
type TopologyTlv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Description: Description of the tlv

	Description *string `json:"description,omitempty"`
	// EnablePerSession: Enable TLV per session
	EnablePerSession *Multivalue `json:"enablePerSession,omitempty"`
	// IncludeInMessages: Include the TLV in these protocol messages
	IncludeInMessages []string `json:"includeInMessages"`
	// IsEnabled: Enables/disables this tlv

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Name: Name of the tlv

	Name *string `json:"name,omitempty"`

	Length *TopologyLength `json:"length,omitempty"`

	Type_ *TopologyType `json:"type,omitempty"`

	Value *TopologyValue `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTlv) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTlv) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTlv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTlv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.EnablePerSession.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enablePerSession",
		isMultivalue: true,
	})
	n.Length.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "length",
	})
	n.Type_.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "type",
	})
	n.Value.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "value",
	})
}

// TopologyTlvProfile: Tlv profile functionality is contained under this node
type TopologyTlvProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath      *XPath                `json:"xpath,omitempty"`
	DefaultTlv []*TopologyDefaultTlv `json:"defaultTlv"`
	Tlv        []*TopologyTlv        `json:"tlv"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTlvProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTlvProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTlvProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTlvProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.DefaultTlv {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "defaultTlv",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tlv {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tlv",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyTrillMCastIpv4GroupList: TRILL Multicast IPv4 Groups
type TopologyTrillMCastIpv4GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillMCastIpv4GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillMCastIpv4GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillMCastIpv4GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillMCastIpv4GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyTrillMCastIpv6GroupList: TRILL Multicast IPv6 Groups
type TopologyTrillMCastIpv6GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillMCastIpv6GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillMCastIpv6GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillMCastIpv6GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillMCastIpv6GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyTrillMCastMacGroupList: TRILL Multicast MAC Groups
type TopologyTrillMCastMacGroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillMCastMacGroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillMCastMacGroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillMCastMacGroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillMCastMacGroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyTrillNodeTopologyList: TRILL Node Topology
type TopologyTrillNodeTopologyList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterestedVlanRangeCount: Interested VLAN Range Count(multiplier)

	InterestedVlanRangeCount *float32 `json:"interestedVlanRangeCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NoOfTreesToCompute: No. of Trees to Compute
	NoOfTreesToCompute *Multivalue `json:"noOfTreesToCompute,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`

	InterestedVlanList *TopologyTrillNodeTopologyListInterestedVlanList `json:"interestedVlanList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillNodeTopologyList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillNodeTopologyList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillNodeTopologyList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillNodeTopologyList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.NoOfTreesToCompute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfTreesToCompute",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.InterestedVlanList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "interestedVlanList",
	})
}

// TopologyTrillNodeTopologyListInterestedVlanList: ISIS-TRILL Node Interested Vlans
type TopologyTrillNodeTopologyListInterestedVlanList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterNodeVlanIdIncr: Inter-Node Vlan Id Increment
	InterNodeVlanIdIncr *Multivalue `json:"interNodeVlanIdIncr,omitempty"`
	// M4BitEnabled: M4 Bit Enabled
	M4BitEnabled *Multivalue `json:"m4BitEnabled,omitempty"`
	// M6BitEnabled: M6 Bit Enabled
	M6BitEnabled *Multivalue `json:"m6BitEnabled,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// NoOfSpanningTreeRoots: No. of Spanning Tree Roots
	NoOfSpanningTreeRoots *Multivalue `json:"noOfSpanningTreeRoots,omitempty"`
	// StartSpanningTreeRootBridgeId: Start Spanning Tree Root Bridge ID
	StartSpanningTreeRootBridgeId *Multivalue `json:"startSpanningTreeRootBridgeId,omitempty"`
	// StartVlanId: Start Vlan Id
	StartVlanId *Multivalue `json:"startVlanId,omitempty"`
	// VlanCount: Vlan Count
	VlanCount *Multivalue `json:"vlanCount,omitempty"`
	// VlanIdIncr: Vlan Id Increment
	VlanIdIncr *Multivalue `json:"vlanIdIncr,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillNodeTopologyListInterestedVlanList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillNodeTopologyListInterestedVlanList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillNodeTopologyListInterestedVlanList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillNodeTopologyListInterestedVlanList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterNodeVlanIdIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interNodeVlanIdIncr",
		isMultivalue: true,
	})
	n.M4BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m4BitEnabled",
		isMultivalue: true,
	})
	n.M6BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m6BitEnabled",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.NoOfSpanningTreeRoots.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfSpanningTreeRoots",
		isMultivalue: true,
	})
	n.StartSpanningTreeRootBridgeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSpanningTreeRootBridgeId",
		isMultivalue: true,
	})
	n.StartVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startVlanId",
		isMultivalue: true,
	})
	n.VlanCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanCount",
		isMultivalue: true,
	})
	n.VlanIdIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdIncr",
		isMultivalue: true,
	})
}

// TopologyTrillSimulatedMCastIpv4GroupList: TRILL Multicast IPv4 Groups
type TopologyTrillSimulatedMCastIpv4GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillSimulatedMCastIpv4GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillSimulatedMCastIpv4GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillSimulatedMCastIpv4GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillSimulatedMCastIpv4GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyTrillSimulatedMCastIpv6GroupList: TRILL Multicast IPv6 Groups
type TopologyTrillSimulatedMCastIpv6GroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillSimulatedMCastIpv6GroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillSimulatedMCastIpv6GroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillSimulatedMCastIpv6GroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillSimulatedMCastIpv6GroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyTrillSimulatedMCastMacGroupList: TRILL Simulated Multicast MAC Groups
type TopologyTrillSimulatedMCastMacGroupList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterGrpUcastAddrIncr: Inter-Group Source Address Increment
	InterGrpUcastAddrIncr *Multivalue `json:"interGrpUcastAddrIncr,omitempty"`
	// McastAddrCnt: Multicast Address Count
	McastAddrCnt *Multivalue `json:"mcastAddrCnt,omitempty"`
	// McastAddrIncr: Multicast Address Increment
	McastAddrIncr *Multivalue `json:"mcastAddrIncr,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// SrcGrpMapping: Source-Group Mapping
	SrcGrpMapping *Multivalue `json:"srcGrpMapping,omitempty"`
	// StartMcastAddr: Start Multicast Address
	StartMcastAddr *Multivalue `json:"startMcastAddr,omitempty"`
	// StartUcastAddr: Start Source Address
	StartUcastAddr *Multivalue `json:"startUcastAddr,omitempty"`
	// TopologyId: Topology/Nickname
	TopologyId *Multivalue `json:"topologyId,omitempty"`
	// UcastAddrIncr: Source Address Increment
	UcastAddrIncr *Multivalue `json:"ucastAddrIncr,omitempty"`
	// UcastSrcCnt: # Sources per Multicast Group
	UcastSrcCnt *Multivalue `json:"ucastSrcCnt,omitempty"`
	// VlanId: Vlan Id
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillSimulatedMCastMacGroupList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillSimulatedMCastMacGroupList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillSimulatedMCastMacGroupList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillSimulatedMCastMacGroupList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.InterGrpUcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "interGrpUcastAddrIncr",
		isMultivalue: true,
	})
	n.McastAddrCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrCnt",
		isMultivalue: true,
	})
	n.McastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "mcastAddrIncr",
		isMultivalue: true,
	})
	n.SrcGrpMapping.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "srcGrpMapping",
		isMultivalue: true,
	})
	n.StartMcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startMcastAddr",
		isMultivalue: true,
	})
	n.StartUcastAddr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startUcastAddr",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.UcastAddrIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastAddrIncr",
		isMultivalue: true,
	})
	n.UcastSrcCnt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ucastSrcCnt",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyTrillTopologyList: TRILL Topology
type TopologyTrillTopologyList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// InterestedVlanRangeCount: Interested VLAN Range Count(multiplier)

	InterestedVlanRangeCount *float32 `json:"interestedVlanRangeCount,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// NicknameCount: Nickname Count(multiplier)

	NicknameCount *float32 `json:"nicknameCount,omitempty"`
	// NoOfTreesToCompute: No. of Trees to Compute
	NoOfTreesToCompute *Multivalue `json:"noOfTreesToCompute,omitempty"`
	// TopologyId: Topology Id
	TopologyId *Multivalue `json:"topologyId,omitempty"`

	InterestedVlanList *TopologyTrillTopologyListInterestedVlanList `json:"interestedVlanList,omitempty"`

	NicknameRecordList *TopologyTrillTopologyListNicknameRecordList `json:"nicknameRecordList,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillTopologyList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillTopologyList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillTopologyList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillTopologyList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.NoOfTreesToCompute.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfTreesToCompute",
		isMultivalue: true,
	})
	n.TopologyId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "topologyId",
		isMultivalue: true,
	})
	n.InterestedVlanList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "interestedVlanList",
	})
	n.NicknameRecordList.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "nicknameRecordList",
	})
}

// TopologyTrillTopologyListInterestedVlanList: ISIS-TRILL Interested Vlans
type TopologyTrillTopologyListInterestedVlanList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// M4BitEnabled: M4 Bit Enabled
	M4BitEnabled *Multivalue `json:"m4BitEnabled,omitempty"`
	// M6BitEnabled: M6 Bit Enabled
	M6BitEnabled *Multivalue `json:"m6BitEnabled,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// NoOfSpanningTreeRoots: No. of Spanning Tree Roots
	NoOfSpanningTreeRoots *Multivalue `json:"noOfSpanningTreeRoots,omitempty"`
	// StartSpanningTreeRootBridgeId: Start Spanning Tree Root Bridge ID
	StartSpanningTreeRootBridgeId *Multivalue `json:"startSpanningTreeRootBridgeId,omitempty"`
	// StartVlanId: Start Vlan Id
	StartVlanId *Multivalue `json:"startVlanId,omitempty"`
	// VlanCount: Vlan Count
	VlanCount *Multivalue `json:"vlanCount,omitempty"`
	// VlanIdIncr: Vlan Id Increment
	VlanIdIncr *Multivalue `json:"vlanIdIncr,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillTopologyListInterestedVlanList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillTopologyListInterestedVlanList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillTopologyListInterestedVlanList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillTopologyListInterestedVlanList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.M4BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m4BitEnabled",
		isMultivalue: true,
	})
	n.M6BitEnabled.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "m6BitEnabled",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.NoOfSpanningTreeRoots.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "noOfSpanningTreeRoots",
		isMultivalue: true,
	})
	n.StartSpanningTreeRootBridgeId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startSpanningTreeRootBridgeId",
		isMultivalue: true,
	})
	n.StartVlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startVlanId",
		isMultivalue: true,
	})
	n.VlanCount.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanCount",
		isMultivalue: true,
	})
	n.VlanIdIncr.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanIdIncr",
		isMultivalue: true,
	})
}

// TopologyTrillTopologyListNicknameRecordList: ISIS-TRILL Nickname Records
type TopologyTrillTopologyListNicknameRecordList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Activate/Deactivate Configuration
	Active *Multivalue `json:"active,omitempty"`
	// BroadcastRootPriority: Broadcast Root Priority
	BroadcastRootPriority *Multivalue `json:"broadcastRootPriority,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Nickname: Nickname
	Nickname *Multivalue `json:"nickname,omitempty"`
	// Priority: Priority
	Priority *Multivalue `json:"priority,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTrillTopologyListNicknameRecordList) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTrillTopologyListNicknameRecordList) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTrillTopologyListNicknameRecordList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTrillTopologyListNicknameRecordList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.BroadcastRootPriority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "broadcastRootPriority",
		isMultivalue: true,
	})
	n.Nickname.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "nickname",
		isMultivalue: true,
	})
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
}

// TopologyTxChannels: Tx Channel configuration.
type TopologyTxChannels struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ActiveTxChannel: Active
	ActiveTxChannel *Multivalue `json:"activeTxChannel,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// PortId: Port ID component of SCI with which MACsec traffic is transmitted.
	PortId *Multivalue `json:"portId,omitempty"`
	// StartingMessageNumber: Starting Message Number
	StartingMessageNumber *Multivalue `json:"startingMessageNumber,omitempty"`
	// SystemId: System Identifier component of the SCI field with which MACsec traffic is transmitted.
	SystemId *Multivalue `json:"systemId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTxChannels) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTxChannels) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTxChannels) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTxChannels) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActiveTxChannel.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeTxChannel",
		isMultivalue: true,
	})
	n.PortId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "portId",
		isMultivalue: true,
	})
	n.StartingMessageNumber.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "startingMessageNumber",
		isMultivalue: true,
	})
	n.SystemId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "systemId",
		isMultivalue: true,
	})
}

// TopologyTxSakPool: Tx SAKs configuration.
type TopologyTxSakPool struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ActiveSak: Points to the SAK value with which packets are currently getting encrypted.
	ActiveSak *Multivalue `json:"activeSak,omitempty"`
	// AnInUse: Shows the current AN value in use.
	AnInUse *Multivalue `json:"anInUse,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// TxSak128: 128 bit value of Secure Association Key with which DUT is expected to encrypt MACsec packets.
	TxSak128 *Multivalue `json:"txSak128,omitempty"`
	// TxSak256: 256 bit value of Secure Association Key with which DUT is expected to encrypt MACsec packets.
	TxSak256 *Multivalue `json:"txSak256,omitempty"`
	// TxSalt: 12 bytes Salt value for XPN cipher suites.
	TxSalt *Multivalue `json:"txSalt,omitempty"`
	// TxSsci: 4 bytes Short SCI for XPN cipher suites.
	TxSsci *Multivalue `json:"txSsci,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyTxSakPool) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyTxSakPool) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyTxSakPool) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyTxSakPool) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ActiveSak.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "activeSak",
		isMultivalue: true,
	})
	n.AnInUse.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "anInUse",
		isMultivalue: true,
	})
	n.TxSak128.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txSak128",
		isMultivalue: true,
	})
	n.TxSak256.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txSak256",
		isMultivalue: true,
	})
	n.TxSalt.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txSalt",
		isMultivalue: true,
	})
	n.TxSsci.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "txSsci",
		isMultivalue: true,
	})
}

// TopologyType: Tlv type container
type TopologyType struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsEditable: Indicates whether this is editable or not

	IsEditable *bool `json:"isEditable,omitempty"`
	// IsRequired: Indicates whether this is required or not

	IsRequired *bool `json:"isRequired,omitempty"`
	// Name: Name of the node

	Name   *string           `json:"name,omitempty"`
	Object []*TopologyObject `json:"object"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyType) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyType) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyType) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyType) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Object {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "object",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyValue: Tlv value container
type TopologyValue struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: The name of the object

	Name   *string           `json:"name,omitempty"`
	Object []*TopologyObject `json:"object"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyValue) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyValue) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyValue) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyValue) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Object {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "object",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TopologyVlan: VLAN
type TopologyVlan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// Priority: 3-bit user priority field in the VLAN tag.
	Priority *Multivalue `json:"priority,omitempty"`
	// Tpid: 16-bit Tag Protocol Identifier (TPID) or EtherType in the VLAN tag.
	Tpid *Multivalue `json:"tpid,omitempty"`
	// VlanId: 12-bit VLAN ID in the VLAN tag.
	VlanId *Multivalue `json:"vlanId,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyVlan) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyVlan) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyVlan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyVlan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Priority.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "priority",
		isMultivalue: true,
	})
	n.Tpid.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "tpid",
		isMultivalue: true,
	})
	n.VlanId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vlanId",
		isMultivalue: true,
	})
}

// TopologyVpnParameter: VPN
type TopologyVpnParameter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// SiteId: VPN Site Identifier
	SiteId *Multivalue `json:"siteId,omitempty"`
	// UseVpnParameters: Flag to determine whether optional VPN parameters are provided.

	UseVpnParameters *bool `json:"useVpnParameters,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyVpnParameter) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyVpnParameter) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyVpnParameter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyVpnParameter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.SiteId.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "siteId",
		isMultivalue: true,
	})
}

// TopologyVxlan: VXLAN protocol.
type TopologyVxlan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableStaticInfo: If true, VXLAN will use unicast entries for VTEP information instead of multicast learning.

	EnableStaticInfo *bool `json:"enableStaticInfo,omitempty"`
	// ExternalLearning: If true, VXLAN will use information received from another protocol which will handle the learning mechanism.

	ExternalLearning *bool `json:"externalLearning,omitempty"`
	// Ipv4Multicast: IPv4 Multicast Address.
	Ipv4Multicast *Multivalue `json:"ipv4_multicast,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// OvsdbConnectorMultiplier: Ovsdb to Vxlan multiplier, when part of OVSDB Server stack.

	OvsdbConnectorMultiplier *float32 `json:"ovsdbConnectorMultiplier,omitempty"`
	// RunningMode: There will be different behaviours based on role (normal=0, ovsdb controller stack=1, bfd stack=2.

	RunningMode *string `json:"runningMode,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StaticInfoCount: number of unicast VTEP

	StaticInfoCount *float32 `json:"staticInfoCount,omitempty"`
	// Vni: VXLAN Network Identifier.
	Vni            *Multivalue               `json:"vni,omitempty"`
	Bfdv4Interface []*TopologyBfdv4Interface `json:"bfdv4Interface"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	Ethernet            []*TopologyEthernet            `json:"ethernet"`
	Ipv4Loopback        []*TopologyIpv4Loopback        `json:"ipv4Loopback"`
	Ipv6Loopback        []*TopologyIpv6Loopback        `json:"ipv6Loopback"`
	LdpBasicRouter      []*TopologyLdpBasicRouter      `json:"ldpBasicRouter"`
	LdpBasicRouterV6    []*TopologyLdpBasicRouterV6    `json:"ldpBasicRouterV6"`
	LdpTargetedRouter   []*TopologyLdpTargetedRouter   `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6 []*TopologyLdpTargetedRouterV6 `json:"ldpTargetedRouterV6"`
	LearnedInfo         []*TopologyLearnedInfo         `json:"learnedInfo"`

	VxlanStaticInfo *TopologyVxlanStaticInfo `json:"vxlanStaticInfo,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyVxlan) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyVxlan) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyVxlan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyVxlan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Ipv4Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv4_multicast",
		isMultivalue: true,
	})
	n.Vni.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vni",
		isMultivalue: true,
	})
	for i, o := range n.Bfdv4Interface {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bfdv4Interface",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.VxlanStaticInfo.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "vxlanStaticInfo",
	})
}

// TopologyVxlanIPv6StaticInfo: VXLANv6 Unicast Info
type TopologyVxlanIPv6StaticInfo struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// EnableManualRemoteVMMac: Statically configure the Remote Inner Mac address to Outer Vtep IPv6 mapping, used for traffic.
	EnableManualRemoteVMMac *Multivalue `json:"enableManualRemoteVMMac,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RemoteVMIpv4: VM IPv4 Address.
	RemoteVMIpv4 *Multivalue `json:"remoteVMIpv4,omitempty"`
	// RemoteVMMacAddress: Remote VM MAC address
	RemoteVMMacAddress *Multivalue `json:"remoteVMMacAddress,omitempty"`
	// RemoteVtepUnicastIpv6: Remote VTEP Unicast IPv6
	RemoteVtepUnicastIpv6 *Multivalue `json:"remoteVtepUnicastIpv6,omitempty"`
	// SuppressArp: Suppress Arp for VM IP, VM MAC pair.
	SuppressArp *Multivalue `json:"suppressArp,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyVxlanIPv6StaticInfo) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyVxlanIPv6StaticInfo) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyVxlanIPv6StaticInfo) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyVxlanIPv6StaticInfo) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.EnableManualRemoteVMMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "enableManualRemoteVMMac",
		isMultivalue: true,
	})
	n.RemoteVMIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteVMIpv4",
		isMultivalue: true,
	})
	n.RemoteVMMacAddress.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteVMMacAddress",
		isMultivalue: true,
	})
	n.RemoteVtepUnicastIpv6.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteVtepUnicastIpv6",
		isMultivalue: true,
	})
	n.SuppressArp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "suppressArp",
		isMultivalue: true,
	})
}

// TopologyVxlanStaticInfo: VXLAN Unicast Info.
type TopologyVxlanStaticInfo struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Active: Flag.
	Active *Multivalue `json:"active,omitempty"`
	// MacStaticConfig: Statically configure the Remote Inner Mac address to Outer Vtep IP mapping, used for traffic.
	MacStaticConfig *Multivalue `json:"macStaticConfig,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// RemoteVmStaticIpv4: VM IPv4 Address.
	RemoteVmStaticIpv4 *Multivalue `json:"remoteVmStaticIpv4,omitempty"`
	// RemoteVmStaticMac: Remote VM MAC address
	RemoteVmStaticMac *Multivalue `json:"remoteVmStaticMac,omitempty"`
	// RemoteVtepIpv4: Remote VTEP Unicast IPv4
	RemoteVtepIpv4 *Multivalue `json:"remoteVtepIpv4,omitempty"`
	// SuppressArp: Suppress Arp for VM IP, VM MAC pair.
	SuppressArp *Multivalue `json:"suppressArp,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyVxlanStaticInfo) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyVxlanStaticInfo) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyVxlanStaticInfo) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyVxlanStaticInfo) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Active.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "active",
		isMultivalue: true,
	})
	n.MacStaticConfig.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "macStaticConfig",
		isMultivalue: true,
	})
	n.RemoteVmStaticIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteVmStaticIpv4",
		isMultivalue: true,
	})
	n.RemoteVmStaticMac.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteVmStaticMac",
		isMultivalue: true,
	})
	n.RemoteVtepIpv4.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "remoteVtepIpv4",
		isMultivalue: true,
	})
	n.SuppressArp.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "suppressArp",
		isMultivalue: true,
	})
}

// TopologyVxlanv6: VXLANv6 protocol.
type TopologyVxlanv6 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedVia: List of layers this layer used to connect to the wire
	ConnectedVia []string `json:"connectedVia"`
	// ConnectedViaRefs: Track refs for ConnectedVia.
	ConnectedViaRefs []Href `json:"-"`
	// EnableStaticInfo: If true, VXLAN will use unicast entries for VTEP information instead of multicast learning.

	EnableStaticInfo *bool `json:"enableStaticInfo,omitempty"`
	// Ipv6Multicast: IPv6 Multicast Address.
	Ipv6Multicast *Multivalue `json:"ipv6_multicast,omitempty"`
	// Multiplier: Number of layer instances per parent instance (multiplier)

	Multiplier *float32 `json:"multiplier,omitempty"`
	// Name: Name of NGPF element, guaranteed to be unique in Scenario

	Name *string `json:"name,omitempty"`
	// StackedLayers: List of secondary (many to one) child layer protocols
	StackedLayers []string `json:"stackedLayers"`
	// StackedLayersRefs: Track refs for StackedLayers.
	StackedLayersRefs []Href `json:"-"`
	// StaticInfoCount: number of unicast VTEP

	StaticInfoCount *float32 `json:"staticInfoCount,omitempty"`
	// Vni: VXLAN Network Identifier.
	Vni *Multivalue `json:"vni,omitempty"`

	Connector           *TopologyConnector             `json:"connector,omitempty"`
	Ethernet            []*TopologyEthernet            `json:"ethernet"`
	Ipv4Loopback        []*TopologyIpv4Loopback        `json:"ipv4Loopback"`
	Ipv6Loopback        []*TopologyIpv6Loopback        `json:"ipv6Loopback"`
	LdpBasicRouter      []*TopologyLdpBasicRouter      `json:"ldpBasicRouter"`
	LdpBasicRouterV6    []*TopologyLdpBasicRouterV6    `json:"ldpBasicRouterV6"`
	LdpTargetedRouter   []*TopologyLdpTargetedRouter   `json:"ldpTargetedRouter"`
	LdpTargetedRouterV6 []*TopologyLdpTargetedRouterV6 `json:"ldpTargetedRouterV6"`
	LearnedInfo         []*TopologyLearnedInfo         `json:"learnedInfo"`

	VxlanIPv6StaticInfo *TopologyVxlanIPv6StaticInfo `json:"vxlanIPv6StaticInfo,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TopologyVxlanv6) XPath() *XPath {
	return n.Xpath
}

func (n *TopologyVxlanv6) setRestID(id string) {
	n.RestID = id
}

func (n *TopologyVxlanv6) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TopologyVxlanv6) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Ipv6Multicast.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "ipv6_multicast",
		isMultivalue: true,
	})
	n.Vni.updateXPaths(&XPath{
		parentXPath:  xPath.String(),
		objectName:   "vni",
		isMultivalue: true,
	})
	n.Connector.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "connector",
	})
	for i, o := range n.Ethernet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ethernet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv6Loopback {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv6Loopback",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpBasicRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpBasicRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LdpTargetedRouterV6 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ldpTargetedRouterV6",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.LearnedInfo {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "learnedInfo",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.VxlanIPv6StaticInfo.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "vxlanIPv6StaticInfo",
	})
}

// Traffic: TBD
type Traffic struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoCorrectL4HeaderChecksums: This is used for Multis and Xdensity as checksum is not calculated correctly when change on the fly operations are performed. When this option is enabled IxOS uses 2 bytes before CRC, that way ensuring the checksum is correct when change on the fly operations are performed.

	AutoCorrectL4HeaderChecksums *bool `json:"autoCorrectL4HeaderChecksums,omitempty"`
	// CycleOffsetForScheduledStart: TBD

	CycleOffsetForScheduledStart *float32 `json:"cycleOffsetForScheduledStart,omitempty"`
	// CycleOffsetUnitForScheduledStart: TBD

	CycleOffsetUnitForScheduledStart *string `json:"cycleOffsetUnitForScheduledStart,omitempty"`
	// CycleTimeForScheduledStart: TBD

	CycleTimeForScheduledStart *float32 `json:"cycleTimeForScheduledStart,omitempty"`
	// CycleTimeUnitForScheduledStart: TBD

	CycleTimeUnitForScheduledStart *string `json:"cycleTimeUnitForScheduledStart,omitempty"`
	// DataPlaneJitterWindow: TBD

	DataPlaneJitterWindow *string `json:"dataPlaneJitterWindow,omitempty"`
	// DelayTimeForScheduledStart: Delay Time For Scheduled Start Transmit in seconds

	DelayTimeForScheduledStart *float32 `json:"delayTimeForScheduledStart,omitempty"`
	// DestMacRetryCount: TBD

	DestMacRetryCount *float32 `json:"destMacRetryCount,omitempty"`
	// DestMacRetryDelay: TBD

	DestMacRetryDelay *float32 `json:"destMacRetryDelay,omitempty"`
	// DetectMisdirectedOnAllPorts: TBD

	DetectMisdirectedOnAllPorts *bool `json:"detectMisdirectedOnAllPorts,omitempty"`
	// DisablePortLevelMisdirected: TBD

	DisablePortLevelMisdirected *bool `json:"disablePortLevelMisdirected,omitempty"`
	// DisplayMplsCurrentLabelValue: TBD

	DisplayMplsCurrentLabelValue *bool `json:"displayMplsCurrentLabelValue,omitempty"`
	// EgressOnlyTrafficItemName: Traffic Item name for egress only flows in statistics.

	EgressOnlyTrafficItemName *string `json:"egressOnlyTrafficItemName,omitempty"`
	// EnableDataIntegrityCheck: TBD

	EnableDataIntegrityCheck *bool `json:"enableDataIntegrityCheck,omitempty"`
	// EnableDestMacRetry: TBD

	EnableDestMacRetry *bool `json:"enableDestMacRetry,omitempty"`
	// EnableEgressOnlyTracking: This flags enables/disables egress only tracking. In this mode only traffic without ingress tracking is supported on ports with egress only settings, user will have only PGID stats and the packets will not contain any instrumentation block.

	EnableEgressOnlyTracking *bool `json:"enableEgressOnlyTracking,omitempty"`
	// EnableEgressOnlyTxStats: This flags enables/disables egress only tx stats. In this mode all traffic without ingress tracking is considered for tx stats.

	EnableEgressOnlyTxStats *bool `json:"enableEgressOnlyTxStats,omitempty"`
	// EnableInstantaneousStatsSupport: TBD

	EnableInstantaneousStatsSupport *bool `json:"enableInstantaneousStatsSupport,omitempty"`
	// EnableLagAutoRate: TBD

	EnableLagAutoRate *bool `json:"enableLagAutoRate,omitempty"`
	// EnableLagFlowBalancing: TBD

	EnableLagFlowBalancing *bool `json:"enableLagFlowBalancing,omitempty"`
	// EnableLagFlowFailoverMode: TBD

	EnableLagFlowFailoverMode *bool `json:"enableLagFlowFailoverMode,omitempty"`
	// EnableLagRebalanceOnPortUp: TBD

	EnableLagRebalanceOnPortUp *bool `json:"enableLagRebalanceOnPortUp,omitempty"`
	// EnableMinFrameSize: TBD

	EnableMinFrameSize *bool `json:"enableMinFrameSize,omitempty"`
	// EnableMulticastScalingFactor: TBD

	EnableMulticastScalingFactor *bool `json:"enableMulticastScalingFactor,omitempty"`
	// EnableSequenceChecking: TBD

	EnableSequenceChecking *bool `json:"enableSequenceChecking,omitempty"`
	// EnableStaggeredStartDelay: TBD

	EnableStaggeredStartDelay *bool `json:"enableStaggeredStartDelay,omitempty"`
	// EnableStaggeredTransmit: TBD

	EnableStaggeredTransmit *bool `json:"enableStaggeredTransmit,omitempty"`
	// EnableStreamOrdering: TBD

	EnableStreamOrdering *bool `json:"enableStreamOrdering,omitempty"`
	// FrameOrderingMode: TBD

	FrameOrderingMode *string `json:"frameOrderingMode,omitempty"`
	// GlobalStreamControl: TBD

	GlobalStreamControl *string `json:"globalStreamControl,omitempty"`
	// GlobalStreamControlIterations: TBD

	GlobalStreamControlIterations *float32 `json:"globalStreamControlIterations,omitempty"`
	// LargeErrorThreshhold: TBD

	LargeErrorThreshhold *float32 `json:"largeErrorThreshhold,omitempty"`
	// LearningFrameSize: TBD

	LearningFrameSize *float32 `json:"learningFrameSize,omitempty"`
	// LearningFramesCount: TBD

	LearningFramesCount *float32 `json:"learningFramesCount,omitempty"`
	// LearningFramesRate: TBD

	LearningFramesRate *float32 `json:"learningFramesRate,omitempty"`
	// MacChangeOnFly: TBD

	MacChangeOnFly *bool `json:"macChangeOnFly,omitempty"`
	// MaxTrafficGenerationQueries: TBD

	MaxTrafficGenerationQueries *float32 `json:"maxTrafficGenerationQueries,omitempty"`
	// MplsLabelLearningTimeout: TBD

	MplsLabelLearningTimeout *float32 `json:"mplsLabelLearningTimeout,omitempty"`
	// PeakLoadingReplicationCount: TBD

	PeakLoadingReplicationCount *float32 `json:"peakLoadingReplicationCount,omitempty"`
	// PreventDataPlaneToCpu: TBD

	PreventDataPlaneToCpu *bool `json:"preventDataPlaneToCpu,omitempty"`
	// RefreshLearnedInfoBeforeApply: TBD

	RefreshLearnedInfoBeforeApply *bool `json:"refreshLearnedInfoBeforeApply,omitempty"`
	// UseRfc5952: Use RFC 5952 for formatting IPv6 addresses (:ffff:1.2.3.4)

	UseRfc5952 *bool `json:"useRfc5952,omitempty"`
	// UseScheduledStartTransmit: Use Scheduled Start Transmit

	UseScheduledStartTransmit *bool `json:"useScheduledStartTransmit,omitempty"`
	// UseTxRxSync: TBD

	UseTxRxSync *bool `json:"useTxRxSync,omitempty"`
	// WaitTime: TBD

	WaitTime *float32 `json:"waitTime,omitempty"`

	Statistics  *TrafficStatistics    `json:"statistics,omitempty"`
	TrafficItem []*TrafficTrafficItem `json:"trafficItem"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Traffic) XPath() *XPath {
	return n.Xpath
}

func (n *Traffic) setRestID(id string) {
	n.RestID = id
}

func (n *Traffic) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Traffic) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Statistics.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "statistics",
	})
	for i, o := range n.TrafficItem {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "trafficItem",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficAdvancedSequenceChecking: TBD
type TrafficAdvancedSequenceChecking struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvancedSequenceThreshold: TBD

	AdvancedSequenceThreshold *float32 `json:"advancedSequenceThreshold,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficAdvancedSequenceChecking) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficAdvancedSequenceChecking) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficAdvancedSequenceChecking) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficAdvancedSequenceChecking) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficAppLibFlow: TBD
type TrafficAppLibFlow struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Percentage: TBD

	Percentage *float32             `json:"percentage,omitempty"`
	Connection []*TrafficConnection `json:"connection"`
	Parameter  []*TrafficParameter  `json:"parameter"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficAppLibFlow) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficAppLibFlow) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficAppLibFlow) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficAppLibFlow) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Connection {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "connection",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Parameter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "parameter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficAppLibProfile: TBD
type TrafficAppLibProfile struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConfiguredFlows: Configured application library flows within profile.
	ConfiguredFlows []string `json:"configuredFlows"`
	// EnablePerIPStats: Enable Per IP Stats. When true then Per IP statistic drilldown is available.

	EnablePerIPStats *bool `json:"enablePerIPStats,omitempty"`
	// ObjectiveDistribution: Objective distribution value.

	ObjectiveDistribution *string `json:"objectiveDistribution,omitempty"`
	// ObjectiveType: TBD

	ObjectiveType *string `json:"objectiveType,omitempty"`
	// ObjectiveValue: TBD

	ObjectiveValue *float32             `json:"objectiveValue,omitempty"`
	AppLibFlow     []*TrafficAppLibFlow `json:"appLibFlow"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficAppLibProfile) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficAppLibProfile) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficAppLibProfile) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficAppLibProfile) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.AppLibFlow {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "appLibFlow",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficBool: TBD
type TrafficBool struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: Parameter bool value.

	Value *bool `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficBool) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficBool) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficBool) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficBool) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficChoice: TBD
type TrafficChoice struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: Parameter choice selected value.

	Value *string `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficChoice) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficChoice) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficChoice) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficChoice) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficColumn: TBD
type TrafficColumn struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// Format: TBD

	Format *string `json:"format,omitempty"`
	// Offset: TBD

	Offset *float32 `json:"offset,omitempty"`
	// Size: TBD

	Size *float32 `json:"size,omitempty"`
	// Values: TBD
	Values []string `json:"values"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficColumn) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficColumn) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficColumn) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficColumn) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficConfigElement: TBD
type TrafficConfigElement struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Crc: TBD

	Crc *string `json:"crc,omitempty"`
	// DestinationMacMode: TBD

	DestinationMacMode *string `json:"destinationMacMode,omitempty"`
	// EnableDisparityError: TBD

	EnableDisparityError *bool `json:"enableDisparityError,omitempty"`
	// PreambleCustomSize: TBD

	PreambleCustomSize *float32 `json:"preambleCustomSize,omitempty"`
	// PreambleFrameSizeMode: TBD

	PreambleFrameSizeMode *string `json:"preambleFrameSizeMode,omitempty"`

	FramePayload *TrafficFramePayload `json:"framePayload,omitempty"`

	FrameRate *TrafficFrameRate `json:"frameRate,omitempty"`

	FrameRateDistribution *TrafficFrameRateDistribution `json:"frameRateDistribution,omitempty"`

	FrameSize *TrafficFrameSize   `json:"frameSize,omitempty"`
	Stack     []*TrafficStack     `json:"stack"`
	StackLink []*TrafficStackLink `json:"stackLink"`

	TransmissionControl      *TrafficTransmissionControl        `json:"transmissionControl,omitempty"`
	TransmissionDistribution []*TrafficTransmissionDistribution `json:"transmissionDistribution"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficConfigElement) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficConfigElement) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficConfigElement) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficConfigElement) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FramePayload.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "framePayload",
	})
	n.FrameRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "frameRate",
	})
	n.FrameRateDistribution.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "frameRateDistribution",
	})
	n.FrameSize.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "frameSize",
	})
	for i, o := range n.Stack {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "stack",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StackLink {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "stackLink",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.TransmissionControl.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "transmissionControl",
	})
	for i, o := range n.TransmissionDistribution {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "transmissionDistribution",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficConnection: TBD
type TrafficConnection struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath     *XPath              `json:"xpath,omitempty"`
	Parameter []*TrafficParameter `json:"parameter"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficConnection) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficConnection) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficConnection) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficConnection) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Parameter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "parameter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficCounter: TBD
type TrafficCounter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BitOffset: TBD

	BitOffset *float32 `json:"bitOffset,omitempty"`
	// Count: TBD

	Count *float32 `json:"count,omitempty"`
	// Direction: TBD

	Direction *string `json:"direction,omitempty"`
	// StartValue: TBD

	StartValue *float32 `json:"startValue,omitempty"`
	// StepValue: TBD

	StepValue *float32 `json:"stepValue,omitempty"`
	// Width: TBD

	Width *string `json:"width,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficCounter) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficCounter) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficCounter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficCounter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficCpdpConvergence: TBD
type TrafficCpdpConvergence struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DataPlaneJitterWindow: TBD

	DataPlaneJitterWindow *string `json:"dataPlaneJitterWindow,omitempty"`
	// DataPlaneThreshold: TBD

	DataPlaneThreshold *float32 `json:"dataPlaneThreshold,omitempty"`
	// EnableControlPlaneEvents: TBD

	EnableControlPlaneEvents *bool `json:"enableControlPlaneEvents,omitempty"`
	// EnableDataPlaneEventsRateMonitor: TBD

	EnableDataPlaneEventsRateMonitor *bool `json:"enableDataPlaneEventsRateMonitor,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficCpdpConvergence) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficCpdpConvergence) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficCpdpConvergence) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficCpdpConvergence) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficDataIntegrity: TBD
type TrafficDataIntegrity struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficDataIntegrity) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficDataIntegrity) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficDataIntegrity) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficDataIntegrity) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficDelayVariation: TBD
type TrafficDelayVariation struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// LargeSequenceNumberErrorThreshold: TBD

	LargeSequenceNumberErrorThreshold *float32 `json:"largeSequenceNumberErrorThreshold,omitempty"`
	// LatencyMode: TBD

	LatencyMode *string `json:"latencyMode,omitempty"`
	// StatisticsMode: TBD

	StatisticsMode *string `json:"statisticsMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficDelayVariation) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficDelayVariation) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficDelayVariation) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficDelayVariation) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficDynamicUpdate: TBD
type TrafficDynamicUpdate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnabledDynamicUpdateFields: TBD
	EnabledDynamicUpdateFields []string `json:"enabledDynamicUpdateFields"`
	// EnabledSessionAwareTrafficFields: TBD
	EnabledSessionAwareTrafficFields []string `json:"enabledSessionAwareTrafficFields"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficDynamicUpdate) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficDynamicUpdate) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficDynamicUpdate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficDynamicUpdate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficEgress: TBD
type TrafficEgress struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CustomOffsetBits: TBD

	CustomOffsetBits *float32 `json:"customOffsetBits,omitempty"`
	// CustomWidthBits: TBD

	CustomWidthBits *float32 `json:"customWidthBits,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// Encapsulation: TBD

	Encapsulation *string `json:"encapsulation,omitempty"`
	// Offset: TBD

	Offset *string `json:"offset,omitempty"`

	FieldOffset *TrafficFieldOffset `json:"fieldOffset,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficEgress) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficEgress) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficEgress) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficEgress) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FieldOffset.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fieldOffset",
	})
}

// TrafficEgressTracking: TBD
type TrafficEgressTracking struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// CustomOffsetBits: TBD

	CustomOffsetBits *float32 `json:"customOffsetBits,omitempty"`
	// CustomWidthBits: TBD

	CustomWidthBits *float32 `json:"customWidthBits,omitempty"`
	// Encapsulation: TBD

	Encapsulation *string `json:"encapsulation,omitempty"`
	// Offset: TBD

	Offset *string `json:"offset,omitempty"`

	FieldOffset *TrafficFieldOffset `json:"fieldOffset,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficEgressTracking) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficEgressTracking) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficEgressTracking) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficEgressTracking) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FieldOffset.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fieldOffset",
	})
}

// TrafficEndpointSet: TBD
type TrafficEndpointSet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AllowEmptyTopologySets: Enable this to allow the setting of sources and destinations without throwing an error even if the combination produces an empty topology set.

	AllowEmptyTopologySets *bool `json:"allowEmptyTopologySets,omitempty"`
	// DestinationFilter: TBD

	DestinationFilter *string `json:"destinationFilter,omitempty"`
	// Destinations: TBD
	Destinations []string `json:"destinations"`
	// DestinationsRefs: Track refs for Destinations.
	DestinationsRefs []Href `json:"-"`
	// FullyMeshedEndpoints: TBD
	FullyMeshedEndpoints []string `json:"fullyMeshedEndpoints"`
	// FullyMeshedEndpointsRefs: Track refs for FullyMeshedEndpoints.
	FullyMeshedEndpointsRefs []Href `json:"-"`
	// MulticastDestinations: A compact representation of many virtual multicast destinations. Each list item consists of 5 values where the first two, a bool value and enum value, can be defaulted to false and none. The next two values are a starting address and step address which can be either an ipv4, ipv6 or streamId and the last value is a count of addresses.
	MulticastDestinations []map[string]interface{} `json:"multicastDestinations,omitempty"`
	// MulticastReceivers: A list of virtual multicast receivers. Each list item consists of a multicast receiver object reference, port index, host index and group or join/prune index depending on the type of object reference.
	MulticastReceivers []map[string]interface{} `json:"multicastReceivers,omitempty"`
	// Name: TBD

	Name *string `json:"name,omitempty"`
	// NgpfFilters: TBD
	NgpfFilters []map[string]interface{} `json:"ngpfFilters,omitempty"`
	// ScalableDestinations: TBD
	ScalableDestinations []map[string]interface{} `json:"scalableDestinations,omitempty"`
	// ScalableSources: TBD
	ScalableSources []map[string]interface{} `json:"scalableSources,omitempty"`
	// SourceFilter: TBD

	SourceFilter *string `json:"sourceFilter,omitempty"`
	// Sources: TBD
	Sources []string `json:"sources"`
	// SourcesRefs: Track refs for Sources.
	SourcesRefs []Href `json:"-"`
	// TrafficGroups: TBD
	TrafficGroups []string `json:"trafficGroups"`
	// TrafficGroupsRefs: Track refs for TrafficGroups.
	TrafficGroupsRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficEndpointSet) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficEndpointSet) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficEndpointSet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficEndpointSet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficErrorStats: TBD
type TrafficErrorStats struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficErrorStats) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficErrorStats) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficErrorStats) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficErrorStats) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficField: TBD
type TrafficField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ActiveFieldChoice: TBD

	ActiveFieldChoice *bool `json:"activeFieldChoice,omitempty"`
	// Auto: TBD

	Auto *bool `json:"auto,omitempty"`
	// CountValue: TBD

	CountValue *string `json:"countValue,omitempty"`
	// FieldValue: TBD

	FieldValue *string `json:"fieldValue,omitempty"`
	// FixedBits: TBD

	FixedBits *string `json:"fixedBits,omitempty"`
	// FullMesh: TBD

	FullMesh *bool `json:"fullMesh,omitempty"`
	// MaxValue: TBD

	MaxValue *string `json:"maxValue,omitempty"`
	// MinValue: TBD

	MinValue *string `json:"minValue,omitempty"`
	// OnTheFlyMask: TBD

	OnTheFlyMask *string `json:"onTheFlyMask,omitempty"`
	// OptionalEnabled: TBD

	OptionalEnabled *bool `json:"optionalEnabled,omitempty"`
	// RandomMask: TBD

	RandomMask *string `json:"randomMask,omitempty"`
	// Seed: TBD

	Seed *string `json:"seed,omitempty"`
	// SingleValue: TBD

	SingleValue *string `json:"singleValue,omitempty"`
	// StartValue: TBD

	StartValue *string `json:"startValue,omitempty"`
	// StepValue: TBD

	StepValue *string `json:"stepValue,omitempty"`
	// TrackingEnabled: TBD

	TrackingEnabled *bool `json:"trackingEnabled,omitempty"`
	// ValueList: TBD
	ValueList []string `json:"valueList"`
	// ValueType: TBD

	ValueType *string `json:"valueType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficField) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficField) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficFieldOffset: TBD
type TrafficFieldOffset struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath          `json:"xpath,omitempty"`
	Stack []*TrafficStack `json:"stack"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficFieldOffset) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficFieldOffset) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficFieldOffset) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficFieldOffset) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Stack {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "stack",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficFramePayload: TBD
type TrafficFramePayload struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CustomPattern: TBD

	CustomPattern *string `json:"customPattern,omitempty"`
	// CustomRepeat: TBD

	CustomRepeat *bool `json:"customRepeat,omitempty"`
	// Type_: TBD

	Type_ *string `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficFramePayload) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficFramePayload) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficFramePayload) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficFramePayload) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficFramePreemption: TBD
type TrafficFramePreemption struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoFragmentCount: Let the fragments be auto counted

	AutoFragmentCount *bool `json:"autoFragmentCount,omitempty"`
	// Enable: Enable frame preemption on the given stream. Disabled indicates an express frame

	Enable *bool `json:"enable,omitempty"`
	// FragmentCount: Set the fragment count (a value between 0 and 3)

	FragmentCount *float32 `json:"fragmentCount,omitempty"`
	// FrameType: Select the frame type

	FrameType *string `json:"frameType,omitempty"`
	// LastFragment: Indicates if this is the last fragment of the preemptable packet

	LastFragment *bool `json:"lastFragment,omitempty"`
	// SmdType: Select the SMD type

	SmdType *string `json:"smdType,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficFramePreemption) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficFramePreemption) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficFramePreemption) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficFramePreemption) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficFrameRate: TBD
type TrafficFrameRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BitRateUnitsType: TBD

	BitRateUnitsType *string `json:"bitRateUnitsType,omitempty"`
	// EnforceMinimumInterPacketGap: TBD

	EnforceMinimumInterPacketGap *float32 `json:"enforceMinimumInterPacketGap,omitempty"`
	// InterPacketGapUnitsType: TBD

	InterPacketGapUnitsType *string `json:"interPacketGapUnitsType,omitempty"`
	// Rate: TBD

	Rate *float32 `json:"rate,omitempty"`
	// Type_: TBD

	Type_ *string `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficFrameRate) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficFrameRate) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficFrameRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficFrameRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficFrameRateDistribution: TBD
type TrafficFrameRateDistribution struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// PortDistribution: TBD

	PortDistribution *string `json:"portDistribution,omitempty"`
	// StreamDistribution: TBD

	StreamDistribution *string `json:"streamDistribution,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficFrameRateDistribution) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficFrameRateDistribution) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficFrameRateDistribution) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficFrameRateDistribution) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficFrameSize: TBD
type TrafficFrameSize struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// FixedSize: TBD

	FixedSize *float32 `json:"fixedSize,omitempty"`
	// IncrementFrom: TBD

	IncrementFrom *float32 `json:"incrementFrom,omitempty"`
	// IncrementStep: TBD

	IncrementStep *float32 `json:"incrementStep,omitempty"`
	// IncrementTo: TBD

	IncrementTo *float32 `json:"incrementTo,omitempty"`
	// PresetDistribution: TBD

	PresetDistribution *string `json:"presetDistribution,omitempty"`
	// QuadGaussian: TBD
	QuadGaussian []float32 `json:"quadGaussian"`
	// RandomMax: TBD

	RandomMax *float32 `json:"randomMax,omitempty"`
	// RandomMin: TBD

	RandomMin *float32 `json:"randomMin,omitempty"`
	// Type_: TBD

	Type_ *string `json:"type,omitempty"`
	// WeightedPairs: TBD
	WeightedPairs []float32 `json:"weightedPairs"`
	// WeightedRangePairs: TBD
	WeightedRangePairs []map[string]interface{} `json:"weightedRangePairs,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficFrameSize) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficFrameSize) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficFrameSize) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficFrameSize) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficHex: TBD
type TrafficHex struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: Parameter hex value.

	Value *string `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficHex) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficHex) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficHex) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficHex) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficHighLevelStream: TBD
type TrafficHighLevelStream struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Crc: TBD

	Crc *string `json:"crc,omitempty"`
	// DestinationMacMode: TBD

	DestinationMacMode *string `json:"destinationMacMode,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// Name: TBD

	Name *string `json:"name,omitempty"`
	// Pause: TBD

	Pause *bool `json:"pause,omitempty"`
	// PreambleCustomSize: TBD

	PreambleCustomSize *float32 `json:"preambleCustomSize,omitempty"`
	// PreambleFrameSizeMode: TBD

	PreambleFrameSizeMode *string `json:"preambleFrameSizeMode,omitempty"`
	// RxPortIds: TBD
	RxPortIds []string `json:"rxPortIds"`
	// RxPortIdsRefs: Track refs for RxPortIds.
	RxPortIdsRefs []Href `json:"-"`
	// Suspend: TBD

	Suspend *bool `json:"suspend,omitempty"`
	// TxPortId: TBD

	TxPortId *string `json:"txPortId,omitempty"`
	// TxPortIdRefs: Track refs for TxPortId.
	TxPortIdRefs []Href `json:"-"`

	FramePayload *TrafficFramePayload `json:"framePayload,omitempty"`

	FramePreemption *TrafficFramePreemption `json:"framePreemption,omitempty"`

	FrameRate *TrafficFrameRate `json:"frameRate,omitempty"`

	FrameSize *TrafficFrameSize   `json:"frameSize,omitempty"`
	Stack     []*TrafficStack     `json:"stack"`
	StackLink []*TrafficStackLink `json:"stackLink"`
	TableUdf  []*TrafficTableUdf  `json:"tableUdf"`

	TransmissionControl *TrafficTransmissionControl `json:"transmissionControl,omitempty"`
	Udf                 []*TrafficUdf               `json:"udf"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficHighLevelStream) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficHighLevelStream) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficHighLevelStream) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficHighLevelStream) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FramePayload.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "framePayload",
	})
	n.FramePreemption.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "framePreemption",
	})
	n.FrameRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "frameRate",
	})
	n.FrameSize.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "frameSize",
	})
	for i, o := range n.Stack {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "stack",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.StackLink {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "stackLink",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TableUdf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tableUdf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	n.TransmissionControl.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "transmissionControl",
	})
	for i, o := range n.Udf {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "udf",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficInterArrivalTimeRate: TBD
type TrafficInterArrivalTimeRate struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficInterArrivalTimeRate) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficInterArrivalTimeRate) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficInterArrivalTimeRate) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficInterArrivalTimeRate) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficIptv: TBD
type TrafficIptv struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficIptv) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficIptv) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficIptv) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficIptv) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficIpv4: TBD
type TrafficIpv4 struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BitmaskCount: TBD

	BitmaskCount *float32 `json:"bitmaskCount,omitempty"`
	// InnerLoopIncrementBy: TBD

	InnerLoopIncrementBy *float32 `json:"innerLoopIncrementBy,omitempty"`
	// InnerLoopLoopCount: TBD

	InnerLoopLoopCount *float32 `json:"innerLoopLoopCount,omitempty"`
	// OuterLoopLoopCount: TBD

	OuterLoopLoopCount *float32 `json:"outerLoopLoopCount,omitempty"`
	// SkipValues: TBD

	SkipValues *bool `json:"skipValues,omitempty"`
	// StartValue: TBD

	StartValue *float32 `json:"startValue,omitempty"`
	// Width: TBD

	Width *string `json:"width,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficIpv4) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficIpv4) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficIpv4) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficIpv4) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficL1Rates: TBD
type TrafficL1Rates struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficL1Rates) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficL1Rates) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficL1Rates) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficL1Rates) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficLatency: TBD
type TrafficLatency struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// Mode: TBD

	Mode *string `json:"mode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficLatency) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficLatency) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficLatency) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficLatency) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficLatencyBin: TBD
type TrafficLatencyBin struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BinLimits: TBD
	BinLimits []float32 `json:"binLimits"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// NumberOfBins: TBD

	NumberOfBins *float32 `json:"numberOfBins,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficLatencyBin) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficLatencyBin) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficLatencyBin) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficLatencyBin) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficMisdirectedPerFlow: TBD
type TrafficMisdirectedPerFlow struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficMisdirectedPerFlow) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficMisdirectedPerFlow) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficMisdirectedPerFlow) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficMisdirectedPerFlow) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficMultipleJoinLeaveLatency: TBD
type TrafficMultipleJoinLeaveLatency struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficMultipleJoinLeaveLatency) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficMultipleJoinLeaveLatency) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficMultipleJoinLeaveLatency) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficMultipleJoinLeaveLatency) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficNestedCounter: TBD
type TrafficNestedCounter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BitOffset: TBD

	BitOffset *float32 `json:"bitOffset,omitempty"`
	// InnerLoopIncrementBy: TBD

	InnerLoopIncrementBy *float32 `json:"innerLoopIncrementBy,omitempty"`
	// InnerLoopLoopCount: TBD

	InnerLoopLoopCount *float32 `json:"innerLoopLoopCount,omitempty"`
	// InnerLoopRepeatValue: TBD

	InnerLoopRepeatValue *float32 `json:"innerLoopRepeatValue,omitempty"`
	// OuterLoopIncrementBy: TBD

	OuterLoopIncrementBy *float32 `json:"outerLoopIncrementBy,omitempty"`
	// OuterLoopLoopCount: TBD

	OuterLoopLoopCount *float32 `json:"outerLoopLoopCount,omitempty"`
	// StartValue: TBD

	StartValue *float32 `json:"startValue,omitempty"`
	// Width: TBD

	Width *string `json:"width,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficNestedCounter) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficNestedCounter) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficNestedCounter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficNestedCounter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficNumber: TBD
type TrafficNumber struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: Parameter integer value.

	Value *float32 `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficNumber) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficNumber) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficNumber) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficNumber) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficOneTimeJoinLeaveLatency: TBD
type TrafficOneTimeJoinLeaveLatency struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficOneTimeJoinLeaveLatency) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficOneTimeJoinLeaveLatency) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficOneTimeJoinLeaveLatency) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficOneTimeJoinLeaveLatency) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficPacketLossDuration: TBD
type TrafficPacketLossDuration struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficPacketLossDuration) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficPacketLossDuration) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficPacketLossDuration) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficPacketLossDuration) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficParameter: TBD
type TrafficParameter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Option: Each parameter has one or multiple options. Runtime supported options for specific parameter can be retrieved from supportedOptions attribute

	Option *string          `json:"option,omitempty"`
	Bool   []*TrafficBool   `json:"bool"`
	Choice []*TrafficChoice `json:"choice"`
	Hex    []*TrafficHex    `json:"hex"`
	Number []*TrafficNumber `json:"number"`
	Range_ []*TrafficRange  `json:"range"`
	String []*TrafficString `json:"string"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficParameter) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficParameter) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficParameter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficParameter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Bool {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "bool",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Choice {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "choice",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Hex {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "hex",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Number {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "number",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Range_ {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "range",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.String {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "string",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficPrbs: TBD
type TrafficPrbs struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficPrbs) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficPrbs) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficPrbs) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficPrbs) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficRandom: TBD
type TrafficRandom struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Mask: TBD

	Mask *string `json:"mask,omitempty"`
	// Width: TBD

	Width *string `json:"width,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficRandom) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficRandom) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficRandom) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficRandom) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficRange: TBD
type TrafficRange struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// From: Start range value.

	From *float32 `json:"from,omitempty"`
	// To: End range value.

	To *float32 `json:"to,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficRange) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficRange) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficRange) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficRange) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficRangeList: TBD
type TrafficRangeList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BitOffset: TBD

	BitOffset *float32 `json:"bitOffset,omitempty"`
	// StartValueCountStepList: TBD
	StartValueCountStepList []float32 `json:"startValueCountStepList"`
	// Width: TBD

	Width *string `json:"width,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficRangeList) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficRangeList) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficRangeList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficRangeList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficSequenceChecking: TBD
type TrafficSequenceChecking struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AdvancedSequenceThreshold: TBD

	AdvancedSequenceThreshold *float32 `json:"advancedSequenceThreshold,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// SequenceMode: TBD

	SequenceMode *string `json:"sequenceMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficSequenceChecking) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficSequenceChecking) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficSequenceChecking) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficSequenceChecking) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficStack: TBD
type TrafficStack struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath          `json:"xpath,omitempty"`
	Field []*TrafficField `json:"field"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficStack) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficStack) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficStack) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficStack) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficStackLink: TBD
type TrafficStackLink struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// LinkedTo: TBD

	LinkedTo *string `json:"linkedTo,omitempty"`
	// LinkedToRefs: Track refs for LinkedTo.
	LinkedToRefs []Href `json:"-"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficStackLink) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficStackLink) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficStackLink) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficStackLink) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficStatistics: TBD
type TrafficStatistics struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`

	AdvancedSequenceChecking *TrafficAdvancedSequenceChecking `json:"advancedSequenceChecking,omitempty"`

	CpdpConvergence *TrafficCpdpConvergence `json:"cpdpConvergence,omitempty"`

	DataIntegrity *TrafficDataIntegrity `json:"dataIntegrity,omitempty"`

	DelayVariation *TrafficDelayVariation `json:"delayVariation,omitempty"`

	ErrorStats *TrafficErrorStats `json:"errorStats,omitempty"`

	InterArrivalTimeRate *TrafficInterArrivalTimeRate `json:"interArrivalTimeRate,omitempty"`

	Iptv *TrafficIptv `json:"iptv,omitempty"`

	L1Rates *TrafficL1Rates `json:"l1Rates,omitempty"`

	Latency *TrafficLatency `json:"latency,omitempty"`

	MisdirectedPerFlow *TrafficMisdirectedPerFlow `json:"misdirectedPerFlow,omitempty"`

	MultipleJoinLeaveLatency *TrafficMultipleJoinLeaveLatency `json:"multipleJoinLeaveLatency,omitempty"`

	OneTimeJoinLeaveLatency *TrafficOneTimeJoinLeaveLatency `json:"oneTimeJoinLeaveLatency,omitempty"`

	PacketLossDuration *TrafficPacketLossDuration `json:"packetLossDuration,omitempty"`

	Prbs *TrafficPrbs `json:"prbs,omitempty"`

	SequenceChecking *TrafficSequenceChecking `json:"sequenceChecking,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficStatistics) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficStatistics) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficStatistics) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficStatistics) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.AdvancedSequenceChecking.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "advancedSequenceChecking",
	})
	n.CpdpConvergence.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "cpdpConvergence",
	})
	n.DataIntegrity.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dataIntegrity",
	})
	n.DelayVariation.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "delayVariation",
	})
	n.ErrorStats.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "errorStats",
	})
	n.InterArrivalTimeRate.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "interArrivalTimeRate",
	})
	n.Iptv.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "iptv",
	})
	n.L1Rates.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "l1Rates",
	})
	n.Latency.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "latency",
	})
	n.MisdirectedPerFlow.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "misdirectedPerFlow",
	})
	n.MultipleJoinLeaveLatency.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "multipleJoinLeaveLatency",
	})
	n.OneTimeJoinLeaveLatency.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "oneTimeJoinLeaveLatency",
	})
	n.PacketLossDuration.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "packetLossDuration",
	})
	n.Prbs.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "prbs",
	})
	n.SequenceChecking.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "sequenceChecking",
	})
}

// TrafficString: TBD
type TrafficString struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Value: Parameter string value.

	Value *string `json:"value,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficString) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficString) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficString) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficString) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficTableUdf: TBD
type TrafficTableUdf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Enabled: TBD

	Enabled *bool            `json:"enabled,omitempty"`
	Column  []*TrafficColumn `json:"column"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficTableUdf) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficTableUdf) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficTableUdf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficTableUdf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Column {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "column",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficTracking: TBD
type TrafficTracking struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// FieldWidth: TBD

	FieldWidth *string `json:"fieldWidth,omitempty"`
	// Offset: TBD

	Offset *float32 `json:"offset,omitempty"`
	// OneToOneMesh: TBD

	OneToOneMesh *bool `json:"oneToOneMesh,omitempty"`
	// ProtocolOffset: TBD

	ProtocolOffset *string `json:"protocolOffset,omitempty"`
	// TrackBy: TBD
	TrackBy []string `json:"trackBy"`
	// Values: TBD
	Values []string `json:"values"`

	Egress *TrafficEgress `json:"egress,omitempty"`

	LatencyBin *TrafficLatencyBin `json:"latencyBin,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficTracking) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficTracking) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficTracking) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficTracking) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Egress.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "egress",
	})
	n.LatencyBin.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "latencyBin",
	})
}

// TrafficTrafficItem: TBD
type TrafficTrafficItem struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// AllowSelfDestined: TBD

	AllowSelfDestined *bool `json:"allowSelfDestined,omitempty"`
	// BiDirectional: TBD

	BiDirectional *bool `json:"biDirectional,omitempty"`
	// EgressEnabled: TBD

	EgressEnabled *bool `json:"egressEnabled,omitempty"`
	// EnableDynamicMplsLabelValues: TBD

	EnableDynamicMplsLabelValues *bool `json:"enableDynamicMplsLabelValues,omitempty"`
	// EnableMacsecEgressOnlyAutoConfig: TBD

	EnableMacsecEgressOnlyAutoConfig *bool `json:"enableMacsecEgressOnlyAutoConfig,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// FrerDuplicateElimination: TBD

	FrerDuplicateElimination *bool `json:"frerDuplicateElimination,omitempty"`
	// HasOpenFlow: TBD

	HasOpenFlow *bool `json:"hasOpenFlow,omitempty"`
	// HostsPerNetwork: TBD

	HostsPerNetwork *float32 `json:"hostsPerNetwork,omitempty"`
	// InterAsBgpPreference: This attribute is deprecated. Use labelPreferences attribute instead.

	InterAsBgpPreference *string `json:"interAsBgpPreference,omitempty"`
	// InterAsLdpPreference: This attribute is deprecated. Use labelPreferences attribute instead.

	InterAsLdpPreference *string `json:"interAsLdpPreference,omitempty"`
	// LabelPreferences: List of label preferences per Label Category defined as List[Label Category, Label Category input type, List of Label Providers in the preferred order]
	LabelPreferences []map[string]interface{} `json:"labelPreferences,omitempty"`
	// MaxNumberOfVpnLabelStack: TBD

	MaxNumberOfVpnLabelStack *float32 `json:"maxNumberOfVpnLabelStack,omitempty"`
	// MergeDestinations: TBD

	MergeDestinations *bool `json:"mergeDestinations,omitempty"`
	// MulticastForwardingMode: TBD

	MulticastForwardingMode *string `json:"multicastForwardingMode,omitempty"`
	// Name: TBD

	Name *string `json:"name,omitempty"`
	// NumVlansForMulticastReplication: TBD

	NumVlansForMulticastReplication *float32 `json:"numVlansForMulticastReplication,omitempty"`
	// OrdinalNo: TBD

	OrdinalNo *float32 `json:"ordinalNo,omitempty"`
	// OriginatorType: TBD

	OriginatorType *string `json:"originatorType,omitempty"`
	// RoundRobinPacketOrdering: TBD

	RoundRobinPacketOrdering *bool `json:"roundRobinPacketOrdering,omitempty"`
	// RouteMesh: TBD

	RouteMesh *string `json:"routeMesh,omitempty"`
	// SrcDestMesh: TBD

	SrcDestMesh *string `json:"srcDestMesh,omitempty"`
	// Suspend: TBD

	Suspend *bool `json:"suspend,omitempty"`
	// TrafficItemType: TBD

	TrafficItemType *string `json:"trafficItemType,omitempty"`
	// TrafficType: TBD

	TrafficType *string `json:"trafficType,omitempty"`
	// TransmitMode: TBD

	TransmitMode *string `json:"transmitMode,omitempty"`
	// TransportLdpPreference: This attribute is deprecated. Use labelPreferences attribute instead.

	TransportLdpPreference *string `json:"transportLdpPreference,omitempty"`
	// TransportRsvpTePreference: This attribute is deprecated. Use labelPreferences attribute instead.

	TransportRsvpTePreference *string `json:"transportRsvpTePreference,omitempty"`
	// UseControlPlaneFrameSize: TBD

	UseControlPlaneFrameSize *bool `json:"useControlPlaneFrameSize,omitempty"`
	// UseControlPlaneRate: TBD

	UseControlPlaneRate      *bool                              `json:"useControlPlaneRate,omitempty"`
	AppLibProfile            []*TrafficAppLibProfile            `json:"appLibProfile"`
	ConfigElement            []*TrafficConfigElement            `json:"configElement"`
	DynamicUpdate            []*TrafficDynamicUpdate            `json:"dynamicUpdate"`
	EgressTracking           []*TrafficEgressTracking           `json:"egressTracking"`
	EndpointSet              []*TrafficEndpointSet              `json:"endpointSet"`
	HighLevelStream          []*TrafficHighLevelStream          `json:"highLevelStream"`
	Tracking                 []*TrafficTracking                 `json:"tracking"`
	TransmissionDistribution []*TrafficTransmissionDistribution `json:"transmissionDistribution"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficTrafficItem) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficTrafficItem) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficTrafficItem) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficTrafficItem) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.AppLibProfile {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "appLibProfile",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ConfigElement {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "configElement",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.DynamicUpdate {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "dynamicUpdate",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EgressTracking {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "egressTracking",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.EndpointSet {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "endpointSet",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.HighLevelStream {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "highLevelStream",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Tracking {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tracking",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.TransmissionDistribution {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "transmissionDistribution",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficTransmissionControl: TBD
type TrafficTransmissionControl struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// BurstPacketCount: TBD

	BurstPacketCount *float32 `json:"burstPacketCount,omitempty"`
	// Duration: TBD

	Duration *float32 `json:"duration,omitempty"`
	// EnableInterBurstGap: TBD

	EnableInterBurstGap *bool `json:"enableInterBurstGap,omitempty"`
	// EnableInterStreamGap: TBD

	EnableInterStreamGap *bool `json:"enableInterStreamGap,omitempty"`
	// FrameCount: TBD

	FrameCount *float32 `json:"frameCount,omitempty"`
	// InterBurstGap: TBD

	InterBurstGap *float32 `json:"interBurstGap,omitempty"`
	// InterBurstGapUnits: TBD

	InterBurstGapUnits *string `json:"interBurstGapUnits,omitempty"`
	// InterStreamGap: TBD

	InterStreamGap *float32 `json:"interStreamGap,omitempty"`
	// IterationCount: TBD

	IterationCount *float32 `json:"iterationCount,omitempty"`
	// MinGapBytes: TBD

	MinGapBytes *float32 `json:"minGapBytes,omitempty"`
	// RepeatBurst: TBD

	RepeatBurst *float32 `json:"repeatBurst,omitempty"`
	// StartDelay: TBD

	StartDelay *float32 `json:"startDelay,omitempty"`
	// StartDelayUnits: TBD

	StartDelayUnits *string `json:"startDelayUnits,omitempty"`
	// Type_: TBD

	Type_ *string `json:"type,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficTransmissionControl) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficTransmissionControl) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficTransmissionControl) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficTransmissionControl) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficTransmissionDistribution: TBD
type TrafficTransmissionDistribution struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Distributions: TBD
	Distributions []string `json:"distributions"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficTransmissionDistribution) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficTransmissionDistribution) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficTransmissionDistribution) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficTransmissionDistribution) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// TrafficUdf: TBD
type TrafficUdf struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ByteOffset: TBD

	ByteOffset *float32 `json:"byteOffset,omitempty"`
	// ChainedFromUdf: TBD

	ChainedFromUdf *string `json:"chainedFromUdf,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// Type_: TBD

	Type_         *string                 `json:"type,omitempty"`
	Counter       []*TrafficCounter       `json:"counter"`
	Ipv4          []*TrafficIpv4          `json:"ipv4"`
	NestedCounter []*TrafficNestedCounter `json:"nestedCounter"`
	Random        []*TrafficRandom        `json:"random"`
	RangeList     []*TrafficRangeList     `json:"rangeList"`
	ValueList     []*TrafficValueList     `json:"valueList"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficUdf) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficUdf) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficUdf) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficUdf) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Counter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "counter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Ipv4 {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "ipv4",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.NestedCounter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "nestedCounter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.Random {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "random",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.RangeList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "rangeList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
	for i, o := range n.ValueList {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "valueList",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// TrafficValueList: TBD
type TrafficValueList struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// StartValueList: TBD
	StartValueList []float32 `json:"startValueList"`
	// Width: TBD

	Width *string `json:"width,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *TrafficValueList) XPath() *XPath {
	return n.Xpath
}

func (n *TrafficValueList) setRestID(id string) {
	n.RestID = id
}

func (n *TrafficValueList) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *TrafficValueList) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// Vport: TBD
type Vport struct {
	// Xpath: If the resource identified by the xpath exists it will be updated otherwise a new resource will be created

	Xpath *XPath `json:"xpath,omitempty"`
	// ConnectedTo: TBD

	ConnectedTo *string `json:"connectedTo,omitempty"`
	// ConnectedToRefs: Track refs for ConnectedTo.
	ConnectedToRefs []Href `json:"-"`
	// IsPullOnly: TBD

	IsPullOnly *bool `json:"isPullOnly,omitempty"`
	// Location: The current format is {chassisIp}/{frontPanelPort}.{fanoutPort}

	Location *string `json:"location,omitempty"`
	// Name: TBD

	Name *string `json:"name,omitempty"`

	ProtocolStack *VportProtocolStack `json:"protocolStack,omitempty"`
	// RxMode: TBD

	RxMode *string `json:"rxMode,omitempty"`
	// TraceEnabled: Enables/Disables rpf port trace for this port

	TraceEnabled *bool `json:"traceEnabled,omitempty"`
	// TraceLevel: PCPU Trace level

	TraceLevel *string `json:"traceLevel,omitempty"`
	// TraceTag: PCPU Trace Tag

	TraceTag *string `json:"traceTag,omitempty"`
	// TransmitIgnoreLinkStatus: TBD

	TransmitIgnoreLinkStatus *bool `json:"transmitIgnoreLinkStatus,omitempty"`
	// TxGapControlMode: TBD

	TxGapControlMode *string `json:"txGapControlMode,omitempty"`
	// TxMode: TBD

	TxMode *string `json:"txMode,omitempty"`
	// Type_: TBD

	Type_ *string `json:"type,omitempty"`
	// UseGlobalSettings: Enables/Disables use of global settings instead of local settings on port

	UseGlobalSettings *bool `json:"useGlobalSettings,omitempty"`

	Capture *VportCapture `json:"capture,omitempty"`

	L1Config    *VportL1Config      `json:"l1Config,omitempty"`
	TapSettings []*VportTapSettings `json:"tapSettings"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *Vport) XPath() *XPath {
	return n.Xpath
}

func (n *Vport) setRestID(id string) {
	n.RestID = id
}

func (n *Vport) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *Vport) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.ProtocolStack.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "protocolStack",
	})
	n.Capture.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "capture",
	})
	n.L1Config.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "l1Config",
	})
	for i, o := range n.TapSettings {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "tapSettings",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// VportAresOneFourHundredGigLan: TBD
type VportAresOneFourHundredGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AlignmentMarker: TBD

	AlignmentMarker *string `json:"alignmentMarker,omitempty"`
	// AutoCTLEAdjustment: TBD

	AutoCTLEAdjustment *bool `json:"autoCTLEAdjustment,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// BadBlocksNumber: TBD

	BadBlocksNumber *float32 `json:"badBlocksNumber,omitempty"`
	// EnableAutoNegotiation: TBD

	EnableAutoNegotiation *bool `json:"enableAutoNegotiation,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnableRsFec: TBD

	EnableRsFec *bool `json:"enableRsFec,omitempty"`
	// EnableRsFecStats: TBD

	EnableRsFecStats *bool `json:"enableRsFecStats,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FirecodeAdvertise: TBD

	FirecodeAdvertise *bool `json:"firecodeAdvertise,omitempty"`
	// FirecodeForceOff: TBD

	FirecodeForceOff *bool `json:"firecodeForceOff,omitempty"`
	// FirecodeForceOn: TBD

	FirecodeForceOn *bool `json:"firecodeForceOn,omitempty"`
	// FirecodeRequest: TBD

	FirecodeRequest *bool `json:"firecodeRequest,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// ForceDisableFEC: TBD

	ForceDisableFEC *bool `json:"forceDisableFEC,omitempty"`
	// GoodBlocksNumber: TBD

	GoodBlocksNumber *float32 `json:"goodBlocksNumber,omitempty"`
	// LaserOn: TBD

	LaserOn *bool `json:"laserOn,omitempty"`
	// LinkTraining: TBD

	LinkTraining *bool `json:"linkTraining,omitempty"`
	// LoopContinuously: TBD

	LoopContinuously *bool `json:"loopContinuously,omitempty"`
	// LoopCountNumber: TBD

	LoopCountNumber *float32 `json:"loopCountNumber,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// LoopbackMode: TBD

	LoopbackMode *string `json:"loopbackMode,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// RsFecAdvertise: TBD

	RsFecAdvertise *bool `json:"rsFecAdvertise,omitempty"`
	// RsFecForceOn: TBD

	RsFecForceOn *bool `json:"rsFecForceOn,omitempty"`
	// RsFecRequest: TBD

	RsFecRequest *bool `json:"rsFecRequest,omitempty"`
	// SendSetsMode: TBD

	SendSetsMode *string `json:"sendSetsMode,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// StartErrorInsertion: TBD

	StartErrorInsertion *bool `json:"startErrorInsertion,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`
	// TypeAOrderedSets: TBD

	TypeAOrderedSets *string `json:"typeAOrderedSets,omitempty"`
	// TypeBOrderedSets: TBD

	TypeBOrderedSets *string `json:"typeBOrderedSets,omitempty"`
	// UseANResults: TBD

	UseANResults *bool `json:"useANResults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportAresOneFourHundredGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportAresOneFourHundredGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportAresOneFourHundredGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportAresOneFourHundredGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
}

// VportAtlasFourHundredGigLan: TBD
type VportAtlasFourHundredGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// BadBlocksNumber: TBD

	BadBlocksNumber *float32 `json:"badBlocksNumber,omitempty"`
	// EnableAutoNegotiation: TBD

	EnableAutoNegotiation *bool `json:"enableAutoNegotiation,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnableRsFec: TBD

	EnableRsFec *bool `json:"enableRsFec,omitempty"`
	// EnableRsFecStats: TBD

	EnableRsFecStats *bool `json:"enableRsFecStats,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FirecodeAdvertise: TBD

	FirecodeAdvertise *bool `json:"firecodeAdvertise,omitempty"`
	// FirecodeForceOff: TBD

	FirecodeForceOff *bool `json:"firecodeForceOff,omitempty"`
	// FirecodeForceOn: TBD

	FirecodeForceOn *bool `json:"firecodeForceOn,omitempty"`
	// FirecodeRequest: TBD

	FirecodeRequest *bool `json:"firecodeRequest,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// ForceDisableFEC: TBD

	ForceDisableFEC *bool `json:"forceDisableFEC,omitempty"`
	// GoodBlocksNumber: TBD

	GoodBlocksNumber *float32 `json:"goodBlocksNumber,omitempty"`
	// LaserOn: TBD

	LaserOn *bool `json:"laserOn,omitempty"`
	// LinkTraining: TBD

	LinkTraining *bool `json:"linkTraining,omitempty"`
	// LoopContinuously: TBD

	LoopContinuously *bool `json:"loopContinuously,omitempty"`
	// LoopCountNumber: TBD

	LoopCountNumber *float32 `json:"loopCountNumber,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// LoopbackMode: TBD

	LoopbackMode *string `json:"loopbackMode,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// RsFecAdvertise: TBD

	RsFecAdvertise *bool `json:"rsFecAdvertise,omitempty"`
	// RsFecForceOn: TBD

	RsFecForceOn *bool `json:"rsFecForceOn,omitempty"`
	// RsFecRequest: TBD

	RsFecRequest *bool `json:"rsFecRequest,omitempty"`
	// SendSetsMode: TBD

	SendSetsMode *string `json:"sendSetsMode,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// StartErrorInsertion: TBD

	StartErrorInsertion *bool `json:"startErrorInsertion,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`
	// TypeAOrderedSets: TBD

	TypeAOrderedSets *string `json:"typeAOrderedSets,omitempty"`
	// TypeBOrderedSets: TBD

	TypeBOrderedSets *string `json:"typeBOrderedSets,omitempty"`
	// UseANResults: TBD

	UseANResults *bool `json:"useANResults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportAtlasFourHundredGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportAtlasFourHundredGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportAtlasFourHundredGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportAtlasFourHundredGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
}

// VportAtm: TBD
type VportAtm struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// C2Expected: TBD

	C2Expected *float32 `json:"c2Expected,omitempty"`
	// C2Tx: TBD

	C2Tx *float32 `json:"c2Tx,omitempty"`
	// CellHeader: TBD

	CellHeader *string `json:"cellHeader,omitempty"`
	// CosetActive: TBD

	CosetActive *bool `json:"cosetActive,omitempty"`
	// CrcSize: TBD

	CrcSize *string `json:"crcSize,omitempty"`
	// DataScrambling: TBD

	DataScrambling *bool `json:"dataScrambling,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// FillerCell: TBD

	FillerCell *string `json:"fillerCell,omitempty"`
	// InterfaceType: TBD

	InterfaceType *string `json:"interfaceType,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// PatternMatching: TBD

	PatternMatching *bool `json:"patternMatching,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// ReassemblyTimeout: TBD

	ReassemblyTimeout *float32 `json:"reassemblyTimeout,omitempty"`
	// TransmitClocking: TBD

	TransmitClocking *string `json:"transmitClocking,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportAtm) XPath() *XPath {
	return n.Xpath
}

func (n *VportAtm) setRestID(id string) {
	n.RestID = id
}

func (n *VportAtm) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportAtm) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportCapture: TBD
type VportCapture struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AfterTriggerFilter: TBD

	AfterTriggerFilter *string `json:"afterTriggerFilter,omitempty"`
	// BeforeTriggerFilter: TBD

	BeforeTriggerFilter *string `json:"beforeTriggerFilter,omitempty"`
	// CaptureMode: TBD

	CaptureMode *string `json:"captureMode,omitempty"`
	// ContinuousFilters: TBD

	ContinuousFilters *string `json:"continuousFilters,omitempty"`
	// ControlActiveCapture: TBD

	ControlActiveCapture *string `json:"controlActiveCapture,omitempty"`
	// ControlBufferBehaviour: TBD

	ControlBufferBehaviour *string `json:"controlBufferBehaviour,omitempty"`
	// ControlBufferSize: TBD

	ControlBufferSize *float32 `json:"controlBufferSize,omitempty"`
	// ControlCaptureFilter: TBD

	ControlCaptureFilter *string `json:"controlCaptureFilter,omitempty"`
	// ControlCaptureTrigger: TBD

	ControlCaptureTrigger *string `json:"controlCaptureTrigger,omitempty"`
	// ControlInterfaceType: TBD

	ControlInterfaceType *string `json:"controlInterfaceType,omitempty"`
	// ControlSliceSize: TBD

	ControlSliceSize *float32 `json:"controlSliceSize,omitempty"`
	// DataActiveCapture: TBD

	DataActiveCapture *string `json:"dataActiveCapture,omitempty"`
	// DataReceiveTimestamp: TBD

	DataReceiveTimestamp *string `json:"dataReceiveTimestamp,omitempty"`
	// DisplayFiltersControlCapture: TBD

	DisplayFiltersControlCapture *string `json:"displayFiltersControlCapture,omitempty"`
	// DisplayFiltersDataCapture: TBD

	DisplayFiltersDataCapture *string `json:"displayFiltersDataCapture,omitempty"`
	// HardwareEnabled: TBD

	HardwareEnabled *bool `json:"hardwareEnabled,omitempty"`
	// SliceSize: TBD

	SliceSize *float32 `json:"sliceSize,omitempty"`
	// SoftwareEnabled: TBD

	SoftwareEnabled *bool `json:"softwareEnabled,omitempty"`
	// TriggerPosition: TBD

	TriggerPosition *float32 `json:"triggerPosition,omitempty"`

	CurrentPacket *VportCurrentPacket `json:"currentPacket,omitempty"`

	Filter *VportFilter `json:"filter,omitempty"`

	FilterPallette *VportFilterPallette `json:"filterPallette,omitempty"`

	Trigger *VportTrigger `json:"trigger,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportCapture) XPath() *XPath {
	return n.Xpath
}

func (n *VportCapture) setRestID(id string) {
	n.RestID = id
}

func (n *VportCapture) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportCapture) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.CurrentPacket.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "currentPacket",
	})
	n.Filter.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "filter",
	})
	n.FilterPallette.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "filterPallette",
	})
	n.Trigger.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "trigger",
	})
}

// VportCurrentPacket: TBD
type VportCurrentPacket struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath        `json:"xpath,omitempty"`
	Stack []*VportStack `json:"stack"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportCurrentPacket) XPath() *XPath {
	return n.Xpath
}

func (n *VportCurrentPacket) setRestID(id string) {
	n.RestID = id
}

func (n *VportCurrentPacket) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportCurrentPacket) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Stack {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "stack",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// VportDcc: TBD
type VportDcc struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// Crc: TBD

	Crc *string `json:"crc,omitempty"`
	// OverheadByte: TBD

	OverheadByte *string `json:"overheadByte,omitempty"`
	// TimeFill: TBD

	TimeFill *string `json:"timeFill,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportDcc) XPath() *XPath {
	return n.Xpath
}

func (n *VportDcc) setRestID(id string) {
	n.RestID = id
}

func (n *VportDcc) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportDcc) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportEthernet: TBD
type VportEthernet struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// AutoNegotiate: TBD

	AutoNegotiate *bool `json:"autoNegotiate,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// MasterSlaveMode: TBD

	MasterSlaveMode *string `json:"masterSlaveMode,omitempty"`
	// Media: TBD

	Media *string `json:"media,omitempty"`
	// NegotiateMasterSlave: TBD

	NegotiateMasterSlave *bool `json:"negotiateMasterSlave,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// SpeedAuto: TBD
	SpeedAuto []string `json:"speedAuto"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	Oam *VportOam `json:"oam,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportEthernet) XPath() *XPath {
	return n.Xpath
}

func (n *VportEthernet) setRestID(id string) {
	n.RestID = id
}

func (n *VportEthernet) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportEthernet) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.Oam.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "oam",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportEthernetImpairment: TBD
type VportEthernetImpairment struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportEthernetImpairment) XPath() *XPath {
	return n.Xpath
}

func (n *VportEthernetImpairment) setRestID(id string) {
	n.RestID = id
}

func (n *VportEthernetImpairment) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportEthernetImpairment) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportEthernetvm: TBD
type VportEthernetvm struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// Mtu: TBD

	Mtu *float32 `json:"mtu,omitempty"`
	// PromiscuousMode: TBD

	PromiscuousMode *bool `json:"promiscuousMode,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportEthernetvm) XPath() *XPath {
	return n.Xpath
}

func (n *VportEthernetvm) setRestID(id string) {
	n.RestID = id
}

func (n *VportEthernetvm) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportEthernetvm) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportFc: TBD
type VportFc struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CreditStarvationValue: TBD

	CreditStarvationValue *float32 `json:"creditStarvationValue,omitempty"`
	// EnableEmissionLoweringProtocol: TBD

	EnableEmissionLoweringProtocol *bool `json:"enableEmissionLoweringProtocol,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// FixedDelayValue: TBD

	FixedDelayValue *float32 `json:"fixedDelayValue,omitempty"`
	// ForceErrors: TBD

	ForceErrors *string `json:"forceErrors,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// MaxDelayForRandomValue: TBD

	MaxDelayForRandomValue *float32 `json:"maxDelayForRandomValue,omitempty"`
	// MinDelayForRandomValue: TBD

	MinDelayForRandomValue *float32 `json:"minDelayForRandomValue,omitempty"`
	// NoRRDYAfter: TBD

	NoRRDYAfter *float32 `json:"noRRDYAfter,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// RrdyResponseDelays: TBD

	RrdyResponseDelays *string `json:"rrdyResponseDelays,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// TxIgnoreAvailableCredits: TBD

	TxIgnoreAvailableCredits *bool `json:"txIgnoreAvailableCredits,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportFc) XPath() *XPath {
	return n.Xpath
}

func (n *VportFc) setRestID(id string) {
	n.RestID = id
}

func (n *VportFc) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportFc) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportFcoe: TBD
type VportFcoe struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnablePFCPauseDelay: TBD

	EnablePFCPauseDelay *bool `json:"enablePFCPauseDelay,omitempty"`
	// FlowControlType: TBD

	FlowControlType *string `json:"flowControlType,omitempty"`
	// PfcPauseDelay: TBD

	PfcPauseDelay *float32 `json:"pfcPauseDelay,omitempty"`
	// PfcPriorityGroups: TBD
	PfcPriorityGroups []string `json:"pfcPriorityGroups"`
	// PriorityGroupSize: TBD

	PriorityGroupSize *string `json:"priorityGroupSize,omitempty"`
	// SupportDataCenterMode: TBD

	SupportDataCenterMode *bool `json:"supportDataCenterMode,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportFcoe) XPath() *XPath {
	return n.Xpath
}

func (n *VportFcoe) setRestID(id string) {
	n.RestID = id
}

func (n *VportFcoe) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportFcoe) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportField: TBD
type VportField struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportField) XPath() *XPath {
	return n.Xpath
}

func (n *VportField) setRestID(id string) {
	n.RestID = id
}

func (n *VportField) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportField) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportFilter: TBD
type VportFilter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CaptureFilterDA: TBD

	CaptureFilterDA *string `json:"captureFilterDA,omitempty"`
	// CaptureFilterEnable: TBD

	CaptureFilterEnable *bool `json:"captureFilterEnable,omitempty"`
	// CaptureFilterError: TBD

	CaptureFilterError *string `json:"captureFilterError,omitempty"`
	// CaptureFilterExpressionString: TBD

	CaptureFilterExpressionString *string `json:"captureFilterExpressionString,omitempty"`
	// CaptureFilterFrameSizeEnable: TBD

	CaptureFilterFrameSizeEnable *bool `json:"captureFilterFrameSizeEnable,omitempty"`
	// CaptureFilterFrameSizeFrom: TBD

	CaptureFilterFrameSizeFrom *float32 `json:"captureFilterFrameSizeFrom,omitempty"`
	// CaptureFilterFrameSizeTo: TBD

	CaptureFilterFrameSizeTo *float32 `json:"captureFilterFrameSizeTo,omitempty"`
	// CaptureFilterPattern: TBD

	CaptureFilterPattern *string `json:"captureFilterPattern,omitempty"`
	// CaptureFilterSA: TBD

	CaptureFilterSA *string `json:"captureFilterSA,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportFilter) XPath() *XPath {
	return n.Xpath
}

func (n *VportFilter) setRestID(id string) {
	n.RestID = id
}

func (n *VportFilter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportFilter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportFilterPalette: TBD
type VportFilterPalette struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DestinationAddress1: TBD

	DestinationAddress1 *string `json:"destinationAddress1,omitempty"`
	// DestinationAddress1Mask: TBD

	DestinationAddress1Mask *string `json:"destinationAddress1Mask,omitempty"`
	// DestinationAddress2: TBD

	DestinationAddress2 *string `json:"destinationAddress2,omitempty"`
	// DestinationAddress2Mask: TBD

	DestinationAddress2Mask *string `json:"destinationAddress2Mask,omitempty"`
	// Pattern1: TBD

	Pattern1 *string `json:"pattern1,omitempty"`
	// Pattern1Mask: TBD

	Pattern1Mask *string `json:"pattern1Mask,omitempty"`
	// Pattern1Offset: TBD

	Pattern1Offset *float32 `json:"pattern1Offset,omitempty"`
	// Pattern1OffsetType: TBD

	Pattern1OffsetType *string `json:"pattern1OffsetType,omitempty"`
	// Pattern2: TBD

	Pattern2 *string `json:"pattern2,omitempty"`
	// Pattern2Mask: TBD

	Pattern2Mask *string `json:"pattern2Mask,omitempty"`
	// Pattern2Offset: TBD

	Pattern2Offset *float32 `json:"pattern2Offset,omitempty"`
	// Pattern2OffsetType: TBD

	Pattern2OffsetType *string `json:"pattern2OffsetType,omitempty"`
	// SourceAddress1: TBD

	SourceAddress1 *string `json:"sourceAddress1,omitempty"`
	// SourceAddress1Mask: TBD

	SourceAddress1Mask *string `json:"sourceAddress1Mask,omitempty"`
	// SourceAddress2: TBD

	SourceAddress2 *string `json:"sourceAddress2,omitempty"`
	// SourceAddress2Mask: TBD

	SourceAddress2Mask *string `json:"sourceAddress2Mask,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportFilterPalette) XPath() *XPath {
	return n.Xpath
}

func (n *VportFilterPalette) setRestID(id string) {
	n.RestID = id
}

func (n *VportFilterPalette) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportFilterPalette) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportFilterPallette: TBD
type VportFilterPallette struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// DA1: TBD

	DA1 *string `json:"DA1,omitempty"`
	// DA2: TBD

	DA2 *string `json:"DA2,omitempty"`
	// DAMask1: TBD

	DAMask1 *string `json:"DAMask1,omitempty"`
	// DAMask2: TBD

	DAMask2 *string `json:"DAMask2,omitempty"`
	// SA1: TBD

	SA1 *string `json:"SA1,omitempty"`
	// SA2: TBD

	SA2 *string `json:"SA2,omitempty"`
	// SAMask1: TBD

	SAMask1 *string `json:"SAMask1,omitempty"`
	// SAMask2: TBD

	SAMask2 *string `json:"SAMask2,omitempty"`
	// Pattern1: TBD

	Pattern1 *string `json:"pattern1,omitempty"`
	// Pattern2: TBD

	Pattern2 *string `json:"pattern2,omitempty"`
	// PatternMask1: TBD

	PatternMask1 *string `json:"patternMask1,omitempty"`
	// PatternMask2: TBD

	PatternMask2 *string `json:"patternMask2,omitempty"`
	// PatternOffset1: TBD

	PatternOffset1 *float32 `json:"patternOffset1,omitempty"`
	// PatternOffset2: TBD

	PatternOffset2 *float32 `json:"patternOffset2,omitempty"`
	// PatternOffsetType1: TBD

	PatternOffsetType1 *string `json:"patternOffsetType1,omitempty"`
	// PatternOffsetType2: TBD

	PatternOffsetType2 *string `json:"patternOffsetType2,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportFilterPallette) XPath() *XPath {
	return n.Xpath
}

func (n *VportFilterPallette) setRestID(id string) {
	n.RestID = id
}

func (n *VportFilterPallette) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportFilterPallette) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportFortyGigLan: TBD
type VportFortyGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// EnableLASIMonitoring: TBD

	EnableLASIMonitoring *bool `json:"enableLASIMonitoring,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// TransmitClocking: TBD

	TransmitClocking *string `json:"transmitClocking,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportFortyGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportFortyGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportFortyGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportFortyGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportFramePreemption: TBD
type VportFramePreemption struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsFramePreemptionEnabled: TBD

	IsFramePreemptionEnabled *bool `json:"isFramePreemptionEnabled,omitempty"`
	// IsSmdVREnabled: TBD

	IsSmdVREnabled *bool `json:"isSmdVREnabled,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportFramePreemption) XPath() *XPath {
	return n.Xpath
}

func (n *VportFramePreemption) setRestID(id string) {
	n.RestID = id
}

func (n *VportFramePreemption) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportFramePreemption) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportHundredGigLan: TBD
type VportHundredGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportHundredGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportHundredGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportHundredGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportHundredGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportKrakenFourHundredGigLan: TBD
type VportKrakenFourHundredGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// BadBlocksNumber: TBD

	BadBlocksNumber *float32 `json:"badBlocksNumber,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnableRsFec: TBD

	EnableRsFec *bool `json:"enableRsFec,omitempty"`
	// EnableRsFecStats: TBD

	EnableRsFecStats *bool `json:"enableRsFecStats,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FirecodeAdvertise: TBD

	FirecodeAdvertise *bool `json:"firecodeAdvertise,omitempty"`
	// FirecodeForceOff: TBD

	FirecodeForceOff *bool `json:"firecodeForceOff,omitempty"`
	// FirecodeForceOn: TBD

	FirecodeForceOn *bool `json:"firecodeForceOn,omitempty"`
	// FirecodeRequest: TBD

	FirecodeRequest *bool `json:"firecodeRequest,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// ForceDisableFEC: TBD

	ForceDisableFEC *bool `json:"forceDisableFEC,omitempty"`
	// GoodBlocksNumber: TBD

	GoodBlocksNumber *float32 `json:"goodBlocksNumber,omitempty"`
	// LaserOn: TBD

	LaserOn *bool `json:"laserOn,omitempty"`
	// LoopContinuously: TBD

	LoopContinuously *bool `json:"loopContinuously,omitempty"`
	// LoopCountNumber: TBD

	LoopCountNumber *float32 `json:"loopCountNumber,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// LoopbackMode: TBD

	LoopbackMode *string `json:"loopbackMode,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// RsFecAdvertise: TBD

	RsFecAdvertise *bool `json:"rsFecAdvertise,omitempty"`
	// RsFecForceOn: TBD

	RsFecForceOn *bool `json:"rsFecForceOn,omitempty"`
	// RsFecRequest: TBD

	RsFecRequest *bool `json:"rsFecRequest,omitempty"`
	// SendSetsMode: TBD

	SendSetsMode *string `json:"sendSetsMode,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// StartErrorInsertion: TBD

	StartErrorInsertion *bool `json:"startErrorInsertion,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`
	// TypeAOrderedSets: TBD

	TypeAOrderedSets *string `json:"typeAOrderedSets,omitempty"`
	// TypeBOrderedSets: TBD

	TypeBOrderedSets *string `json:"typeBOrderedSets,omitempty"`
	// UseANResults: TBD

	UseANResults *bool `json:"useANResults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportKrakenFourHundredGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportKrakenFourHundredGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportKrakenFourHundredGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportKrakenFourHundredGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
}

// VportL1Config: TBD
type VportL1Config struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CurrentType: TBD

	CurrentType *string `json:"currentType,omitempty"`

	OAM *VportOam `json:"OAM,omitempty"`

	AresOneFourHundredGigLan *VportAresOneFourHundredGigLan `json:"aresOneFourHundredGigLan,omitempty"`

	AtlasFourHundredGigLan *VportAtlasFourHundredGigLan `json:"atlasFourHundredGigLan,omitempty"`

	Atm *VportAtm `json:"atm,omitempty"`

	Ethernet *VportEthernet `json:"ethernet,omitempty"`

	EthernetImpairment *VportEthernetImpairment `json:"ethernetImpairment,omitempty"`

	Ethernetvm *VportEthernetvm `json:"ethernetvm,omitempty"`

	Fc *VportFc `json:"fc,omitempty"`

	FortyGigLan *VportFortyGigLan `json:"fortyGigLan,omitempty"`

	FramePreemption *VportFramePreemption `json:"framePreemption,omitempty"`

	HundredGigLan *VportHundredGigLan `json:"hundredGigLan,omitempty"`

	KrakenFourHundredGigLan *VportKrakenFourHundredGigLan `json:"krakenFourHundredGigLan,omitempty"`

	NovusHundredGigLan *VportNovusHundredGigLan `json:"novusHundredGigLan,omitempty"`

	NovusTenGigLan *VportNovusTenGigLan `json:"novusTenGigLan,omitempty"`

	Pos *VportPos `json:"pos,omitempty"`

	RxFilters *VportRxFilters `json:"rxFilters,omitempty"`

	TenFortyHundredGigLan *VportTenFortyHundredGigLan `json:"tenFortyHundredGigLan,omitempty"`

	TenGigLan *VportTenGigLan `json:"tenGigLan,omitempty"`

	TenGigWan *VportTenGigWan `json:"tenGigWan,omitempty"`

	UhdOneHundredGigLan *VportUhdOneHundredGigLan `json:"uhdOneHundredGigLan,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportL1Config) XPath() *XPath {
	return n.Xpath
}

func (n *VportL1Config) setRestID(id string) {
	n.RestID = id
}

func (n *VportL1Config) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportL1Config) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.OAM.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "OAM",
	})
	n.AresOneFourHundredGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "aresOneFourHundredGigLan",
	})
	n.AtlasFourHundredGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "atlasFourHundredGigLan",
	})
	n.Atm.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "atm",
	})
	n.Ethernet.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ethernet",
	})
	n.EthernetImpairment.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ethernetImpairment",
	})
	n.Ethernetvm.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ethernetvm",
	})
	n.Fc.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fc",
	})
	n.FortyGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fortyGigLan",
	})
	n.FramePreemption.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "framePreemption",
	})
	n.HundredGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "hundredGigLan",
	})
	n.KrakenFourHundredGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "krakenFourHundredGigLan",
	})
	n.NovusHundredGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "novusHundredGigLan",
	})
	n.NovusTenGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "novusTenGigLan",
	})
	n.Pos.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "pos",
	})
	n.RxFilters.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "rxFilters",
	})
	n.TenFortyHundredGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "tenFortyHundredGigLan",
	})
	n.TenGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "tenGigLan",
	})
	n.TenGigWan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "tenGigWan",
	})
	n.UhdOneHundredGigLan.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "uhdOneHundredGigLan",
	})
}

// VportNovusHundredGigLan: TBD
type VportNovusHundredGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// BadBlocksNumber: TBD

	BadBlocksNumber *float32 `json:"badBlocksNumber,omitempty"`
	// EnableAutoNegotiation: TBD

	EnableAutoNegotiation *bool `json:"enableAutoNegotiation,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnableRsFec: TBD

	EnableRsFec *bool `json:"enableRsFec,omitempty"`
	// EnableRsFecStats: TBD

	EnableRsFecStats *bool `json:"enableRsFecStats,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FirecodeAdvertise: TBD

	FirecodeAdvertise *bool `json:"firecodeAdvertise,omitempty"`
	// FirecodeForceOff: TBD

	FirecodeForceOff *bool `json:"firecodeForceOff,omitempty"`
	// FirecodeForceOn: TBD

	FirecodeForceOn *bool `json:"firecodeForceOn,omitempty"`
	// FirecodeRequest: TBD

	FirecodeRequest *bool `json:"firecodeRequest,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// ForceDisableFEC: TBD

	ForceDisableFEC *bool `json:"forceDisableFEC,omitempty"`
	// GoodBlocksNumber: TBD

	GoodBlocksNumber *float32 `json:"goodBlocksNumber,omitempty"`
	// IeeeL1Defaults: TBD

	IeeeL1Defaults *bool `json:"ieeeL1Defaults,omitempty"`
	// LaserOn: TBD

	LaserOn *bool `json:"laserOn,omitempty"`
	// LoopContinuously: TBD

	LoopContinuously *bool `json:"loopContinuously,omitempty"`
	// LoopCountNumber: TBD

	LoopCountNumber *float32 `json:"loopCountNumber,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// LoopbackMode: TBD

	LoopbackMode *string `json:"loopbackMode,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// RsFecAdvertise: TBD

	RsFecAdvertise *bool `json:"rsFecAdvertise,omitempty"`
	// RsFecForceOn: TBD

	RsFecForceOn *bool `json:"rsFecForceOn,omitempty"`
	// RsFecRequest: TBD

	RsFecRequest *bool `json:"rsFecRequest,omitempty"`
	// SendSetsMode: TBD

	SendSetsMode *string `json:"sendSetsMode,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// StartErrorInsertion: TBD

	StartErrorInsertion *bool `json:"startErrorInsertion,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`
	// TypeAOrderedSets: TBD

	TypeAOrderedSets *string `json:"typeAOrderedSets,omitempty"`
	// TypeBOrderedSets: TBD

	TypeBOrderedSets *string `json:"typeBOrderedSets,omitempty"`
	// UseANResults: TBD

	UseANResults *bool `json:"useANResults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportNovusHundredGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportNovusHundredGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportNovusHundredGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportNovusHundredGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportNovusTenGigLan: TBD
type VportNovusTenGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// AutoNegotiate: TBD

	AutoNegotiate *bool `json:"autoNegotiate,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// LoopbackMode: TBD

	LoopbackMode *string `json:"loopbackMode,omitempty"`
	// MasterSlaveMode: TBD

	MasterSlaveMode *string `json:"masterSlaveMode,omitempty"`
	// Media: TBD

	Media *string `json:"media,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// SpeedAuto: TBD
	SpeedAuto []string `json:"speedAuto"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportNovusTenGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportNovusTenGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportNovusTenGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportNovusTenGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportOam: TBD
type VportOam struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// EnableTlvOption: TBD

	EnableTlvOption *bool `json:"enableTlvOption,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// IdleTimer: TBD

	IdleTimer *float32 `json:"idleTimer,omitempty"`
	// LinkEvents: TBD

	LinkEvents *bool `json:"linkEvents,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// MacAddress: TBD

	MacAddress *string `json:"macAddress,omitempty"`
	// MaxOAMPDUSize: TBD

	MaxOAMPDUSize *float32 `json:"maxOAMPDUSize,omitempty"`
	// OrganizationUniqueIdentifier: TBD

	OrganizationUniqueIdentifier *string `json:"organizationUniqueIdentifier,omitempty"`
	// TlvType: TBD

	TlvType *string `json:"tlvType,omitempty"`
	// TlvValue: TBD

	TlvValue *string `json:"tlvValue,omitempty"`
	// VendorSpecificInformation: TBD

	VendorSpecificInformation *string `json:"vendorSpecificInformation,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportOam) XPath() *XPath {
	return n.Xpath
}

func (n *VportOam) setRestID(id string) {
	n.RestID = id
}

func (n *VportOam) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportOam) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportParameter: TBD
type VportParameter struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CurrentValue: Parameter UI Display Value

	CurrentValue *string `json:"currentValue,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportParameter) XPath() *XPath {
	return n.Xpath
}

func (n *VportParameter) setRestID(id string) {
	n.RestID = id
}

func (n *VportParameter) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportParameter) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportPos: TBD
type VportPos struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// C2Expected: TBD

	C2Expected *float32 `json:"c2Expected,omitempty"`
	// C2Tx: TBD

	C2Tx *float32 `json:"c2Tx,omitempty"`
	// CrcSize: TBD

	CrcSize *string `json:"crcSize,omitempty"`
	// DataScrambling: TBD

	DataScrambling *bool `json:"dataScrambling,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// InterfaceType: TBD

	InterfaceType *string `json:"interfaceType,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// PayloadType: TBD

	PayloadType *string `json:"payloadType,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// TrafficMapType: TBD

	TrafficMapType *string `json:"trafficMapType,omitempty"`
	// TransmitClocking: TBD

	TransmitClocking *string `json:"transmitClocking,omitempty"`

	Dcc *VportDcc `json:"dcc,omitempty"`

	Ppp *VportPpp `json:"ppp,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportPos) XPath() *XPath {
	return n.Xpath
}

func (n *VportPos) setRestID(id string) {
	n.RestID = id
}

func (n *VportPos) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportPos) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Dcc.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "dcc",
	})
	n.Ppp.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "ppp",
	})
}

// VportPpp: TBD
type VportPpp struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// ConfigurationRetries: TBD

	ConfigurationRetries *float32 `json:"configurationRetries,omitempty"`
	// EnableAccmNegotiation: TBD

	EnableAccmNegotiation *bool `json:"enableAccmNegotiation,omitempty"`
	// EnableIpV4: TBD

	EnableIpV4 *bool `json:"enableIpV4,omitempty"`
	// EnableIpV6: TBD

	EnableIpV6 *bool `json:"enableIpV6,omitempty"`
	// EnableLqm: TBD

	EnableLqm *bool `json:"enableLqm,omitempty"`
	// EnableMpls: TBD

	EnableMpls *bool `json:"enableMpls,omitempty"`
	// EnableOsi: TBD

	EnableOsi *bool `json:"enableOsi,omitempty"`
	// Enabled: TBD

	Enabled *bool `json:"enabled,omitempty"`
	// LocalIpAddress: TBD

	LocalIpAddress *string `json:"localIpAddress,omitempty"`
	// LocalIpV6IdType: TBD

	LocalIpV6IdType *string `json:"localIpV6IdType,omitempty"`
	// LocalIpV6Iid: TBD

	LocalIpV6Iid *string `json:"localIpV6Iid,omitempty"`
	// LocalIpV6MacBasedIid: TBD

	LocalIpV6MacBasedIid *string `json:"localIpV6MacBasedIid,omitempty"`
	// LocalIpV6NegotiationMode: TBD

	LocalIpV6NegotiationMode *string `json:"localIpV6NegotiationMode,omitempty"`
	// LqmReportInterval: TBD

	LqmReportInterval *float32 `json:"lqmReportInterval,omitempty"`
	// PeerIpV6IdType: TBD

	PeerIpV6IdType *string `json:"peerIpV6IdType,omitempty"`
	// PeerIpV6Iid: TBD

	PeerIpV6Iid *string `json:"peerIpV6Iid,omitempty"`
	// PeerIpV6MacBasedIid: TBD

	PeerIpV6MacBasedIid *string `json:"peerIpV6MacBasedIid,omitempty"`
	// PeerIpV6NegotiationMode: TBD

	PeerIpV6NegotiationMode *string `json:"peerIpV6NegotiationMode,omitempty"`
	// RetryTimeout: TBD

	RetryTimeout *float32 `json:"retryTimeout,omitempty"`
	// RxAlignment: TBD

	RxAlignment *float32 `json:"rxAlignment,omitempty"`
	// RxMaxReceiveUnit: TBD

	RxMaxReceiveUnit *float32 `json:"rxMaxReceiveUnit,omitempty"`
	// TxAlignment: TBD

	TxAlignment *float32 `json:"txAlignment,omitempty"`
	// TxMaxReceiveUnit: TBD

	TxMaxReceiveUnit *float32 `json:"txMaxReceiveUnit,omitempty"`
	// UseMagicNumber: TBD

	UseMagicNumber *bool `json:"useMagicNumber,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportPpp) XPath() *XPath {
	return n.Xpath
}

func (n *VportPpp) setRestID(id string) {
	n.RestID = id
}

func (n *VportPpp) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportPpp) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportProtocolStack: VPort protocol stack configuration
type VportProtocolStack struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`

	Options *VportProtocolStackOptions `json:"options,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportProtocolStack) XPath() *XPath {
	return n.Xpath
}

func (n *VportProtocolStack) setRestID(id string) {
	n.RestID = id
}

func (n *VportProtocolStack) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportProtocolStack) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Options.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "options",
	})
}

// VportProtocolStackOptions: VPort protocol stack options
type VportProtocolStackOptions struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// McastSolicit: Number of Neighbor Solicitations to send until giving up on link layer address resolution

	McastSolicit *float32 `json:"mcast_solicit,omitempty"`

	RetransTime *float32 `json:"retransTime,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportProtocolStackOptions) XPath() *XPath {
	return n.Xpath
}

func (n *VportProtocolStackOptions) setRestID(id string) {
	n.RestID = id
}

func (n *VportProtocolStackOptions) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportProtocolStackOptions) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportRxFilters: TBD
type VportRxFilters struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`

	FilterPalette *VportFilterPalette `json:"filterPalette,omitempty"`
	Uds           []*VportUds         `json:"uds"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportRxFilters) XPath() *XPath {
	return n.Xpath
}

func (n *VportRxFilters) setRestID(id string) {
	n.RestID = id
}

func (n *VportRxFilters) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportRxFilters) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.FilterPalette.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "filterPalette",
	})
	for i, o := range n.Uds {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "uds",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// VportStack: TBD
type VportStack struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath        `json:"xpath,omitempty"`
	Field []*VportField `json:"field"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportStack) XPath() *XPath {
	return n.Xpath
}

func (n *VportStack) setRestID(id string) {
	n.RestID = id
}

func (n *VportStack) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportStack) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Field {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "field",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// VportTapSettings: TBD
type VportTapSettings struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath     *XPath            `json:"xpath,omitempty"`
	Parameter []*VportParameter `json:"parameter"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportTapSettings) XPath() *XPath {
	return n.Xpath
}

func (n *VportTapSettings) setRestID(id string) {
	n.RestID = id
}

func (n *VportTapSettings) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportTapSettings) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	for i, o := range n.Parameter {
		alias := ""
		if o.Xpath != nil {
			alias = o.Xpath.alias
		}
		o.updateXPaths(&XPath{
			parentXPath: xPath.String(),
			objectName:  "parameter",
			alias:       alias,
			index:       uint64(i + 1),
		})
	}
}

// VportTenFortyHundredGigLan: TBD
type VportTenFortyHundredGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// BadBlocksNumber: TBD

	BadBlocksNumber *float32 `json:"badBlocksNumber,omitempty"`
	// EnableAutoNegotiation: TBD

	EnableAutoNegotiation *bool `json:"enableAutoNegotiation,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnableRsFec: TBD

	EnableRsFec *bool `json:"enableRsFec,omitempty"`
	// EnableRsFecStats: TBD

	EnableRsFecStats *bool `json:"enableRsFecStats,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// GoodBlocksNumber: TBD

	GoodBlocksNumber *float32 `json:"goodBlocksNumber,omitempty"`
	// IeeeL1Defaults: TBD

	IeeeL1Defaults *bool `json:"ieeeL1Defaults,omitempty"`
	// LaserOn: TBD

	LaserOn *bool `json:"laserOn,omitempty"`
	// LinkTraining: TBD

	LinkTraining *bool `json:"linkTraining,omitempty"`
	// LoopContinuously: TBD

	LoopContinuously *bool `json:"loopContinuously,omitempty"`
	// LoopCountNumber: TBD

	LoopCountNumber *float32 `json:"loopCountNumber,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// LoopbackMode: TBD

	LoopbackMode *string `json:"loopbackMode,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// SendSetsMode: TBD

	SendSetsMode *string `json:"sendSetsMode,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// StartErrorInsertion: TBD

	StartErrorInsertion *bool `json:"startErrorInsertion,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`
	// TypeAOrderedSets: TBD

	TypeAOrderedSets *string `json:"typeAOrderedSets,omitempty"`
	// TypeBOrderedSets: TBD

	TypeBOrderedSets *string `json:"typeBOrderedSets,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportTenFortyHundredGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportTenFortyHundredGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportTenFortyHundredGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportTenFortyHundredGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportTenGigLan: TBD
type VportTenGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// AutoNegotiate: TBD

	AutoNegotiate *string `json:"autoNegotiate,omitempty"`
	// EnableLASIMonitoring: TBD

	EnableLASIMonitoring *bool `json:"enableLASIMonitoring,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// LoopbackMode: TBD

	LoopbackMode *string `json:"loopbackMode,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// TransmitClocking: TBD

	TransmitClocking *string `json:"transmitClocking,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	Oam *VportOam `json:"oam,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportTenGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportTenGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportTenGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportTenGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.Oam.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "oam",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportTenGigWan: TBD
type VportTenGigWan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// C2Expected: TBD

	C2Expected *float32 `json:"c2Expected,omitempty"`
	// C2Tx: TBD

	C2Tx *float32 `json:"c2Tx,omitempty"`
	// EnablePPM: TBD

	EnablePPM *bool `json:"enablePPM,omitempty"`
	// EnabledFlowControl: TBD

	EnabledFlowControl *bool `json:"enabledFlowControl,omitempty"`
	// FlowControlDirectedAddress: TBD

	FlowControlDirectedAddress *string `json:"flowControlDirectedAddress,omitempty"`
	// IfsStretch: TBD

	IfsStretch *bool `json:"ifsStretch,omitempty"`
	// InterfaceType: TBD

	InterfaceType *string `json:"interfaceType,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// Ppm: TBD

	Ppm *float32 `json:"ppm,omitempty"`
	// TransmitClocking: TBD

	TransmitClocking *string `json:"transmitClocking,omitempty"`
	// TxIgnoreRxLinkFaults: TBD

	TxIgnoreRxLinkFaults *bool `json:"txIgnoreRxLinkFaults,omitempty"`

	Fcoe *VportFcoe `json:"fcoe,omitempty"`

	TxLane *VportTxLane `json:"txLane,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportTenGigWan) XPath() *XPath {
	return n.Xpath
}

func (n *VportTenGigWan) setRestID(id string) {
	n.RestID = id
}

func (n *VportTenGigWan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportTenGigWan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
	n.Fcoe.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "fcoe",
	})
	n.TxLane.updateXPaths(&XPath{
		parentXPath: xPath.String(),
		objectName:  "txLane",
	})
}

// VportTrigger: TBD
type VportTrigger struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CaptureTriggerDA: TBD

	CaptureTriggerDA *string `json:"captureTriggerDA,omitempty"`
	// CaptureTriggerEnable: TBD

	CaptureTriggerEnable *bool `json:"captureTriggerEnable,omitempty"`
	// CaptureTriggerError: TBD

	CaptureTriggerError *string `json:"captureTriggerError,omitempty"`
	// CaptureTriggerExpressionString: TBD

	CaptureTriggerExpressionString *string `json:"captureTriggerExpressionString,omitempty"`
	// CaptureTriggerFrameSizeEnable: TBD

	CaptureTriggerFrameSizeEnable *bool `json:"captureTriggerFrameSizeEnable,omitempty"`
	// CaptureTriggerFrameSizeFrom: TBD

	CaptureTriggerFrameSizeFrom *float32 `json:"captureTriggerFrameSizeFrom,omitempty"`
	// CaptureTriggerFrameSizeTo: TBD

	CaptureTriggerFrameSizeTo *float32 `json:"captureTriggerFrameSizeTo,omitempty"`
	// CaptureTriggerPattern: TBD

	CaptureTriggerPattern *string `json:"captureTriggerPattern,omitempty"`
	// CaptureTriggerSA: TBD

	CaptureTriggerSA *string `json:"captureTriggerSA,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportTrigger) XPath() *XPath {
	return n.Xpath
}

func (n *VportTrigger) setRestID(id string) {
	n.RestID = id
}

func (n *VportTrigger) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportTrigger) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportTxLane: TBD
type VportTxLane struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// IsSkewSynchronized: TBD

	IsSkewSynchronized *bool `json:"isSkewSynchronized,omitempty"`
	// LaneMappingType: TBD

	LaneMappingType *string `json:"laneMappingType,omitempty"`
	// PcsLane: TBD
	PcsLane []float32 `json:"pcsLane"`
	// SkewValues: TBD
	SkewValues []float32 `json:"skewValues"`
	// SynchronizedSkewVal: TBD

	SynchronizedSkewVal *float32 `json:"synchronizedSkewVal,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportTxLane) XPath() *XPath {
	return n.Xpath
}

func (n *VportTxLane) setRestID(id string) {
	n.RestID = id
}

func (n *VportTxLane) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportTxLane) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportUds: TBD
type VportUds struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// CustomFrameSizeFrom: TBD

	CustomFrameSizeFrom *float32 `json:"customFrameSizeFrom,omitempty"`
	// CustomFrameSizeTo: TBD

	CustomFrameSizeTo *float32 `json:"customFrameSizeTo,omitempty"`
	// DestinationAddressSelector: TBD

	DestinationAddressSelector *string `json:"destinationAddressSelector,omitempty"`
	// Error_: TBD

	Error_ *string `json:"error,omitempty"`
	// FrameSizeType: TBD

	FrameSizeType *string `json:"frameSizeType,omitempty"`
	// IsEnabled: TBD

	IsEnabled *bool `json:"isEnabled,omitempty"`
	// PatternSelector: TBD

	PatternSelector *string `json:"patternSelector,omitempty"`
	// SourceAddressSelector: TBD

	SourceAddressSelector *string `json:"sourceAddressSelector,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportUds) XPath() *XPath {
	return n.Xpath
}

func (n *VportUds) setRestID(id string) {
	n.RestID = id
}

func (n *VportUds) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportUds) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}

// VportUhdOneHundredGigLan: TBD
type VportUhdOneHundredGigLan struct {
	// Xpath: If the resource identified by the xpath exists it will be updated

	Xpath *XPath `json:"xpath,omitempty"`
	// AutoInstrumentation: TBD

	AutoInstrumentation *string `json:"autoInstrumentation,omitempty"`
	// EnableAutoNegotiation: TBD

	EnableAutoNegotiation *bool `json:"enableAutoNegotiation,omitempty"`
	// EnableRsFec: TBD

	EnableRsFec *bool `json:"enableRsFec,omitempty"`
	// EnableRsFecStats: TBD

	EnableRsFecStats *bool `json:"enableRsFecStats,omitempty"`
	// FirecodeAdvertise: TBD

	FirecodeAdvertise *bool `json:"firecodeAdvertise,omitempty"`
	// FirecodeForceOff: TBD

	FirecodeForceOff *bool `json:"firecodeForceOff,omitempty"`
	// FirecodeForceOn: TBD

	FirecodeForceOn *bool `json:"firecodeForceOn,omitempty"`
	// FirecodeRequest: TBD

	FirecodeRequest *bool `json:"firecodeRequest,omitempty"`
	// ForceDisableFEC: TBD

	ForceDisableFEC *bool `json:"forceDisableFEC,omitempty"`
	// IeeeL1Defaults: TBD

	IeeeL1Defaults *bool `json:"ieeeL1Defaults,omitempty"`
	// LaserOn: TBD

	LaserOn *bool `json:"laserOn,omitempty"`
	// LinkTraining: TBD

	LinkTraining *bool `json:"linkTraining,omitempty"`
	// Loopback: TBD

	Loopback *bool `json:"loopback,omitempty"`
	// Mtu: TBD

	Mtu *float32 `json:"mtu,omitempty"`
	// RsFecAdvertise: TBD

	RsFecAdvertise *bool `json:"rsFecAdvertise,omitempty"`
	// RsFecForceOn: TBD

	RsFecForceOn *bool `json:"rsFecForceOn,omitempty"`
	// RsFecRequest: TBD

	RsFecRequest *bool `json:"rsFecRequest,omitempty"`
	// Speed: TBD

	Speed *string `json:"speed,omitempty"`
	// UseANResults: TBD

	UseANResults *bool `json:"useANResults,omitempty"`
	// RestID represents the REST API path for a config object (if it is applicable to this object.)
	RestID string `json:"-"`
}

func (n *VportUhdOneHundredGigLan) XPath() *XPath {
	return n.Xpath
}

func (n *VportUhdOneHundredGigLan) setRestID(id string) {
	n.RestID = id
}

func (n *VportUhdOneHundredGigLan) GetRestID() string {
	return n.RestID
}

// updateXPaths recursively updates this structs XPath and those of its subconfig properties.
func (n *VportUhdOneHundredGigLan) updateXPaths(xPath *XPath) {
	if n == nil {
		return
	}
	n.Xpath = xPath
}
