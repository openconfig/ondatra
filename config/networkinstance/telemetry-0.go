package networkinstance

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"reflect"
	"testing"

	config "github.com/openconfig/ondatra/config"
	"github.com/openconfig/ondatra/internal/gnmigen/genutil"
	oc "github.com/openconfig/ondatra/telemetry"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstancePath) Get(t testing.TB) *oc.NetworkInstance {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance with a ONCE subscription.
func (n *NetworkInstancePathAny) Get(t testing.TB) []*oc.NetworkInstance {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance.
func (n *NetworkInstancePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance in the given batch object.
func (n *NetworkInstancePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance.
func (n *NetworkInstancePath) Replace(t testing.TB, val *oc.NetworkInstance) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance in the given batch object.
func (n *NetworkInstancePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance.
func (n *NetworkInstancePath) Update(t testing.TB, val *oc.NetworkInstance) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance in the given batch object.
func (n *NetworkInstancePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPointPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPointPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPointPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point with a ONCE subscription.
func (n *NetworkInstance_ConnectionPointPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point.
func (n *NetworkInstance_ConnectionPointPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point in the given batch object.
func (n *NetworkInstance_ConnectionPointPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point.
func (n *NetworkInstance_ConnectionPointPath) Replace(t testing.TB, val *oc.NetworkInstance_ConnectionPoint) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point in the given batch object.
func (n *NetworkInstance_ConnectionPointPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point.
func (n *NetworkInstance_ConnectionPointPath) Update(t testing.TB, val *oc.NetworkInstance_ConnectionPoint) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point in the given batch object.
func (n *NetworkInstance_ConnectionPointPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/config/connection-point-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_ConnectionPointIdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath extracts the value of the leaf ConnectionPointId from its parent oc.NetworkInstance_ConnectionPoint
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_ConnectionPointIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ConnectionPointId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_EndpointPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_EndpointPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint in the given batch object.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Replace(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint in the given batch object.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) Update(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint in the given batch object.
func (n *NetworkInstance_ConnectionPoint_EndpointPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/endpoint-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath extracts the value of the leaf EndpointId from its parent oc.NetworkInstance_ConnectionPoint_Endpoint
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_EndpointIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.EndpointId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Local{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint_Local {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint_Local
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Replace(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) Update(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_LocalPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/interface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath extracts the value of the leaf SiteId from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-offset in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath extracts the value of the leaf SiteLabelBlockOffset from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockOffsetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteLabelBlockOffset
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/site-label-block-size in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath extracts the value of the leaf SiteLabelBlockSize from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SiteLabelBlockSizePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteLabelBlockSize
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Local{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Local", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local/config/subinterface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Local
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_ConnectionPoint_Endpoint_Local_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Local) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/precedence in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_PrecedencePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath extracts the value of the leaf Precedence from its parent oc.NetworkInstance_ConnectionPoint_Endpoint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_PrecedencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Precedence
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Remote{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint_Remote {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Replace(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) Update(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_RemotePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/remote-system in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath extracts the value of the leaf RemoteSystem from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Remote_RemoteSystemPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteSystem
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/site-id in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath extracts the value of the leaf SiteId from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_ConnectionPoint_Endpoint_Remote_SiteIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SiteId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Remote{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Remote", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote/config/virtual-circuit-identifier in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath extracts the value of the leaf VirtualCircuitIdentifier from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Remote
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_ConnectionPoint_Endpoint_Remote_VirtualCircuitIdentifierPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Remote) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.VirtualCircuitIdentifier
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_ENDPOINT_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Replace(t testing.TB, val oc.E_NetworkInstanceTypes_ENDPOINT_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_ENDPOINT_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) Update(t testing.TB, val oc.E_NetworkInstanceTypes_ENDPOINT_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/config/type in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_TypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_ENDPOINT_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_ConnectionPoint_Endpoint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE.
func convertNetworkInstance_ConnectionPoint_Endpoint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint) *oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_ENDPOINT_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Get(t testing.TB) *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_ConnectionPoint_Endpoint_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPathAny) Get(t testing.TB) []*oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Replace(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) Update(t testing.TB, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_VxlanPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/description in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath extracts the value of the leaf Description from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_DescriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Description
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/enabled in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_ConnectionPoint_Endpoint_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface with a ONCE subscription.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/config/source-interface in the given batch object.
func (n *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath extracts the value of the leaf SourceInterface from its parent oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_ConnectionPoint_Endpoint_Vxlan_SourceInterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_ConnectionPoint_Endpoint_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SourceInterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/config/description with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_DescriptionPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_DescriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/config/description with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_DescriptionPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/config/description with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_DescriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_DescriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/config/description with a ONCE subscription.
func (n *NetworkInstance_DescriptionPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/config/description.
func (n *NetworkInstance_DescriptionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/config/description in the given batch object.
func (n *NetworkInstance_DescriptionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/config/description.
func (n *NetworkInstance_DescriptionPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/config/description in the given batch object.
func (n *NetworkInstance_DescriptionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/config/description.
func (n *NetworkInstance_DescriptionPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/config/description in the given batch object.
func (n *NetworkInstance_DescriptionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_DescriptionPath extracts the value of the leaf Description from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_DescriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Description
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Lookup(t testing.TB) *oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_EnabledAddressFamiliesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Get(t testing.TB) []oc.E_Types_ADDRESS_FAMILY {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EnabledAddressFamiliesPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Types_ADDRESS_FAMILYSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_EnabledAddressFamiliesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families with a ONCE subscription.
func (n *NetworkInstance_EnabledAddressFamiliesPathAny) Get(t testing.TB) [][]oc.E_Types_ADDRESS_FAMILY {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Types_ADDRESS_FAMILY
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families in the given batch object.
func (n *NetworkInstance_EnabledAddressFamiliesPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Replace(t testing.TB, val []oc.E_Types_ADDRESS_FAMILY) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families in the given batch object.
func (n *NetworkInstance_EnabledAddressFamiliesPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []oc.E_Types_ADDRESS_FAMILY) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families.
func (n *NetworkInstance_EnabledAddressFamiliesPath) Update(t testing.TB, val []oc.E_Types_ADDRESS_FAMILY) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/config/enabled-address-families in the given batch object.
func (n *NetworkInstance_EnabledAddressFamiliesPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []oc.E_Types_ADDRESS_FAMILY) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_EnabledAddressFamiliesPath extracts the value of the leaf EnabledAddressFamilies from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Types_ADDRESS_FAMILYSlice.
func convertNetworkInstance_EnabledAddressFamiliesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	qv := &oc.QualifiedE_Types_ADDRESS_FAMILYSlice{
		Metadata: md,
	}
	val := parent.EnabledAddressFamilies
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/config/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/config/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/config/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/config/enabled with a ONCE subscription.
func (n *NetworkInstance_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/config/enabled.
func (n *NetworkInstance_EnabledPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/config/enabled in the given batch object.
func (n *NetworkInstance_EnabledPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/config/enabled.
func (n *NetworkInstance_EnabledPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/config/enabled in the given batch object.
func (n *NetworkInstance_EnabledPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/config/enabled.
func (n *NetworkInstance_EnabledPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/config/enabled in the given batch object.
func (n *NetworkInstance_EnabledPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EncapsulationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Encapsulation {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Encapsulation{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EncapsulationPath) Get(t testing.TB) *oc.NetworkInstance_Encapsulation {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EncapsulationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Encapsulation {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Encapsulation
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Encapsulation{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation with a ONCE subscription.
func (n *NetworkInstance_EncapsulationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Encapsulation {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Encapsulation
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation.
func (n *NetworkInstance_EncapsulationPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/encapsulation in the given batch object.
func (n *NetworkInstance_EncapsulationPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation.
func (n *NetworkInstance_EncapsulationPath) Replace(t testing.TB, val *oc.NetworkInstance_Encapsulation) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/encapsulation in the given batch object.
func (n *NetworkInstance_EncapsulationPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Encapsulation) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation.
func (n *NetworkInstance_EncapsulationPath) Update(t testing.TB, val *oc.NetworkInstance_Encapsulation) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/encapsulation in the given batch object.
func (n *NetworkInstance_EncapsulationPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Encapsulation) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Encapsulation_ControlWordPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Encapsulation_ControlWordPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Encapsulation_ControlWordPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word with a ONCE subscription.
func (n *NetworkInstance_Encapsulation_ControlWordPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word in the given batch object.
func (n *NetworkInstance_Encapsulation_ControlWordPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word in the given batch object.
func (n *NetworkInstance_Encapsulation_ControlWordPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word.
func (n *NetworkInstance_Encapsulation_ControlWordPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/control-word in the given batch object.
func (n *NetworkInstance_Encapsulation_ControlWordPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Encapsulation_ControlWordPath extracts the value of the leaf ControlWord from its parent oc.NetworkInstance_Encapsulation
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Encapsulation_ControlWordPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Encapsulation) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ControlWord
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Encapsulation_EncapsulationTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Encapsulation_EncapsulationTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type with a ONCE subscription.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_ENCAPSULATION
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type in the given batch object.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Replace(t testing.TB, val oc.E_NetworkInstanceTypes_ENCAPSULATION) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type in the given batch object.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_ENCAPSULATION) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) Update(t testing.TB, val oc.E_NetworkInstanceTypes_ENCAPSULATION) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/encapsulation-type in the given batch object.
func (n *NetworkInstance_Encapsulation_EncapsulationTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_ENCAPSULATION) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Encapsulation_EncapsulationTypePath extracts the value of the leaf EncapsulationType from its parent oc.NetworkInstance_Encapsulation
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION.
func convertNetworkInstance_Encapsulation_EncapsulationTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Encapsulation) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION{
		Metadata: md,
	}
	val := parent.EncapsulationType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Encapsulation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Encapsulation", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Encapsulation_LabelAllocationModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Encapsulation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Encapsulation", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Encapsulation_LabelAllocationModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode with a ONCE subscription.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode in the given batch object.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Replace(t testing.TB, val oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode in the given batch object.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) Update(t testing.TB, val oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/encapsulation/config/label-allocation-mode in the given batch object.
func (n *NetworkInstance_Encapsulation_LabelAllocationModePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Encapsulation_LabelAllocationModePath extracts the value of the leaf LabelAllocationMode from its parent oc.NetworkInstance_Encapsulation
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE.
func convertNetworkInstance_Encapsulation_LabelAllocationModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Encapsulation) *oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_LABEL_ALLOCATION_MODE{
		Metadata: md,
	}
	val := parent.LabelAllocationMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_EvpnPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_EvpnPath) Get(t testing.TB) *oc.NetworkInstance_Evpn {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_EvpnPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn with a ONCE subscription.
func (n *NetworkInstance_EvpnPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn.
func (n *NetworkInstance_EvpnPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn in the given batch object.
func (n *NetworkInstance_EvpnPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn.
func (n *NetworkInstance_EvpnPath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn in the given batch object.
func (n *NetworkInstance_EvpnPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn.
func (n *NetworkInstance_EvpnPath) Update(t testing.TB, val *oc.NetworkInstance_Evpn) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn in the given batch object.
func (n *NetworkInstance_EvpnPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegmentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegmentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EthernetSegment {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EthernetSegment
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EthernetSegment) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EthernetSegment) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EthernetSegment) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegmentPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EthernetSegment) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EthernetSegment_DfElection{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EthernetSegment_DfElection {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EthernetSegment_DfElection
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElectionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Lookup(t testing.TB) *oc.QualifiedE_DfElection_DfElectionMethod {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Get(t testing.TB) oc.E_DfElection_DfElectionMethod {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_DfElection_DfElectionMethod {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_DfElection_DfElectionMethod
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPathAny) Get(t testing.TB) []oc.E_DfElection_DfElectionMethod {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_DfElection_DfElectionMethod
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Replace(t testing.TB, val oc.E_DfElection_DfElectionMethod) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_DfElection_DfElectionMethod) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) Update(t testing.TB, val oc.E_DfElection_DfElectionMethod) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/df-election-method in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_DfElection_DfElectionMethod) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath extracts the value of the leaf DfElectionMethod from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedE_DfElection_DfElectionMethod.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_DfElectionMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedE_DfElection_DfElectionMethod {
	t.Helper()
	qv := &oc.QualifiedE_DfElection_DfElectionMethod{
		Metadata: md,
	}
	val := parent.DfElectionMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/election-wait-time in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath extracts the value of the leaf ElectionWaitTime from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_ElectionWaitTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ElectionWaitTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/preference in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetRevertive())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment_DfElection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment_DfElection", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election/config/revertive in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath extracts the value of the leaf Revertive from its parent oc.NetworkInstance_Evpn_EthernetSegment_DfElection
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Evpn_EthernetSegment_DfElection_RevertivePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment_DfElection) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Revertive
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_EsiPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Get(t testing.TB) oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_EsiPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPathAny) Get(t testing.TB) []oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Replace(t testing.TB, val oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) Update(t testing.TB, val oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Evpn_EthernetSegment_Esi_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EthernetSegment_EsiPath extracts the value of the leaf Esi from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union.
func convertNetworkInstance_Evpn_EthernetSegment_EsiPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EthernetSegment_Esi_Union{
		Metadata: md,
	}
	val := parent.Esi
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnTypes_EsiType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath(t, md, goStruct)
	}
	return (&oc.QualifiedE_EvpnTypes_EsiType{
		Metadata: md,
	}).SetVal(goStruct.GetEsiType())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Get(t testing.TB) oc.E_EvpnTypes_EsiType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnTypes_EsiType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnTypes_EsiType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePathAny) Get(t testing.TB) []oc.E_EvpnTypes_EsiType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnTypes_EsiType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Replace(t testing.TB, val oc.E_EvpnTypes_EsiType) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnTypes_EsiType) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) Update(t testing.TB, val oc.E_EvpnTypes_EsiType) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/esi-type in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_EsiTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnTypes_EsiType) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath extracts the value of the leaf EsiType from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnTypes_EsiType.
func convertNetworkInstance_Evpn_EthernetSegment_EsiTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedE_EvpnTypes_EsiType {
	t.Helper()
	qv := &oc.QualifiedE_EvpnTypes_EsiType{
		Metadata: md,
	}
	val := parent.EsiType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/interface in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EthernetSegment_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EthernetSegment_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/name in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_NamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EthernetSegment_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EthernetSegment_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Get(t testing.TB) oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePathAny) Get(t testing.TB) []oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Replace(t testing.TB, val oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) Update(t testing.TB, val oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/redundancy-mode in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_RedundancyModePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnTypes_EVPN_REDUNDANCY_MODE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath extracts the value of the leaf RedundancyMode from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE.
func convertNetworkInstance_Evpn_EthernetSegment_RedundancyModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE {
	t.Helper()
	qv := &oc.QualifiedE_EvpnTypes_EVPN_REDUNDANCY_MODE{
		Metadata: md,
	}
	val := parent.RedundancyMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EthernetSegment", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EthernetSegment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EthernetSegment", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/config/subinterface in the given batch object.
func (n *NetworkInstance_Evpn_EthernetSegment_SubinterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Evpn_EthernetSegment
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EthernetSegment_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EthernetSegment) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstancePathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstancePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstancePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance.
func (n *NetworkInstance_Evpn_EvpnInstancePath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstancePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponentPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/b-component-name in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath extracts the value of the leaf BComponentName from its parent oc.NetworkInstance_Evpn_EvpnInstance_BComponent
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_BComponent_BComponentNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.BComponentName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/config/backbone-src-mac in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath extracts the value of the leaf BackboneSrcMac from its parent oc.NetworkInstance_Evpn_EvpnInstance_BComponent
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_BComponent_BackboneSrcMacPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_BComponent) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.BackboneSrcMac
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponentPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component/config/i-sid in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath extracts the value of the leaf ISid from its parent oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EvpnInstance_BComponent_IComponent_ISidPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ISid
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Lookup(t testing.TB) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Get(t testing.TB) oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePathAny) Get(t testing.TB) []oc.E_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NetworkInstanceTypes_ENCAPSULATION
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Replace(t testing.TB, val oc.E_NetworkInstanceTypes_ENCAPSULATION) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_ENCAPSULATION) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) Update(t testing.TB, val oc.E_NetworkInstanceTypes_ENCAPSULATION) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/encapsulation-type in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_NetworkInstanceTypes_ENCAPSULATION) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath extracts the value of the leaf EncapsulationType from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION.
func convertNetworkInstance_Evpn_EvpnInstance_EncapsulationTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION {
	t.Helper()
	qv := &oc.QualifiedE_NetworkInstanceTypes_ENCAPSULATION{
		Metadata: md,
	}
	val := parent.EncapsulationType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_EviPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_EviPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/evi in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_EviPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_EviPath extracts the value of the leaf Evi from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_EviPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Evi
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Get(t testing.TB) []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Replace(t testing.TB, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) Update(t testing.TB, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/export-route-target in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath extracts the value of the leaf ExportRouteTarget from its parent oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice.
func convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTargetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_UnionSlice{
		Metadata: md,
	}
	val := parent.ExportRouteTarget
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Get(t testing.TB) []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Replace(t testing.TB, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) Update(t testing.TB, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/config/import-route-target in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath extracts the value of the leaf ImportRouteTarget from its parent oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice.
func convertNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTargetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_UnionSlice{
		Metadata: md,
	}
	val := parent.ImportRouteTarget
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-group in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath extracts the value of the leaf MulticastGroup from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_MulticastGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MulticastGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/multicast-mask in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_MulticastMaskPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath extracts the value of the leaf MulticastMask from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_MulticastMaskPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MulticastMask
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnInstance_ReplicationMode {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Get(t testing.TB) oc.E_EvpnInstance_ReplicationMode {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnInstance_ReplicationMode {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnInstance_ReplicationMode
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePathAny) Get(t testing.TB) []oc.E_EvpnInstance_ReplicationMode {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnInstance_ReplicationMode
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Replace(t testing.TB, val oc.E_EvpnInstance_ReplicationMode) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnInstance_ReplicationMode) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) Update(t testing.TB, val oc.E_EvpnInstance_ReplicationMode) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/replication-mode in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ReplicationModePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnInstance_ReplicationMode) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath extracts the value of the leaf ReplicationMode from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnInstance_ReplicationMode.
func convertNetworkInstance_Evpn_EvpnInstance_ReplicationModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedE_EvpnInstance_ReplicationMode {
	t.Helper()
	qv := &oc.QualifiedE_EvpnInstance_ReplicationMode{
		Metadata: md,
	}
	val := parent.ReplicationMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Get(t testing.TB) oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPathAny) Get(t testing.TB) []oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Replace(t testing.TB, val oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) Update(t testing.TB, val oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/route-distinguisher in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath extracts the value of the leaf RouteDistinguisher from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union.
func convertNetworkInstance_Evpn_EvpnInstance_RouteDistinguisherPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union{
		Metadata: md,
	}
	val := parent.RouteDistinguisher
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Lookup(t testing.TB) *oc.QualifiedE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Get(t testing.TB) oc.E_EvpnTypes_EVPN_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_EvpnTypes_EVPN_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePathAny) Get(t testing.TB) []oc.E_EvpnTypes_EVPN_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_EvpnTypes_EVPN_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Replace(t testing.TB, val oc.E_EvpnTypes_EVPN_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnTypes_EVPN_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) Update(t testing.TB, val oc.E_EvpnTypes_EVPN_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/config/service-type in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_ServiceTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_EvpnTypes_EVPN_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath extracts the value of the leaf ServiceType from its parent oc.NetworkInstance_Evpn_EvpnInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedE_EvpnTypes_EVPN_TYPE.
func convertNetworkInstance_Evpn_EvpnInstance_ServiceTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance) *oc.QualifiedE_EvpnTypes_EVPN_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_EvpnTypes_EVPN_TYPE{
		Metadata: md,
	}
	val := parent.ServiceType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_VxlanPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Get(t testing.TB) *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Replace(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) Update(t testing.TB, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/interface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface/config/subinterface in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/host-reachability-bgp in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath extracts the value of the leaf HostReachabilityBgp from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_HostReachabilityBgpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HostReachabilityBgp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-group in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath extracts the value of the leaf MulticastGroup from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MulticastGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/multicast-mask in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath extracts the value of the leaf MulticastMask from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_MulticastMaskPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MulticastMask
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint-network-instance in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath extracts the value of the leaf OverlayEndpointNetworkInstance from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointNetworkInstancePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.OverlayEndpointNetworkInstance
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/overlay-endpoint in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath extracts the value of the leaf OverlayEndpoint from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_OverlayEndpointPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.OverlayEndpoint
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Evpn_EvpnInstance_Vxlan{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Evpn_EvpnInstance_Vxlan", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni with a ONCE subscription.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/config/vni in the given batch object.
func (n *NetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath extracts the value of the leaf Vni from its parent oc.NetworkInstance_Evpn_EvpnInstance_Vxlan
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Evpn_EvpnInstance_Vxlan_VniPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Evpn_EvpnInstance_Vxlan) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Vni
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_FdbPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_FdbPath) Get(t testing.TB) *oc.NetworkInstance_Fdb {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_FdbPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb with a ONCE subscription.
func (n *NetworkInstance_FdbPathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb.
func (n *NetworkInstance_FdbPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb in the given batch object.
func (n *NetworkInstance_FdbPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb.
func (n *NetworkInstance_FdbPath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb in the given batch object.
func (n *NetworkInstance_FdbPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb.
func (n *NetworkInstance_FdbPath) Update(t testing.TB, val *oc.NetworkInstance_Fdb) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb in the given batch object.
func (n *NetworkInstance_FdbPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_AnycastGatewayMacPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_AnycastGatewayMacPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac with a ONCE subscription.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac in the given batch object.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac in the given batch object.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/anycast-gateway-mac in the given batch object.
func (n *NetworkInstance_Fdb_AnycastGatewayMacPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_AnycastGatewayMacPath extracts the value of the leaf AnycastGatewayMac from its parent oc.NetworkInstance_Fdb
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Fdb_AnycastGatewayMacPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AnycastGatewayMac
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_ArpProxyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb_ArpProxy {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_ArpProxy", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb_ArpProxy{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_ArpProxyPath) Get(t testing.TB) *oc.NetworkInstance_Fdb_ArpProxy {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_ArpProxyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb_ArpProxy {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb_ArpProxy
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_ArpProxy", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb_ArpProxy{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy with a ONCE subscription.
func (n *NetworkInstance_Fdb_ArpProxyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb_ArpProxy {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb_ArpProxy
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy.
func (n *NetworkInstance_Fdb_ArpProxyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy.
func (n *NetworkInstance_Fdb_ArpProxyPath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb_ArpProxy) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_ArpProxy) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy.
func (n *NetworkInstance_Fdb_ArpProxyPath) Update(t testing.TB, val *oc.NetworkInstance_Fdb_ArpProxy) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_ArpProxy) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_ArpProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_ArpProxy_ArpSuppressionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetArpSuppression())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_ArpProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_ArpProxy_ArpSuppressionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression with a ONCE subscription.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/arp-suppression in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_ArpSuppressionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_ArpProxy_ArpSuppressionPath extracts the value of the leaf ArpSuppression from its parent oc.NetworkInstance_Fdb_ArpProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Fdb_ArpProxy_ArpSuppressionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_ArpProxy) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ArpSuppression
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_ArpProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_ArpProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval with a ONCE subscription.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath extracts the value of the leaf DuplicateIpDetectionInterval from its parent oc.NetworkInstance_Fdb_ArpProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_ArpProxy_DuplicateIpDetectionIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_ArpProxy) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.DuplicateIpDetectionInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_ArpProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_ArpProxy_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_ArpProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_ArpProxy_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable with a ONCE subscription.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/enable in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_EnablePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_ArpProxy_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Fdb_ArpProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Fdb_ArpProxy_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_ArpProxy) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_ArpProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_ArpProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_ArpProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold with a ONCE subscription.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath extracts the value of the leaf IpMobilityThreshold from its parent oc.NetworkInstance_Fdb_ArpProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_ArpProxy_IpMobilityThresholdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_ArpProxy) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.IpMobilityThreshold
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_FloodUnknownUnicastSupressionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetFloodUnknownUnicastSupression())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_FloodUnknownUnicastSupressionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression with a ONCE subscription.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression in the given batch object.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression in the given batch object.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/flood-unknown-unicast-supression in the given batch object.
func (n *NetworkInstance_Fdb_FloodUnknownUnicastSupressionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_FloodUnknownUnicastSupressionPath extracts the value of the leaf FloodUnknownUnicastSupression from its parent oc.NetworkInstance_Fdb
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Fdb_FloodUnknownUnicastSupressionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.FloodUnknownUnicastSupression
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacAgingTimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacAgingTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacAgingTimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacAgingTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacAgingTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacAgingTimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time.
func (n *NetworkInstance_Fdb_MacAgingTimePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time in the given batch object.
func (n *NetworkInstance_Fdb_MacAgingTimePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time.
func (n *NetworkInstance_Fdb_MacAgingTimePath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time in the given batch object.
func (n *NetworkInstance_Fdb_MacAgingTimePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time.
func (n *NetworkInstance_Fdb_MacAgingTimePath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-aging-time in the given batch object.
func (n *NetworkInstance_Fdb_MacAgingTimePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacAgingTimePath extracts the value of the leaf MacAgingTime from its parent oc.NetworkInstance_Fdb
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_MacAgingTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.MacAgingTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacLearningPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacLearningPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacLearningPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacLearningPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacLearningPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacLearningPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning.
func (n *NetworkInstance_Fdb_MacLearningPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning in the given batch object.
func (n *NetworkInstance_Fdb_MacLearningPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning.
func (n *NetworkInstance_Fdb_MacLearningPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning in the given batch object.
func (n *NetworkInstance_Fdb_MacLearningPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning.
func (n *NetworkInstance_Fdb_MacLearningPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/mac-learning in the given batch object.
func (n *NetworkInstance_Fdb_MacLearningPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacLearningPath extracts the value of the leaf MacLearning from its parent oc.NetworkInstance_Fdb
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Fdb_MacLearningPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.MacLearning
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacMobilityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb_MacMobility {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacMobility", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb_MacMobility{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacMobilityPath) Get(t testing.TB) *oc.NetworkInstance_Fdb_MacMobility {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacMobilityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb_MacMobility {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb_MacMobility
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacMobility", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb_MacMobility{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacMobilityPathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb_MacMobility {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb_MacMobility
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility.
func (n *NetworkInstance_Fdb_MacMobilityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility in the given batch object.
func (n *NetworkInstance_Fdb_MacMobilityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility.
func (n *NetworkInstance_Fdb_MacMobilityPath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb_MacMobility) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility in the given batch object.
func (n *NetworkInstance_Fdb_MacMobilityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacMobility) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility.
func (n *NetworkInstance_Fdb_MacMobilityPath) Update(t testing.TB, val *oc.NetworkInstance_Fdb_MacMobility) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility in the given batch object.
func (n *NetworkInstance_Fdb_MacMobilityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacMobility) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacMobility", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacMobility", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath extracts the value of the leaf DuplicateIpDetectionInterval from its parent oc.NetworkInstance_Fdb_MacMobility
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_MacMobility_DuplicateIpDetectionIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacMobility) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.DuplicateIpDetectionInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacMobility", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacMobility", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath extracts the value of the leaf IpMobilityThreshold from its parent oc.NetworkInstance_Fdb_MacMobility
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_MacMobility_IpMobilityThresholdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacMobility) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.IpMobilityThreshold
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacMobility", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacMobility_MacMobilityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacMobility", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacMobility_MacMobilityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacMobility_MacMobilityPath extracts the value of the leaf MacMobility from its parent oc.NetworkInstance_Fdb_MacMobility
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Fdb_MacMobility_MacMobilityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacMobility) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.MacMobility
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacMobility", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetMacMobilityThreshold())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacMobility", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath extracts the value of the leaf MacMobilityThreshold from its parent oc.NetworkInstance_Fdb_MacMobility
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Fdb_MacMobility_MacMobilityThresholdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacMobility) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.MacMobilityThreshold
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacMobility", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacMobility_MacMobilityWindowPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetMacMobilityWindow())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacMobility{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacMobility", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacMobility_MacMobilityWindowPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility/config/mac-mobility-window in the given batch object.
func (n *NetworkInstance_Fdb_MacMobility_MacMobilityWindowPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacMobility_MacMobilityWindowPath extracts the value of the leaf MacMobilityWindow from its parent oc.NetworkInstance_Fdb_MacMobility
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_MacMobility_MacMobilityWindowPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacMobility) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.MacMobilityWindow
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTablePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb_MacTable {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb_MacTable{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTablePath) Get(t testing.TB) *oc.NetworkInstance_Fdb_MacTable {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTablePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb_MacTable {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb_MacTable
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb_MacTable{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTablePathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb_MacTable {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb_MacTable
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table.
func (n *NetworkInstance_Fdb_MacTablePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table in the given batch object.
func (n *NetworkInstance_Fdb_MacTablePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table.
func (n *NetworkInstance_Fdb_MacTablePath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table in the given batch object.
func (n *NetworkInstance_Fdb_MacTablePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table.
func (n *NetworkInstance_Fdb_MacTablePath) Update(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table in the given batch object.
func (n *NetworkInstance_Fdb_MacTablePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb_MacTable_Entry {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable_Entry", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb_MacTable_Entry{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) Get(t testing.TB) *oc.NetworkInstance_Fdb_MacTable_Entry {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTable_EntryPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb_MacTable_Entry {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb_MacTable_Entry
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable_Entry", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb_MacTable_Entry{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTable_EntryPathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb_MacTable_Entry {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb_MacTable_Entry
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable_Entry) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable_Entry) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) Update(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable_Entry) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_EntryPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable_Entry) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable_Entry_Interface", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Fdb_MacTable_Entry_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable_Entry_Interface", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb_MacTable_Entry_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb_MacTable_Entry_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) Update(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) Update(t testing.TB, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRefPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable_Entry", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacTable_Entry_MacAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable_Entry", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacTable_Entry_MacAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/mac-address in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_MacAddressPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacTable_Entry_MacAddressPath extracts the value of the leaf MacAddress from its parent oc.NetworkInstance_Fdb_MacTable_Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Fdb_MacTable_Entry_MacAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacTable_Entry) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.MacAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_MacTable_Entry", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MacTable_Entry_VlanPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_MacTable_Entry{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_MacTable_Entry", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MacTable_Entry_VlanPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan with a ONCE subscription.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/config/vlan in the given batch object.
func (n *NetworkInstance_Fdb_MacTable_Entry_VlanPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MacTable_Entry_VlanPath extracts the value of the leaf Vlan from its parent oc.NetworkInstance_Fdb_MacTable_Entry
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_MacTable_Entry_VlanPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_MacTable_Entry) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Vlan
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_MaximumEntriesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_MaximumEntriesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_MaximumEntriesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries with a ONCE subscription.
func (n *NetworkInstance_Fdb_MaximumEntriesPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries in the given batch object.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries in the given batch object.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/config/maximum-entries in the given batch object.
func (n *NetworkInstance_Fdb_MaximumEntriesPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_MaximumEntriesPath extracts the value of the leaf MaximumEntries from its parent oc.NetworkInstance_Fdb
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_MaximumEntriesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.MaximumEntries
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_NdProxyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Fdb_NdProxy {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_NdProxy", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Fdb_NdProxy{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_NdProxyPath) Get(t testing.TB) *oc.NetworkInstance_Fdb_NdProxy {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_NdProxyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Fdb_NdProxy {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Fdb_NdProxy
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_NdProxy", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Fdb_NdProxy{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy with a ONCE subscription.
func (n *NetworkInstance_Fdb_NdProxyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Fdb_NdProxy {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Fdb_NdProxy
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy.
func (n *NetworkInstance_Fdb_NdProxyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy in the given batch object.
func (n *NetworkInstance_Fdb_NdProxyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy.
func (n *NetworkInstance_Fdb_NdProxyPath) Replace(t testing.TB, val *oc.NetworkInstance_Fdb_NdProxy) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy in the given batch object.
func (n *NetworkInstance_Fdb_NdProxyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_NdProxy) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy.
func (n *NetworkInstance_Fdb_NdProxyPath) Update(t testing.TB, val *oc.NetworkInstance_Fdb_NdProxy) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy in the given batch object.
func (n *NetworkInstance_Fdb_NdProxyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Fdb_NdProxy) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_NdProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_NdProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval with a ONCE subscription.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/duplicate-ip-detection-interval in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath extracts the value of the leaf DuplicateIpDetectionInterval from its parent oc.NetworkInstance_Fdb_NdProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_NdProxy_DuplicateIpDetectionIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_NdProxy) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.DuplicateIpDetectionInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_NdProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_NdProxy_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_NdProxy_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_NdProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_NdProxy_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable with a ONCE subscription.
func (n *NetworkInstance_Fdb_NdProxy_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/enable in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_EnablePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_NdProxy_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Fdb_NdProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Fdb_NdProxy_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_NdProxy) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_NdProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_NdProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold with a ONCE subscription.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/ip-mobility-threshold in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath extracts the value of the leaf IpMobilityThreshold from its parent oc.NetworkInstance_Fdb_NdProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Fdb_NdProxy_IpMobilityThresholdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_NdProxy) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.IpMobilityThreshold
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Fdb_NdProxy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Fdb_NdProxy_NdSuppressionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetNdSuppression())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Fdb_NdProxy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Fdb_NdProxy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Fdb_NdProxy_NdSuppressionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression with a ONCE subscription.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy/config/nd-suppression in the given batch object.
func (n *NetworkInstance_Fdb_NdProxy_NdSuppressionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Fdb_NdProxy_NdSuppressionPath extracts the value of the leaf NdSuppression from its parent oc.NetworkInstance_Fdb_NdProxy
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Fdb_NdProxy_NdSuppressionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Fdb_NdProxy) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.NdSuppression
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePoliciesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_InterInstancePolicies {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_InterInstancePolicies{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePoliciesPath) Get(t testing.TB) *oc.NetworkInstance_InterInstancePolicies {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePoliciesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_InterInstancePolicies {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_InterInstancePolicies
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_InterInstancePolicies{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies with a ONCE subscription.
func (n *NetworkInstance_InterInstancePoliciesPathAny) Get(t testing.TB) []*oc.NetworkInstance_InterInstancePolicies {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_InterInstancePolicies
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies.
func (n *NetworkInstance_InterInstancePoliciesPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies in the given batch object.
func (n *NetworkInstance_InterInstancePoliciesPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies.
func (n *NetworkInstance_InterInstancePoliciesPath) Replace(t testing.TB, val *oc.NetworkInstance_InterInstancePolicies) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies in the given batch object.
func (n *NetworkInstance_InterInstancePoliciesPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_InterInstancePolicies) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies.
func (n *NetworkInstance_InterInstancePoliciesPath) Update(t testing.TB, val *oc.NetworkInstance_InterInstancePolicies) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies in the given batch object.
func (n *NetworkInstance_InterInstancePoliciesPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_InterInstancePolicies) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_InterInstancePolicies_ApplyPolicy {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_InterInstancePolicies_ApplyPolicy{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) Get(t testing.TB) *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_InterInstancePolicies_ApplyPolicy {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_InterInstancePolicies_ApplyPolicy
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_InterInstancePolicies_ApplyPolicy{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPathAny) Get(t testing.TB) []*oc.NetworkInstance_InterInstancePolicies_ApplyPolicy {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_InterInstancePolicies_ApplyPolicy
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) Replace(t testing.TB, val *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) Update(t testing.TB, val *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) Lookup(t testing.TB) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}).SetVal(goStruct.GetDefaultExportPolicy())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) Get(t testing.TB) oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPathAny) Get(t testing.TB) []oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_RoutingPolicy_DefaultPolicyType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) Replace(t testing.TB, val oc.E_RoutingPolicy_DefaultPolicyType) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_RoutingPolicy_DefaultPolicyType) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) Update(t testing.TB, val oc.E_RoutingPolicy_DefaultPolicyType) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_RoutingPolicy_DefaultPolicyType) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath extracts the value of the leaf DefaultExportPolicy from its parent oc.NetworkInstance_InterInstancePolicies_ApplyPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedE_RoutingPolicy_DefaultPolicyType.
func convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultExportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	qv := &oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}
	val := parent.DefaultExportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) Lookup(t testing.TB) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}).SetVal(goStruct.GetDefaultImportPolicy())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) Get(t testing.TB) oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPathAny) Get(t testing.TB) []oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_RoutingPolicy_DefaultPolicyType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) Replace(t testing.TB, val oc.E_RoutingPolicy_DefaultPolicyType) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_RoutingPolicy_DefaultPolicyType) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) Update(t testing.TB, val oc.E_RoutingPolicy_DefaultPolicyType) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/default-import-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_RoutingPolicy_DefaultPolicyType) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath extracts the value of the leaf DefaultImportPolicy from its parent oc.NetworkInstance_InterInstancePolicies_ApplyPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedE_RoutingPolicy_DefaultPolicyType.
func convertNetworkInstance_InterInstancePolicies_ApplyPolicy_DefaultImportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	qv := &oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}
	val := parent.DefaultImportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath extracts the value of the leaf ExportPolicy from its parent oc.NetworkInstance_InterInstancePolicies_ApplyPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ExportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ExportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ApplyPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ApplyPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy/config/import-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath extracts the value of the leaf ImportPolicy from its parent oc.NetworkInstance_InterInstancePolicies_ApplyPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_InterInstancePolicies_ApplyPolicy_ImportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_InterInstancePolicies_ApplyPolicy) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ImportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ImportExportPolicy", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) Get(t testing.TB) *oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ImportExportPolicy", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPathAny) Get(t testing.TB) []*oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) Replace(t testing.TB, val *oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) Update(t testing.TB, val *oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ImportExportPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) Get(t testing.TB) []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ImportExportPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPathAny) Get(t testing.TB) [][]oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) Replace(t testing.TB, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) Update(t testing.TB, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/export-route-target in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath extracts the value of the leaf ExportRouteTarget from its parent oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_UnionSlice.
func convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTargetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy) *oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_UnionSlice{
		Metadata: md,
	}
	val := parent.ExportRouteTarget
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_InterInstancePolicies_ImportExportPolicy", goStruct, true, true)
	if ok {
		return convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) Get(t testing.TB) []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_InterInstancePolicies_ImportExportPolicy", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target with a ONCE subscription.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPathAny) Get(t testing.TB) [][]oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) Replace(t testing.TB, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) Update(t testing.TB, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/config/import-route-target in the given batch object.
func (n *NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath extracts the value of the leaf ImportRouteTarget from its parent oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_UnionSlice.
func convertNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTargetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_InterInstancePolicies_ImportExportPolicy) *oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_UnionSlice{
		Metadata: md,
	}
	val := parent.ImportRouteTarget
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Interface", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Interface", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface.
func (n *NetworkInstance_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface in the given batch object.
func (n *NetworkInstance_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface.
func (n *NetworkInstance_InterfacePath) Replace(t testing.TB, val *oc.NetworkInstance_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface in the given batch object.
func (n *NetworkInstance_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Interface) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface.
func (n *NetworkInstance_InterfacePath) Update(t testing.TB, val *oc.NetworkInstance_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface in the given batch object.
func (n *NetworkInstance_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Interface) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) Lookup(t testing.TB) *oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Interface_AssociatedAddressFamiliesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) Get(t testing.TB) []oc.E_Types_ADDRESS_FAMILY {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Types_ADDRESS_FAMILYSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Interface_AssociatedAddressFamiliesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families with a ONCE subscription.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPathAny) Get(t testing.TB) [][]oc.E_Types_ADDRESS_FAMILY {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Types_ADDRESS_FAMILY
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families in the given batch object.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) Replace(t testing.TB, val []oc.E_Types_ADDRESS_FAMILY) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families in the given batch object.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []oc.E_Types_ADDRESS_FAMILY) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) Update(t testing.TB, val []oc.E_Types_ADDRESS_FAMILY) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/associated-address-families in the given batch object.
func (n *NetworkInstance_Interface_AssociatedAddressFamiliesPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []oc.E_Types_ADDRESS_FAMILY) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Interface_AssociatedAddressFamiliesPath extracts the value of the leaf AssociatedAddressFamilies from its parent oc.NetworkInstance_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Types_ADDRESS_FAMILYSlice.
func convertNetworkInstance_Interface_AssociatedAddressFamiliesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Interface) *oc.QualifiedE_Types_ADDRESS_FAMILYSlice {
	t.Helper()
	qv := &oc.QualifiedE_Types_ADDRESS_FAMILYSlice{
		Metadata: md,
	}
	val := parent.AssociatedAddressFamilies
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Interface_IdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Interface_IdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Interface_IdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Interface_IdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Interface_IdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id with a ONCE subscription.
func (n *NetworkInstance_Interface_IdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id.
func (n *NetworkInstance_Interface_IdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id in the given batch object.
func (n *NetworkInstance_Interface_IdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id.
func (n *NetworkInstance_Interface_IdPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id in the given batch object.
func (n *NetworkInstance_Interface_IdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id.
func (n *NetworkInstance_Interface_IdPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/id in the given batch object.
func (n *NetworkInstance_Interface_IdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Interface_IdPath extracts the value of the leaf Id from its parent oc.NetworkInstance_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Interface_IdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Id
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Interface_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Interface_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Interface_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Interface_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Interface_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface with a ONCE subscription.
func (n *NetworkInstance_Interface_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface.
func (n *NetworkInstance_Interface_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface in the given batch object.
func (n *NetworkInstance_Interface_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface.
func (n *NetworkInstance_Interface_InterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface in the given batch object.
func (n *NetworkInstance_Interface_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface.
func (n *NetworkInstance_Interface_InterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/interface in the given batch object.
func (n *NetworkInstance_Interface_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Interface_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Interface_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) Lookup(t testing.TB) *oc.QualifiedE_Interface_IrbAnycastGateway {
	t.Helper()
	goStruct := &oc.NetworkInstance_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Interface_IrbAnycastGatewayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) Get(t testing.TB) oc.E_Interface_IrbAnycastGateway {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Interface_IrbAnycastGateway {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Interface_IrbAnycastGateway
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Interface_IrbAnycastGatewayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway with a ONCE subscription.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPathAny) Get(t testing.TB) []oc.E_Interface_IrbAnycastGateway {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Interface_IrbAnycastGateway
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway in the given batch object.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) Replace(t testing.TB, val oc.E_Interface_IrbAnycastGateway) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway in the given batch object.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_Interface_IrbAnycastGateway) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) Update(t testing.TB, val oc.E_Interface_IrbAnycastGateway) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/irb-anycast-gateway in the given batch object.
func (n *NetworkInstance_Interface_IrbAnycastGatewayPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_Interface_IrbAnycastGateway) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Interface_IrbAnycastGatewayPath extracts the value of the leaf IrbAnycastGateway from its parent oc.NetworkInstance_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Interface_IrbAnycastGateway.
func convertNetworkInstance_Interface_IrbAnycastGatewayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Interface) *oc.QualifiedE_Interface_IrbAnycastGateway {
	t.Helper()
	qv := &oc.QualifiedE_Interface_IrbAnycastGateway{
		Metadata: md,
	}
	val := parent.IrbAnycastGateway
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Interface_MacPinningPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Interface_MacPinningPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Interface_MacPinningPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Interface_MacPinningPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Interface_MacPinningPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning with a ONCE subscription.
func (n *NetworkInstance_Interface_MacPinningPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning.
func (n *NetworkInstance_Interface_MacPinningPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning in the given batch object.
func (n *NetworkInstance_Interface_MacPinningPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning.
func (n *NetworkInstance_Interface_MacPinningPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning in the given batch object.
func (n *NetworkInstance_Interface_MacPinningPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning.
func (n *NetworkInstance_Interface_MacPinningPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/mac-pinning in the given batch object.
func (n *NetworkInstance_Interface_MacPinningPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Interface_MacPinningPath extracts the value of the leaf MacPinning from its parent oc.NetworkInstance_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Interface_MacPinningPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Interface) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.MacPinning
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Interface_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Interface_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Interface_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Interface_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Interface_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface with a ONCE subscription.
func (n *NetworkInstance_Interface_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface.
func (n *NetworkInstance_Interface_SubinterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface in the given batch object.
func (n *NetworkInstance_Interface_SubinterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface.
func (n *NetworkInstance_Interface_SubinterfacePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface in the given batch object.
func (n *NetworkInstance_Interface_SubinterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface.
func (n *NetworkInstance_Interface_SubinterfacePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/interfaces/interface/config/subinterface in the given batch object.
func (n *NetworkInstance_Interface_SubinterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Interface_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Interface_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Interface) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_MplsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_MplsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_MplsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls with a ONCE subscription.
func (n *NetworkInstance_MplsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls.
func (n *NetworkInstance_MplsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls in the given batch object.
func (n *NetworkInstance_MplsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls.
func (n *NetworkInstance_MplsPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls in the given batch object.
func (n *NetworkInstance_MplsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls.
func (n *NetworkInstance_MplsPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls in the given batch object.
func (n *NetworkInstance_MplsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global with a ONCE subscription.
func (n *NetworkInstance_Mpls_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global.
func (n *NetworkInstance_Mpls_GlobalPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global in the given batch object.
func (n *NetworkInstance_Mpls_GlobalPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global.
func (n *NetworkInstance_Mpls_GlobalPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Global) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global in the given batch object.
func (n *NetworkInstance_Mpls_GlobalPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global.
func (n *NetworkInstance_Mpls_GlobalPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Global) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global in the given batch object.
func (n *NetworkInstance_Mpls_GlobalPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Global_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_Interface", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Global_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Global_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Global_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Global_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_Interface", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Global_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Global_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Global_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface.
func (n *NetworkInstance_Mpls_Global_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface in the given batch object.
func (n *NetworkInstance_Mpls_Global_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface.
func (n *NetworkInstance_Mpls_Global_InterfacePath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Global_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface in the given batch object.
func (n *NetworkInstance_Mpls_Global_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global_Interface) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface.
func (n *NetworkInstance_Mpls_Global_InterfacePath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Global_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface in the given batch object.
func (n *NetworkInstance_Mpls_Global_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global_Interface) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/interface-id in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceIdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Global_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_Global_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Global_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Global_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_Interface_InterfaceRef", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Global_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Global_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Global_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_Interface_InterfaceRef", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Global_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRefPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_Interface_InterfaceRef", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_Interface_InterfaceRef", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_Interface_InterfaceRef", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_Interface_InterfaceRef", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_Global_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_Interface_MplsEnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetMplsEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_Interface_MplsEnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/config/mpls-enabled in the given batch object.
func (n *NetworkInstance_Mpls_Global_Interface_MplsEnabledPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Global_Interface_MplsEnabledPath extracts the value of the leaf MplsEnabled from its parent oc.NetworkInstance_Mpls_Global_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Global_Interface_MplsEnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global_Interface) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.MplsEnabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_NULL_LABEL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_NullLabelPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_NULL_LABEL_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetNullLabel())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) Get(t testing.TB) oc.E_MplsTypes_NULL_LABEL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_NullLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_NULL_LABEL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_NULL_LABEL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_NullLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_NullLabelPathAny) Get(t testing.TB) []oc.E_MplsTypes_NULL_LABEL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_NULL_LABEL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label in the given batch object.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) Replace(t testing.TB, val oc.E_MplsTypes_NULL_LABEL_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label in the given batch object.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_NULL_LABEL_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) Update(t testing.TB, val oc.E_MplsTypes_NULL_LABEL_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/null-label in the given batch object.
func (n *NetworkInstance_Mpls_Global_NullLabelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_NULL_LABEL_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Global_NullLabelPath extracts the value of the leaf NullLabel from its parent oc.NetworkInstance_Mpls_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_NULL_LABEL_TYPE.
func convertNetworkInstance_Mpls_Global_NullLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global) *oc.QualifiedE_MplsTypes_NULL_LABEL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_NULL_LABEL_TYPE{
		Metadata: md,
	}
	val := parent.NullLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_PwEncapsulationPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) Get(t testing.TB) oc.E_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PSEUDOWIRE_ENCAPSULATION
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_PwEncapsulationPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPathAny) Get(t testing.TB) []oc.E_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PSEUDOWIRE_ENCAPSULATION
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation in the given batch object.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) Replace(t testing.TB, val oc.E_MplsTypes_PSEUDOWIRE_ENCAPSULATION) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation in the given batch object.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PSEUDOWIRE_ENCAPSULATION) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) Update(t testing.TB, val oc.E_MplsTypes_PSEUDOWIRE_ENCAPSULATION) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/pw-encapsulation in the given batch object.
func (n *NetworkInstance_Mpls_Global_PwEncapsulationPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PSEUDOWIRE_ENCAPSULATION) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Global_PwEncapsulationPath extracts the value of the leaf PwEncapsulation from its parent oc.NetworkInstance_Mpls_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PSEUDOWIRE_ENCAPSULATION.
func convertNetworkInstance_Mpls_Global_PwEncapsulationPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global) *oc.QualifiedE_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PSEUDOWIRE_ENCAPSULATION{
		Metadata: md,
	}
	val := parent.PwEncapsulation
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Global_ReservedLabelBlock {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Global_ReservedLabelBlock
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlockPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/local-id in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath extracts the value of the leaf LocalId from its parent oc.NetworkInstance_Mpls_Global_ReservedLabelBlock
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LocalIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LocalId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/lower-bound in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath extracts the value of the leaf LowerBound from its parent oc.NetworkInstance_Mpls_Global_ReservedLabelBlock
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union.
func convertNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock) *oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union{
		Metadata: md,
	}
	val := parent.LowerBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global_ReservedLabelBlock{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global_ReservedLabelBlock", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/config/upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath extracts the value of the leaf UpperBound from its parent oc.NetworkInstance_Mpls_Global_ReservedLabelBlock
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union.
func convertNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global_ReservedLabelBlock) *oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union{
		Metadata: md,
	}
	val := parent.UpperBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Global", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Global_TtlPropagationPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetTtlPropagation())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Global", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Global_TtlPropagationPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation with a ONCE subscription.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation in the given batch object.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation in the given batch object.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/global/config/ttl-propagation in the given batch object.
func (n *NetworkInstance_Mpls_Global_TtlPropagationPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Global_TtlPropagationPath extracts the value of the leaf TtlPropagation from its parent oc.NetworkInstance_Mpls_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Global_TtlPropagationPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Global) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.TtlPropagation
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface.
func (n *NetworkInstance_Mpls_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface in the given batch object.
func (n *NetworkInstance_Mpls_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface.
func (n *NetworkInstance_Mpls_InterfacePath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface in the given batch object.
func (n *NetworkInstance_Mpls_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Interface) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface.
func (n *NetworkInstance_Mpls_InterfacePath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Interface) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface in the given batch object.
func (n *NetworkInstance_Mpls_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Interface) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_AdminGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_AdminGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group in the given batch object.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group in the given batch object.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/admin-group in the given batch object.
func (n *NetworkInstance_Mpls_Interface_AdminGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Interface_AdminGroupPath extracts the value of the leaf AdminGroup from its parent oc.NetworkInstance_Mpls_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Interface_AdminGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.AdminGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Interface_IgpFloodingBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Interface_IgpFloodingBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Interface_IgpFloodingBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidthPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/delta-percentage in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath extracts the value of the leaf DeltaPercentage from its parent oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DeltaPercentagePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.DeltaPercentage
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) Lookup(t testing.TB) *oc.QualifiedUint8Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) Get(t testing.TB) []uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPathAny) Get(t testing.TB) [][]uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) Replace(t testing.TB, val []uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []uint8) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) Update(t testing.TB, val []uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/down-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []uint8) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath extracts the value of the leaf DownThresholds from its parent oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8Slice.
func convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_DownThresholdsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *oc.QualifiedUint8Slice {
	t.Helper()
	qv := &oc.QualifiedUint8Slice{
		Metadata: md,
	}
	val := parent.DownThresholds
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) Lookup(t testing.TB) *oc.QualifiedE_IgpFloodingBandwidth_ThresholdSpecification {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) Get(t testing.TB) oc.E_IgpFloodingBandwidth_ThresholdSpecification {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IgpFloodingBandwidth_ThresholdSpecification {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IgpFloodingBandwidth_ThresholdSpecification
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPathAny) Get(t testing.TB) []oc.E_IgpFloodingBandwidth_ThresholdSpecification {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IgpFloodingBandwidth_ThresholdSpecification
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) Replace(t testing.TB, val oc.E_IgpFloodingBandwidth_ThresholdSpecification) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_IgpFloodingBandwidth_ThresholdSpecification) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) Update(t testing.TB, val oc.E_IgpFloodingBandwidth_ThresholdSpecification) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-specification in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_IgpFloodingBandwidth_ThresholdSpecification) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath extracts the value of the leaf ThresholdSpecification from its parent oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IgpFloodingBandwidth_ThresholdSpecification.
func convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdSpecificationPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *oc.QualifiedE_IgpFloodingBandwidth_ThresholdSpecification {
	t.Helper()
	qv := &oc.QualifiedE_IgpFloodingBandwidth_ThresholdSpecification{
		Metadata: md,
	}
	val := parent.ThresholdSpecification
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) Lookup(t testing.TB) *oc.QualifiedE_IgpFloodingBandwidth_ThresholdType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) Get(t testing.TB) oc.E_IgpFloodingBandwidth_ThresholdType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IgpFloodingBandwidth_ThresholdType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IgpFloodingBandwidth_ThresholdType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePathAny) Get(t testing.TB) []oc.E_IgpFloodingBandwidth_ThresholdType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IgpFloodingBandwidth_ThresholdType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) Replace(t testing.TB, val oc.E_IgpFloodingBandwidth_ThresholdType) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_IgpFloodingBandwidth_ThresholdType) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) Update(t testing.TB, val oc.E_IgpFloodingBandwidth_ThresholdType) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/threshold-type in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_IgpFloodingBandwidth_ThresholdType) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath extracts the value of the leaf ThresholdType from its parent oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IgpFloodingBandwidth_ThresholdType.
func convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_ThresholdTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *oc.QualifiedE_IgpFloodingBandwidth_ThresholdType {
	t.Helper()
	qv := &oc.QualifiedE_IgpFloodingBandwidth_ThresholdType{
		Metadata: md,
	}
	val := parent.ThresholdType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) Lookup(t testing.TB) *oc.QualifiedUint8Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) Get(t testing.TB) []uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPathAny) Get(t testing.TB) [][]uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) Replace(t testing.TB, val []uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []uint8) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) Update(t testing.TB, val []uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-down-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []uint8) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath extracts the value of the leaf UpDownThresholds from its parent oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8Slice.
func convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpDownThresholdsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *oc.QualifiedUint8Slice {
	t.Helper()
	qv := &oc.QualifiedUint8Slice{
		Metadata: md,
	}
	val := parent.UpDownThresholds
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) Lookup(t testing.TB) *oc.QualifiedUint8Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) Get(t testing.TB) []uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_IgpFloodingBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPathAny) Get(t testing.TB) [][]uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) Replace(t testing.TB, val []uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []uint8) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) Update(t testing.TB, val []uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth/config/up-thresholds in the given batch object.
func (n *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []uint8) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath extracts the value of the leaf UpThresholds from its parent oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8Slice.
func convertNetworkInstance_Mpls_Interface_IgpFloodingBandwidth_UpThresholdsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) *oc.QualifiedUint8Slice {
	t.Helper()
	qv := &oc.QualifiedUint8Slice{
		Metadata: md,
	}
	val := parent.UpThresholds
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/interface-id in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceIdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_InterfaceRef", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_InterfaceRef", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Interface_InterfaceRef) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Interface_InterfaceRef) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Interface_InterfaceRef) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRefPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Interface_InterfaceRef) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_InterfaceRef", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_InterfaceRef", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/interface in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface_InterfaceRef", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface_InterfaceRef", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref/config/subinterface in the given batch object.
func (n *NetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_SrlgMembershipPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_SrlgMembershipPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership in the given batch object.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership in the given batch object.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/srlg-membership in the given batch object.
func (n *NetworkInstance_Mpls_Interface_SrlgMembershipPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Interface_SrlgMembershipPath extracts the value of the leaf SrlgMembership from its parent oc.NetworkInstance_Mpls_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Interface_SrlgMembershipPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.SrlgMembership
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Interface", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Interface_TeMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Interface_TeMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Interface", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Interface_TeMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Interface_TeMetricPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric in the given batch object.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric in the given batch object.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/config/te-metric in the given batch object.
func (n *NetworkInstance_Mpls_Interface_TeMetricPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Interface_TeMetricPath extracts the value of the leaf TeMetric from its parent oc.NetworkInstance_Mpls_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_Interface_TeMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Interface) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.TeMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_LspsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_LspsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_LspsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps with a ONCE subscription.
func (n *NetworkInstance_Mpls_LspsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps.
func (n *NetworkInstance_Mpls_LspsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps in the given batch object.
func (n *NetworkInstance_Mpls_LspsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps.
func (n *NetworkInstance_Mpls_LspsPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps in the given batch object.
func (n *NetworkInstance_Mpls_LspsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps.
func (n *NetworkInstance_Mpls_LspsPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps in the given batch object.
func (n *NetworkInstance_Mpls_LspsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPathPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPathPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObjectPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/address in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_MplsHopType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) Get(t testing.TB) oc.E_Mpls_MplsHopType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_MplsHopType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_MplsHopType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePathAny) Get(t testing.TB) []oc.E_Mpls_MplsHopType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_MplsHopType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) Replace(t testing.TB, val oc.E_Mpls_MplsHopType) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_MplsHopType) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) Update(t testing.TB, val oc.E_Mpls_MplsHopType) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/hop-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_MplsHopType) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath extracts the value of the leaf HopType from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_MplsHopType.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_HopTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) *oc.QualifiedE_Mpls_MplsHopType {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_MplsHopType{
		Metadata: md,
	}
	val := parent.HopType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object/config/index in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetSidProtectionRequired())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-protection-required in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath extracts the value of the leaf SidProtectionRequired from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidProtectionRequiredPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SidProtectionRequired
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) Lookup(t testing.TB) *oc.QualifiedE_NamedExplicitPath_SidSelectionMode {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath(t, md, goStruct)
	}
	return (&oc.QualifiedE_NamedExplicitPath_SidSelectionMode{
		Metadata: md,
	}).SetVal(goStruct.GetSidSelectionMode())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) Get(t testing.TB) oc.E_NamedExplicitPath_SidSelectionMode {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_NamedExplicitPath_SidSelectionMode {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_NamedExplicitPath_SidSelectionMode
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePathAny) Get(t testing.TB) []oc.E_NamedExplicitPath_SidSelectionMode {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_NamedExplicitPath_SidSelectionMode
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) Replace(t testing.TB, val oc.E_NamedExplicitPath_SidSelectionMode) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_NamedExplicitPath_SidSelectionMode) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) Update(t testing.TB, val oc.E_NamedExplicitPath_SidSelectionMode) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/config/sid-selection-mode in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_NamedExplicitPath_SidSelectionMode) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath extracts the value of the leaf SidSelectionMode from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_NamedExplicitPath_SidSelectionMode.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_SidSelectionModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) *oc.QualifiedE_NamedExplicitPath_SidSelectionMode {
	t.Helper()
	qv := &oc.QualifiedE_NamedExplicitPath_SidSelectionMode{
		Metadata: md,
	}
	val := parent.SidSelectionMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_TunnelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_TUNNEL_ADMIN_STATUS {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_TUNNEL_ADMIN_STATUS{
		Metadata: md,
	}).SetVal(goStruct.GetAdminStatus())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) Get(t testing.TB) oc.E_MplsTypes_TUNNEL_ADMIN_STATUS {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_TUNNEL_ADMIN_STATUS {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_TUNNEL_ADMIN_STATUS
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPathAny) Get(t testing.TB) []oc.E_MplsTypes_TUNNEL_ADMIN_STATUS {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_TUNNEL_ADMIN_STATUS
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) Replace(t testing.TB, val oc.E_MplsTypes_TUNNEL_ADMIN_STATUS) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_TUNNEL_ADMIN_STATUS) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) Update(t testing.TB, val oc.E_MplsTypes_TUNNEL_ADMIN_STATUS) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/admin-status in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_TUNNEL_ADMIN_STATUS) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath extracts the value of the leaf AdminStatus from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_TUNNEL_ADMIN_STATUS.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_AdminStatusPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_TUNNEL_ADMIN_STATUS {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_TUNNEL_ADMIN_STATUS{
		Metadata: md,
	}
	val := parent.AdminStatus
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_BandwidthPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidthPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) Replace(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) Update(t testing.TB, val uint32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-interval in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath extracts the value of the leaf AdjustInterval from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.AdjustInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/adjust-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath extracts the value of the leaf AdjustThreshold from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_AdjustThresholdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.AdjustThreshold
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) Replace(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) Update(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/max-bw in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath extracts the value of the leaf MaxBw from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MaxBwPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MaxBw
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) Replace(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) Update(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/config/min-bw in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath extracts the value of the leaf MinBw from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_MinBwPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MinBw
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_OverflowPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/overflow-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath extracts the value of the leaf OverflowThreshold from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_OverflowThresholdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.OverflowThreshold
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow/config/trigger-event-count in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath extracts the value of the leaf TriggerEventCount from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow_TriggerEventCountPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.TriggerEventCount
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_UnderflowPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/trigger-event-count in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath extracts the value of the leaf TriggerEventCount from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_TriggerEventCountPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.TriggerEventCount
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow/config/underflow-threshold in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath extracts the value of the leaf UnderflowThreshold from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow_UnderflowThresholdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.UnderflowThreshold
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) Replace(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) Update(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/set-bandwidth in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath extracts the value of the leaf SetBandwidth from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SetBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SetBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_TeBandwidthType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_TeBandwidthType{
		Metadata: md,
	}).SetVal(goStruct.GetSpecificationType())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) Get(t testing.TB) oc.E_Mpls_TeBandwidthType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_TeBandwidthType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_TeBandwidthType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePathAny) Get(t testing.TB) []oc.E_Mpls_TeBandwidthType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_TeBandwidthType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) Replace(t testing.TB, val oc.E_Mpls_TeBandwidthType) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_TeBandwidthType) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) Update(t testing.TB, val oc.E_Mpls_TeBandwidthType) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/config/specification-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_TeBandwidthType) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath extracts the value of the leaf SpecificationType from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_TeBandwidthType.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_SpecificationTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) *oc.QualifiedE_Mpls_TeBandwidthType {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_TeBandwidthType{
		Metadata: md,
	}
	val := parent.SpecificationType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/description in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath extracts the value of the leaf Description from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Description
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Lookup(t testing.TB) *oc.QualifiedInt32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Get(t testing.TB) int32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedInt32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedInt32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny) Get(t testing.TB) []int32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []int32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Replace(t testing.TB, val int32) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val int32) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Update(t testing.TB, val int32) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val int32) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedInt32.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedInt32 {
	t.Helper()
	qv := &oc.QualifiedInt32{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetMetricType())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Get(t testing.TB) oc.E_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny) Get(t testing.TB) []oc.E_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_LSP_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Replace(t testing.TB, val oc.E_MplsTypes_LSP_METRIC_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_LSP_METRIC_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Update(t testing.TB, val oc.E_MplsTypes_LSP_METRIC_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/metric-type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_LSP_METRIC_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath extracts the value of the leaf MetricType from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.MetricType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/config/destination in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath extracts the value of the leaf Destination from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Destination
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/exclude-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath extracts the value of the leaf ExcludeGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ExcludeGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-all-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath extracts the value of the leaf IncludeAllGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAllGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/config/include-any-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath extracts the value of the leaf IncludeAnyGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAnyGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath extracts the value of the leaf Priority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Priority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/config/secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath extracts the value of the leaf SecondaryPath from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SecondaryPath
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}).SetVal(goStruct.GetCspfTiebreaker())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Get(t testing.TB) oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_CspfTieBreaking
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Get(t testing.TB) []oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_CspfTieBreaking
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Replace(t testing.TB, val oc.E_Mpls_CspfTieBreaking) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_CspfTieBreaking) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Update(t testing.TB, val oc.E_Mpls_CspfTieBreaking) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/cspf-tiebreaker in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_CspfTieBreaking) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath extracts the value of the leaf CspfTiebreaker from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_CspfTieBreaking.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}
	val := parent.CspfTiebreaker
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/explicit-path-name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath extracts the value of the leaf ExplicitPathName from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ExplicitPathName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}).SetVal(goStruct.GetPathComputationMethod())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Get(t testing.TB) oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_COMPUTATION_METHOD
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Replace(t testing.TB, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Update(t testing.TB, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-method in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath extracts the value of the leaf PathComputationMethod from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}
	val := parent.PathComputationMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/path-computation-server in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath extracts the value of the leaf PathComputationServer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.PathComputationServer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint64{
		Metadata: md,
	}).SetVal(goStruct.GetMetricUpperBound())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Replace(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Update(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath extracts the value of the leaf MetricUpperBound from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MetricUpperBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Get(t testing.TB) oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Replace(t testing.TB, val oc.E_MplsTypes_PATH_METRIC_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_METRIC_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Update(t testing.TB, val oc.E_MplsTypes_PATH_METRIC_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_METRIC_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/retry-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath extracts the value of the leaf RetryTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RetryTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/config/use-cspf in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath extracts the value of the leaf UseCspf from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.UseCspf
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/exclude-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath extracts the value of the leaf ExcludeGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ExcludeGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-all-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath extracts the value of the leaf IncludeAllGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAllGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Replace(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Update(t testing.TB, val []string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/config/include-any-group in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val []string) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath extracts the value of the leaf IncludeAnyGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAnyGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}).SetVal(goStruct.GetCspfTiebreaker())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Get(t testing.TB) oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_CspfTieBreaking
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Get(t testing.TB) []oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_CspfTieBreaking
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Replace(t testing.TB, val oc.E_Mpls_CspfTieBreaking) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_CspfTieBreaking) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Update(t testing.TB, val oc.E_Mpls_CspfTieBreaking) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/cspf-tiebreaker in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_Mpls_CspfTieBreaking) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath extracts the value of the leaf CspfTiebreaker from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_CspfTieBreaking.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}
	val := parent.CspfTiebreaker
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/explicit-path-name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath extracts the value of the leaf ExplicitPathName from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ExplicitPathName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/hold-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}).SetVal(goStruct.GetPathComputationMethod())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Get(t testing.TB) oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_COMPUTATION_METHOD
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Replace(t testing.TB, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Update(t testing.TB, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-method in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath extracts the value of the leaf PathComputationMethod from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}
	val := parent.PathComputationMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/path-computation-server in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath extracts the value of the leaf PathComputationServer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.PathComputationServer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint64{
		Metadata: md,
	}).SetVal(goStruct.GetMetricUpperBound())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Replace(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Update(t testing.TB, val uint64) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/metric-upper-bound in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint64) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath extracts the value of the leaf MetricUpperBound from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MetricUpperBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Get(t testing.TB) oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Replace(t testing.TB, val oc.E_MplsTypes_PATH_METRIC_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_METRIC_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Update(t testing.TB, val oc.E_MplsTypes_PATH_METRIC_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_METRIC_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/retry-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath extracts the value of the leaf RetryTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RetryTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/config/use-cspf in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath extracts the value of the leaf UseCspf from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.UseCspf
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/preference in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetProtectionStyleRequested())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Get(t testing.TB) oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Get(t testing.TB) []oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PROTECTION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Replace(t testing.TB, val oc.E_MplsTypes_PROTECTION_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PROTECTION_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Update(t testing.TB, val oc.E_MplsTypes_PROTECTION_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/protection-style-requested in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PROTECTION_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath extracts the value of the leaf ProtectionStyleRequested from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PROTECTION_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}
	val := parent.ProtectionStyleRequested
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Replace(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Update(t testing.TB, val uint16) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/reoptimize-timer in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint16) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath extracts the value of the leaf ReoptimizeTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ReoptimizeTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Replace(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Update(t testing.TB, val uint8) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/setup-priority in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val uint8) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetShortcutEligible())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/shortcut-eligible in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath extracts the value of the leaf ShortcutEligible from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ShortcutEligible
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Get(t testing.TB) oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_SETUP_PROTOCOL
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Replace(t testing.TB, val oc.E_MplsTypes_PATH_SETUP_PROTOCOL) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_SETUP_PROTOCOL) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Update(t testing.TB, val oc.E_MplsTypes_PATH_SETUP_PROTOCOL) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/signaling-protocol in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_PATH_SETUP_PROTOCOL) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath extracts the value of the leaf SignalingProtocol from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL{
		Metadata: md,
	}
	val := parent.SignalingProtocol
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetSoftPreemption())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/soft-preemption in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath extracts the value of the leaf SoftPreemption from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SoftPreemption
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/source in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath extracts the value of the leaf Source from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Source
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Get(t testing.TB) oc.E_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_TUNNEL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_TUNNEL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Replace(t testing.TB, val oc.E_MplsTypes_TUNNEL_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_TUNNEL_TYPE) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Update(t testing.TB, val oc.E_MplsTypes_TUNNEL_TYPE) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/config/type in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.E_MplsTypes_TUNNEL_TYPE) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_TUNNEL_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_TUNNEL_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/config/name in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/incoming-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/next-hop in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Replace(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Update(t testing.TB, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/config/push-label in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp in the given batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Replace(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Update(t testing.TB, val string) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/authentication-key in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val string) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/config/enable in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, false, true)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, false, true)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Replace(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) {
	t.Helper()
	b.BatchReplace(t, n, val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Update(t testing.TB, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) {
	t.Helper()
	b.BatchUpdate(t, n, val)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, true)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled with a ONCE subscription,
// failing the test fatally is no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, true)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Delete deletes the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Delete(t testing.TB) *gpb.SetResponse {
	t.Helper()
	return genutil.Delete(t, n)
}

// BatchDelete buffers a config delete operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) BatchDelete(t testing.TB, b *config.SetRequestBatch) {
	t.Helper()
	b.BatchDelete(t, n)
}

// Replace replaces the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Replace(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Replace(t, n, &val)
}

// BatchReplace buffers a config replace operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) BatchReplace(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchReplace(t, n, &val)
}

// Update updates the configuration at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Update(t testing.TB, val bool) *gpb.SetResponse {
	t.Helper()
	return genutil.Update(t, n, &val)
}

// BatchUpdate buffers a config update operation at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/config/enabled in the given batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) BatchUpdate(t testing.TB, b *config.SetRequestBatch, val bool) {
	t.Helper()
	b.BatchUpdate(t, n, &val)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}
