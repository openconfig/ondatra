/*
Package telemetry is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /usr/local/google/home/gdennis/go/pkg/mod/github.com/openconfig/ygot@v0.14.0/genutil/names.go
using the following YANG input files:
	- gnmi-collector-metadata.yang
	- public/release/models/acl/openconfig-acl.yang
	- public/release/models/acl/openconfig-packet-match.yang
	- public/release/models/aft/openconfig-aft.yang
	- public/release/models/ate/openconfig-ate-flow.yang
	- public/release/models/ate/openconfig-ate-intf.yang
	- public/release/models/bfd/openconfig-bfd.yang
	- public/release/models/bgp/openconfig-bgp-policy.yang
	- public/release/models/bgp/openconfig-bgp-types.yang
	- public/release/models/interfaces/openconfig-if-aggregate.yang
	- public/release/models/interfaces/openconfig-if-ethernet.yang
	- public/release/models/interfaces/openconfig-if-ip-ext.yang
	- public/release/models/interfaces/openconfig-if-ip.yang
	- public/release/models/interfaces/openconfig-interfaces.yang
	- public/release/models/isis/openconfig-isis.yang
	- public/release/models/lacp/openconfig-lacp.yang
	- public/release/models/lldp/openconfig-lldp-types.yang
	- public/release/models/lldp/openconfig-lldp.yang
	- public/release/models/local-routing/openconfig-local-routing.yang
	- public/release/models/mpls/openconfig-mpls-types.yang
	- public/release/models/multicast/openconfig-pim.yang
	- public/release/models/network-instance/openconfig-network-instance.yang
	- public/release/models/openconfig-extensions.yang
	- public/release/models/optical-transport/openconfig-transport-types.yang
	- public/release/models/ospf/openconfig-ospfv2.yang
	- public/release/models/platform/openconfig-platform-cpu.yang
	- public/release/models/platform/openconfig-platform-software.yang
	- public/release/models/platform/openconfig-platform-transceiver.yang
	- public/release/models/platform/openconfig-platform.yang
	- public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
	- public/release/models/policy/openconfig-policy-types.yang
	- public/release/models/qos/openconfig-qos-elements.yang
	- public/release/models/qos/openconfig-qos-interfaces.yang
	- public/release/models/qos/openconfig-qos-types.yang
	- public/release/models/qos/openconfig-qos.yang
	- public/release/models/rib/openconfig-rib-bgp.yang
	- public/release/models/segment-routing/openconfig-segment-routing-types.yang
	- public/release/models/system/openconfig-system.yang
	- public/release/models/types/openconfig-inet-types.yang
	- public/release/models/types/openconfig-types.yang
	- public/release/models/types/openconfig-yang-types.yang
	- public/release/models/vlan/openconfig-vlan.yang
	- public/third_party/ietf/iana-if-type.yang
	- public/third_party/ietf/ietf-inet-types.yang
	- public/third_party/ietf/ietf-interfaces.yang
	- public/third_party/ietf/ietf-yang-types.yang
Imported modules were sourced from:
	- public/release/models/...
	- public/third_party/ietf/...
*/
package telemetry

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent YANG schema element.
type NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent struct {
	V1 *uint32 `path:"state/v1" module:"openconfig-network-instance/openconfig-network-instance"`
	V2 *uint32 `path:"state/v2" module:"openconfig-network-instance/openconfig-network-instance"`
	V3 *uint32 `path:"state/v3" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) IsYANGGoStruct() {}

// GetV1 retrieves the value of the leaf V1 from the NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V1 is set, it can
// safely use t.GetV1() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V1 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) GetV1() uint32 {
	if t == nil || t.V1 == nil {
		return 0
	}
	return *t.V1
}

// GetV2 retrieves the value of the leaf V2 from the NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V2 is set, it can
// safely use t.GetV2() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V2 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) GetV2() uint32 {
	if t == nil || t.V2 == nil {
		return 0
	}
	return *t.V2
}

// GetV3 retrieves the value of the leaf V3 from the NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V3 is set, it can
// safely use t.GetV3() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V3 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) GetV3() uint32 {
	if t == nil || t.V3 == nil {
		return 0
	}
	return *t.V3
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Igmp_Interface_Counters_Reports represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports YANG schema element.
type NetworkInstance_Protocol_Igmp_Interface_Counters_Reports struct {
	V1 *uint32 `path:"state/v1" module:"openconfig-network-instance/openconfig-network-instance"`
	V2 *uint32 `path:"state/v2" module:"openconfig-network-instance/openconfig-network-instance"`
	V3 *uint32 `path:"state/v3" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Igmp_Interface_Counters_Reports implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) IsYANGGoStruct() {}

// GetV1 retrieves the value of the leaf V1 from the NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V1 is set, it can
// safely use t.GetV1() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V1 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) GetV1() uint32 {
	if t == nil || t.V1 == nil {
		return 0
	}
	return *t.V1
}

// GetV2 retrieves the value of the leaf V2 from the NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V2 is set, it can
// safely use t.GetV2() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V2 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) GetV2() uint32 {
	if t == nil || t.V2 == nil {
		return 0
	}
	return *t.V2
}

// GetV3 retrieves the value of the leaf V3 from the NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V3 is set, it can
// safely use t.GetV3() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V3 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) GetV3() uint32 {
	if t == nil || t.V3 == nil {
		return 0
	}
	return *t.V3
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Counters_Reports"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Igmp_Interface_Group represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group YANG schema element.
type NetworkInstance_Protocol_Igmp_Interface_Group struct {
	Group    *string `path:"state/group|group" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"group" shadow-module:"openconfig-network-instance"`
	Reporter *string `path:"state/reporter" module:"openconfig-network-instance/openconfig-network-instance"`
	Source   *string `path:"state/source" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Igmp_Interface_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Igmp_Interface_Group) IsYANGGoStruct() {}

// GetGroup retrieves the value of the leaf Group from the NetworkInstance_Protocol_Igmp_Interface_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Group is set, it can
// safely use t.GetGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Group == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) GetGroup() string {
	if t == nil || t.Group == nil {
		return ""
	}
	return *t.Group
}

// GetReporter retrieves the value of the leaf Reporter from the NetworkInstance_Protocol_Igmp_Interface_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Reporter is set, it can
// safely use t.GetReporter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Reporter == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) GetReporter() string {
	if t == nil || t.Reporter == nil {
		return ""
	}
	return *t.Reporter
}

// GetSource retrieves the value of the leaf Source from the NetworkInstance_Protocol_Igmp_Interface_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Source is set, it can
// safely use t.GetSource() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Source == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) GetSource() string {
	if t == nil || t.Source == nil {
		return ""
	}
	return *t.Source
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Igmp_Interface_Group
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Igmp_Interface_Group struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Group == nil {
		return nil, fmt.Errorf("nil value for key Group")
	}

	return map[string]interface{}{
		"group": *t.Group,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Igmp_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref YANG schema element.
type NetworkInstance_Protocol_Igmp_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Igmp_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Protocol_Igmp_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Protocol_Igmp_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Igmp_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Igmp_Interface_StaticGroups represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups YANG schema element.
type NetworkInstance_Protocol_Igmp_Interface_StaticGroups struct {
	Source      *string `path:"state/source" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	StaticGroup *string `path:"state/static-group|static-group" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/static-group|static-group" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Igmp_Interface_StaticGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Igmp_Interface_StaticGroups) IsYANGGoStruct() {}

// GetSource retrieves the value of the leaf Source from the NetworkInstance_Protocol_Igmp_Interface_StaticGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Source is set, it can
// safely use t.GetSource() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Source == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_StaticGroups) GetSource() string {
	if t == nil || t.Source == nil {
		return ""
	}
	return *t.Source
}

// GetStaticGroup retrieves the value of the leaf StaticGroup from the NetworkInstance_Protocol_Igmp_Interface_StaticGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StaticGroup is set, it can
// safely use t.GetStaticGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StaticGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Igmp_Interface_StaticGroups) GetStaticGroup() string {
	if t == nil || t.StaticGroup == nil {
		return ""
	}
	return *t.StaticGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Igmp_Interface_StaticGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Igmp_Interface_StaticGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Igmp_Interface_StaticGroups struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Igmp_Interface_StaticGroups) ΛListKeyMap() (map[string]interface{}, error) {
	if t.StaticGroup == nil {
		return nil, fmt.Errorf("nil value for key StaticGroup")
	}

	return map[string]interface{}{
		"static-group": *t.StaticGroup,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Igmp_Interface_StaticGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Igmp_Interface_StaticGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Igmp_Interface_StaticGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis YANG schema element.
type NetworkInstance_Protocol_Isis struct {
	Global    *NetworkInstance_Protocol_Isis_Global               `path:"global" module:"openconfig-network-instance"`
	Interface map[string]*NetworkInstance_Protocol_Isis_Interface `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Level     map[uint8]*NetworkInstance_Protocol_Isis_Level      `path:"levels/level" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Protocol_Isis struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis) NewInterface(InterfaceId string) (*NetworkInstance_Protocol_Isis_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Isis_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Protocol_Isis_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Protocol_Isis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Protocol_Isis_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Protocol_Isis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetInterface(InterfaceId string) *NetworkInstance_Protocol_Isis_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Protocol_Isis_Interface struct to the
// list Interface of NetworkInstance_Protocol_Isis. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis) AppendInterface(v *NetworkInstance_Protocol_Isis_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Protocol_Isis_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewLevel creates a new entry in the Level list of the
// NetworkInstance_Protocol_Isis struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis) NewLevel(LevelNumber uint8) (*NetworkInstance_Protocol_Isis_Level, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Level)
	}

	key := LevelNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Level[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Level", key)
	}

	t.Level[key] = &NetworkInstance_Protocol_Isis_Level{
		LevelNumber: &LevelNumber,
	}

	return t.Level[key], nil
}

// RenameLevel renames an entry in the list Level within
// the NetworkInstance_Protocol_Isis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis) RenameLevel(oldK, newK uint8) error {
	if _, ok := t.Level[newK]; ok {
		return fmt.Errorf("key %v already exists in Level", newK)
	}

	e, ok := t.Level[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Level", oldK)
	}
	e.LevelNumber = &newK

	t.Level[newK] = e
	delete(t.Level, oldK)
	return nil
}

// GetOrCreateLevel retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Level {

	key := LevelNumber

	if v, ok := t.Level[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLevel(LevelNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLevel got unexpected error: %v", err))
	}
	return v
}

// GetLevel retrieves the value with the specified key from
// the Level map field of NetworkInstance_Protocol_Isis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Level {

	if t == nil {
		return nil
	}

	key := LevelNumber

	if lm, ok := t.Level[key]; ok {
		return lm
	}
	return nil
}

// DeleteLevel deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis) DeleteLevel(LevelNumber uint8) {
	key := LevelNumber

	delete(t.Level, key)
}

// AppendLevel appends the supplied NetworkInstance_Protocol_Isis_Level struct to the
// list Level of NetworkInstance_Protocol_Isis. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis) AppendLevel(v *NetworkInstance_Protocol_Isis_Level) error {
	if v.LevelNumber == nil {
		return fmt.Errorf("invalid nil key received for LevelNumber")
	}

	key := *v.LevelNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Level)
	}

	if _, ok := t.Level[key]; ok {
		return fmt.Errorf("duplicate key for list Level %v", key)
	}

	t.Level[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis) GetOrCreateGlobal() *NetworkInstance_Protocol_Isis_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Protocol_Isis_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Isis. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis) GetGlobal() *NetworkInstance_Protocol_Isis_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.Level {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NetworkInstance_Protocol_Isis_Global represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global YANG schema element.
type NetworkInstance_Protocol_Isis_Global struct {
	Af                            map[NetworkInstance_Protocol_Isis_Global_Af_Key]*NetworkInstance_Protocol_Isis_Global_Af `path:"afi-safi/af" module:"openconfig-network-instance/openconfig-network-instance"`
	Afi                           map[E_IsisTypes_AFI_TYPE]*NetworkInstance_Protocol_Isis_Global_Afi                       `path:"igp-shortcuts/afi" module:"openconfig-network-instance/openconfig-network-instance"`
	AuthenticationCheck           *bool                                                                                    `path:"state/authentication-check" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/authentication-check" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	FastFlooding                  *bool                                                                                    `path:"state/fast-flooding" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/fast-flooding" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	GracefulRestart               *NetworkInstance_Protocol_Isis_Global_GracefulRestart                                    `path:"graceful-restart" module:"openconfig-network-instance"`
	IidTlv                        *bool                                                                                    `path:"state/iid-tlv" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/iid-tlv" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Instance                      *string                                                                                  `path:"state/instance" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/instance" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	InterLevelPropagationPolicies *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies                      `path:"inter-level-propagation-policies" module:"openconfig-network-instance"`
	LevelCapability               E_IsisTypes_LevelType                                                                    `path:"state/level-capability" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/level-capability" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspBit                        *NetworkInstance_Protocol_Isis_Global_LspBit                                             `path:"lsp-bit" module:"openconfig-network-instance"`
	MaxEcmpPaths                  *uint8                                                                                   `path:"state/max-ecmp-paths" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-ecmp-paths" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MaximumAreaAddresses          *uint8                                                                                   `path:"state/maximum-area-addresses" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/maximum-area-addresses" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Mpls                          *NetworkInstance_Protocol_Isis_Global_Mpls                                               `path:"mpls" module:"openconfig-network-instance"`
	Net                           []string                                                                                 `path:"state/net" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/net" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Nsr                           *NetworkInstance_Protocol_Isis_Global_Nsr                                                `path:"nsr" module:"openconfig-network-instance"`
	PoiTlv                        *bool                                                                                    `path:"state/poi-tlv" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/poi-tlv" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReferenceBandwidth            *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth                                 `path:"reference-bandwidth" module:"openconfig-network-instance"`
	SegmentRouting                *NetworkInstance_Protocol_Isis_Global_SegmentRouting                                     `path:"segment-routing" module:"openconfig-network-instance"`
	Timers                        *NetworkInstance_Protocol_Isis_Global_Timers                                             `path:"timers" module:"openconfig-network-instance"`
	Transport                     *NetworkInstance_Protocol_Isis_Global_Transport                                          `path:"transport" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Isis_Global_Af_Key represents the key for list Af of element /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global.
type NetworkInstance_Protocol_Isis_Global_Af_Key struct {
	AfiName  E_IsisTypes_AFI_TYPE  `path:"afi-name"`
	SafiName E_IsisTypes_SAFI_TYPE `path:"safi-name"`
}

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global) NewAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Global_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Global_Af_Key]*NetworkInstance_Protocol_Isis_Global_Af)
	}

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Global_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Global_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Af {

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// DeleteAf deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Global) DeleteAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) {
	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	delete(t.Af, key)
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Global_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global) AppendAf(v *NetworkInstance_Protocol_Isis_Global_Af) error {
	key := NetworkInstance_Protocol_Isis_Global_Af_Key{
		AfiName:  v.AfiName,
		SafiName: v.SafiName,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Global_Af_Key]*NetworkInstance_Protocol_Isis_Global_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// NewAfi creates a new entry in the Afi list of the
// NetworkInstance_Protocol_Isis_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global) NewAfi(AfiName E_IsisTypes_AFI_TYPE) (*NetworkInstance_Protocol_Isis_Global_Afi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Afi == nil {
		t.Afi = make(map[E_IsisTypes_AFI_TYPE]*NetworkInstance_Protocol_Isis_Global_Afi)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Afi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Afi", key)
	}

	t.Afi[key] = &NetworkInstance_Protocol_Isis_Global_Afi{
		AfiName: AfiName,
	}

	return t.Afi[key], nil
}

// RenameAfi renames an entry in the list Afi within
// the NetworkInstance_Protocol_Isis_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global) RenameAfi(oldK, newK E_IsisTypes_AFI_TYPE) error {
	if _, ok := t.Afi[newK]; ok {
		return fmt.Errorf("key %v already exists in Afi", newK)
	}

	e, ok := t.Afi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Afi", oldK)
	}
	e.AfiName = newK

	t.Afi[newK] = e
	delete(t.Afi, oldK)
	return nil
}

// GetOrCreateAfi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateAfi(AfiName E_IsisTypes_AFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Afi {

	key := AfiName

	if v, ok := t.Afi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfi(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfi got unexpected error: %v", err))
	}
	return v
}

// GetAfi retrieves the value with the specified key from
// the Afi map field of NetworkInstance_Protocol_Isis_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetAfi(AfiName E_IsisTypes_AFI_TYPE) *NetworkInstance_Protocol_Isis_Global_Afi {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.Afi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfi deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Global) DeleteAfi(AfiName E_IsisTypes_AFI_TYPE) {
	key := AfiName

	delete(t.Afi, key)
}

// AppendAfi appends the supplied NetworkInstance_Protocol_Isis_Global_Afi struct to the
// list Afi of NetworkInstance_Protocol_Isis_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_Afi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global) AppendAfi(v *NetworkInstance_Protocol_Isis_Global_Afi) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Afi == nil {
		t.Afi = make(map[E_IsisTypes_AFI_TYPE]*NetworkInstance_Protocol_Isis_Global_Afi)
	}

	if _, ok := t.Afi[key]; ok {
		return fmt.Errorf("duplicate key for list Afi %v", key)
	}

	t.Afi[key] = v
	return nil
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateInterLevelPropagationPolicies retrieves the value of the InterLevelPropagationPolicies field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateInterLevelPropagationPolicies() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	if t.InterLevelPropagationPolicies != nil {
		return t.InterLevelPropagationPolicies
	}
	t.InterLevelPropagationPolicies = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	return t.InterLevelPropagationPolicies
}

// GetOrCreateLspBit retrieves the value of the LspBit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateLspBit() *NetworkInstance_Protocol_Isis_Global_LspBit {
	if t.LspBit != nil {
		return t.LspBit
	}
	t.LspBit = &NetworkInstance_Protocol_Isis_Global_LspBit{}
	return t.LspBit
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateMpls() *NetworkInstance_Protocol_Isis_Global_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Protocol_Isis_Global_Mpls{}
	return t.Mpls
}

// GetOrCreateNsr retrieves the value of the Nsr field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateNsr() *NetworkInstance_Protocol_Isis_Global_Nsr {
	if t.Nsr != nil {
		return t.Nsr
	}
	t.Nsr = &NetworkInstance_Protocol_Isis_Global_Nsr{}
	return t.Nsr
}

// GetOrCreateReferenceBandwidth retrieves the value of the ReferenceBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateReferenceBandwidth() *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	if t.ReferenceBandwidth != nil {
		return t.ReferenceBandwidth
	}
	t.ReferenceBandwidth = &NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	return t.ReferenceBandwidth
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateSegmentRouting() *NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	return t.SegmentRouting
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Global_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Isis_Global_Timers{}
	return t.Timers
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global) GetOrCreateTransport() *NetworkInstance_Protocol_Isis_Global_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &NetworkInstance_Protocol_Isis_Global_Transport{}
	return t.Transport
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetGracefulRestart() *NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetInterLevelPropagationPolicies returns the value of the InterLevelPropagationPolicies struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field InterLevelPropagationPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetInterLevelPropagationPolicies() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	if t != nil && t.InterLevelPropagationPolicies != nil {
		return t.InterLevelPropagationPolicies
	}
	return nil
}

// GetLspBit returns the value of the LspBit struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field LspBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetLspBit() *NetworkInstance_Protocol_Isis_Global_LspBit {
	if t != nil && t.LspBit != nil {
		return t.LspBit
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetMpls() *NetworkInstance_Protocol_Isis_Global_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetNsr returns the value of the Nsr struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Nsr is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetNsr() *NetworkInstance_Protocol_Isis_Global_Nsr {
	if t != nil && t.Nsr != nil {
		return t.Nsr
	}
	return nil
}

// GetReferenceBandwidth returns the value of the ReferenceBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field ReferenceBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetReferenceBandwidth() *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	if t != nil && t.ReferenceBandwidth != nil {
		return t.ReferenceBandwidth
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetSegmentRouting() *NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetTimers() *NetworkInstance_Protocol_Isis_Global_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_Protocol_Isis_Global. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global) GetTransport() *NetworkInstance_Protocol_Isis_Global_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// GetAuthenticationCheck retrieves the value of the leaf AuthenticationCheck from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationCheck is set, it can
// safely use t.GetAuthenticationCheck() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationCheck == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetAuthenticationCheck() bool {
	if t == nil || t.AuthenticationCheck == nil {
		return true
	}
	return *t.AuthenticationCheck
}

// GetFastFlooding retrieves the value of the leaf FastFlooding from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FastFlooding is set, it can
// safely use t.GetFastFlooding() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FastFlooding == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetFastFlooding() bool {
	if t == nil || t.FastFlooding == nil {
		return true
	}
	return *t.FastFlooding
}

// GetIidTlv retrieves the value of the leaf IidTlv from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IidTlv is set, it can
// safely use t.GetIidTlv() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IidTlv == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetIidTlv() bool {
	if t == nil || t.IidTlv == nil {
		return false
	}
	return *t.IidTlv
}

// GetInstance retrieves the value of the leaf Instance from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Instance is set, it can
// safely use t.GetInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Instance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetInstance() string {
	if t == nil || t.Instance == nil {
		return "0"
	}
	return *t.Instance
}

// GetLevelCapability retrieves the value of the leaf LevelCapability from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LevelCapability is set, it can
// safely use t.GetLevelCapability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LevelCapability == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetLevelCapability() E_IsisTypes_LevelType {
	if t == nil || t.LevelCapability == 0 {
		return IsisTypes_LevelType_LEVEL_1_2
	}
	return t.LevelCapability
}

// GetMaxEcmpPaths retrieves the value of the leaf MaxEcmpPaths from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxEcmpPaths is set, it can
// safely use t.GetMaxEcmpPaths() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxEcmpPaths == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetMaxEcmpPaths() uint8 {
	if t == nil || t.MaxEcmpPaths == nil {
		return 0
	}
	return *t.MaxEcmpPaths
}

// GetMaximumAreaAddresses retrieves the value of the leaf MaximumAreaAddresses from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumAreaAddresses is set, it can
// safely use t.GetMaximumAreaAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumAreaAddresses == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetMaximumAreaAddresses() uint8 {
	if t == nil || t.MaximumAreaAddresses == nil {
		return 3
	}
	return *t.MaximumAreaAddresses
}

// GetNet retrieves the value of the leaf Net from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Net is set, it can
// safely use t.GetNet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Net == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetNet() []string {
	if t == nil || t.Net == nil {
		return nil
	}
	return t.Net
}

// GetPoiTlv retrieves the value of the leaf PoiTlv from the NetworkInstance_Protocol_Isis_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PoiTlv is set, it can
// safely use t.GetPoiTlv() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PoiTlv == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global) GetPoiTlv() bool {
	if t == nil || t.PoiTlv == nil {
		return false
	}
	return *t.PoiTlv
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AuthenticationCheck == nil {
		var v bool = true
		t.AuthenticationCheck = &v
	}
	if t.FastFlooding == nil {
		var v bool = true
		t.FastFlooding = &v
	}
	if t.IidTlv == nil {
		var v bool = false
		t.IidTlv = &v
	}
	if t.Instance == nil {
		var v string = "0"
		t.Instance = &v
	}
	if t.LevelCapability == 0 {
		t.LevelCapability = IsisTypes_LevelType_LEVEL_1_2
	}
	if t.MaximumAreaAddresses == nil {
		var v uint8 = 3
		t.MaximumAreaAddresses = &v
	}
	if t.PoiTlv == nil {
		var v bool = false
		t.PoiTlv = &v
	}
	t.GracefulRestart.PopulateDefaults()
	t.InterLevelPropagationPolicies.PopulateDefaults()
	t.LspBit.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.Nsr.PopulateDefaults()
	t.ReferenceBandwidth.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
	t.Timers.PopulateDefaults()
	t.Transport.PopulateDefaults()
	for _, e := range t.Af {
		e.PopulateDefaults()
	}
	for _, e := range t.Afi {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Af represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Af struct {
	AfiName       E_IsisTypes_AFI_TYPE                                   `path:"state/afi-name|afi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-name|afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Enabled       *bool                                                  `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Metric        *uint32                                                `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MultiTopology *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology `path:"multi-topology" module:"openconfig-network-instance"`
	SafiName      E_IsisTypes_SAFI_TYPE                                  `path:"state/safi-name|safi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/safi-name|safi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Af implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Af) IsYANGGoStruct() {}

// GetOrCreateMultiTopology retrieves the value of the MultiTopology field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetOrCreateMultiTopology() *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	if t.MultiTopology != nil {
		return t.MultiTopology
	}
	t.MultiTopology = &NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	return t.MultiTopology
}

// GetMultiTopology returns the value of the MultiTopology struct pointer
// from NetworkInstance_Protocol_Isis_Global_Af. If the receiver or the field MultiTopology is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetMultiTopology() *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	if t != nil && t.MultiTopology != nil {
		return t.MultiTopology
	}
	return nil
}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Protocol_Isis_Global_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetAfiName() E_IsisTypes_AFI_TYPE {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Global_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Protocol_Isis_Global_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetMetric() uint32 {
	if t == nil || t.Metric == nil {
		return 10
	}
	return *t.Metric
}

// GetSafiName retrieves the value of the leaf SafiName from the NetworkInstance_Protocol_Isis_Global_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SafiName is set, it can
// safely use t.GetSafiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SafiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Af) GetSafiName() E_IsisTypes_SAFI_TYPE {
	if t == nil || t.SafiName == 0 {
		return 0
	}
	return t.SafiName
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Af
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Af) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Metric == nil {
		var v uint32 = 10
		t.Metric = &v
	}
	t.MultiTopology.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Af"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Af_MultiTopology represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Af_MultiTopology struct {
	AfiName  E_IsisTypes_AFI_TYPE  `path:"state/afi-name" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled  *bool                 `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	SafiName E_IsisTypes_SAFI_TYPE `path:"state/safi-name" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/safi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Af_MultiTopology implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) IsYANGGoStruct() {}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) GetAfiName() E_IsisTypes_AFI_TYPE {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetSafiName retrieves the value of the leaf SafiName from the NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SafiName is set, it can
// safely use t.GetSafiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SafiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) GetSafiName() E_IsisTypes_SAFI_TYPE {
	if t == nil || t.SafiName == 0 {
		return 0
	}
	return t.SafiName
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Af_MultiTopology"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Afi represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Afi struct {
	AfiName E_IsisTypes_AFI_TYPE              `path:"state/afi-name|afi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-name|afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	NhType  []E_MplsTypes_PATH_SETUP_PROTOCOL `path:"state/nh-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/nh-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Afi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Afi) IsYANGGoStruct() {}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Protocol_Isis_Global_Afi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) GetAfiName() E_IsisTypes_AFI_TYPE {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// GetNhType retrieves the value of the leaf NhType from the NetworkInstance_Protocol_Isis_Global_Afi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NhType is set, it can
// safely use t.GetNhType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NhType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) GetNhType() []E_MplsTypes_PATH_SETUP_PROTOCOL {
	if t == nil || t.NhType == nil {
		return nil
	}
	return t.NhType
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Afi
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_Afi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Afi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Afi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_GracefulRestart represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart YANG schema element.
type NetworkInstance_Protocol_Isis_Global_GracefulRestart struct {
	Enabled    *bool `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelperOnly *bool `path:"state/helper-only" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/helper-only" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_GracefulRestart implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_GracefulRestart) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetHelperOnly retrieves the value of the leaf HelperOnly from the NetworkInstance_Protocol_Isis_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelperOnly is set, it can
// safely use t.GetHelperOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelperOnly == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) GetHelperOnly() bool {
	if t == nil || t.HelperOnly == nil {
		return false
	}
	return *t.HelperOnly
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_GracefulRestart
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies YANG schema element.
type NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies struct {
	Level1ToLevel2 *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 `path:"level1-to-level2" module:"openconfig-network-instance"`
	Level2ToLevel1 *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 `path:"level2-to-level1" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) IsYANGGoStruct() {}

// GetOrCreateLevel1ToLevel2 retrieves the value of the Level1ToLevel2 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetOrCreateLevel1ToLevel2() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	if t.Level1ToLevel2 != nil {
		return t.Level1ToLevel2
	}
	t.Level1ToLevel2 = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	return t.Level1ToLevel2
}

// GetOrCreateLevel2ToLevel1 retrieves the value of the Level2ToLevel1 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetOrCreateLevel2ToLevel1() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	if t.Level2ToLevel1 != nil {
		return t.Level2ToLevel1
	}
	t.Level2ToLevel1 = &NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	return t.Level2ToLevel1
}

// GetLevel1ToLevel2 returns the value of the Level1ToLevel2 struct pointer
// from NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies. If the receiver or the field Level1ToLevel2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetLevel1ToLevel2() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	if t != nil && t.Level1ToLevel2 != nil {
		return t.Level1ToLevel2
	}
	return nil
}

// GetLevel2ToLevel1 returns the value of the Level2ToLevel1 struct pointer
// from NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies. If the receiver or the field Level2ToLevel1 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) GetLevel2ToLevel1() *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	if t != nil && t.Level2ToLevel1 != nil {
		return t.Level2ToLevel1
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Level1ToLevel2.PopulateDefaults()
	t.Level2ToLevel1.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 YANG schema element.
type NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 struct {
	DefaultImportPolicy E_RoutingPolicy_DefaultPolicyType `path:"state/default-import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/default-import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportPolicy        []string                          `path:"state/import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) IsYANGGoStruct() {
}

// GetDefaultImportPolicy retrieves the value of the leaf DefaultImportPolicy from the NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultImportPolicy is set, it can
// safely use t.GetDefaultImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) GetDefaultImportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultImportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultImportPolicy
}

// GetImportPolicy retrieves the value of the leaf ImportPolicy from the NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportPolicy is set, it can
// safely use t.GetImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) GetImportPolicy() []string {
	if t == nil || t.ImportPolicy == nil {
		return nil
	}
	return t.ImportPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultImportPolicy == 0 {
		t.DefaultImportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 YANG schema element.
type NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 struct {
	DefaultImportPolicy E_RoutingPolicy_DefaultPolicyType `path:"state/default-import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/default-import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportPolicy        []string                          `path:"state/import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) IsYANGGoStruct() {
}

// GetDefaultImportPolicy retrieves the value of the leaf DefaultImportPolicy from the NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultImportPolicy is set, it can
// safely use t.GetDefaultImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) GetDefaultImportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultImportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultImportPolicy
}

// GetImportPolicy retrieves the value of the leaf ImportPolicy from the NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportPolicy is set, it can
// safely use t.GetImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) GetImportPolicy() []string {
	if t == nil || t.ImportPolicy == nil {
		return nil
	}
	return t.ImportPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultImportPolicy == 0 {
		t.DefaultImportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_LspBit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit YANG schema element.
type NetworkInstance_Protocol_Isis_Global_LspBit struct {
	AttachedBit *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit `path:"attached-bit" module:"openconfig-network-instance"`
	OverloadBit *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit `path:"overload-bit" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_LspBit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_LspBit) IsYANGGoStruct() {}

// GetOrCreateAttachedBit retrieves the value of the AttachedBit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetOrCreateAttachedBit() *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	if t.AttachedBit != nil {
		return t.AttachedBit
	}
	t.AttachedBit = &NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	return t.AttachedBit
}

// GetOrCreateOverloadBit retrieves the value of the OverloadBit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetOrCreateOverloadBit() *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	if t.OverloadBit != nil {
		return t.OverloadBit
	}
	t.OverloadBit = &NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	return t.OverloadBit
}

// GetAttachedBit returns the value of the AttachedBit struct pointer
// from NetworkInstance_Protocol_Isis_Global_LspBit. If the receiver or the field AttachedBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetAttachedBit() *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	if t != nil && t.AttachedBit != nil {
		return t.AttachedBit
	}
	return nil
}

// GetOverloadBit returns the value of the OverloadBit struct pointer
// from NetworkInstance_Protocol_Isis_Global_LspBit. If the receiver or the field OverloadBit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) GetOverloadBit() *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	if t != nil && t.OverloadBit != nil {
		return t.OverloadBit
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_LspBit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AttachedBit.PopulateDefaults()
	t.OverloadBit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit YANG schema element.
type NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit struct {
	IgnoreBit   *bool `path:"state/ignore-bit" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ignore-bit" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SuppressBit *bool `path:"state/suppress-bit" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/suppress-bit" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) IsYANGGoStruct() {}

// GetIgnoreBit retrieves the value of the leaf IgnoreBit from the NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IgnoreBit is set, it can
// safely use t.GetIgnoreBit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IgnoreBit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) GetIgnoreBit() bool {
	if t == nil || t.IgnoreBit == nil {
		return false
	}
	return *t.IgnoreBit
}

// GetSuppressBit retrieves the value of the leaf SuppressBit from the NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressBit is set, it can
// safely use t.GetSuppressBit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressBit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) GetSuppressBit() bool {
	if t == nil || t.SuppressBit == nil {
		return false
	}
	return *t.SuppressBit
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.IgnoreBit == nil {
		var v bool = false
		t.IgnoreBit = &v
	}
	if t.SuppressBit == nil {
		var v bool = false
		t.SuppressBit = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit YANG schema element.
type NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit struct {
	AdvertiseHighMetric *bool                                                                                                             `path:"state/advertise-high-metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/advertise-high-metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ResetTrigger        map[E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE]*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger `path:"reset-triggers/reset-trigger" module:"openconfig-network-instance/openconfig-network-instance"`
	SetBit              *bool                                                                                                             `path:"state/set-bit" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/set-bit" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SetBitOnBoot        *bool                                                                                                             `path:"state/set-bit-on-boot" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/set-bit-on-boot" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) IsYANGGoStruct() {}

// NewResetTrigger creates a new entry in the ResetTrigger list of the
// NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) NewResetTrigger(ResetTrigger E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) (*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ResetTrigger == nil {
		t.ResetTrigger = make(map[E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE]*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
	}

	key := ResetTrigger

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ResetTrigger[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ResetTrigger", key)
	}

	t.ResetTrigger[key] = &NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
		ResetTrigger: ResetTrigger,
	}

	return t.ResetTrigger[key], nil
}

// RenameResetTrigger renames an entry in the list ResetTrigger within
// the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) RenameResetTrigger(oldK, newK E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) error {
	if _, ok := t.ResetTrigger[newK]; ok {
		return fmt.Errorf("key %v already exists in ResetTrigger", newK)
	}

	e, ok := t.ResetTrigger[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ResetTrigger", oldK)
	}
	e.ResetTrigger = newK

	t.ResetTrigger[newK] = e
	delete(t.ResetTrigger, oldK)
	return nil
}

// GetOrCreateResetTrigger retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetOrCreateResetTrigger(ResetTrigger E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {

	key := ResetTrigger

	if v, ok := t.ResetTrigger[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResetTrigger(ResetTrigger)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResetTrigger got unexpected error: %v", err))
	}
	return v
}

// GetResetTrigger retrieves the value with the specified key from
// the ResetTrigger map field of NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetResetTrigger(ResetTrigger E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {

	if t == nil {
		return nil
	}

	key := ResetTrigger

	if lm, ok := t.ResetTrigger[key]; ok {
		return lm
	}
	return nil
}

// DeleteResetTrigger deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) DeleteResetTrigger(ResetTrigger E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) {
	key := ResetTrigger

	delete(t.ResetTrigger, key)
}

// AppendResetTrigger appends the supplied NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger struct to the
// list ResetTrigger of NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) AppendResetTrigger(v *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) error {
	key := v.ResetTrigger

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ResetTrigger == nil {
		t.ResetTrigger = make(map[E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE]*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
	}

	if _, ok := t.ResetTrigger[key]; ok {
		return fmt.Errorf("duplicate key for list ResetTrigger %v", key)
	}

	t.ResetTrigger[key] = v
	return nil
}

// GetAdvertiseHighMetric retrieves the value of the leaf AdvertiseHighMetric from the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertiseHighMetric is set, it can
// safely use t.GetAdvertiseHighMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertiseHighMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetAdvertiseHighMetric() bool {
	if t == nil || t.AdvertiseHighMetric == nil {
		return false
	}
	return *t.AdvertiseHighMetric
}

// GetSetBit retrieves the value of the leaf SetBit from the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetBit is set, it can
// safely use t.GetSetBit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetBit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetSetBit() bool {
	if t == nil || t.SetBit == nil {
		return false
	}
	return *t.SetBit
}

// GetSetBitOnBoot retrieves the value of the leaf SetBitOnBoot from the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetBitOnBoot is set, it can
// safely use t.GetSetBitOnBoot() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetBitOnBoot == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) GetSetBitOnBoot() bool {
	if t == nil || t.SetBitOnBoot == nil {
		return false
	}
	return *t.SetBitOnBoot
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdvertiseHighMetric == nil {
		var v bool = false
		t.AdvertiseHighMetric = &v
	}
	if t.SetBit == nil {
		var v bool = false
		t.SetBit = &v
	}
	if t.SetBitOnBoot == nil {
		var v bool = false
		t.SetBitOnBoot = &v
	}
	for _, e := range t.ResetTrigger {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger YANG schema element.
type NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger struct {
	Delay        *uint16                                 `path:"state/delay" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/delay" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ResetTrigger E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE `path:"state/reset-trigger|reset-trigger" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/reset-trigger|reset-trigger" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) IsYANGGoStruct() {}

// GetDelay retrieves the value of the leaf Delay from the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Delay is set, it can
// safely use t.GetDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Delay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) GetDelay() uint16 {
	if t == nil || t.Delay == nil {
		return 0
	}
	return *t.Delay
}

// GetResetTrigger retrieves the value of the leaf ResetTrigger from the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ResetTrigger is set, it can
// safely use t.GetResetTrigger() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ResetTrigger == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) GetResetTrigger() E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	if t == nil || t.ResetTrigger == 0 {
		return 0
	}
	return t.ResetTrigger
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"reset-trigger": t.ResetTrigger,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Mpls represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Mpls struct {
	IgpLdpSync *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync `path:"igp-ldp-sync" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Mpls) IsYANGGoStruct() {}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	if t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	t.IgpLdpSync = &NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	return t.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Isis_Global_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	if t != nil && t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IgpLdpSync.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync struct {
	Enabled            *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PostSessionUpDelay *uint16 `path:"state/post-session-up-delay" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/post-session-up-delay" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetPostSessionUpDelay retrieves the value of the leaf PostSessionUpDelay from the NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PostSessionUpDelay is set, it can
// safely use t.GetPostSessionUpDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PostSessionUpDelay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) GetPostSessionUpDelay() uint16 {
	if t == nil || t.PostSessionUpDelay == nil {
		return 0
	}
	return *t.PostSessionUpDelay
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Nsr represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Nsr struct {
	Enabled *bool `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Nsr implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Nsr) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Global_Nsr
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Nsr) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Nsr
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Nsr) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Nsr) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Nsr"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Nsr) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth YANG schema element.
type NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth struct {
	ReferenceBandwidth *uint32 `path:"state/reference-bandwidth" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/reference-bandwidth" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) IsYANGGoStruct() {}

// GetReferenceBandwidth retrieves the value of the leaf ReferenceBandwidth from the NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReferenceBandwidth is set, it can
// safely use t.GetReferenceBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReferenceBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) GetReferenceBandwidth() uint32 {
	if t == nil || t.ReferenceBandwidth == nil {
		return 0
	}
	return *t.ReferenceBandwidth
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_SegmentRouting represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing YANG schema element.
type NetworkInstance_Protocol_Isis_Global_SegmentRouting struct {
	Enabled *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Srgb    *string `path:"state/srgb" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/srgb" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Srlb    *string `path:"state/srlb" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/srlb" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_SegmentRouting implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_SegmentRouting) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Global_SegmentRouting
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetSrgb retrieves the value of the leaf Srgb from the NetworkInstance_Protocol_Isis_Global_SegmentRouting
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Srgb is set, it can
// safely use t.GetSrgb() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Srgb == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) GetSrgb() string {
	if t == nil || t.Srgb == nil {
		return ""
	}
	return *t.Srgb
}

// GetSrlb retrieves the value of the leaf Srlb from the NetworkInstance_Protocol_Isis_Global_SegmentRouting
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Srlb is set, it can
// safely use t.GetSrlb() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Srlb == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) GetSrlb() string {
	if t == nil || t.Srlb == nil {
		return ""
	}
	return *t.Srlb
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_SegmentRouting
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Timers represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Timers struct {
	LspGeneration       *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration `path:"lsp-generation" module:"openconfig-network-instance"`
	LspLifetimeInterval *uint16                                                    `path:"state/lsp-lifetime-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsp-lifetime-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspRefreshInterval  *uint16                                                    `path:"state/lsp-refresh-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsp-refresh-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Spf                 *NetworkInstance_Protocol_Isis_Global_Timers_Spf           `path:"spf" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Timers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Timers) IsYANGGoStruct() {}

// GetOrCreateLspGeneration retrieves the value of the LspGeneration field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetOrCreateLspGeneration() *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	if t.LspGeneration != nil {
		return t.LspGeneration
	}
	t.LspGeneration = &NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	return t.LspGeneration
}

// GetOrCreateSpf retrieves the value of the Spf field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetOrCreateSpf() *NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	if t.Spf != nil {
		return t.Spf
	}
	t.Spf = &NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	return t.Spf
}

// GetLspGeneration returns the value of the LspGeneration struct pointer
// from NetworkInstance_Protocol_Isis_Global_Timers. If the receiver or the field LspGeneration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetLspGeneration() *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	if t != nil && t.LspGeneration != nil {
		return t.LspGeneration
	}
	return nil
}

// GetSpf returns the value of the Spf struct pointer
// from NetworkInstance_Protocol_Isis_Global_Timers. If the receiver or the field Spf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetSpf() *NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	if t != nil && t.Spf != nil {
		return t.Spf
	}
	return nil
}

// GetLspLifetimeInterval retrieves the value of the leaf LspLifetimeInterval from the NetworkInstance_Protocol_Isis_Global_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspLifetimeInterval is set, it can
// safely use t.GetLspLifetimeInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspLifetimeInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetLspLifetimeInterval() uint16 {
	if t == nil || t.LspLifetimeInterval == nil {
		return 1200
	}
	return *t.LspLifetimeInterval
}

// GetLspRefreshInterval retrieves the value of the leaf LspRefreshInterval from the NetworkInstance_Protocol_Isis_Global_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspRefreshInterval is set, it can
// safely use t.GetLspRefreshInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspRefreshInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) GetLspRefreshInterval() uint16 {
	if t == nil || t.LspRefreshInterval == nil {
		return 0
	}
	return *t.LspRefreshInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Timers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.LspLifetimeInterval == nil {
		var v uint16 = 1200
		t.LspLifetimeInterval = &v
	}
	t.LspGeneration.PopulateDefaults()
	t.Spf.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration struct {
	AdaptiveTimer         E_IsisTypes_AdaptiveTimerType `path:"state/adaptive-timer" module:"openconfig-network-instance/openconfig-network-instance"`
	LspFirstWaitInterval  *uint64                       `path:"state/lsp-first-wait-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsp-first-wait-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspMaxWaitInterval    *uint64                       `path:"state/lsp-max-wait-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsp-max-wait-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspSecondWaitInterval *uint64                       `path:"state/lsp-second-wait-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsp-second-wait-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) IsYANGGoStruct() {}

// GetAdaptiveTimer retrieves the value of the leaf AdaptiveTimer from the NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdaptiveTimer is set, it can
// safely use t.GetAdaptiveTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdaptiveTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) GetAdaptiveTimer() E_IsisTypes_AdaptiveTimerType {
	if t == nil || t.AdaptiveTimer == 0 {
		return 0
	}
	return t.AdaptiveTimer
}

// GetLspFirstWaitInterval retrieves the value of the leaf LspFirstWaitInterval from the NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspFirstWaitInterval is set, it can
// safely use t.GetLspFirstWaitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspFirstWaitInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) GetLspFirstWaitInterval() uint64 {
	if t == nil || t.LspFirstWaitInterval == nil {
		return 0
	}
	return *t.LspFirstWaitInterval
}

// GetLspMaxWaitInterval retrieves the value of the leaf LspMaxWaitInterval from the NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspMaxWaitInterval is set, it can
// safely use t.GetLspMaxWaitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspMaxWaitInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) GetLspMaxWaitInterval() uint64 {
	if t == nil || t.LspMaxWaitInterval == nil {
		return 0
	}
	return *t.LspMaxWaitInterval
}

// GetLspSecondWaitInterval retrieves the value of the leaf LspSecondWaitInterval from the NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspSecondWaitInterval is set, it can
// safely use t.GetLspSecondWaitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspSecondWaitInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) GetLspSecondWaitInterval() uint64 {
	if t == nil || t.LspSecondWaitInterval == nil {
		return 0
	}
	return *t.LspSecondWaitInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Timers_Spf represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Timers_Spf struct {
	AdaptiveTimer     E_IsisTypes_AdaptiveTimerType `path:"state/adaptive-timer" module:"openconfig-network-instance/openconfig-network-instance"`
	SpfFirstInterval  *uint64                       `path:"state/spf-first-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/spf-first-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SpfHoldInterval   *uint64                       `path:"state/spf-hold-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/spf-hold-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SpfSecondInterval *uint64                       `path:"state/spf-second-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/spf-second-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Timers_Spf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Timers_Spf) IsYANGGoStruct() {}

// GetAdaptiveTimer retrieves the value of the leaf AdaptiveTimer from the NetworkInstance_Protocol_Isis_Global_Timers_Spf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdaptiveTimer is set, it can
// safely use t.GetAdaptiveTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdaptiveTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) GetAdaptiveTimer() E_IsisTypes_AdaptiveTimerType {
	if t == nil || t.AdaptiveTimer == 0 {
		return 0
	}
	return t.AdaptiveTimer
}

// GetSpfFirstInterval retrieves the value of the leaf SpfFirstInterval from the NetworkInstance_Protocol_Isis_Global_Timers_Spf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfFirstInterval is set, it can
// safely use t.GetSpfFirstInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfFirstInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) GetSpfFirstInterval() uint64 {
	if t == nil || t.SpfFirstInterval == nil {
		return 0
	}
	return *t.SpfFirstInterval
}

// GetSpfHoldInterval retrieves the value of the leaf SpfHoldInterval from the NetworkInstance_Protocol_Isis_Global_Timers_Spf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfHoldInterval is set, it can
// safely use t.GetSpfHoldInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfHoldInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) GetSpfHoldInterval() uint64 {
	if t == nil || t.SpfHoldInterval == nil {
		return 5000
	}
	return *t.SpfHoldInterval
}

// GetSpfSecondInterval retrieves the value of the leaf SpfSecondInterval from the NetworkInstance_Protocol_Isis_Global_Timers_Spf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfSecondInterval is set, it can
// safely use t.GetSpfSecondInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfSecondInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) GetSpfSecondInterval() uint64 {
	if t == nil || t.SpfSecondInterval == nil {
		return 0
	}
	return *t.SpfSecondInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Timers_Spf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SpfHoldInterval == nil {
		var v uint64 = 5000
		t.SpfHoldInterval = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Timers_Spf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Timers_Spf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Global_Transport represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport YANG schema element.
type NetworkInstance_Protocol_Isis_Global_Transport struct {
	LspMtuSize *uint16 `path:"state/lsp-mtu-size" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsp-mtu-size" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Global_Transport implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Global_Transport) IsYANGGoStruct() {}

// GetLspMtuSize retrieves the value of the leaf LspMtuSize from the NetworkInstance_Protocol_Isis_Global_Transport
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspMtuSize is set, it can
// safely use t.GetLspMtuSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspMtuSize == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Global_Transport) GetLspMtuSize() uint16 {
	if t == nil || t.LspMtuSize == nil {
		return 0
	}
	return *t.LspMtuSize
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Global_Transport
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Global_Transport) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Global_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Global_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Global_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface YANG schema element.
type NetworkInstance_Protocol_Isis_Interface struct {
	Af              map[NetworkInstance_Protocol_Isis_Interface_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Af `path:"afi-safi/af" module:"openconfig-network-instance/openconfig-network-instance"`
	Authentication  *NetworkInstance_Protocol_Isis_Interface_Authentication                                        `path:"authentication" module:"openconfig-network-instance"`
	Bfd             *NetworkInstance_Protocol_Isis_Interface_Bfd                                                   `path:"bfd" module:"openconfig-network-instance"`
	CircuitCounters *NetworkInstance_Protocol_Isis_Interface_CircuitCounters                                       `path:"circuit-counters" module:"openconfig-network-instance"`
	CircuitType     E_IsisTypes_CircuitType                                                                        `path:"state/circuit-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/circuit-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EnableBfd       *NetworkInstance_Protocol_Isis_Interface_EnableBfd                                             `path:"enable-bfd" module:"openconfig-network-instance"`
	Enabled         *bool                                                                                          `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloPadding    E_IsisTypes_HelloPaddingType                                                                   `path:"state/hello-padding" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-padding" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	InterfaceId     *string                                                                                        `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef    *NetworkInstance_Protocol_Isis_Interface_InterfaceRef                                          `path:"interface-ref" module:"openconfig-network-instance"`
	Level           map[uint8]*NetworkInstance_Protocol_Isis_Interface_Level                                       `path:"levels/level" module:"openconfig-network-instance/openconfig-network-instance"`
	Mpls            *NetworkInstance_Protocol_Isis_Interface_Mpls                                                  `path:"mpls" module:"openconfig-network-instance"`
	Passive         *bool                                                                                          `path:"state/passive" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/passive" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Timers          *NetworkInstance_Protocol_Isis_Interface_Timers                                                `path:"timers" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Isis_Interface_Af_Key represents the key for list Af of element /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface.
type NetworkInstance_Protocol_Isis_Interface_Af_Key struct {
	AfiName  E_IsisTypes_AFI_TYPE  `path:"afi-name"`
	SafiName E_IsisTypes_SAFI_TYPE `path:"safi-name"`
}

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface) NewAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Interface_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Af)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Interface_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Interface_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Af {

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// DeleteAf deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface) DeleteAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) {
	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	delete(t.Af, key)
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Interface_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface) AppendAf(v *NetworkInstance_Protocol_Isis_Interface_Af) error {
	key := NetworkInstance_Protocol_Isis_Interface_Af_Key{
		AfiName:  v.AfiName,
		SafiName: v.SafiName,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// NewLevel creates a new entry in the Level list of the
// NetworkInstance_Protocol_Isis_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface) NewLevel(LevelNumber uint8) (*NetworkInstance_Protocol_Isis_Interface_Level, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Interface_Level)
	}

	key := LevelNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Level[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Level", key)
	}

	t.Level[key] = &NetworkInstance_Protocol_Isis_Interface_Level{
		LevelNumber: &LevelNumber,
	}

	return t.Level[key], nil
}

// RenameLevel renames an entry in the list Level within
// the NetworkInstance_Protocol_Isis_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface) RenameLevel(oldK, newK uint8) error {
	if _, ok := t.Level[newK]; ok {
		return fmt.Errorf("key %v already exists in Level", newK)
	}

	e, ok := t.Level[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Level", oldK)
	}
	e.LevelNumber = &newK

	t.Level[newK] = e
	delete(t.Level, oldK)
	return nil
}

// GetOrCreateLevel retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Interface_Level {

	key := LevelNumber

	if v, ok := t.Level[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLevel(LevelNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLevel got unexpected error: %v", err))
	}
	return v
}

// GetLevel retrieves the value with the specified key from
// the Level map field of NetworkInstance_Protocol_Isis_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetLevel(LevelNumber uint8) *NetworkInstance_Protocol_Isis_Interface_Level {

	if t == nil {
		return nil
	}

	key := LevelNumber

	if lm, ok := t.Level[key]; ok {
		return lm
	}
	return nil
}

// DeleteLevel deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface) DeleteLevel(LevelNumber uint8) {
	key := LevelNumber

	delete(t.Level, key)
}

// AppendLevel appends the supplied NetworkInstance_Protocol_Isis_Interface_Level struct to the
// list Level of NetworkInstance_Protocol_Isis_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface) AppendLevel(v *NetworkInstance_Protocol_Isis_Interface_Level) error {
	if v.LevelNumber == nil {
		return fmt.Errorf("invalid nil key received for LevelNumber")
	}

	key := *v.LevelNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*NetworkInstance_Protocol_Isis_Interface_Level)
	}

	if _, ok := t.Level[key]; ok {
		return fmt.Errorf("duplicate key for list Level %v", key)
	}

	t.Level[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Interface_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Protocol_Isis_Interface_Authentication{}
	return t.Authentication
}

// GetOrCreateBfd retrieves the value of the Bfd field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateBfd() *NetworkInstance_Protocol_Isis_Interface_Bfd {
	if t.Bfd != nil {
		return t.Bfd
	}
	t.Bfd = &NetworkInstance_Protocol_Isis_Interface_Bfd{}
	return t.Bfd
}

// GetOrCreateCircuitCounters retrieves the value of the CircuitCounters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateCircuitCounters() *NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	if t.CircuitCounters != nil {
		return t.CircuitCounters
	}
	t.CircuitCounters = &NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	return t.CircuitCounters
}

// GetOrCreateEnableBfd retrieves the value of the EnableBfd field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateEnableBfd() *NetworkInstance_Protocol_Isis_Interface_EnableBfd {
	if t.EnableBfd != nil {
		return t.EnableBfd
	}
	t.EnableBfd = &NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	return t.EnableBfd
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateMpls() *NetworkInstance_Protocol_Isis_Interface_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Protocol_Isis_Interface_Mpls{}
	return t.Mpls
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Interface_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Isis_Interface_Timers{}
	return t.Timers
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetAuthentication() *NetworkInstance_Protocol_Isis_Interface_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetBfd returns the value of the Bfd struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Bfd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetBfd() *NetworkInstance_Protocol_Isis_Interface_Bfd {
	if t != nil && t.Bfd != nil {
		return t.Bfd
	}
	return nil
}

// GetCircuitCounters returns the value of the CircuitCounters struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field CircuitCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetCircuitCounters() *NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	if t != nil && t.CircuitCounters != nil {
		return t.CircuitCounters
	}
	return nil
}

// GetEnableBfd returns the value of the EnableBfd struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field EnableBfd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetEnableBfd() *NetworkInstance_Protocol_Isis_Interface_EnableBfd {
	if t != nil && t.EnableBfd != nil {
		return t.EnableBfd
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetInterfaceRef() *NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetMpls() *NetworkInstance_Protocol_Isis_Interface_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Interface. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface) GetTimers() *NetworkInstance_Protocol_Isis_Interface_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetCircuitType retrieves the value of the leaf CircuitType from the NetworkInstance_Protocol_Isis_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CircuitType is set, it can
// safely use t.GetCircuitType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CircuitType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface) GetCircuitType() E_IsisTypes_CircuitType {
	if t == nil || t.CircuitType == 0 {
		return 0
	}
	return t.CircuitType
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetHelloPadding retrieves the value of the leaf HelloPadding from the NetworkInstance_Protocol_Isis_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloPadding is set, it can
// safely use t.GetHelloPadding() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloPadding == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface) GetHelloPadding() E_IsisTypes_HelloPaddingType {
	if t == nil || t.HelloPadding == 0 {
		return 0
	}
	return t.HelloPadding
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Protocol_Isis_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetPassive retrieves the value of the leaf Passive from the NetworkInstance_Protocol_Isis_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Passive is set, it can
// safely use t.GetPassive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Passive == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface) GetPassive() bool {
	if t == nil || t.Passive == nil {
		return false
	}
	return *t.Passive
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	if t.Passive == nil {
		var v bool = false
		t.Passive = &v
	}
	t.Authentication.PopulateDefaults()
	t.Bfd.PopulateDefaults()
	t.CircuitCounters.PopulateDefaults()
	t.EnableBfd.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.Timers.PopulateDefaults()
	for _, e := range t.Af {
		e.PopulateDefaults()
	}
	for _, e := range t.Level {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Af represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Af struct {
	AfiName  E_IsisTypes_AFI_TYPE  `path:"state/afi-name|afi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-name|afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Enabled  *bool                 `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SafiName E_IsisTypes_SAFI_TYPE `path:"state/safi-name|safi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/safi-name|safi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Af implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Af) IsYANGGoStruct() {}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Protocol_Isis_Interface_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) GetAfiName() E_IsisTypes_AFI_TYPE {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetSafiName retrieves the value of the leaf SafiName from the NetworkInstance_Protocol_Isis_Interface_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SafiName is set, it can
// safely use t.GetSafiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SafiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) GetSafiName() E_IsisTypes_SAFI_TYPE {
	if t == nil || t.SafiName == 0 {
		return 0
	}
	return t.SafiName
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Af
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Af"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Authentication represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Authentication struct {
	Enabled  *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Keychain *string `path:"state/keychain" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/keychain" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Authentication) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetKeychain retrieves the value of the leaf Keychain from the NetworkInstance_Protocol_Isis_Interface_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Keychain is set, it can
// safely use t.GetKeychain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Keychain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) GetKeychain() string {
	if t == nil || t.Keychain == nil {
		return ""
	}
	return *t.Keychain
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Bfd represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Bfd struct {
	BfdTlv *bool `path:"state/bfd-tlv" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/bfd-tlv" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Bfd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Bfd) IsYANGGoStruct() {}

// GetBfdTlv retrieves the value of the leaf BfdTlv from the NetworkInstance_Protocol_Isis_Interface_Bfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BfdTlv is set, it can
// safely use t.GetBfdTlv() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BfdTlv == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Bfd) GetBfdTlv() bool {
	if t == nil || t.BfdTlv == nil {
		return false
	}
	return *t.BfdTlv
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Bfd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Bfd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Bfd) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Bfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Bfd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_CircuitCounters represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_CircuitCounters struct {
	AdjChanges               *uint32 `path:"state/adj-changes" module:"openconfig-network-instance/openconfig-network-instance"`
	AdjNumber                *uint32 `path:"state/adj-number" module:"openconfig-network-instance/openconfig-network-instance"`
	AuthFails                *uint32 `path:"state/auth-fails" module:"openconfig-network-instance/openconfig-network-instance"`
	AuthTypeFails            *uint32 `path:"state/auth-type-fails" module:"openconfig-network-instance/openconfig-network-instance"`
	IdFieldLenMismatches     *uint32 `path:"state/id-field-len-mismatches" module:"openconfig-network-instance/openconfig-network-instance"`
	InitFails                *uint32 `path:"state/init-fails" module:"openconfig-network-instance/openconfig-network-instance"`
	LanDisChanges            *uint32 `path:"state/lan-dis-changes" module:"openconfig-network-instance/openconfig-network-instance"`
	MaxAreaAddressMismatches *uint32 `path:"state/max-area-address-mismatches" module:"openconfig-network-instance/openconfig-network-instance"`
	RejectedAdj              *uint32 `path:"state/rejected-adj" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_CircuitCounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_CircuitCounters) IsYANGGoStruct() {}

// GetAdjChanges retrieves the value of the leaf AdjChanges from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjChanges is set, it can
// safely use t.GetAdjChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetAdjChanges() uint32 {
	if t == nil || t.AdjChanges == nil {
		return 0
	}
	return *t.AdjChanges
}

// GetAdjNumber retrieves the value of the leaf AdjNumber from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjNumber is set, it can
// safely use t.GetAdjNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetAdjNumber() uint32 {
	if t == nil || t.AdjNumber == nil {
		return 0
	}
	return *t.AdjNumber
}

// GetAuthFails retrieves the value of the leaf AuthFails from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthFails is set, it can
// safely use t.GetAuthFails() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthFails == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetAuthFails() uint32 {
	if t == nil || t.AuthFails == nil {
		return 0
	}
	return *t.AuthFails
}

// GetAuthTypeFails retrieves the value of the leaf AuthTypeFails from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthTypeFails is set, it can
// safely use t.GetAuthTypeFails() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthTypeFails == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetAuthTypeFails() uint32 {
	if t == nil || t.AuthTypeFails == nil {
		return 0
	}
	return *t.AuthTypeFails
}

// GetIdFieldLenMismatches retrieves the value of the leaf IdFieldLenMismatches from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IdFieldLenMismatches is set, it can
// safely use t.GetIdFieldLenMismatches() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IdFieldLenMismatches == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetIdFieldLenMismatches() uint32 {
	if t == nil || t.IdFieldLenMismatches == nil {
		return 0
	}
	return *t.IdFieldLenMismatches
}

// GetInitFails retrieves the value of the leaf InitFails from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InitFails is set, it can
// safely use t.GetInitFails() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InitFails == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetInitFails() uint32 {
	if t == nil || t.InitFails == nil {
		return 0
	}
	return *t.InitFails
}

// GetLanDisChanges retrieves the value of the leaf LanDisChanges from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LanDisChanges is set, it can
// safely use t.GetLanDisChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LanDisChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetLanDisChanges() uint32 {
	if t == nil || t.LanDisChanges == nil {
		return 0
	}
	return *t.LanDisChanges
}

// GetMaxAreaAddressMismatches retrieves the value of the leaf MaxAreaAddressMismatches from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxAreaAddressMismatches is set, it can
// safely use t.GetMaxAreaAddressMismatches() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxAreaAddressMismatches == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetMaxAreaAddressMismatches() uint32 {
	if t == nil || t.MaxAreaAddressMismatches == nil {
		return 0
	}
	return *t.MaxAreaAddressMismatches
}

// GetRejectedAdj retrieves the value of the leaf RejectedAdj from the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RejectedAdj is set, it can
// safely use t.GetRejectedAdj() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RejectedAdj == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) GetRejectedAdj() uint32 {
	if t == nil || t.RejectedAdj == nil {
		return 0
	}
	return *t.RejectedAdj
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_CircuitCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_CircuitCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_EnableBfd represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_EnableBfd struct {
	Enabled *bool `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_EnableBfd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_EnableBfd) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface_EnableBfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_EnableBfd) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_EnableBfd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_EnableBfd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_EnableBfd) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_EnableBfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_EnableBfd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Protocol_Isis_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Protocol_Isis_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level struct {
	Adjacency           map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency                                        `path:"adjacencies/adjacency" module:"openconfig-network-instance/openconfig-network-instance"`
	Af                  map[NetworkInstance_Protocol_Isis_Interface_Level_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af `path:"afi-safi/af" module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled             *bool                                                                                                      `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloAuthentication *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication                                         `path:"hello-authentication" module:"openconfig-network-instance"`
	LevelNumber         *uint8                                                                                                     `path:"state/level-number|level-number" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/level-number|level-number" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	PacketCounters      *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters                                              `path:"packet-counters" module:"openconfig-network-instance"`
	Passive             *bool                                                                                                      `path:"state/passive" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/passive" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Priority            *uint8                                                                                                     `path:"state/priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Timers              *NetworkInstance_Protocol_Isis_Interface_Level_Timers                                                      `path:"timers" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_Key represents the key for list Af of element /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level.
type NetworkInstance_Protocol_Isis_Interface_Level_Af_Key struct {
	AfiName  E_IsisTypes_AFI_TYPE  `path:"afi-name"`
	SafiName E_IsisTypes_SAFI_TYPE `path:"safi-name"`
}

// NewAdjacency creates a new entry in the Adjacency list of the
// NetworkInstance_Protocol_Isis_Interface_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) NewAdjacency(SystemId string) (*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adjacency == nil {
		t.Adjacency = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Adjacency[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Adjacency", key)
	}

	t.Adjacency[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
		SystemId: &SystemId,
	}

	return t.Adjacency[key], nil
}

// RenameAdjacency renames an entry in the list Adjacency within
// the NetworkInstance_Protocol_Isis_Interface_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) RenameAdjacency(oldK, newK string) error {
	if _, ok := t.Adjacency[newK]; ok {
		return fmt.Errorf("key %v already exists in Adjacency", newK)
	}

	e, ok := t.Adjacency[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Adjacency", oldK)
	}
	e.SystemId = &newK

	t.Adjacency[newK] = e
	delete(t.Adjacency, oldK)
	return nil
}

// GetOrCreateAdjacency retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateAdjacency(SystemId string) *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {

	key := SystemId

	if v, ok := t.Adjacency[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacency(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacency got unexpected error: %v", err))
	}
	return v
}

// GetAdjacency retrieves the value with the specified key from
// the Adjacency map field of NetworkInstance_Protocol_Isis_Interface_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetAdjacency(SystemId string) *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Adjacency[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacency deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) DeleteAdjacency(SystemId string) {
	key := SystemId

	delete(t.Adjacency, key)
}

// AppendAdjacency appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Adjacency struct to the
// list Adjacency of NetworkInstance_Protocol_Isis_Interface_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Adjacency already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) AppendAdjacency(v *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) error {
	if v.SystemId == nil {
		return fmt.Errorf("invalid nil key received for SystemId")
	}

	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adjacency == nil {
		t.Adjacency = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
	}

	if _, ok := t.Adjacency[key]; ok {
		return fmt.Errorf("duplicate key for list Adjacency %v", key)
	}

	t.Adjacency[key] = v
	return nil
}

// NewAf creates a new entry in the Af list of the
// NetworkInstance_Protocol_Isis_Interface_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) NewAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) (*NetworkInstance_Protocol_Isis_Interface_Level_Af, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Af[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Af", key)
	}

	t.Af[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	return t.Af[key], nil
}

// RenameAf renames an entry in the list Af within
// the NetworkInstance_Protocol_Isis_Interface_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) RenameAf(oldK, newK NetworkInstance_Protocol_Isis_Interface_Level_Af_Key) error {
	if _, ok := t.Af[newK]; ok {
		return fmt.Errorf("key %v already exists in Af", newK)
	}

	e, ok := t.Af[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Af", oldK)
	}
	e.AfiName = newK.AfiName
	e.SafiName = newK.SafiName

	t.Af[newK] = e
	delete(t.Af, oldK)
	return nil
}

// GetOrCreateAf retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Level_Af {

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if v, ok := t.Af[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAf(AfiName, SafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAf got unexpected error: %v", err))
	}
	return v
}

// GetAf retrieves the value with the specified key from
// the Af map field of NetworkInstance_Protocol_Isis_Interface_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) *NetworkInstance_Protocol_Isis_Interface_Level_Af {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	if lm, ok := t.Af[key]; ok {
		return lm
	}
	return nil
}

// DeleteAf deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) DeleteAf(AfiName E_IsisTypes_AFI_TYPE, SafiName E_IsisTypes_SAFI_TYPE) {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  AfiName,
		SafiName: SafiName,
	}

	delete(t.Af, key)
}

// AppendAf appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af struct to the
// list Af of NetworkInstance_Protocol_Isis_Interface_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) AppendAf(v *NetworkInstance_Protocol_Isis_Interface_Level_Af) error {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_Key{
		AfiName:  v.AfiName,
		SafiName: v.SafiName,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Af == nil {
		t.Af = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af)
	}

	if _, ok := t.Af[key]; ok {
		return fmt.Errorf("duplicate key for list Af %v", key)
	}

	t.Af[key] = v
	return nil
}

// GetOrCreateHelloAuthentication retrieves the value of the HelloAuthentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateHelloAuthentication() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	if t.HelloAuthentication != nil {
		return t.HelloAuthentication
	}
	t.HelloAuthentication = &NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	return t.HelloAuthentication
}

// GetOrCreatePacketCounters retrieves the value of the PacketCounters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreatePacketCounters() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	if t.PacketCounters != nil {
		return t.PacketCounters
	}
	t.PacketCounters = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	return t.PacketCounters
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetOrCreateTimers() *NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	return t.Timers
}

// GetHelloAuthentication returns the value of the HelloAuthentication struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field HelloAuthentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetHelloAuthentication() *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	if t != nil && t.HelloAuthentication != nil {
		return t.HelloAuthentication
	}
	return nil
}

// GetPacketCounters returns the value of the PacketCounters struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field PacketCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetPacketCounters() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	if t != nil && t.PacketCounters != nil {
		return t.PacketCounters
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetTimers() *NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetLevelNumber retrieves the value of the leaf LevelNumber from the NetworkInstance_Protocol_Isis_Interface_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LevelNumber is set, it can
// safely use t.GetLevelNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LevelNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetLevelNumber() uint8 {
	if t == nil || t.LevelNumber == nil {
		return 0
	}
	return *t.LevelNumber
}

// GetPassive retrieves the value of the leaf Passive from the NetworkInstance_Protocol_Isis_Interface_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Passive is set, it can
// safely use t.GetPassive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Passive == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetPassive() bool {
	if t == nil || t.Passive == nil {
		return false
	}
	return *t.Passive
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_Protocol_Isis_Interface_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	if t.Passive == nil {
		var v bool = false
		t.Passive = &v
	}
	t.HelloAuthentication.PopulateDefaults()
	t.PacketCounters.PopulateDefaults()
	t.Timers.PopulateDefaults()
	for _, e := range t.Adjacency {
		e.PopulateDefaults()
	}
	for _, e := range t.Af {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LevelNumber == nil {
		return nil, fmt.Errorf("nil value for key LevelNumber")
	}

	return map[string]interface{}{
		"level-number": *t.LevelNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_Adjacency represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_Adjacency struct {
	AdjacencyState            E_IsisTypes_IsisInterfaceAdjState `path:"state/adjacency-state" module:"openconfig-network-instance/openconfig-network-instance"`
	AdjacencyType             E_IsisTypes_LevelType             `path:"state/adjacency-type" module:"openconfig-network-instance/openconfig-network-instance"`
	AreaAddress               []string                          `path:"state/area-address" module:"openconfig-network-instance/openconfig-network-instance"`
	DisSystemId               *string                           `path:"state/dis-system-id" module:"openconfig-network-instance/openconfig-network-instance"`
	LocalExtendedCircuitId    *uint32                           `path:"state/local-extended-circuit-id" module:"openconfig-network-instance/openconfig-network-instance"`
	MultiTopology             *bool                             `path:"state/multi-topology" module:"openconfig-network-instance/openconfig-network-instance"`
	NeighborCircuitType       E_IsisTypes_LevelType             `path:"state/neighbor-circuit-type" module:"openconfig-network-instance/openconfig-network-instance"`
	NeighborExtendedCircuitId *uint32                           `path:"state/neighbor-extended-circuit-id" module:"openconfig-network-instance/openconfig-network-instance"`
	NeighborIpv4Address       *string                           `path:"state/neighbor-ipv4-address" module:"openconfig-network-instance/openconfig-network-instance"`
	NeighborIpv6Address       *string                           `path:"state/neighbor-ipv6-address" module:"openconfig-network-instance/openconfig-network-instance"`
	NeighborSnpa              *string                           `path:"state/neighbor-snpa" module:"openconfig-network-instance/openconfig-network-instance"`
	Nlpid                     []E_Adjacency_Nlpid               `path:"state/nlpid" module:"openconfig-network-instance/openconfig-network-instance"`
	Priority                  *uint8                            `path:"state/priority" module:"openconfig-network-instance/openconfig-network-instance"`
	RestartStatus             *bool                             `path:"state/restart-status" module:"openconfig-network-instance/openconfig-network-instance"`
	RestartSupport            *bool                             `path:"state/restart-support" module:"openconfig-network-instance/openconfig-network-instance"`
	RestartSuppress           *bool                             `path:"state/restart-suppress" module:"openconfig-network-instance/openconfig-network-instance"`
	SystemId                  *string                           `path:"state/system-id|system-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"system-id" shadow-module:"openconfig-network-instance"`
	Topology                  []E_IsisTypes_AFI_SAFI_TYPE       `path:"state/topology" module:"openconfig-network-instance/openconfig-network-instance"`
	UpTimestamp               *uint64                           `path:"state/up-timestamp" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_Adjacency implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) IsYANGGoStruct() {}

// GetAdjacencyState retrieves the value of the leaf AdjacencyState from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjacencyState is set, it can
// safely use t.GetAdjacencyState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjacencyState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetAdjacencyState() E_IsisTypes_IsisInterfaceAdjState {
	if t == nil || t.AdjacencyState == 0 {
		return 0
	}
	return t.AdjacencyState
}

// GetAdjacencyType retrieves the value of the leaf AdjacencyType from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjacencyType is set, it can
// safely use t.GetAdjacencyType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjacencyType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetAdjacencyType() E_IsisTypes_LevelType {
	if t == nil || t.AdjacencyType == 0 {
		return 0
	}
	return t.AdjacencyType
}

// GetAreaAddress retrieves the value of the leaf AreaAddress from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AreaAddress is set, it can
// safely use t.GetAreaAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AreaAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetAreaAddress() []string {
	if t == nil || t.AreaAddress == nil {
		return nil
	}
	return t.AreaAddress
}

// GetDisSystemId retrieves the value of the leaf DisSystemId from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisSystemId is set, it can
// safely use t.GetDisSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisSystemId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetDisSystemId() string {
	if t == nil || t.DisSystemId == nil {
		return ""
	}
	return *t.DisSystemId
}

// GetLocalExtendedCircuitId retrieves the value of the leaf LocalExtendedCircuitId from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalExtendedCircuitId is set, it can
// safely use t.GetLocalExtendedCircuitId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalExtendedCircuitId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetLocalExtendedCircuitId() uint32 {
	if t == nil || t.LocalExtendedCircuitId == nil {
		return 0
	}
	return *t.LocalExtendedCircuitId
}

// GetMultiTopology retrieves the value of the leaf MultiTopology from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MultiTopology is set, it can
// safely use t.GetMultiTopology() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MultiTopology == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetMultiTopology() bool {
	if t == nil || t.MultiTopology == nil {
		return false
	}
	return *t.MultiTopology
}

// GetNeighborCircuitType retrieves the value of the leaf NeighborCircuitType from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborCircuitType is set, it can
// safely use t.GetNeighborCircuitType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborCircuitType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetNeighborCircuitType() E_IsisTypes_LevelType {
	if t == nil || t.NeighborCircuitType == 0 {
		return 0
	}
	return t.NeighborCircuitType
}

// GetNeighborExtendedCircuitId retrieves the value of the leaf NeighborExtendedCircuitId from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborExtendedCircuitId is set, it can
// safely use t.GetNeighborExtendedCircuitId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborExtendedCircuitId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetNeighborExtendedCircuitId() uint32 {
	if t == nil || t.NeighborExtendedCircuitId == nil {
		return 0
	}
	return *t.NeighborExtendedCircuitId
}

// GetNeighborIpv4Address retrieves the value of the leaf NeighborIpv4Address from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborIpv4Address is set, it can
// safely use t.GetNeighborIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborIpv4Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetNeighborIpv4Address() string {
	if t == nil || t.NeighborIpv4Address == nil {
		return ""
	}
	return *t.NeighborIpv4Address
}

// GetNeighborIpv6Address retrieves the value of the leaf NeighborIpv6Address from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborIpv6Address is set, it can
// safely use t.GetNeighborIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborIpv6Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetNeighborIpv6Address() string {
	if t == nil || t.NeighborIpv6Address == nil {
		return ""
	}
	return *t.NeighborIpv6Address
}

// GetNeighborSnpa retrieves the value of the leaf NeighborSnpa from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborSnpa is set, it can
// safely use t.GetNeighborSnpa() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborSnpa == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetNeighborSnpa() string {
	if t == nil || t.NeighborSnpa == nil {
		return ""
	}
	return *t.NeighborSnpa
}

// GetNlpid retrieves the value of the leaf Nlpid from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Nlpid is set, it can
// safely use t.GetNlpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Nlpid == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetNlpid() []E_Adjacency_Nlpid {
	if t == nil || t.Nlpid == nil {
		return nil
	}
	return t.Nlpid
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// GetRestartStatus retrieves the value of the leaf RestartStatus from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RestartStatus is set, it can
// safely use t.GetRestartStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RestartStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetRestartStatus() bool {
	if t == nil || t.RestartStatus == nil {
		return false
	}
	return *t.RestartStatus
}

// GetRestartSupport retrieves the value of the leaf RestartSupport from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RestartSupport is set, it can
// safely use t.GetRestartSupport() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RestartSupport == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetRestartSupport() bool {
	if t == nil || t.RestartSupport == nil {
		return false
	}
	return *t.RestartSupport
}

// GetRestartSuppress retrieves the value of the leaf RestartSuppress from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RestartSuppress is set, it can
// safely use t.GetRestartSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RestartSuppress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetRestartSuppress() bool {
	if t == nil || t.RestartSuppress == nil {
		return false
	}
	return *t.RestartSuppress
}

// GetSystemId retrieves the value of the leaf SystemId from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetTopology retrieves the value of the leaf Topology from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Topology is set, it can
// safely use t.GetTopology() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Topology == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetTopology() []E_IsisTypes_AFI_SAFI_TYPE {
	if t == nil || t.Topology == nil {
		return nil
	}
	return t.Topology
}

// GetUpTimestamp retrieves the value of the leaf UpTimestamp from the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpTimestamp is set, it can
// safely use t.GetUpTimestamp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpTimestamp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) GetUpTimestamp() uint64 {
	if t == nil || t.UpTimestamp == nil {
		return 0
	}
	return *t.UpTimestamp
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Adjacency struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Adjacency"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_Af represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_Af struct {
	AfiName        E_IsisTypes_AFI_TYPE                                             `path:"state/afi-name|afi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-name|afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Enabled        *bool                                                            `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Metric         *uint32                                                          `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SafiName       E_IsisTypes_SAFI_TYPE                                            `path:"state/safi-name|safi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/safi-name|safi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	SegmentRouting *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting `path:"segment-routing" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_Af implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_Af) IsYANGGoStruct() {}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetOrCreateSegmentRouting() *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	return t.SegmentRouting
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_Af. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetSegmentRouting() *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Protocol_Isis_Interface_Level_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetAfiName() E_IsisTypes_AFI_TYPE {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface_Level_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Protocol_Isis_Interface_Level_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetMetric() uint32 {
	if t == nil || t.Metric == nil {
		return 10
	}
	return *t.Metric
}

// GetSafiName retrieves the value of the leaf SafiName from the NetworkInstance_Protocol_Isis_Interface_Level_Af
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SafiName is set, it can
// safely use t.GetSafiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SafiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) GetSafiName() E_IsisTypes_SAFI_TYPE {
	if t == nil || t.SafiName == 0 {
		return 0
	}
	return t.SafiName
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_Af
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Metric == nil {
		var v uint32 = 10
		t.Metric = &v
	}
	t.SegmentRouting.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name":  t.AfiName,
		"safi-name": t.SafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct {
	AdjacencySid map[NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid `path:"adjacency-sids/adjacency-sid" module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixSid    map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid                                                                              `path:"prefix-sids/prefix-sid" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key represents the key for list AdjacencySid of element /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing.
type NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key struct {
	Neighbor string                                                                                   `path:"neighbor"`
	SidId    NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union `path:"sid-id"`
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) NewAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
		Neighbor: &Neighbor,
		SidId:    SidId,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) RenameAdjacencySid(oldK, newK NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Neighbor = &newK.Neighbor
	e.SidId = newK.SidId

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetOrCreateAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Neighbor, SidId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) DeleteAdjacencySid(Neighbor string, SidId NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) {
	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: Neighbor,
		SidId:    SidId,
	}

	delete(t.AdjacencySid, key)
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) error {
	if v.Neighbor == nil {
		return fmt.Errorf("invalid nil key for Neighbor")
	}

	key := NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key{
		Neighbor: *v.Neighbor,
		SidId:    v.SidId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_Key]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) NewPrefixSid(Prefix string) (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
		Prefix: &Prefix,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) RenamePrefixSid(oldK, newK string) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Prefix = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetOrCreatePrefixSid(Prefix string) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {

	key := Prefix

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) GetPrefixSid(Prefix string) *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) DeletePrefixSid(Prefix string) {
	key := Prefix

	delete(t.PrefixSid, key)
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[string]*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AdjacencySid {
		e.PopulateDefaults()
	}
	for _, e := range t.PrefixSid {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid struct {
	AllocatedDynamicLocal NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union `path:"state/allocated-dynamic-local" module:"openconfig-network-instance/openconfig-network-instance"`
	Group                 *bool                                                                                                    `path:"state/group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Neighbor              *string                                                                                                  `path:"state/neighbor|neighbor" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/neighbor|neighbor" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ProtectionEligible    *bool                                                                                                    `path:"state/protection-eligible" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/protection-eligible" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SidId                 NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union                 `path:"state/sid-id|sid-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/sid-id|sid-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) IsYANGGoStruct() {
}

// GetAllocatedDynamicLocal retrieves the value of the leaf AllocatedDynamicLocal from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllocatedDynamicLocal is set, it can
// safely use t.GetAllocatedDynamicLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllocatedDynamicLocal == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) GetAllocatedDynamicLocal() NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	if t == nil || t.AllocatedDynamicLocal == nil {
		return nil
	}
	return t.AllocatedDynamicLocal
}

// GetGroup retrieves the value of the leaf Group from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Group is set, it can
// safely use t.GetGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Group == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) GetGroup() bool {
	if t == nil || t.Group == nil {
		return false
	}
	return *t.Group
}

// GetNeighbor retrieves the value of the leaf Neighbor from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Neighbor is set, it can
// safely use t.GetNeighbor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Neighbor == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) GetNeighbor() string {
	if t == nil || t.Neighbor == nil {
		return ""
	}
	return *t.Neighbor
}

// GetProtectionEligible retrieves the value of the leaf ProtectionEligible from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionEligible is set, it can
// safely use t.GetProtectionEligible() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionEligible == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) GetProtectionEligible() bool {
	if t == nil || t.ProtectionEligible == nil {
		return true
	}
	return *t.ProtectionEligible
}

// GetSidId retrieves the value of the leaf SidId from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidId is set, it can
// safely use t.GetSidId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) GetSidId() NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	if t == nil || t.SidId == nil {
		return nil
	}
	return t.SidId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Group == nil {
		var v bool = false
		t.Group = &v
	}
	if t.ProtectionEligible == nil {
		var v bool = true
		t.ProtectionEligible = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"sid-id":   t.SidId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid struct {
	LabelOptions E_PrefixSid_LabelOptions                                                              `path:"state/label-options" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/label-options" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix       *string                                                                               `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/prefix|prefix" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	SidId        NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union `path:"state/sid-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/sid-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) IsYANGGoStruct() {}

// GetLabelOptions retrieves the value of the leaf LabelOptions from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelOptions is set, it can
// safely use t.GetLabelOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelOptions == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) GetLabelOptions() E_PrefixSid_LabelOptions {
	if t == nil || t.LabelOptions == 0 {
		return 0
	}
	return t.LabelOptions
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetSidId retrieves the value of the leaf SidId from the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidId is set, it can
// safely use t.GetSidId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) GetSidId() NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	if t == nil || t.SidId == nil {
		return nil
	}
	return t.SidId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication struct {
	Enabled  *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Keychain *string `path:"state/keychain" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/keychain" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetKeychain retrieves the value of the leaf Keychain from the NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Keychain is set, it can
// safely use t.GetKeychain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Keychain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) GetKeychain() string {
	if t == nil || t.Keychain == nil {
		return ""
	}
	return *t.Keychain
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters struct {
	Csnp    *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp    `path:"csnp" module:"openconfig-network-instance"`
	Esh     *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh     `path:"esh" module:"openconfig-network-instance"`
	Iih     *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih     `path:"iih" module:"openconfig-network-instance"`
	Ish     *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish     `path:"ish" module:"openconfig-network-instance"`
	Lsp     *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp     `path:"lsp" module:"openconfig-network-instance"`
	Psnp    *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp    `path:"psnp" module:"openconfig-network-instance"`
	Unknown *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown `path:"unknown" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) IsYANGGoStruct() {}

// GetOrCreateCsnp retrieves the value of the Csnp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateCsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	if t.Csnp != nil {
		return t.Csnp
	}
	t.Csnp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	return t.Csnp
}

// GetOrCreateEsh retrieves the value of the Esh field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateEsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	if t.Esh != nil {
		return t.Esh
	}
	t.Esh = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	return t.Esh
}

// GetOrCreateIih retrieves the value of the Iih field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateIih() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	if t.Iih != nil {
		return t.Iih
	}
	t.Iih = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	return t.Iih
}

// GetOrCreateIsh retrieves the value of the Ish field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateIsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	if t.Ish != nil {
		return t.Ish
	}
	t.Ish = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	return t.Ish
}

// GetOrCreateLsp retrieves the value of the Lsp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateLsp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	if t.Lsp != nil {
		return t.Lsp
	}
	t.Lsp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	return t.Lsp
}

// GetOrCreatePsnp retrieves the value of the Psnp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreatePsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	if t.Psnp != nil {
		return t.Psnp
	}
	t.Psnp = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	return t.Psnp
}

// GetOrCreateUnknown retrieves the value of the Unknown field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetOrCreateUnknown() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	if t.Unknown != nil {
		return t.Unknown
	}
	t.Unknown = &NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	return t.Unknown
}

// GetCsnp returns the value of the Csnp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Csnp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetCsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	if t != nil && t.Csnp != nil {
		return t.Csnp
	}
	return nil
}

// GetEsh returns the value of the Esh struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Esh is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetEsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	if t != nil && t.Esh != nil {
		return t.Esh
	}
	return nil
}

// GetIih returns the value of the Iih struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Iih is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetIih() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	if t != nil && t.Iih != nil {
		return t.Iih
	}
	return nil
}

// GetIsh returns the value of the Ish struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Ish is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetIsh() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	if t != nil && t.Ish != nil {
		return t.Ish
	}
	return nil
}

// GetLsp returns the value of the Lsp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Lsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetLsp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	if t != nil && t.Lsp != nil {
		return t.Lsp
	}
	return nil
}

// GetPsnp returns the value of the Psnp struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Psnp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetPsnp() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	if t != nil && t.Psnp != nil {
		return t.Psnp
	}
	return nil
}

// GetUnknown returns the value of the Unknown struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters. If the receiver or the field Unknown is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) GetUnknown() *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	if t != nil && t.Unknown != nil {
		return t.Unknown
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Csnp.PopulateDefaults()
	t.Esh.PopulateDefaults()
	t.Iih.PopulateDefaults()
	t.Ish.PopulateDefaults()
	t.Lsp.PopulateDefaults()
	t.Psnp.PopulateDefaults()
	t.Unknown.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp struct {
	Dropped    *uint32 `path:"state/dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	Processed  *uint32 `path:"state/processed" module:"openconfig-network-instance/openconfig-network-instance"`
	Received   *uint32 `path:"state/received" module:"openconfig-network-instance/openconfig-network-instance"`
	Retransmit *uint32 `path:"state/retransmit" module:"openconfig-network-instance/openconfig-network-instance"`
	Sent       *uint32 `path:"state/sent" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) IsYANGGoStruct() {}

// GetDropped retrieves the value of the leaf Dropped from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropped is set, it can
// safely use t.GetDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) GetDropped() uint32 {
	if t == nil || t.Dropped == nil {
		return 0
	}
	return *t.Dropped
}

// GetProcessed retrieves the value of the leaf Processed from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Processed is set, it can
// safely use t.GetProcessed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Processed == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) GetProcessed() uint32 {
	if t == nil || t.Processed == nil {
		return 0
	}
	return *t.Processed
}

// GetReceived retrieves the value of the leaf Received from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Received is set, it can
// safely use t.GetReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Received == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) GetReceived() uint32 {
	if t == nil || t.Received == nil {
		return 0
	}
	return *t.Received
}

// GetRetransmit retrieves the value of the leaf Retransmit from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retransmit is set, it can
// safely use t.GetRetransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retransmit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) GetRetransmit() uint32 {
	if t == nil || t.Retransmit == nil {
		return 0
	}
	return *t.Retransmit
}

// GetSent retrieves the value of the leaf Sent from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sent is set, it can
// safely use t.GetSent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) GetSent() uint32 {
	if t == nil || t.Sent == nil {
		return 0
	}
	return *t.Sent
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh struct {
	Dropped    *uint32 `path:"state/dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	Processed  *uint32 `path:"state/processed" module:"openconfig-network-instance/openconfig-network-instance"`
	Received   *uint32 `path:"state/received" module:"openconfig-network-instance/openconfig-network-instance"`
	Retransmit *uint32 `path:"state/retransmit" module:"openconfig-network-instance/openconfig-network-instance"`
	Sent       *uint32 `path:"state/sent" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) IsYANGGoStruct() {}

// GetDropped retrieves the value of the leaf Dropped from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropped is set, it can
// safely use t.GetDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) GetDropped() uint32 {
	if t == nil || t.Dropped == nil {
		return 0
	}
	return *t.Dropped
}

// GetProcessed retrieves the value of the leaf Processed from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Processed is set, it can
// safely use t.GetProcessed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Processed == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) GetProcessed() uint32 {
	if t == nil || t.Processed == nil {
		return 0
	}
	return *t.Processed
}

// GetReceived retrieves the value of the leaf Received from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Received is set, it can
// safely use t.GetReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Received == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) GetReceived() uint32 {
	if t == nil || t.Received == nil {
		return 0
	}
	return *t.Received
}

// GetRetransmit retrieves the value of the leaf Retransmit from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retransmit is set, it can
// safely use t.GetRetransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retransmit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) GetRetransmit() uint32 {
	if t == nil || t.Retransmit == nil {
		return 0
	}
	return *t.Retransmit
}

// GetSent retrieves the value of the leaf Sent from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sent is set, it can
// safely use t.GetSent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) GetSent() uint32 {
	if t == nil || t.Sent == nil {
		return 0
	}
	return *t.Sent
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih struct {
	Dropped    *uint32 `path:"state/dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	Processed  *uint32 `path:"state/processed" module:"openconfig-network-instance/openconfig-network-instance"`
	Received   *uint32 `path:"state/received" module:"openconfig-network-instance/openconfig-network-instance"`
	Retransmit *uint32 `path:"state/retransmit" module:"openconfig-network-instance/openconfig-network-instance"`
	Sent       *uint32 `path:"state/sent" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) IsYANGGoStruct() {}

// GetDropped retrieves the value of the leaf Dropped from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropped is set, it can
// safely use t.GetDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) GetDropped() uint32 {
	if t == nil || t.Dropped == nil {
		return 0
	}
	return *t.Dropped
}

// GetProcessed retrieves the value of the leaf Processed from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Processed is set, it can
// safely use t.GetProcessed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Processed == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) GetProcessed() uint32 {
	if t == nil || t.Processed == nil {
		return 0
	}
	return *t.Processed
}

// GetReceived retrieves the value of the leaf Received from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Received is set, it can
// safely use t.GetReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Received == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) GetReceived() uint32 {
	if t == nil || t.Received == nil {
		return 0
	}
	return *t.Received
}

// GetRetransmit retrieves the value of the leaf Retransmit from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retransmit is set, it can
// safely use t.GetRetransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retransmit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) GetRetransmit() uint32 {
	if t == nil || t.Retransmit == nil {
		return 0
	}
	return *t.Retransmit
}

// GetSent retrieves the value of the leaf Sent from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sent is set, it can
// safely use t.GetSent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) GetSent() uint32 {
	if t == nil || t.Sent == nil {
		return 0
	}
	return *t.Sent
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish struct {
	Dropped    *uint32 `path:"state/dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	Processed  *uint32 `path:"state/processed" module:"openconfig-network-instance/openconfig-network-instance"`
	Received   *uint32 `path:"state/received" module:"openconfig-network-instance/openconfig-network-instance"`
	Retransmit *uint32 `path:"state/retransmit" module:"openconfig-network-instance/openconfig-network-instance"`
	Sent       *uint32 `path:"state/sent" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) IsYANGGoStruct() {}

// GetDropped retrieves the value of the leaf Dropped from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropped is set, it can
// safely use t.GetDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) GetDropped() uint32 {
	if t == nil || t.Dropped == nil {
		return 0
	}
	return *t.Dropped
}

// GetProcessed retrieves the value of the leaf Processed from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Processed is set, it can
// safely use t.GetProcessed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Processed == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) GetProcessed() uint32 {
	if t == nil || t.Processed == nil {
		return 0
	}
	return *t.Processed
}

// GetReceived retrieves the value of the leaf Received from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Received is set, it can
// safely use t.GetReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Received == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) GetReceived() uint32 {
	if t == nil || t.Received == nil {
		return 0
	}
	return *t.Received
}

// GetRetransmit retrieves the value of the leaf Retransmit from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retransmit is set, it can
// safely use t.GetRetransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retransmit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) GetRetransmit() uint32 {
	if t == nil || t.Retransmit == nil {
		return 0
	}
	return *t.Retransmit
}

// GetSent retrieves the value of the leaf Sent from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sent is set, it can
// safely use t.GetSent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) GetSent() uint32 {
	if t == nil || t.Sent == nil {
		return 0
	}
	return *t.Sent
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp struct {
	Dropped    *uint32 `path:"state/dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	Processed  *uint32 `path:"state/processed" module:"openconfig-network-instance/openconfig-network-instance"`
	Received   *uint32 `path:"state/received" module:"openconfig-network-instance/openconfig-network-instance"`
	Retransmit *uint32 `path:"state/retransmit" module:"openconfig-network-instance/openconfig-network-instance"`
	Sent       *uint32 `path:"state/sent" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) IsYANGGoStruct() {}

// GetDropped retrieves the value of the leaf Dropped from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropped is set, it can
// safely use t.GetDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) GetDropped() uint32 {
	if t == nil || t.Dropped == nil {
		return 0
	}
	return *t.Dropped
}

// GetProcessed retrieves the value of the leaf Processed from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Processed is set, it can
// safely use t.GetProcessed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Processed == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) GetProcessed() uint32 {
	if t == nil || t.Processed == nil {
		return 0
	}
	return *t.Processed
}

// GetReceived retrieves the value of the leaf Received from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Received is set, it can
// safely use t.GetReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Received == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) GetReceived() uint32 {
	if t == nil || t.Received == nil {
		return 0
	}
	return *t.Received
}

// GetRetransmit retrieves the value of the leaf Retransmit from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retransmit is set, it can
// safely use t.GetRetransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retransmit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) GetRetransmit() uint32 {
	if t == nil || t.Retransmit == nil {
		return 0
	}
	return *t.Retransmit
}

// GetSent retrieves the value of the leaf Sent from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sent is set, it can
// safely use t.GetSent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) GetSent() uint32 {
	if t == nil || t.Sent == nil {
		return 0
	}
	return *t.Sent
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp struct {
	Dropped    *uint32 `path:"state/dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	Processed  *uint32 `path:"state/processed" module:"openconfig-network-instance/openconfig-network-instance"`
	Received   *uint32 `path:"state/received" module:"openconfig-network-instance/openconfig-network-instance"`
	Retransmit *uint32 `path:"state/retransmit" module:"openconfig-network-instance/openconfig-network-instance"`
	Sent       *uint32 `path:"state/sent" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) IsYANGGoStruct() {}

// GetDropped retrieves the value of the leaf Dropped from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropped is set, it can
// safely use t.GetDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) GetDropped() uint32 {
	if t == nil || t.Dropped == nil {
		return 0
	}
	return *t.Dropped
}

// GetProcessed retrieves the value of the leaf Processed from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Processed is set, it can
// safely use t.GetProcessed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Processed == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) GetProcessed() uint32 {
	if t == nil || t.Processed == nil {
		return 0
	}
	return *t.Processed
}

// GetReceived retrieves the value of the leaf Received from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Received is set, it can
// safely use t.GetReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Received == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) GetReceived() uint32 {
	if t == nil || t.Received == nil {
		return 0
	}
	return *t.Received
}

// GetRetransmit retrieves the value of the leaf Retransmit from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retransmit is set, it can
// safely use t.GetRetransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retransmit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) GetRetransmit() uint32 {
	if t == nil || t.Retransmit == nil {
		return 0
	}
	return *t.Retransmit
}

// GetSent retrieves the value of the leaf Sent from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sent is set, it can
// safely use t.GetSent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) GetSent() uint32 {
	if t == nil || t.Sent == nil {
		return 0
	}
	return *t.Sent
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown struct {
	Dropped    *uint32 `path:"state/dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	Processed  *uint32 `path:"state/processed" module:"openconfig-network-instance/openconfig-network-instance"`
	Received   *uint32 `path:"state/received" module:"openconfig-network-instance/openconfig-network-instance"`
	Retransmit *uint32 `path:"state/retransmit" module:"openconfig-network-instance/openconfig-network-instance"`
	Sent       *uint32 `path:"state/sent" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) IsYANGGoStruct() {}

// GetDropped retrieves the value of the leaf Dropped from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropped is set, it can
// safely use t.GetDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) GetDropped() uint32 {
	if t == nil || t.Dropped == nil {
		return 0
	}
	return *t.Dropped
}

// GetProcessed retrieves the value of the leaf Processed from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Processed is set, it can
// safely use t.GetProcessed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Processed == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) GetProcessed() uint32 {
	if t == nil || t.Processed == nil {
		return 0
	}
	return *t.Processed
}

// GetReceived retrieves the value of the leaf Received from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Received is set, it can
// safely use t.GetReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Received == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) GetReceived() uint32 {
	if t == nil || t.Received == nil {
		return 0
	}
	return *t.Received
}

// GetRetransmit retrieves the value of the leaf Retransmit from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retransmit is set, it can
// safely use t.GetRetransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retransmit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) GetRetransmit() uint32 {
	if t == nil || t.Retransmit == nil {
		return 0
	}
	return *t.Retransmit
}

// GetSent retrieves the value of the leaf Sent from the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sent is set, it can
// safely use t.GetSent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) GetSent() uint32 {
	if t == nil || t.Sent == nil {
		return 0
	}
	return *t.Sent
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Level_Timers represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Level_Timers struct {
	HelloInterval   *uint32 `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloMultiplier *uint8  `path:"state/hello-multiplier" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-multiplier" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Level_Timers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Level_Timers) IsYANGGoStruct() {}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Protocol_Isis_Interface_Level_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) GetHelloInterval() uint32 {
	if t == nil || t.HelloInterval == nil {
		return 0
	}
	return *t.HelloInterval
}

// GetHelloMultiplier retrieves the value of the leaf HelloMultiplier from the NetworkInstance_Protocol_Isis_Interface_Level_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloMultiplier is set, it can
// safely use t.GetHelloMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloMultiplier == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) GetHelloMultiplier() uint8 {
	if t == nil || t.HelloMultiplier == nil {
		return 0
	}
	return *t.HelloMultiplier
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Level_Timers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Level_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Mpls represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Mpls struct {
	IgpLdpSync *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync `path:"igp-ldp-sync" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Mpls) IsYANGGoStruct() {}

// GetOrCreateIgpLdpSync retrieves the value of the IgpLdpSync field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls) GetOrCreateIgpLdpSync() *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	if t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	t.IgpLdpSync = &NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	return t.IgpLdpSync
}

// GetIgpLdpSync returns the value of the IgpLdpSync struct pointer
// from NetworkInstance_Protocol_Isis_Interface_Mpls. If the receiver or the field IgpLdpSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls) GetIgpLdpSync() *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	if t != nil && t.IgpLdpSync != nil {
		return t.IgpLdpSync
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IgpLdpSync.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync struct {
	Enabled            *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PostSessionUpDelay *uint16 `path:"state/post-session-up-delay" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/post-session-up-delay" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetPostSessionUpDelay retrieves the value of the leaf PostSessionUpDelay from the NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PostSessionUpDelay is set, it can
// safely use t.GetPostSessionUpDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PostSessionUpDelay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) GetPostSessionUpDelay() uint16 {
	if t == nil || t.PostSessionUpDelay == nil {
		return 0
	}
	return *t.PostSessionUpDelay
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Interface_Timers represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers YANG schema element.
type NetworkInstance_Protocol_Isis_Interface_Timers struct {
	CsnpInterval      *uint16 `path:"state/csnp-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/csnp-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LspPacingInterval *uint64 `path:"state/lsp-pacing-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsp-pacing-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Interface_Timers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Interface_Timers) IsYANGGoStruct() {}

// GetCsnpInterval retrieves the value of the leaf CsnpInterval from the NetworkInstance_Protocol_Isis_Interface_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CsnpInterval is set, it can
// safely use t.GetCsnpInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CsnpInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) GetCsnpInterval() uint16 {
	if t == nil || t.CsnpInterval == nil {
		return 0
	}
	return *t.CsnpInterval
}

// GetLspPacingInterval retrieves the value of the leaf LspPacingInterval from the NetworkInstance_Protocol_Isis_Interface_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspPacingInterval is set, it can
// safely use t.GetLspPacingInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspPacingInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) GetLspPacingInterval() uint64 {
	if t == nil || t.LspPacingInterval == nil {
		return 0
	}
	return *t.LspPacingInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Interface_Timers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Interface_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Interface_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level YANG schema element.
type NetworkInstance_Protocol_Isis_Level struct {
	Authentication      *NetworkInstance_Protocol_Isis_Level_Authentication      `path:"authentication" module:"openconfig-network-instance"`
	AuthenticationCheck *bool                                                    `path:"state/authentication-check" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/authentication-check" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled             *bool                                                    `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LevelNumber         *uint8                                                   `path:"state/level-number|level-number" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/level-number|level-number" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Lsp                 map[string]*NetworkInstance_Protocol_Isis_Level_Lsp      `path:"link-state-database/lsp" module:"openconfig-network-instance/openconfig-network-instance"`
	MetricStyle         E_IsisTypes_MetricStyle                                  `path:"state/metric-style" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric-style" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RoutePreference     *NetworkInstance_Protocol_Isis_Level_RoutePreference     `path:"route-preference" module:"openconfig-network-instance"`
	SystemLevelCounters *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters `path:"system-level-counters" module:"openconfig-network-instance"`
	TrafficEngineering  *NetworkInstance_Protocol_Isis_Level_TrafficEngineering  `path:"traffic-engineering" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level) IsYANGGoStruct() {}

// NewLsp creates a new entry in the Lsp list of the
// NetworkInstance_Protocol_Isis_Level struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level) NewLsp(LspId string) (*NetworkInstance_Protocol_Isis_Level_Lsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsp == nil {
		t.Lsp = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp)
	}

	key := LspId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lsp", key)
	}

	t.Lsp[key] = &NetworkInstance_Protocol_Isis_Level_Lsp{
		LspId: &LspId,
	}

	return t.Lsp[key], nil
}

// RenameLsp renames an entry in the list Lsp within
// the NetworkInstance_Protocol_Isis_Level struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level) RenameLsp(oldK, newK string) error {
	if _, ok := t.Lsp[newK]; ok {
		return fmt.Errorf("key %v already exists in Lsp", newK)
	}

	e, ok := t.Lsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lsp", oldK)
	}
	e.LspId = &newK

	t.Lsp[newK] = e
	delete(t.Lsp, oldK)
	return nil
}

// GetOrCreateLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateLsp(LspId string) *NetworkInstance_Protocol_Isis_Level_Lsp {

	key := LspId

	if v, ok := t.Lsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsp(LspId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsp got unexpected error: %v", err))
	}
	return v
}

// GetLsp retrieves the value with the specified key from
// the Lsp map field of NetworkInstance_Protocol_Isis_Level. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetLsp(LspId string) *NetworkInstance_Protocol_Isis_Level_Lsp {

	if t == nil {
		return nil
	}

	key := LspId

	if lm, ok := t.Lsp[key]; ok {
		return lm
	}
	return nil
}

// DeleteLsp deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level) DeleteLsp(LspId string) {
	key := LspId

	delete(t.Lsp, key)
}

// AppendLsp appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp struct to the
// list Lsp of NetworkInstance_Protocol_Isis_Level. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level) AppendLsp(v *NetworkInstance_Protocol_Isis_Level_Lsp) error {
	if v.LspId == nil {
		return fmt.Errorf("invalid nil key received for LspId")
	}

	key := *v.LspId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsp == nil {
		t.Lsp = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp)
	}

	if _, ok := t.Lsp[key]; ok {
		return fmt.Errorf("duplicate key for list Lsp %v", key)
	}

	t.Lsp[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Level_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Protocol_Isis_Level_Authentication{}
	return t.Authentication
}

// GetOrCreateRoutePreference retrieves the value of the RoutePreference field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateRoutePreference() *NetworkInstance_Protocol_Isis_Level_RoutePreference {
	if t.RoutePreference != nil {
		return t.RoutePreference
	}
	t.RoutePreference = &NetworkInstance_Protocol_Isis_Level_RoutePreference{}
	return t.RoutePreference
}

// GetOrCreateSystemLevelCounters retrieves the value of the SystemLevelCounters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateSystemLevelCounters() *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	if t.SystemLevelCounters != nil {
		return t.SystemLevelCounters
	}
	t.SystemLevelCounters = &NetworkInstance_Protocol_Isis_Level_SystemLevelCounters{}
	return t.SystemLevelCounters
}

// GetOrCreateTrafficEngineering retrieves the value of the TrafficEngineering field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level) GetOrCreateTrafficEngineering() *NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	if t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	t.TrafficEngineering = &NetworkInstance_Protocol_Isis_Level_TrafficEngineering{}
	return t.TrafficEngineering
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetAuthentication() *NetworkInstance_Protocol_Isis_Level_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetRoutePreference returns the value of the RoutePreference struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field RoutePreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetRoutePreference() *NetworkInstance_Protocol_Isis_Level_RoutePreference {
	if t != nil && t.RoutePreference != nil {
		return t.RoutePreference
	}
	return nil
}

// GetSystemLevelCounters returns the value of the SystemLevelCounters struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field SystemLevelCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetSystemLevelCounters() *NetworkInstance_Protocol_Isis_Level_SystemLevelCounters {
	if t != nil && t.SystemLevelCounters != nil {
		return t.SystemLevelCounters
	}
	return nil
}

// GetTrafficEngineering returns the value of the TrafficEngineering struct pointer
// from NetworkInstance_Protocol_Isis_Level. If the receiver or the field TrafficEngineering is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level) GetTrafficEngineering() *NetworkInstance_Protocol_Isis_Level_TrafficEngineering {
	if t != nil && t.TrafficEngineering != nil {
		return t.TrafficEngineering
	}
	return nil
}

// GetAuthenticationCheck retrieves the value of the leaf AuthenticationCheck from the NetworkInstance_Protocol_Isis_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationCheck is set, it can
// safely use t.GetAuthenticationCheck() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationCheck == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level) GetAuthenticationCheck() bool {
	if t == nil || t.AuthenticationCheck == nil {
		return true
	}
	return *t.AuthenticationCheck
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetLevelNumber retrieves the value of the leaf LevelNumber from the NetworkInstance_Protocol_Isis_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LevelNumber is set, it can
// safely use t.GetLevelNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LevelNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level) GetLevelNumber() uint8 {
	if t == nil || t.LevelNumber == nil {
		return 0
	}
	return *t.LevelNumber
}

// GetMetricStyle retrieves the value of the leaf MetricStyle from the NetworkInstance_Protocol_Isis_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricStyle is set, it can
// safely use t.GetMetricStyle() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricStyle == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level) GetMetricStyle() E_IsisTypes_MetricStyle {
	if t == nil || t.MetricStyle == 0 {
		return 0
	}
	return t.MetricStyle
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AuthenticationCheck == nil {
		var v bool = true
		t.AuthenticationCheck = &v
	}
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.Authentication.PopulateDefaults()
	t.RoutePreference.PopulateDefaults()
	t.SystemLevelCounters.PopulateDefaults()
	t.TrafficEngineering.PopulateDefaults()
	for _, e := range t.Lsp {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LevelNumber == nil {
		return nil, fmt.Errorf("nil value for key LevelNumber")
	}

	return map[string]interface{}{
		"level-number": *t.LevelNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Authentication represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Authentication struct {
	DisableCsnp *bool   `path:"state/disable-csnp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/disable-csnp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DisableLsp  *bool   `path:"state/disable-lsp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/disable-lsp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DisablePsnp *bool   `path:"state/disable-psnp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/disable-psnp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled     *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Keychain    *string `path:"state/keychain" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/keychain" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Authentication) IsYANGGoStruct() {}

// GetDisableCsnp retrieves the value of the leaf DisableCsnp from the NetworkInstance_Protocol_Isis_Level_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableCsnp is set, it can
// safely use t.GetDisableCsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableCsnp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetDisableCsnp() bool {
	if t == nil || t.DisableCsnp == nil {
		return false
	}
	return *t.DisableCsnp
}

// GetDisableLsp retrieves the value of the leaf DisableLsp from the NetworkInstance_Protocol_Isis_Level_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableLsp is set, it can
// safely use t.GetDisableLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableLsp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetDisableLsp() bool {
	if t == nil || t.DisableLsp == nil {
		return false
	}
	return *t.DisableLsp
}

// GetDisablePsnp retrieves the value of the leaf DisablePsnp from the NetworkInstance_Protocol_Isis_Level_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisablePsnp is set, it can
// safely use t.GetDisablePsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisablePsnp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetDisablePsnp() bool {
	if t == nil || t.DisablePsnp == nil {
		return false
	}
	return *t.DisablePsnp
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Isis_Level_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetKeychain retrieves the value of the leaf Keychain from the NetworkInstance_Protocol_Isis_Level_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Keychain is set, it can
// safely use t.GetKeychain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Keychain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) GetKeychain() string {
	if t == nil || t.Keychain == nil {
		return ""
	}
	return *t.Keychain
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DisableCsnp == nil {
		var v bool = false
		t.DisableCsnp = &v
	}
	if t.DisableLsp == nil {
		var v bool = false
		t.DisableLsp = &v
	}
	if t.DisablePsnp == nil {
		var v bool = false
		t.DisablePsnp = &v
	}
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp struct {
	Checksum             *uint16                                                                        `path:"state/checksum" module:"openconfig-network-instance/openconfig-network-instance"`
	Flags                []E_Lsp_Flags                                                                  `path:"state/flags" module:"openconfig-network-instance/openconfig-network-instance"`
	IdLength             *uint8                                                                         `path:"state/id-length" module:"openconfig-network-instance/openconfig-network-instance"`
	IsType               *uint8                                                                         `path:"state/is-type" module:"openconfig-network-instance/openconfig-network-instance"`
	LspId                *string                                                                        `path:"state/lsp-id|lsp-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"lsp-id" shadow-module:"openconfig-network-instance"`
	MaximumAreaAddresses *uint8                                                                         `path:"state/maximum-area-addresses" module:"openconfig-network-instance/openconfig-network-instance"`
	PduLength            *uint16                                                                        `path:"state/pdu-length" module:"openconfig-network-instance/openconfig-network-instance"`
	PduType              E_Lsp_PduType                                                                  `path:"state/pdu-type" module:"openconfig-network-instance/openconfig-network-instance"`
	RemainingLifetime    *uint16                                                                        `path:"state/remaining-lifetime" module:"openconfig-network-instance/openconfig-network-instance"`
	SequenceNumber       *uint32                                                                        `path:"state/sequence-number" module:"openconfig-network-instance/openconfig-network-instance"`
	Tlv                  map[E_IsisLsdbTypes_ISIS_TLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv `path:"tlvs/tlv" module:"openconfig-network-instance/openconfig-network-instance"`
	UndefinedTlv         map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv                `path:"undefined-tlvs/undefined-tlv" module:"openconfig-network-instance/openconfig-network-instance"`
	Version              *uint8                                                                         `path:"state/version" module:"openconfig-network-instance/openconfig-network-instance"`
	Version2             *uint8                                                                         `path:"state/version2" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp) IsYANGGoStruct() {}

// NewTlv creates a new entry in the Tlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) NewTlv(Type E_IsisLsdbTypes_ISIS_TLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[E_IsisLsdbTypes_ISIS_TLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
		Type: Type,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) RenameTlv(oldK, newK E_IsisLsdbTypes_ISIS_TLV_TYPE) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = newK

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetOrCreateTlv(Type E_IsisLsdbTypes_ISIS_TLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {

	key := Type

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of NetworkInstance_Protocol_Isis_Level_Lsp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetTlv(Type E_IsisLsdbTypes_ISIS_TLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteTlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) DeleteTlv(Type E_IsisLsdbTypes_ISIS_TLV_TYPE) {
	key := Type

	delete(t.Tlv, key)
}

// AppendTlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct to the
// list Tlv of NetworkInstance_Protocol_Isis_Level_Lsp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) AppendTlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[E_IsisLsdbTypes_ISIS_TLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// NewUndefinedTlv creates a new entry in the UndefinedTlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) NewUndefinedTlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedTlv == nil {
		t.UndefinedTlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedTlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedTlv", key)
	}

	t.UndefinedTlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv{
		Type: &Type,
	}

	return t.UndefinedTlv[key], nil
}

// RenameUndefinedTlv renames an entry in the list UndefinedTlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) RenameUndefinedTlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedTlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedTlv", newK)
	}

	e, ok := t.UndefinedTlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedTlv", oldK)
	}
	e.Type = &newK

	t.UndefinedTlv[newK] = e
	delete(t.UndefinedTlv, oldK)
	return nil
}

// GetOrCreateUndefinedTlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetOrCreateUndefinedTlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {

	key := Type

	if v, ok := t.UndefinedTlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedTlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedTlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedTlv retrieves the value with the specified key from
// the UndefinedTlv map field of NetworkInstance_Protocol_Isis_Level_Lsp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetUndefinedTlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedTlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedTlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) DeleteUndefinedTlv(Type uint8) {
	key := Type

	delete(t.UndefinedTlv, key)
}

// AppendUndefinedTlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv struct to the
// list UndefinedTlv of NetworkInstance_Protocol_Isis_Level_Lsp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) AppendUndefinedTlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key received for Type")
	}

	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedTlv == nil {
		t.UndefinedTlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_UndefinedTlv)
	}

	if _, ok := t.UndefinedTlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedTlv %v", key)
	}

	t.UndefinedTlv[key] = v
	return nil
}

// GetChecksum retrieves the value of the leaf Checksum from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Checksum is set, it can
// safely use t.GetChecksum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Checksum == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetChecksum() uint16 {
	if t == nil || t.Checksum == nil {
		return 0
	}
	return *t.Checksum
}

// GetFlags retrieves the value of the leaf Flags from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetFlags() []E_Lsp_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// GetIdLength retrieves the value of the leaf IdLength from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IdLength is set, it can
// safely use t.GetIdLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IdLength == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetIdLength() uint8 {
	if t == nil || t.IdLength == nil {
		return 0
	}
	return *t.IdLength
}

// GetIsType retrieves the value of the leaf IsType from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsType is set, it can
// safely use t.GetIsType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetIsType() uint8 {
	if t == nil || t.IsType == nil {
		return 0
	}
	return *t.IsType
}

// GetLspId retrieves the value of the leaf LspId from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspId is set, it can
// safely use t.GetLspId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetLspId() string {
	if t == nil || t.LspId == nil {
		return ""
	}
	return *t.LspId
}

// GetMaximumAreaAddresses retrieves the value of the leaf MaximumAreaAddresses from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumAreaAddresses is set, it can
// safely use t.GetMaximumAreaAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumAreaAddresses == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetMaximumAreaAddresses() uint8 {
	if t == nil || t.MaximumAreaAddresses == nil {
		return 0
	}
	return *t.MaximumAreaAddresses
}

// GetPduLength retrieves the value of the leaf PduLength from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PduLength is set, it can
// safely use t.GetPduLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PduLength == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetPduLength() uint16 {
	if t == nil || t.PduLength == nil {
		return 0
	}
	return *t.PduLength
}

// GetPduType retrieves the value of the leaf PduType from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PduType is set, it can
// safely use t.GetPduType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PduType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetPduType() E_Lsp_PduType {
	if t == nil || t.PduType == 0 {
		return 0
	}
	return t.PduType
}

// GetRemainingLifetime retrieves the value of the leaf RemainingLifetime from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemainingLifetime is set, it can
// safely use t.GetRemainingLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemainingLifetime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetRemainingLifetime() uint16 {
	if t == nil || t.RemainingLifetime == nil {
		return 0
	}
	return *t.RemainingLifetime
}

// GetSequenceNumber retrieves the value of the leaf SequenceNumber from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceNumber is set, it can
// safely use t.GetSequenceNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetSequenceNumber() uint32 {
	if t == nil || t.SequenceNumber == nil {
		return 0
	}
	return *t.SequenceNumber
}

// GetVersion retrieves the value of the leaf Version from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Version is set, it can
// safely use t.GetVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Version == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetVersion() uint8 {
	if t == nil || t.Version == nil {
		return 1
	}
	return *t.Version
}

// GetVersion2 retrieves the value of the leaf Version2 from the NetworkInstance_Protocol_Isis_Level_Lsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Version2 is set, it can
// safely use t.GetVersion2() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Version2 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) GetVersion2() uint8 {
	if t == nil || t.Version2 == nil {
		return 1
	}
	return *t.Version2
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Version == nil {
		var v uint8 = 1
		t.Version = &v
	}
	if t.Version2 == nil {
		var v uint8 = 1
		t.Version2 = &v
	}
	for _, e := range t.Tlv {
		e.PopulateDefaults()
	}
	for _, e := range t.UndefinedTlv {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LspId == nil {
		return nil, fmt.Errorf("nil value for key LspId")
	}

	return map[string]interface{}{
		"lsp-id": *t.LspId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct {
	AreaAddress              *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress              `path:"area-address" module:"openconfig-network-instance"`
	Authentication           *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication           `path:"authentication" module:"openconfig-network-instance"`
	Capability               map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability    `path:"router-capabilities/capability" module:"openconfig-network-instance/openconfig-network-instance"`
	ExtendedIpv4Reachability *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability `path:"extended-ipv4-reachability" module:"openconfig-network-instance"`
	ExtendedIsReachability   *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability   `path:"extended-is-reachability" module:"openconfig-network-instance"`
	Hostname                 *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname                 `path:"hostname" module:"openconfig-network-instance"`
	InstanceId               map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId    `path:"instance-ids/instance-id" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv4ExternalReachability *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability `path:"ipv4-external-reachability" module:"openconfig-network-instance"`
	Ipv4InterfaceAddresses   *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses   `path:"ipv4-interface-addresses" module:"openconfig-network-instance"`
	Ipv4InternalReachability *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability `path:"ipv4-internal-reachability" module:"openconfig-network-instance"`
	Ipv4Srlg                 map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg      `path:"ipv4-srlgs/ipv4-srlg" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv4TeRouterId           *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId           `path:"ipv4-te-router-id" module:"openconfig-network-instance"`
	Ipv6InterfaceAddresses   *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses   `path:"ipv6-interface-addresses" module:"openconfig-network-instance"`
	Ipv6Reachability         *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability         `path:"ipv6-reachability" module:"openconfig-network-instance"`
	Ipv6Srlg                 map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg      `path:"ipv6-srlgs/ipv6-srlg" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv6TeRouterId           *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId           `path:"ipv6-te-router-id" module:"openconfig-network-instance"`
	IsAliasId                *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId                `path:"is-alias-id" module:"openconfig-network-instance"`
	IsReachability           *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability           `path:"is-reachability" module:"openconfig-network-instance"`
	IsisNeighborAttribute    *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute    `path:"isis-neighbor-attribute" module:"openconfig-network-instance"`
	LspBufferSize            *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize            `path:"lsp-buffer-size" module:"openconfig-network-instance"`
	MtIpv4Reachability       *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability       `path:"mt-ipv4-reachability" module:"openconfig-network-instance"`
	MtIpv6Reachability       *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability       `path:"mt-ipv6-reachability" module:"openconfig-network-instance"`
	MtIsisNeighborAttribute  *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute  `path:"mt-isis-neighbor-attribute" module:"openconfig-network-instance"`
	MtIsn                    *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn                    `path:"mt-isn" module:"openconfig-network-instance"`
	MultiTopology            *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology            `path:"multi-topology" module:"openconfig-network-instance"`
	Nlpid                    *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid                    `path:"nlpid" module:"openconfig-network-instance"`
	PurgeOi                  *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi                  `path:"purge-oi" module:"openconfig-network-instance"`
	Type                     E_IsisLsdbTypes_ISIS_TLV_TYPE                                         `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"type" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) IsYANGGoStruct() {}

// NewCapability creates a new entry in the Capability list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewCapability(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
		InstanceNumber: &InstanceNumber,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameCapability(oldK, newK uint32) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.InstanceNumber = &newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateCapability(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {

	key := InstanceNumber

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetCapability(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// DeleteCapability deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteCapability(InstanceNumber uint32) {
	key := InstanceNumber

	delete(t.Capability, key)
}

// AppendCapability appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct to the
// list Capability of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendCapability(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) error {
	if v.InstanceNumber == nil {
		return fmt.Errorf("invalid nil key received for InstanceNumber")
	}

	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewInstanceId creates a new entry in the InstanceId list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewInstanceId(InstanceId uint16) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InstanceId == nil {
		t.InstanceId = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId)
	}

	key := InstanceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InstanceId[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InstanceId", key)
	}

	t.InstanceId[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId{
		InstanceId: &InstanceId,
	}

	return t.InstanceId[key], nil
}

// RenameInstanceId renames an entry in the list InstanceId within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameInstanceId(oldK, newK uint16) error {
	if _, ok := t.InstanceId[newK]; ok {
		return fmt.Errorf("key %v already exists in InstanceId", newK)
	}

	e, ok := t.InstanceId[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InstanceId", oldK)
	}
	e.InstanceId = &newK

	t.InstanceId[newK] = e
	delete(t.InstanceId, oldK)
	return nil
}

// GetOrCreateInstanceId retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateInstanceId(InstanceId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId {

	key := InstanceId

	if v, ok := t.InstanceId[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstanceId(InstanceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstanceId got unexpected error: %v", err))
	}
	return v
}

// GetInstanceId retrieves the value with the specified key from
// the InstanceId map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetInstanceId(InstanceId uint16) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId {

	if t == nil {
		return nil
	}

	key := InstanceId

	if lm, ok := t.InstanceId[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstanceId deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteInstanceId(InstanceId uint16) {
	key := InstanceId

	delete(t.InstanceId, key)
}

// AppendInstanceId appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId struct to the
// list InstanceId of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendInstanceId(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId) error {
	if v.InstanceId == nil {
		return fmt.Errorf("invalid nil key received for InstanceId")
	}

	key := *v.InstanceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InstanceId == nil {
		t.InstanceId = make(map[uint16]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_InstanceId)
	}

	if _, ok := t.InstanceId[key]; ok {
		return fmt.Errorf("duplicate key for list InstanceId %v", key)
	}

	t.InstanceId[key] = v
	return nil
}

// NewIpv4Srlg creates a new entry in the Ipv4Srlg list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewIpv4Srlg(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Srlg == nil {
		t.Ipv4Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Srlg", key)
	}

	t.Ipv4Srlg[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg{
		InstanceNumber: &InstanceNumber,
	}

	return t.Ipv4Srlg[key], nil
}

// RenameIpv4Srlg renames an entry in the list Ipv4Srlg within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameIpv4Srlg(oldK, newK uint32) error {
	if _, ok := t.Ipv4Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Srlg", newK)
	}

	e, ok := t.Ipv4Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Srlg", oldK)
	}
	e.InstanceNumber = &newK

	t.Ipv4Srlg[newK] = e
	delete(t.Ipv4Srlg, oldK)
	return nil
}

// GetOrCreateIpv4Srlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg {

	key := InstanceNumber

	if v, ok := t.Ipv4Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Srlg(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Srlg got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Srlg retrieves the value with the specified key from
// the Ipv4Srlg map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Ipv4Srlg[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Srlg deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteIpv4Srlg(InstanceNumber uint32) {
	key := InstanceNumber

	delete(t.Ipv4Srlg, key)
}

// AppendIpv4Srlg appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg struct to the
// list Ipv4Srlg of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendIpv4Srlg(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg) error {
	if v.InstanceNumber == nil {
		return fmt.Errorf("invalid nil key received for InstanceNumber")
	}

	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Srlg == nil {
		t.Ipv4Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4Srlg)
	}

	if _, ok := t.Ipv4Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Srlg %v", key)
	}

	t.Ipv4Srlg[key] = v
	return nil
}

// NewIpv6Srlg creates a new entry in the Ipv6Srlg list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) NewIpv6Srlg(InstanceNumber uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Srlg == nil {
		t.Ipv6Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Srlg", key)
	}

	t.Ipv6Srlg[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg{
		InstanceNumber: &InstanceNumber,
	}

	return t.Ipv6Srlg[key], nil
}

// RenameIpv6Srlg renames an entry in the list Ipv6Srlg within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) RenameIpv6Srlg(oldK, newK uint32) error {
	if _, ok := t.Ipv6Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Srlg", newK)
	}

	e, ok := t.Ipv6Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Srlg", oldK)
	}
	e.InstanceNumber = &newK

	t.Ipv6Srlg[newK] = e
	delete(t.Ipv6Srlg, oldK)
	return nil
}

// GetOrCreateIpv6Srlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg {

	key := InstanceNumber

	if v, ok := t.Ipv6Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Srlg(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Srlg got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Srlg retrieves the value with the specified key from
// the Ipv6Srlg map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6Srlg(InstanceNumber uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg {

	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Ipv6Srlg[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Srlg deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) DeleteIpv6Srlg(InstanceNumber uint32) {
	key := InstanceNumber

	delete(t.Ipv6Srlg, key)
}

// AppendIpv6Srlg appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg struct to the
// list Ipv6Srlg of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) AppendIpv6Srlg(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg) error {
	if v.InstanceNumber == nil {
		return fmt.Errorf("invalid nil key received for InstanceNumber")
	}

	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Srlg == nil {
		t.Ipv6Srlg = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Srlg)
	}

	if _, ok := t.Ipv6Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Srlg %v", key)
	}

	t.Ipv6Srlg[key] = v
	return nil
}

// GetOrCreateAreaAddress retrieves the value of the AreaAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateAreaAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	if t.AreaAddress != nil {
		return t.AreaAddress
	}
	t.AreaAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	return t.AreaAddress
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateAuthentication() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	return t.Authentication
}

// GetOrCreateExtendedIpv4Reachability retrieves the value of the ExtendedIpv4Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateExtendedIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	if t.ExtendedIpv4Reachability != nil {
		return t.ExtendedIpv4Reachability
	}
	t.ExtendedIpv4Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	return t.ExtendedIpv4Reachability
}

// GetOrCreateExtendedIsReachability retrieves the value of the ExtendedIsReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateExtendedIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability {
	if t.ExtendedIsReachability != nil {
		return t.ExtendedIsReachability
	}
	t.ExtendedIsReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability{}
	return t.ExtendedIsReachability
}

// GetOrCreateHostname retrieves the value of the Hostname field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateHostname() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname {
	if t.Hostname != nil {
		return t.Hostname
	}
	t.Hostname = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname{}
	return t.Hostname
}

// GetOrCreateIpv4ExternalReachability retrieves the value of the Ipv4ExternalReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4ExternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability {
	if t.Ipv4ExternalReachability != nil {
		return t.Ipv4ExternalReachability
	}
	t.Ipv4ExternalReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability{}
	return t.Ipv4ExternalReachability
}

// GetOrCreateIpv4InterfaceAddresses retrieves the value of the Ipv4InterfaceAddresses field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses {
	if t.Ipv4InterfaceAddresses != nil {
		return t.Ipv4InterfaceAddresses
	}
	t.Ipv4InterfaceAddresses = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses{}
	return t.Ipv4InterfaceAddresses
}

// GetOrCreateIpv4InternalReachability retrieves the value of the Ipv4InternalReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4InternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability {
	if t.Ipv4InternalReachability != nil {
		return t.Ipv4InternalReachability
	}
	t.Ipv4InternalReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability{}
	return t.Ipv4InternalReachability
}

// GetOrCreateIpv4TeRouterId retrieves the value of the Ipv4TeRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv4TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId {
	if t.Ipv4TeRouterId != nil {
		return t.Ipv4TeRouterId
	}
	t.Ipv4TeRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId{}
	return t.Ipv4TeRouterId
}

// GetOrCreateIpv6InterfaceAddresses retrieves the value of the Ipv6InterfaceAddresses field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses {
	if t.Ipv6InterfaceAddresses != nil {
		return t.Ipv6InterfaceAddresses
	}
	t.Ipv6InterfaceAddresses = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses{}
	return t.Ipv6InterfaceAddresses
}

// GetOrCreateIpv6Reachability retrieves the value of the Ipv6Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability {
	if t.Ipv6Reachability != nil {
		return t.Ipv6Reachability
	}
	t.Ipv6Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability{}
	return t.Ipv6Reachability
}

// GetOrCreateIpv6TeRouterId retrieves the value of the Ipv6TeRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIpv6TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId {
	if t.Ipv6TeRouterId != nil {
		return t.Ipv6TeRouterId
	}
	t.Ipv6TeRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId{}
	return t.Ipv6TeRouterId
}

// GetOrCreateIsAliasId retrieves the value of the IsAliasId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsAliasId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId {
	if t.IsAliasId != nil {
		return t.IsAliasId
	}
	t.IsAliasId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId{}
	return t.IsAliasId
}

// GetOrCreateIsReachability retrieves the value of the IsReachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability {
	if t.IsReachability != nil {
		return t.IsReachability
	}
	t.IsReachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability{}
	return t.IsReachability
}

// GetOrCreateIsisNeighborAttribute retrieves the value of the IsisNeighborAttribute field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute {
	if t.IsisNeighborAttribute != nil {
		return t.IsisNeighborAttribute
	}
	t.IsisNeighborAttribute = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute{}
	return t.IsisNeighborAttribute
}

// GetOrCreateLspBufferSize retrieves the value of the LspBufferSize field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateLspBufferSize() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize {
	if t.LspBufferSize != nil {
		return t.LspBufferSize
	}
	t.LspBufferSize = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize{}
	return t.LspBufferSize
}

// GetOrCreateMtIpv4Reachability retrieves the value of the MtIpv4Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability {
	if t.MtIpv4Reachability != nil {
		return t.MtIpv4Reachability
	}
	t.MtIpv4Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability{}
	return t.MtIpv4Reachability
}

// GetOrCreateMtIpv6Reachability retrieves the value of the MtIpv6Reachability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability {
	if t.MtIpv6Reachability != nil {
		return t.MtIpv6Reachability
	}
	t.MtIpv6Reachability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability{}
	return t.MtIpv6Reachability
}

// GetOrCreateMtIsisNeighborAttribute retrieves the value of the MtIsisNeighborAttribute field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute {
	if t.MtIsisNeighborAttribute != nil {
		return t.MtIsisNeighborAttribute
	}
	t.MtIsisNeighborAttribute = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute{}
	return t.MtIsisNeighborAttribute
}

// GetOrCreateMtIsn retrieves the value of the MtIsn field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMtIsn() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn {
	if t.MtIsn != nil {
		return t.MtIsn
	}
	t.MtIsn = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn{}
	return t.MtIsn
}

// GetOrCreateMultiTopology retrieves the value of the MultiTopology field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateMultiTopology() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	if t.MultiTopology != nil {
		return t.MultiTopology
	}
	t.MultiTopology = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology{}
	return t.MultiTopology
}

// GetOrCreateNlpid retrieves the value of the Nlpid field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreateNlpid() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	if t.Nlpid != nil {
		return t.Nlpid
	}
	t.Nlpid = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid{}
	return t.Nlpid
}

// GetOrCreatePurgeOi retrieves the value of the PurgeOi field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetOrCreatePurgeOi() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	if t.PurgeOi != nil {
		return t.PurgeOi
	}
	t.PurgeOi = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi{}
	return t.PurgeOi
}

// GetAreaAddress returns the value of the AreaAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field AreaAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetAreaAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	if t != nil && t.AreaAddress != nil {
		return t.AreaAddress
	}
	return nil
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetAuthentication() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetExtendedIpv4Reachability returns the value of the ExtendedIpv4Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field ExtendedIpv4Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetExtendedIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	if t != nil && t.ExtendedIpv4Reachability != nil {
		return t.ExtendedIpv4Reachability
	}
	return nil
}

// GetExtendedIsReachability returns the value of the ExtendedIsReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field ExtendedIsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetExtendedIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability {
	if t != nil && t.ExtendedIsReachability != nil {
		return t.ExtendedIsReachability
	}
	return nil
}

// GetHostname returns the value of the Hostname struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Hostname is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetHostname() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Hostname {
	if t != nil && t.Hostname != nil {
		return t.Hostname
	}
	return nil
}

// GetIpv4ExternalReachability returns the value of the Ipv4ExternalReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4ExternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4ExternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4ExternalReachability {
	if t != nil && t.Ipv4ExternalReachability != nil {
		return t.Ipv4ExternalReachability
	}
	return nil
}

// GetIpv4InterfaceAddresses returns the value of the Ipv4InterfaceAddresses struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4InterfaceAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InterfaceAddresses {
	if t != nil && t.Ipv4InterfaceAddresses != nil {
		return t.Ipv4InterfaceAddresses
	}
	return nil
}

// GetIpv4InternalReachability returns the value of the Ipv4InternalReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4InternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4InternalReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4InternalReachability {
	if t != nil && t.Ipv4InternalReachability != nil {
		return t.Ipv4InternalReachability
	}
	return nil
}

// GetIpv4TeRouterId returns the value of the Ipv4TeRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv4TeRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv4TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv4TeRouterId {
	if t != nil && t.Ipv4TeRouterId != nil {
		return t.Ipv4TeRouterId
	}
	return nil
}

// GetIpv6InterfaceAddresses returns the value of the Ipv6InterfaceAddresses struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6InterfaceAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6InterfaceAddresses() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6InterfaceAddresses {
	if t != nil && t.Ipv6InterfaceAddresses != nil {
		return t.Ipv6InterfaceAddresses
	}
	return nil
}

// GetIpv6Reachability returns the value of the Ipv6Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6Reachability {
	if t != nil && t.Ipv6Reachability != nil {
		return t.Ipv6Reachability
	}
	return nil
}

// GetIpv6TeRouterId returns the value of the Ipv6TeRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Ipv6TeRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIpv6TeRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Ipv6TeRouterId {
	if t != nil && t.Ipv6TeRouterId != nil {
		return t.Ipv6TeRouterId
	}
	return nil
}

// GetIsAliasId returns the value of the IsAliasId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsAliasId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsAliasId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsAliasId {
	if t != nil && t.IsAliasId != nil {
		return t.IsAliasId
	}
	return nil
}

// GetIsReachability returns the value of the IsReachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsReachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsReachability {
	if t != nil && t.IsReachability != nil {
		return t.IsReachability
	}
	return nil
}

// GetIsisNeighborAttribute returns the value of the IsisNeighborAttribute struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field IsisNeighborAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_IsisNeighborAttribute {
	if t != nil && t.IsisNeighborAttribute != nil {
		return t.IsisNeighborAttribute
	}
	return nil
}

// GetLspBufferSize returns the value of the LspBufferSize struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field LspBufferSize is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetLspBufferSize() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_LspBufferSize {
	if t != nil && t.LspBufferSize != nil {
		return t.LspBufferSize
	}
	return nil
}

// GetMtIpv4Reachability returns the value of the MtIpv4Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIpv4Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIpv4Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv4Reachability {
	if t != nil && t.MtIpv4Reachability != nil {
		return t.MtIpv4Reachability
	}
	return nil
}

// GetMtIpv6Reachability returns the value of the MtIpv6Reachability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIpv6Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIpv6Reachability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIpv6Reachability {
	if t != nil && t.MtIpv6Reachability != nil {
		return t.MtIpv6Reachability
	}
	return nil
}

// GetMtIsisNeighborAttribute returns the value of the MtIsisNeighborAttribute struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIsisNeighborAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIsisNeighborAttribute() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsisNeighborAttribute {
	if t != nil && t.MtIsisNeighborAttribute != nil {
		return t.MtIsisNeighborAttribute
	}
	return nil
}

// GetMtIsn returns the value of the MtIsn struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MtIsn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMtIsn() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MtIsn {
	if t != nil && t.MtIsn != nil {
		return t.MtIsn
	}
	return nil
}

// GetMultiTopology returns the value of the MultiTopology struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field MultiTopology is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetMultiTopology() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_MultiTopology {
	if t != nil && t.MultiTopology != nil {
		return t.MultiTopology
	}
	return nil
}

// GetNlpid returns the value of the Nlpid struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field Nlpid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetNlpid() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Nlpid {
	if t != nil && t.Nlpid != nil {
		return t.Nlpid
	}
	return nil
}

// GetPurgeOi returns the value of the PurgeOi struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv. If the receiver or the field PurgeOi is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetPurgeOi() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_PurgeOi {
	if t != nil && t.PurgeOi != nil {
		return t.PurgeOi
	}
	return nil
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) GetType() E_IsisLsdbTypes_ISIS_TLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AreaAddress.PopulateDefaults()
	t.Authentication.PopulateDefaults()
	t.ExtendedIpv4Reachability.PopulateDefaults()
	t.ExtendedIsReachability.PopulateDefaults()
	t.Hostname.PopulateDefaults()
	t.Ipv4ExternalReachability.PopulateDefaults()
	t.Ipv4InterfaceAddresses.PopulateDefaults()
	t.Ipv4InternalReachability.PopulateDefaults()
	t.Ipv4TeRouterId.PopulateDefaults()
	t.Ipv6InterfaceAddresses.PopulateDefaults()
	t.Ipv6Reachability.PopulateDefaults()
	t.Ipv6TeRouterId.PopulateDefaults()
	t.IsAliasId.PopulateDefaults()
	t.IsReachability.PopulateDefaults()
	t.IsisNeighborAttribute.PopulateDefaults()
	t.LspBufferSize.PopulateDefaults()
	t.MtIpv4Reachability.PopulateDefaults()
	t.MtIpv6Reachability.PopulateDefaults()
	t.MtIsisNeighborAttribute.PopulateDefaults()
	t.MtIsn.PopulateDefaults()
	t.MultiTopology.PopulateDefaults()
	t.Nlpid.PopulateDefaults()
	t.PurgeOi.PopulateDefaults()
	for _, e := range t.Capability {
		e.PopulateDefaults()
	}
	for _, e := range t.InstanceId {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv4Srlg {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Srlg {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress struct {
	Address []string `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) GetAddress() []string {
	if t == nil || t.Address == nil {
		return nil
	}
	return t.Address
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication struct {
	AuthenticationKey *string                     `path:"state/authentication-key" module:"openconfig-network-instance/openconfig-network-instance"`
	CryptoType        E_Authentication_CryptoType `path:"state/crypto-type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) IsYANGGoStruct() {}

// GetAuthenticationKey retrieves the value of the leaf AuthenticationKey from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationKey is set, it can
// safely use t.GetAuthenticationKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationKey == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) GetAuthenticationKey() string {
	if t == nil || t.AuthenticationKey == nil {
		return ""
	}
	return *t.AuthenticationKey
}

// GetCryptoType retrieves the value of the leaf CryptoType from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CryptoType is set, it can
// safely use t.GetCryptoType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CryptoType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) GetCryptoType() E_Authentication_CryptoType {
	if t == nil || t.CryptoType == 0 {
		return 0
	}
	return t.CryptoType
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct {
	Flags           []E_Capability_Flags                                                                                `path:"state/flags" module:"openconfig-network-instance/openconfig-network-instance"`
	InstanceNumber  *uint32                                                                                             `path:"state/instance-number|instance-number" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"instance-number" shadow-module:"openconfig-network-instance"`
	RouterId        *string                                                                                             `path:"state/router-id" module:"openconfig-network-instance/openconfig-network-instance"`
	Subtlv          map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv `path:"subtlvs/subtlv" module:"openconfig-network-instance/openconfig-network-instance"`
	UndefinedSubtlv map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv                   `path:"undefined-subtlvs/undefined-subtlv" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) IsYANGGoStruct() {}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) NewSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) RenameSubtlv(oldK, newK E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetOrCreateSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) DeleteSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key received for Type")
	}

	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// GetFlags retrieves the value of the leaf Flags from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetFlags() []E_Capability_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// GetInstanceNumber retrieves the value of the leaf InstanceNumber from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceNumber is set, it can
// safely use t.GetInstanceNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetInstanceNumber() uint32 {
	if t == nil || t.InstanceNumber == nil {
		return 0
	}
	return *t.InstanceNumber
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Subtlv {
		e.PopulateDefaults()
	}
	for _, e := range t.UndefinedSubtlv {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv struct {
	SegmentRoutingAlgorithms *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms `path:"segment-routing-algorithms" module:"openconfig-network-instance"`
	SegmentRoutingCapability *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability `path:"segment-routing-capability" module:"openconfig-network-instance"`
	Type                     E_IsisLsdbTypes_ISIS_SUBTLV_TYPE                                                        `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"type" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) IsYANGGoStruct() {}

// GetOrCreateSegmentRoutingAlgorithms retrieves the value of the SegmentRoutingAlgorithms field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetOrCreateSegmentRoutingAlgorithms() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	if t.SegmentRoutingAlgorithms != nil {
		return t.SegmentRoutingAlgorithms
	}
	t.SegmentRoutingAlgorithms = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	return t.SegmentRoutingAlgorithms
}

// GetOrCreateSegmentRoutingCapability retrieves the value of the SegmentRoutingCapability field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetOrCreateSegmentRoutingCapability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	if t.SegmentRoutingCapability != nil {
		return t.SegmentRoutingCapability
	}
	t.SegmentRoutingCapability = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	return t.SegmentRoutingCapability
}

// GetSegmentRoutingAlgorithms returns the value of the SegmentRoutingAlgorithms struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv. If the receiver or the field SegmentRoutingAlgorithms is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetSegmentRoutingAlgorithms() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	if t != nil && t.SegmentRoutingAlgorithms != nil {
		return t.SegmentRoutingAlgorithms
	}
	return nil
}

// GetSegmentRoutingCapability returns the value of the SegmentRoutingCapability struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv. If the receiver or the field SegmentRoutingCapability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetSegmentRoutingCapability() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	if t != nil && t.SegmentRoutingCapability != nil {
		return t.SegmentRoutingCapability
	}
	return nil
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) GetType() E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SegmentRoutingAlgorithms.PopulateDefaults()
	t.SegmentRoutingCapability.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms struct {
	Algorithm []E_SegmentRoutingAlgorithms_Algorithm `path:"state/algorithm" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) IsYANGGoStruct() {
}

// GetAlgorithm retrieves the value of the leaf Algorithm from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Algorithm is set, it can
// safely use t.GetAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Algorithm == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) GetAlgorithm() []E_SegmentRoutingAlgorithms_Algorithm {
	if t == nil || t.Algorithm == nil {
		return nil
	}
	return t.Algorithm
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability struct {
	Flags          []E_SegmentRoutingCapability_Flags                                                                                `path:"state/flags" module:"openconfig-network-instance/openconfig-network-instance"`
	SrgbDescriptor map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor `path:"srgb-descriptors/srgb-descriptor" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) IsYANGGoStruct() {
}

// NewSrgbDescriptor creates a new entry in the SrgbDescriptor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) NewSrgbDescriptor(Range uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrgbDescriptor == nil {
		t.SrgbDescriptor = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
	}

	key := Range

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SrgbDescriptor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SrgbDescriptor", key)
	}

	t.SrgbDescriptor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
		Range: &Range,
	}

	return t.SrgbDescriptor[key], nil
}

// RenameSrgbDescriptor renames an entry in the list SrgbDescriptor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) RenameSrgbDescriptor(oldK, newK uint32) error {
	if _, ok := t.SrgbDescriptor[newK]; ok {
		return fmt.Errorf("key %v already exists in SrgbDescriptor", newK)
	}

	e, ok := t.SrgbDescriptor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SrgbDescriptor", oldK)
	}
	e.Range = &newK

	t.SrgbDescriptor[newK] = e
	delete(t.SrgbDescriptor, oldK)
	return nil
}

// GetOrCreateSrgbDescriptor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) GetOrCreateSrgbDescriptor(Range uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {

	key := Range

	if v, ok := t.SrgbDescriptor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrgbDescriptor(Range)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrgbDescriptor got unexpected error: %v", err))
	}
	return v
}

// GetSrgbDescriptor retrieves the value with the specified key from
// the SrgbDescriptor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) GetSrgbDescriptor(Range uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {

	if t == nil {
		return nil
	}

	key := Range

	if lm, ok := t.SrgbDescriptor[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrgbDescriptor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) DeleteSrgbDescriptor(Range uint32) {
	key := Range

	delete(t.SrgbDescriptor, key)
}

// AppendSrgbDescriptor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor struct to the
// list SrgbDescriptor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) AppendSrgbDescriptor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) error {
	if v.Range == nil {
		return fmt.Errorf("invalid nil key received for Range")
	}

	key := *v.Range

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrgbDescriptor == nil {
		t.SrgbDescriptor = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
	}

	if _, ok := t.SrgbDescriptor[key]; ok {
		return fmt.Errorf("duplicate key for list SrgbDescriptor %v", key)
	}

	t.SrgbDescriptor[key] = v
	return nil
}

// GetFlags retrieves the value of the leaf Flags from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) GetFlags() []E_SegmentRoutingCapability_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.SrgbDescriptor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor struct {
	Label NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	Range *uint32                                                                                                           `path:"state/range|range" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"range" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) IsYANGGoStruct() {
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) GetLabel() NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	if t == nil || t.Label == nil {
		return nil
	}
	return t.Label
}

// GetRange retrieves the value of the leaf Range from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Range is set, it can
// safely use t.GetRange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Range == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) GetRange() uint32 {
	if t == nil || t.Range == nil {
		return 0
	}
	return *t.Range
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Range == nil {
		return nil, fmt.Errorf("nil value for key Range")
	}

	return map[string]interface{}{
		"range": *t.Range,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv struct {
	Length *uint8 `path:"state/length" module:"openconfig-network-instance/openconfig-network-instance"`
	Type   *uint8 `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"type" shadow-module:"openconfig-network-instance"`
	Value  Binary `path:"state/value" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) IsYANGGoStruct() {}

// GetLength retrieves the value of the leaf Length from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Length is set, it can
// safely use t.GetLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Length == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) GetLength() uint8 {
	if t == nil || t.Length == nil {
		return 0
	}
	return *t.Length
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) GetType() uint8 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// GetValue retrieves the value of the leaf Value from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) GetValue() Binary {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability struct {
	Prefix map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix `path:"prefixes/prefix" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) NewPrefix(Prefix string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) GetOrCreatePrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) GetPrefix(Prefix string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct to the
// list Prefix of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) AppendPrefix(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct {
	Metric          *uint32                                                                                                                  `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix          *string                                                                                                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"prefix" shadow-module:"openconfig-network-instance"`
	SBit            *bool                                                                                                                    `path:"state/s-bit" module:"openconfig-network-instance/openconfig-network-instance"`
	Subtlv          map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv `path:"subtlvs/subtlv" module:"openconfig-network-instance/openconfig-network-instance"`
	UndefinedSubtlv map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv                   `path:"undefined-subtlvs/undefined-subtlv" module:"openconfig-network-instance/openconfig-network-instance"`
	UpDown          *bool                                                                                                                    `path:"state/up-down" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) IsYANGGoStruct() {
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) NewSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) RenameSubtlv(oldK, newK E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetOrCreateSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) DeleteSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key received for Type")
	}

	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetMetric() uint32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetSBit retrieves the value of the leaf SBit from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SBit is set, it can
// safely use t.GetSBit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SBit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetSBit() bool {
	if t == nil || t.SBit == nil {
		return false
	}
	return *t.SBit
}

// GetUpDown retrieves the value of the leaf UpDown from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpDown is set, it can
// safely use t.GetUpDown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpDown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) GetUpDown() bool {
	if t == nil || t.UpDown == nil {
		return false
	}
	return *t.UpDown
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Subtlv {
		e.PopulateDefaults()
	}
	for _, e := range t.UndefinedSubtlv {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct {
	Flags              *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags                `path:"flags" module:"openconfig-network-instance"`
	Ipv4SourceRouterId *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId   `path:"ipv4-source-router-id" module:"openconfig-network-instance"`
	Ipv6SourceRouterId *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId   `path:"ipv6-source-router-id" module:"openconfig-network-instance"`
	PrefixSid          map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid `path:"prefix-sids/prefix-sid" module:"openconfig-network-instance/openconfig-network-instance"`
	Tag                *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag                  `path:"tag" module:"openconfig-network-instance"`
	Tag64              *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64                `path:"tag64" module:"openconfig-network-instance"`
	Type               E_IsisLsdbTypes_ISIS_SUBTLV_TYPE                                                                         `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"type" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) IsYANGGoStruct() {
}

// NewPrefixSid creates a new entry in the PrefixSid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) NewPrefixSid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSid", key)
	}

	t.PrefixSid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid{
		Value: &Value,
	}

	return t.PrefixSid[key], nil
}

// RenamePrefixSid renames an entry in the list PrefixSid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) RenamePrefixSid(oldK, newK uint32) error {
	if _, ok := t.PrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSid", newK)
	}

	e, ok := t.PrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSid", oldK)
	}
	e.Value = &newK

	t.PrefixSid[newK] = e
	delete(t.PrefixSid, oldK)
	return nil
}

// GetOrCreatePrefixSid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreatePrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid {

	key := Value

	if v, ok := t.PrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSid retrieves the value with the specified key from
// the PrefixSid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetPrefixSid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.PrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) DeletePrefixSid(Value uint32) {
	key := Value

	delete(t.PrefixSid, key)
}

// AppendPrefixSid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid struct to the
// list PrefixSid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) AppendPrefixSid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) error {
	if v.Value == nil {
		return fmt.Errorf("invalid nil key received for Value")
	}

	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSid == nil {
		t.PrefixSid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid)
	}

	if _, ok := t.PrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSid %v", key)
	}

	t.PrefixSid[key] = v
	return nil
}

// GetOrCreateFlags retrieves the value of the Flags field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	if t.Flags != nil {
		return t.Flags
	}
	t.Flags = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	return t.Flags
}

// GetOrCreateIpv4SourceRouterId retrieves the value of the Ipv4SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	t.Ipv4SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	return t.Ipv4SourceRouterId
}

// GetOrCreateIpv6SourceRouterId retrieves the value of the Ipv6SourceRouterId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	t.Ipv6SourceRouterId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	return t.Ipv6SourceRouterId
}

// GetOrCreateTag retrieves the value of the Tag field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag {
	if t.Tag != nil {
		return t.Tag
	}
	t.Tag = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag{}
	return t.Tag
}

// GetOrCreateTag64 retrieves the value of the Tag64 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetOrCreateTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 {
	if t.Tag64 != nil {
		return t.Tag64
	}
	t.Tag64 = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64{}
	return t.Tag64
}

// GetFlags returns the value of the Flags struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Flags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetFlags() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	if t != nil && t.Flags != nil {
		return t.Flags
	}
	return nil
}

// GetIpv4SourceRouterId returns the value of the Ipv4SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv4SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetIpv4SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	if t != nil && t.Ipv4SourceRouterId != nil {
		return t.Ipv4SourceRouterId
	}
	return nil
}

// GetIpv6SourceRouterId returns the value of the Ipv6SourceRouterId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Ipv6SourceRouterId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetIpv6SourceRouterId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	if t != nil && t.Ipv6SourceRouterId != nil {
		return t.Ipv6SourceRouterId
	}
	return nil
}

// GetTag returns the value of the Tag struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetTag() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag {
	if t != nil && t.Tag != nil {
		return t.Tag
	}
	return nil
}

// GetTag64 returns the value of the Tag64 struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv. If the receiver or the field Tag64 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetTag64() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 {
	if t != nil && t.Tag64 != nil {
		return t.Tag64
	}
	return nil
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) GetType() E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Flags.PopulateDefaults()
	t.Ipv4SourceRouterId.PopulateDefaults()
	t.Ipv6SourceRouterId.PopulateDefaults()
	t.Tag.PopulateDefaults()
	t.Tag64.PopulateDefaults()
	for _, e := range t.PrefixSid {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags struct {
	Flags []E_Flags_Flags                  `path:"state/flags" module:"openconfig-network-instance/openconfig-network-instance"`
	Type  E_IsisLsdbTypes_ISIS_SUBTLV_TYPE `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) IsYANGGoStruct() {
}

// GetFlags retrieves the value of the leaf Flags from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) GetFlags() []E_Flags_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) GetType() E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId struct {
	RouterId *string                          `path:"state/router-id" module:"openconfig-network-instance/openconfig-network-instance"`
	Type     E_IsisLsdbTypes_ISIS_SUBTLV_TYPE `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) IsYANGGoStruct() {
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) GetType() E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId struct {
	RouterId *string                          `path:"state/router-id" module:"openconfig-network-instance/openconfig-network-instance"`
	Type     E_IsisLsdbTypes_ISIS_SUBTLV_TYPE `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) IsYANGGoStruct() {
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) GetType() E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/prefix-sids/prefix-sid YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid struct {
	Algorithm *uint8              `path:"state/algorithm" module:"openconfig-network-instance/openconfig-network-instance"`
	Flags     []E_PrefixSid_Flags `path:"state/flags" module:"openconfig-network-instance/openconfig-network-instance"`
	Value     *uint32             `path:"state/value|value" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"value" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) IsYANGGoStruct() {
}

// GetAlgorithm retrieves the value of the leaf Algorithm from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Algorithm is set, it can
// safely use t.GetAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Algorithm == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) GetAlgorithm() uint8 {
	if t == nil || t.Algorithm == nil {
		return 0
	}
	return *t.Algorithm
}

// GetFlags retrieves the value of the leaf Flags from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) GetFlags() []E_PrefixSid_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// GetValue retrieves the value of the leaf Value from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_PrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/tag YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag struct {
	Tag32 []uint32 `path:"state/tag32" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) IsYANGGoStruct() {
}

// GetTag32 retrieves the value of the leaf Tag32 from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag32 is set, it can
// safely use t.GetTag32() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag32 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) GetTag32() []uint32 {
	if t == nil || t.Tag32 == nil {
		return nil
	}
	return t.Tag32
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/tag64 YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 struct {
	Tag64 []uint64 `path:"state/tag64" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) IsYANGGoStruct() {
}

// GetTag64 retrieves the value of the leaf Tag64 from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag64 is set, it can
// safely use t.GetTag64() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag64 == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) GetTag64() []uint64 {
	if t == nil || t.Tag64 == nil {
		return nil
	}
	return t.Tag64
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Tag64) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/undefined-subtlvs/undefined-subtlv YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv struct {
	Length *uint8 `path:"state/length" module:"openconfig-network-instance/openconfig-network-instance"`
	Type   *uint8 `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"type" shadow-module:"openconfig-network-instance"`
	Value  Binary `path:"state/value" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) IsYANGGoStruct() {
}

// GetLength retrieves the value of the leaf Length from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Length is set, it can
// safely use t.GetLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Length == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) GetLength() uint8 {
	if t == nil || t.Length == nil {
		return 0
	}
	return *t.Length
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) GetType() uint8 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// GetValue retrieves the value of the leaf Value from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) GetValue() Binary {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_UndefinedSubtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability struct {
	Neighbor map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor `path:"neighbors/neighbor" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) NewNeighbor(SystemId string) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.SystemId = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) GetOrCreateNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) GetNeighbor(SystemId string) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) DeleteNeighbor(SystemId string) {
	key := SystemId

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) AppendNeighbor(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) error {
	if v.SystemId == nil {
		return fmt.Errorf("invalid nil key received for SystemId")
	}

	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct {
	Instance map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance `path:"instances/instance" module:"openconfig-network-instance/openconfig-network-instance"`
	SystemId *string                                                                                          `path:"state/system-id|system-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"system-id" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) IsYANGGoStruct() {
}

// NewInstance creates a new entry in the Instance list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) NewInstance(Id uint64) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance{
		Id: &Id,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) RenameInstance(oldK, newK uint64) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.Id = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetOrCreateInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance {

	key := Id

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetInstance(Id uint64) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) DeleteInstance(Id uint64) {
	key := Id

	delete(t.Instance, key)
}

// AppendInstance appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct to the
// list Instance of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) AppendInstance(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint64]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// GetSystemId retrieves the value of the leaf SystemId from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Instance {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct {
	Id              *uint64                                                                                                                           `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	Metric          *uint32                                                                                                                           `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance"`
	Subtlv          map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv `path:"subtlvs/subtlv" module:"openconfig-network-instance/openconfig-network-instance"`
	UndefinedSubtlv map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv                   `path:"undefined-subtlvs/undefined-subtlv" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) IsYANGGoStruct() {
}

// NewSubtlv creates a new entry in the Subtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) NewSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subtlv", key)
	}

	t.Subtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv{
		Type: Type,
	}

	return t.Subtlv[key], nil
}

// RenameSubtlv renames an entry in the list Subtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) RenameSubtlv(oldK, newK E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) error {
	if _, ok := t.Subtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Subtlv", newK)
	}

	e, ok := t.Subtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subtlv", oldK)
	}
	e.Type = newK

	t.Subtlv[newK] = e
	delete(t.Subtlv, oldK)
	return nil
}

// GetOrCreateSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetOrCreateSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv {

	key := Type

	if v, ok := t.Subtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetSubtlv retrieves the value with the specified key from
// the Subtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.Subtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) DeleteSubtlv(Type E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) {
	key := Type

	delete(t.Subtlv, key)
}

// AppendSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct to the
// list Subtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) AppendSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subtlv == nil {
		t.Subtlv = make(map[E_IsisLsdbTypes_ISIS_SUBTLV_TYPE]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv)
	}

	if _, ok := t.Subtlv[key]; ok {
		return fmt.Errorf("duplicate key for list Subtlv %v", key)
	}

	t.Subtlv[key] = v
	return nil
}

// NewUndefinedSubtlv creates a new entry in the UndefinedSubtlv list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) NewUndefinedSubtlv(Type uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UndefinedSubtlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UndefinedSubtlv", key)
	}

	t.UndefinedSubtlv[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv{
		Type: &Type,
	}

	return t.UndefinedSubtlv[key], nil
}

// RenameUndefinedSubtlv renames an entry in the list UndefinedSubtlv within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) RenameUndefinedSubtlv(oldK, newK uint8) error {
	if _, ok := t.UndefinedSubtlv[newK]; ok {
		return fmt.Errorf("key %v already exists in UndefinedSubtlv", newK)
	}

	e, ok := t.UndefinedSubtlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in UndefinedSubtlv", oldK)
	}
	e.Type = &newK

	t.UndefinedSubtlv[newK] = e
	delete(t.UndefinedSubtlv, oldK)
	return nil
}

// GetOrCreateUndefinedSubtlv retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetOrCreateUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv {

	key := Type

	if v, ok := t.UndefinedSubtlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUndefinedSubtlv(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUndefinedSubtlv got unexpected error: %v", err))
	}
	return v
}

// GetUndefinedSubtlv retrieves the value with the specified key from
// the UndefinedSubtlv map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetUndefinedSubtlv(Type uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.UndefinedSubtlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteUndefinedSubtlv deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) DeleteUndefinedSubtlv(Type uint8) {
	key := Type

	delete(t.UndefinedSubtlv, key)
}

// AppendUndefinedSubtlv appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv struct to the
// list UndefinedSubtlv of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) AppendUndefinedSubtlv(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key received for Type")
	}

	key := *v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UndefinedSubtlv == nil {
		t.UndefinedSubtlv = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_UndefinedSubtlv)
	}

	if _, ok := t.UndefinedSubtlv[key]; ok {
		return fmt.Errorf("duplicate key for list UndefinedSubtlv %v", key)
	}

	t.UndefinedSubtlv[key] = v
	return nil
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) GetMetric() uint32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Subtlv {
		e.PopulateDefaults()
	}
	for _, e := range t.UndefinedSubtlv {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct {
	AdjacencySid               map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid       `path:"adjacency-sids/adjacency-sid" module:"openconfig-network-instance/openconfig-network-instance"`
	AdminGroup                 *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup                    `path:"admin-group" module:"openconfig-network-instance"`
	AvailableBandwidth         *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth            `path:"available-bandwidth" module:"openconfig-network-instance"`
	BandwidthConstraint        map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint `path:"bandwidth-constraints/bandwidth-constraint" module:"openconfig-network-instance/openconfig-network-instance"`
	ExtendedAdminGroup         *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup            `path:"extended-admin-group" module:"openconfig-network-instance"`
	Ipv4InterfaceAddress       *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress          `path:"ipv4-interface-address" module:"openconfig-network-instance"`
	Ipv4NeighborAddress        *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress           `path:"ipv4-neighbor-address" module:"openconfig-network-instance"`
	Ipv6InterfaceAddress       *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress          `path:"ipv6-interface-address" module:"openconfig-network-instance"`
	Ipv6NeighborAddress        *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress           `path:"ipv6-neighbor-address" module:"openconfig-network-instance"`
	LanAdjacencySid            map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid    `path:"lan-adjacency-sids/lan-adjacency-sid" module:"openconfig-network-instance/openconfig-network-instance"`
	LinkAttributes             *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes                `path:"link-attributes" module:"openconfig-network-instance"`
	LinkDelay                  *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay                     `path:"link-delay" module:"openconfig-network-instance"`
	LinkDelayVariation         *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation            `path:"link-delay-variation" module:"openconfig-network-instance"`
	LinkId                     *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId                        `path:"link-id" module:"openconfig-network-instance"`
	LinkLoss                   *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss                      `path:"link-loss" module:"openconfig-network-instance"`
	LinkProtectionType         *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType            `path:"link-protection-type" module:"openconfig-network-instance"`
	MaxLinkBandwidth           *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth              `path:"max-link-bandwidth" module:"openconfig-network-instance"`
	MaxReservableLinkBandwidth *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth    `path:"max-reservable-link-bandwidth" module:"openconfig-network-instance"`
	MinMaxLinkDelay            *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay               `path:"min-max-link-delay" module:"openconfig-network-instance"`
	ResidualBandwidth          *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth             `path:"residual-bandwidth" module:"openconfig-network-instance"`
	SetupPriority              map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority       `path:"unreserved-bandwidth/setup-priority" module:"openconfig-network-instance/openconfig-network-instance"`
	TeDefaultMetric            *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric               `path:"te-default-metric" module:"openconfig-network-instance"`
	Type                       E_IsisLsdbTypes_ISIS_SUBTLV_TYPE                                                                                           `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"type" shadow-module:"openconfig-network-instance"`
	UnconstrainedLsp           *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp              `path:"unconstrained-lsp" module:"openconfig-network-instance"`
	UtilizedBandwidth          *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth             `path:"utilized-bandwidth" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) IsYANGGoStruct() {
}

// NewAdjacencySid creates a new entry in the AdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencySid", key)
	}

	t.AdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid{
		Value: &Value,
	}

	return t.AdjacencySid[key], nil
}

// RenameAdjacencySid renames an entry in the list AdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.AdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencySid", newK)
	}

	e, ok := t.AdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencySid", oldK)
	}
	e.Value = &newK

	t.AdjacencySid[newK] = e
	delete(t.AdjacencySid, oldK)
	return nil
}

// GetOrCreateAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid {

	key := Value

	if v, ok := t.AdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencySid retrieves the value with the specified key from
// the AdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.AdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteAdjacencySid(Value uint32) {
	key := Value

	delete(t.AdjacencySid, key)
}

// AppendAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid struct to the
// list AdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) error {
	if v.Value == nil {
		return fmt.Errorf("invalid nil key received for Value")
	}

	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencySid == nil {
		t.AdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid)
	}

	if _, ok := t.AdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencySid %v", key)
	}

	t.AdjacencySid[key] = v
	return nil
}

// NewBandwidthConstraint creates a new entry in the BandwidthConstraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewBandwidthConstraint(ModelId uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	key := ModelId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthConstraint", key)
	}

	t.BandwidthConstraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint{
		ModelId: &ModelId,
	}

	return t.BandwidthConstraint[key], nil
}

// RenameBandwidthConstraint renames an entry in the list BandwidthConstraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameBandwidthConstraint(oldK, newK uint8) error {
	if _, ok := t.BandwidthConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthConstraint", newK)
	}

	e, ok := t.BandwidthConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthConstraint", oldK)
	}
	e.ModelId = &newK

	t.BandwidthConstraint[newK] = e
	delete(t.BandwidthConstraint, oldK)
	return nil
}

// GetOrCreateBandwidthConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint {

	key := ModelId

	if v, ok := t.BandwidthConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthConstraint(ModelId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthConstraint got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthConstraint retrieves the value with the specified key from
// the BandwidthConstraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetBandwidthConstraint(ModelId uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint {

	if t == nil {
		return nil
	}

	key := ModelId

	if lm, ok := t.BandwidthConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteBandwidthConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteBandwidthConstraint(ModelId uint8) {
	key := ModelId

	delete(t.BandwidthConstraint, key)
}

// AppendBandwidthConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct to the
// list BandwidthConstraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendBandwidthConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) error {
	if v.ModelId == nil {
		return fmt.Errorf("invalid nil key received for ModelId")
	}

	key := *v.ModelId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthConstraint == nil {
		t.BandwidthConstraint = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint)
	}

	if _, ok := t.BandwidthConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthConstraint %v", key)
	}

	t.BandwidthConstraint[key] = v
	return nil
}

// NewLanAdjacencySid creates a new entry in the LanAdjacencySid list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewLanAdjacencySid(Value uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LanAdjacencySid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LanAdjacencySid", key)
	}

	t.LanAdjacencySid[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid{
		Value: &Value,
	}

	return t.LanAdjacencySid[key], nil
}

// RenameLanAdjacencySid renames an entry in the list LanAdjacencySid within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameLanAdjacencySid(oldK, newK uint32) error {
	if _, ok := t.LanAdjacencySid[newK]; ok {
		return fmt.Errorf("key %v already exists in LanAdjacencySid", newK)
	}

	e, ok := t.LanAdjacencySid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LanAdjacencySid", oldK)
	}
	e.Value = &newK

	t.LanAdjacencySid[newK] = e
	delete(t.LanAdjacencySid, oldK)
	return nil
}

// GetOrCreateLanAdjacencySid retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid {

	key := Value

	if v, ok := t.LanAdjacencySid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLanAdjacencySid(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLanAdjacencySid got unexpected error: %v", err))
	}
	return v
}

// GetLanAdjacencySid retrieves the value with the specified key from
// the LanAdjacencySid map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLanAdjacencySid(Value uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.LanAdjacencySid[key]; ok {
		return lm
	}
	return nil
}

// DeleteLanAdjacencySid deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteLanAdjacencySid(Value uint32) {
	key := Value

	delete(t.LanAdjacencySid, key)
}

// AppendLanAdjacencySid appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid struct to the
// list LanAdjacencySid of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendLanAdjacencySid(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) error {
	if v.Value == nil {
		return fmt.Errorf("invalid nil key received for Value")
	}

	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LanAdjacencySid == nil {
		t.LanAdjacencySid = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid)
	}

	if _, ok := t.LanAdjacencySid[key]; ok {
		return fmt.Errorf("duplicate key for list LanAdjacencySid %v", key)
	}

	t.LanAdjacencySid[key] = v
	return nil
}

// NewSetupPriority creates a new entry in the SetupPriority list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) NewSetupPriority(Priority uint8) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SetupPriority[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SetupPriority", key)
	}

	t.SetupPriority[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority{
		Priority: &Priority,
	}

	return t.SetupPriority[key], nil
}

// RenameSetupPriority renames an entry in the list SetupPriority within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) RenameSetupPriority(oldK, newK uint8) error {
	if _, ok := t.SetupPriority[newK]; ok {
		return fmt.Errorf("key %v already exists in SetupPriority", newK)
	}

	e, ok := t.SetupPriority[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SetupPriority", oldK)
	}
	e.Priority = &newK

	t.SetupPriority[newK] = e
	delete(t.SetupPriority, oldK)
	return nil
}

// GetOrCreateSetupPriority retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority {

	key := Priority

	if v, ok := t.SetupPriority[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSetupPriority(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSetupPriority got unexpected error: %v", err))
	}
	return v
}

// GetSetupPriority retrieves the value with the specified key from
// the SetupPriority map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetSetupPriority(Priority uint8) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.SetupPriority[key]; ok {
		return lm
	}
	return nil
}

// DeleteSetupPriority deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) DeleteSetupPriority(Priority uint8) {
	key := Priority

	delete(t.SetupPriority, key)
}

// AppendSetupPriority appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority struct to the
// list SetupPriority of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) AppendSetupPriority(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) error {
	if v.Priority == nil {
		return fmt.Errorf("invalid nil key received for Priority")
	}

	key := *v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SetupPriority == nil {
		t.SetupPriority = make(map[uint8]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority)
	}

	if _, ok := t.SetupPriority[key]; ok {
		return fmt.Errorf("duplicate key for list SetupPriority %v", key)
	}

	t.SetupPriority[key] = v
	return nil
}

// GetOrCreateAdminGroup retrieves the value of the AdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup {
	if t.AdminGroup != nil {
		return t.AdminGroup
	}
	t.AdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup{}
	return t.AdminGroup
}

// GetOrCreateAvailableBandwidth retrieves the value of the AvailableBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	t.AvailableBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth{}
	return t.AvailableBandwidth
}

// GetOrCreateExtendedAdminGroup retrieves the value of the ExtendedAdminGroup field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	t.ExtendedAdminGroup = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup{}
	return t.ExtendedAdminGroup
}

// GetOrCreateIpv4InterfaceAddress retrieves the value of the Ipv4InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	t.Ipv4InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress{}
	return t.Ipv4InterfaceAddress
}

// GetOrCreateIpv4NeighborAddress retrieves the value of the Ipv4NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	t.Ipv4NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress{}
	return t.Ipv4NeighborAddress
}

// GetOrCreateIpv6InterfaceAddress retrieves the value of the Ipv6InterfaceAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	t.Ipv6InterfaceAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress{}
	return t.Ipv6InterfaceAddress
}

// GetOrCreateIpv6NeighborAddress retrieves the value of the Ipv6NeighborAddress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	t.Ipv6NeighborAddress = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress{}
	return t.Ipv6NeighborAddress
}

// GetOrCreateLinkAttributes retrieves the value of the LinkAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes {
	if t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	t.LinkAttributes = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes{}
	return t.LinkAttributes
}

// GetOrCreateLinkDelay retrieves the value of the LinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay {
	if t.LinkDelay != nil {
		return t.LinkDelay
	}
	t.LinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay{}
	return t.LinkDelay
}

// GetOrCreateLinkDelayVariation retrieves the value of the LinkDelayVariation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	t.LinkDelayVariation = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation{}
	return t.LinkDelayVariation
}

// GetOrCreateLinkId retrieves the value of the LinkId field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId {
	if t.LinkId != nil {
		return t.LinkId
	}
	t.LinkId = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId{}
	return t.LinkId
}

// GetOrCreateLinkLoss retrieves the value of the LinkLoss field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss {
	if t.LinkLoss != nil {
		return t.LinkLoss
	}
	t.LinkLoss = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss{}
	return t.LinkLoss
}

// GetOrCreateLinkProtectionType retrieves the value of the LinkProtectionType field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	t.LinkProtectionType = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType{}
	return t.LinkProtectionType
}

// GetOrCreateMaxLinkBandwidth retrieves the value of the MaxLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	t.MaxLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth{}
	return t.MaxLinkBandwidth
}

// GetOrCreateMaxReservableLinkBandwidth retrieves the value of the MaxReservableLinkBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	t.MaxReservableLinkBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth{}
	return t.MaxReservableLinkBandwidth
}

// GetOrCreateMinMaxLinkDelay retrieves the value of the MinMaxLinkDelay field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	t.MinMaxLinkDelay = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay{}
	return t.MinMaxLinkDelay
}

// GetOrCreateResidualBandwidth retrieves the value of the ResidualBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	t.ResidualBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth{}
	return t.ResidualBandwidth
}

// GetOrCreateTeDefaultMetric retrieves the value of the TeDefaultMetric field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	t.TeDefaultMetric = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric{}
	return t.TeDefaultMetric
}

// GetOrCreateUnconstrainedLsp retrieves the value of the UnconstrainedLsp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	t.UnconstrainedLsp = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp{}
	return t.UnconstrainedLsp
}

// GetOrCreateUtilizedBandwidth retrieves the value of the UtilizedBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetOrCreateUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	t.UtilizedBandwidth = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth{}
	return t.UtilizedBandwidth
}

// GetAdminGroup returns the value of the AdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field AdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup {
	if t != nil && t.AdminGroup != nil {
		return t.AdminGroup
	}
	return nil
}

// GetAvailableBandwidth returns the value of the AvailableBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field AvailableBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetAvailableBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth {
	if t != nil && t.AvailableBandwidth != nil {
		return t.AvailableBandwidth
	}
	return nil
}

// GetExtendedAdminGroup returns the value of the ExtendedAdminGroup struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field ExtendedAdminGroup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetExtendedAdminGroup() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup {
	if t != nil && t.ExtendedAdminGroup != nil {
		return t.ExtendedAdminGroup
	}
	return nil
}

// GetIpv4InterfaceAddress returns the value of the Ipv4InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv4InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress {
	if t != nil && t.Ipv4InterfaceAddress != nil {
		return t.Ipv4InterfaceAddress
	}
	return nil
}

// GetIpv4NeighborAddress returns the value of the Ipv4NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv4NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv4NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress {
	if t != nil && t.Ipv4NeighborAddress != nil {
		return t.Ipv4NeighborAddress
	}
	return nil
}

// GetIpv6InterfaceAddress returns the value of the Ipv6InterfaceAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6InterfaceAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv6InterfaceAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress {
	if t != nil && t.Ipv6InterfaceAddress != nil {
		return t.Ipv6InterfaceAddress
	}
	return nil
}

// GetIpv6NeighborAddress returns the value of the Ipv6NeighborAddress struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field Ipv6NeighborAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetIpv6NeighborAddress() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress {
	if t != nil && t.Ipv6NeighborAddress != nil {
		return t.Ipv6NeighborAddress
	}
	return nil
}

// GetLinkAttributes returns the value of the LinkAttributes struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkAttributes() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes {
	if t != nil && t.LinkAttributes != nil {
		return t.LinkAttributes
	}
	return nil
}

// GetLinkDelay returns the value of the LinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay {
	if t != nil && t.LinkDelay != nil {
		return t.LinkDelay
	}
	return nil
}

// GetLinkDelayVariation returns the value of the LinkDelayVariation struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkDelayVariation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkDelayVariation() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation {
	if t != nil && t.LinkDelayVariation != nil {
		return t.LinkDelayVariation
	}
	return nil
}

// GetLinkId returns the value of the LinkId struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkId() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId {
	if t != nil && t.LinkId != nil {
		return t.LinkId
	}
	return nil
}

// GetLinkLoss returns the value of the LinkLoss struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkLoss is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkLoss() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss {
	if t != nil && t.LinkLoss != nil {
		return t.LinkLoss
	}
	return nil
}

// GetLinkProtectionType returns the value of the LinkProtectionType struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field LinkProtectionType is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetLinkProtectionType() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType {
	if t != nil && t.LinkProtectionType != nil {
		return t.LinkProtectionType
	}
	return nil
}

// GetMaxLinkBandwidth returns the value of the MaxLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field MaxLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetMaxLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth {
	if t != nil && t.MaxLinkBandwidth != nil {
		return t.MaxLinkBandwidth
	}
	return nil
}

// GetMaxReservableLinkBandwidth returns the value of the MaxReservableLinkBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field MaxReservableLinkBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetMaxReservableLinkBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth {
	if t != nil && t.MaxReservableLinkBandwidth != nil {
		return t.MaxReservableLinkBandwidth
	}
	return nil
}

// GetMinMaxLinkDelay returns the value of the MinMaxLinkDelay struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field MinMaxLinkDelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetMinMaxLinkDelay() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay {
	if t != nil && t.MinMaxLinkDelay != nil {
		return t.MinMaxLinkDelay
	}
	return nil
}

// GetResidualBandwidth returns the value of the ResidualBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field ResidualBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetResidualBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth {
	if t != nil && t.ResidualBandwidth != nil {
		return t.ResidualBandwidth
	}
	return nil
}

// GetTeDefaultMetric returns the value of the TeDefaultMetric struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field TeDefaultMetric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetTeDefaultMetric() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_TeDefaultMetric {
	if t != nil && t.TeDefaultMetric != nil {
		return t.TeDefaultMetric
	}
	return nil
}

// GetUnconstrainedLsp returns the value of the UnconstrainedLsp struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field UnconstrainedLsp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetUnconstrainedLsp() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UnconstrainedLsp {
	if t != nil && t.UnconstrainedLsp != nil {
		return t.UnconstrainedLsp
	}
	return nil
}

// GetUtilizedBandwidth returns the value of the UtilizedBandwidth struct pointer
// from NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv. If the receiver or the field UtilizedBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetUtilizedBandwidth() *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_UtilizedBandwidth {
	if t != nil && t.UtilizedBandwidth != nil {
		return t.UtilizedBandwidth
	}
	return nil
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) GetType() E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AdminGroup.PopulateDefaults()
	t.AvailableBandwidth.PopulateDefaults()
	t.ExtendedAdminGroup.PopulateDefaults()
	t.Ipv4InterfaceAddress.PopulateDefaults()
	t.Ipv4NeighborAddress.PopulateDefaults()
	t.Ipv6InterfaceAddress.PopulateDefaults()
	t.Ipv6NeighborAddress.PopulateDefaults()
	t.LinkAttributes.PopulateDefaults()
	t.LinkDelay.PopulateDefaults()
	t.LinkDelayVariation.PopulateDefaults()
	t.LinkId.PopulateDefaults()
	t.LinkLoss.PopulateDefaults()
	t.LinkProtectionType.PopulateDefaults()
	t.MaxLinkBandwidth.PopulateDefaults()
	t.MaxReservableLinkBandwidth.PopulateDefaults()
	t.MinMaxLinkDelay.PopulateDefaults()
	t.ResidualBandwidth.PopulateDefaults()
	t.TeDefaultMetric.PopulateDefaults()
	t.UnconstrainedLsp.PopulateDefaults()
	t.UtilizedBandwidth.PopulateDefaults()
	for _, e := range t.AdjacencySid {
		e.PopulateDefaults()
	}
	for _, e := range t.BandwidthConstraint {
		e.PopulateDefaults()
	}
	for _, e := range t.LanAdjacencySid {
		e.PopulateDefaults()
	}
	for _, e := range t.SetupPriority {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/adjacency-sids/adjacency-sid YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid struct {
	Flags  []E_AdjacencySid_Flags `path:"state/flags" module:"openconfig-network-instance/openconfig-network-instance"`
	Value  *uint32                `path:"state/value|value" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"value" shadow-module:"openconfig-network-instance"`
	Weight *uint8                 `path:"state/weight" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) IsYANGGoStruct() {
}

// GetFlags retrieves the value of the leaf Flags from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) GetFlags() []E_AdjacencySid_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// GetValue retrieves the value of the leaf Value from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// GetWeight retrieves the value of the leaf Weight from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/admin-group YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup struct {
	AdminGroup []uint32 `path:"state/admin-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup) IsYANGGoStruct() {
}

// GetAdminGroup retrieves the value of the leaf AdminGroup from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroup is set, it can
// safely use t.GetAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup) GetAdminGroup() []uint32 {
	if t == nil || t.AdminGroup == nil {
		return nil
	}
	return t.AdminGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/available-bandwidth YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth struct {
	Bandwidth Binary                           `path:"state/bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	Type      E_IsisLsdbTypes_ISIS_SUBTLV_TYPE `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) IsYANGGoStruct() {
}

// GetBandwidth retrieves the value of the leaf Bandwidth from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bandwidth is set, it can
// safely use t.GetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) GetBandwidth() Binary {
	if t == nil || t.Bandwidth == nil {
		return nil
	}
	return t.Bandwidth
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) GetType() E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_AvailableBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct {
	Constraint map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint `path:"constraints/constraint" module:"openconfig-network-instance/openconfig-network-instance"`
	ModelId    *uint8                                                                                                                                 `path:"state/model-id|model-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"model-id" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) IsYANGGoStruct() {
}

// NewConstraint creates a new entry in the Constraint list of the
// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) NewConstraint(ConstraintId uint32) (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	key := ConstraintId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Constraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Constraint", key)
	}

	t.Constraint[key] = &NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint{
		ConstraintId: &ConstraintId,
	}

	return t.Constraint[key], nil
}

// RenameConstraint renames an entry in the list Constraint within
// the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) RenameConstraint(oldK, newK uint32) error {
	if _, ok := t.Constraint[newK]; ok {
		return fmt.Errorf("key %v already exists in Constraint", newK)
	}

	e, ok := t.Constraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Constraint", oldK)
	}
	e.ConstraintId = &newK

	t.Constraint[newK] = e
	delete(t.Constraint, oldK)
	return nil
}

// GetOrCreateConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) GetOrCreateConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	key := ConstraintId

	if v, ok := t.Constraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConstraint(ConstraintId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConstraint got unexpected error: %v", err))
	}
	return v
}

// GetConstraint retrieves the value with the specified key from
// the Constraint map field of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) GetConstraint(ConstraintId uint32) *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint {

	if t == nil {
		return nil
	}

	key := ConstraintId

	if lm, ok := t.Constraint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) DeleteConstraint(ConstraintId uint32) {
	key := ConstraintId

	delete(t.Constraint, key)
}

// AppendConstraint appends the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct to the
// list Constraint of NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) AppendConstraint(v *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) error {
	if v.ConstraintId == nil {
		return fmt.Errorf("invalid nil key received for ConstraintId")
	}

	key := *v.ConstraintId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Constraint == nil {
		t.Constraint = make(map[uint32]*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint)
	}

	if _, ok := t.Constraint[key]; ok {
		return fmt.Errorf("duplicate key for list Constraint %v", key)
	}

	t.Constraint[key] = v
	return nil
}

// GetModelId retrieves the value of the leaf ModelId from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ModelId is set, it can
// safely use t.GetModelId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ModelId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) GetModelId() uint8 {
	if t == nil || t.ModelId == nil {
		return 0
	}
	return *t.ModelId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Constraint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ModelId == nil {
		return nil, fmt.Errorf("nil value for key ModelId")
	}

	return map[string]interface{}{
		"model-id": *t.ModelId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/bandwidth-constraints/bandwidth-constraint/constraints/constraint YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct {
	Bandwidth    Binary  `path:"state/bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	ConstraintId *uint32 `path:"state/constraint-id|constraint-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"constraint-id" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) IsYANGGoStruct() {
}

// GetBandwidth retrieves the value of the leaf Bandwidth from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bandwidth is set, it can
// safely use t.GetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) GetBandwidth() Binary {
	if t == nil || t.Bandwidth == nil {
		return nil
	}
	return t.Bandwidth
}

// GetConstraintId retrieves the value of the leaf ConstraintId from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConstraintId is set, it can
// safely use t.GetConstraintId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConstraintId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) GetConstraintId() uint32 {
	if t == nil || t.ConstraintId == nil {
		return 0
	}
	return *t.ConstraintId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConstraintId == nil {
		return nil, fmt.Errorf("nil value for key ConstraintId")
	}

	return map[string]interface{}{
		"constraint-id": *t.ConstraintId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_BandwidthConstraint_Constraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/extended-admin-group YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup struct {
	ExtendedAdminGroup []uint32 `path:"state/extended-admin-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup) IsYANGGoStruct() {
}

// GetExtendedAdminGroup retrieves the value of the leaf ExtendedAdminGroup from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExtendedAdminGroup is set, it can
// safely use t.GetExtendedAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExtendedAdminGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup) GetExtendedAdminGroup() []uint32 {
	if t == nil || t.ExtendedAdminGroup == nil {
		return nil
	}
	return t.ExtendedAdminGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ExtendedAdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-interface-address YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress struct {
	Address []string `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) GetAddress() []string {
	if t == nil || t.Address == nil {
		return nil
	}
	return t.Address
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv4-neighbor-address YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress struct {
	Address []string `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) GetAddress() []string {
	if t == nil || t.Address == nil {
		return nil
	}
	return t.Address
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv4NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-interface-address YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress struct {
	Address []string `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) GetAddress() []string {
	if t == nil || t.Address == nil {
		return nil
	}
	return t.Address
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6InterfaceAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/ipv6-neighbor-address YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress struct {
	Address []string `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) GetAddress() []string {
	if t == nil || t.Address == nil {
		return nil
	}
	return t.Address
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_Ipv6NeighborAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/lan-adjacency-sids/lan-adjacency-sid YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid struct {
	Flags      []E_LanAdjacencySid_Flags `path:"state/flags" module:"openconfig-network-instance/openconfig-network-instance"`
	NeighborId *string                   `path:"state/neighbor-id" module:"openconfig-network-instance/openconfig-network-instance"`
	Value      *uint32                   `path:"state/value|value" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"value" shadow-module:"openconfig-network-instance"`
	Weight     *uint8                    `path:"state/weight" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) IsYANGGoStruct() {
}

// GetFlags retrieves the value of the leaf Flags from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) GetFlags() []E_LanAdjacencySid_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// GetNeighborId retrieves the value of the leaf NeighborId from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborId is set, it can
// safely use t.GetNeighborId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) GetNeighborId() string {
	if t == nil || t.NeighborId == nil {
		return ""
	}
	return *t.NeighborId
}

// GetValue retrieves the value of the leaf Value from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// GetWeight retrieves the value of the leaf Weight from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LanAdjacencySid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-attributes YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes struct {
	LocalProtection []E_LinkAttributes_LocalProtection `path:"state/local-protection" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes) IsYANGGoStruct() {
}

// GetLocalProtection retrieves the value of the leaf LocalProtection from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalProtection is set, it can
// safely use t.GetLocalProtection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalProtection == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes) GetLocalProtection() []E_LinkAttributes_LocalProtection {
	if t == nil || t.LocalProtection == nil {
		return nil
	}
	return t.LocalProtection
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay struct {
	ABit  *bool   `path:"state/a-bit" module:"openconfig-network-instance/openconfig-network-instance"`
	Delay *uint32 `path:"state/delay" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) IsYANGGoStruct() {
}

// GetABit retrieves the value of the leaf ABit from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ABit is set, it can
// safely use t.GetABit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ABit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) GetABit() bool {
	if t == nil || t.ABit == nil {
		return false
	}
	return *t.ABit
}

// GetDelay retrieves the value of the leaf Delay from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Delay is set, it can
// safely use t.GetDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Delay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) GetDelay() uint32 {
	if t == nil || t.Delay == nil {
		return 0
	}
	return *t.Delay
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-delay-variation YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation struct {
	Delay *uint32 `path:"state/delay" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation) IsYANGGoStruct() {
}

// GetDelay retrieves the value of the leaf Delay from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Delay is set, it can
// safely use t.GetDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Delay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation) GetDelay() uint32 {
	if t == nil || t.Delay == nil {
		return 0
	}
	return *t.Delay
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkDelayVariation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-id YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId struct {
	Local  *uint32 `path:"state/local" module:"openconfig-network-instance/openconfig-network-instance"`
	Remote *uint32 `path:"state/remote" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) IsYANGGoStruct() {
}

// GetLocal retrieves the value of the leaf Local from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Local is set, it can
// safely use t.GetLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Local == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) GetLocal() uint32 {
	if t == nil || t.Local == nil {
		return 0
	}
	return *t.Local
}

// GetRemote retrieves the value of the leaf Remote from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Remote is set, it can
// safely use t.GetRemote() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Remote == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) GetRemote() uint32 {
	if t == nil || t.Remote == nil {
		return 0
	}
	return *t.Remote
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-loss YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss struct {
	ABit     *bool   `path:"state/a-bit" module:"openconfig-network-instance/openconfig-network-instance"`
	LinkLoss *uint32 `path:"state/link-loss" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) IsYANGGoStruct() {
}

// GetABit retrieves the value of the leaf ABit from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ABit is set, it can
// safely use t.GetABit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ABit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) GetABit() bool {
	if t == nil || t.ABit == nil {
		return false
	}
	return *t.ABit
}

// GetLinkLoss retrieves the value of the leaf LinkLoss from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLoss is set, it can
// safely use t.GetLinkLoss() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLoss == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) GetLinkLoss() uint32 {
	if t == nil || t.LinkLoss == nil {
		return 0
	}
	return *t.LinkLoss
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkLoss) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/link-protection-type YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType struct {
	Type []E_LinkProtectionType_Type `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType) IsYANGGoStruct() {
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType) GetType() []E_LinkProtectionType_Type {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_LinkProtectionType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-link-bandwidth YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth struct {
	Bandwidth Binary `path:"state/bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth) IsYANGGoStruct() {
}

// GetBandwidth retrieves the value of the leaf Bandwidth from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bandwidth is set, it can
// safely use t.GetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth) GetBandwidth() Binary {
	if t == nil || t.Bandwidth == nil {
		return nil
	}
	return t.Bandwidth
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/max-reservable-link-bandwidth YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth struct {
	Bandwidth Binary `path:"state/bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) IsYANGGoStruct() {
}

// GetBandwidth retrieves the value of the leaf Bandwidth from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bandwidth is set, it can
// safely use t.GetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) GetBandwidth() Binary {
	if t == nil || t.Bandwidth == nil {
		return nil
	}
	return t.Bandwidth
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MaxReservableLinkBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/min-max-link-delay YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay struct {
	ABit     *bool   `path:"state/a-bit" module:"openconfig-network-instance/openconfig-network-instance"`
	MaxDelay *uint32 `path:"state/max-delay" module:"openconfig-network-instance/openconfig-network-instance"`
	MinDelay *uint32 `path:"state/min-delay" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) IsYANGGoStruct() {
}

// GetABit retrieves the value of the leaf ABit from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ABit is set, it can
// safely use t.GetABit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ABit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) GetABit() bool {
	if t == nil || t.ABit == nil {
		return false
	}
	return *t.ABit
}

// GetMaxDelay retrieves the value of the leaf MaxDelay from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxDelay is set, it can
// safely use t.GetMaxDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxDelay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) GetMaxDelay() uint32 {
	if t == nil || t.MaxDelay == nil {
		return 0
	}
	return *t.MaxDelay
}

// GetMinDelay retrieves the value of the leaf MinDelay from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinDelay is set, it can
// safely use t.GetMinDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinDelay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) GetMinDelay() uint32 {
	if t == nil || t.MinDelay == nil {
		return 0
	}
	return *t.MinDelay
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_MinMaxLinkDelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/residual-bandwidth YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth struct {
	Bandwidth Binary `path:"state/bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth) IsYANGGoStruct() {
}

// GetBandwidth retrieves the value of the leaf Bandwidth from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bandwidth is set, it can
// safely use t.GetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth) GetBandwidth() Binary {
	if t == nil || t.Bandwidth == nil {
		return nil
	}
	return t.Bandwidth
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_ResidualBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-is-reachability/neighbors/neighbor/instances/instance/subtlvs/subtlv/unreserved-bandwidth/setup-priority YANG schema element.
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority struct {
	Bandwidth Binary `path:"state/bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	Priority  *uint8 `path:"state/priority|priority" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"priority" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) IsYANGGoStruct() {
}

// GetBandwidth retrieves the value of the leaf Bandwidth from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bandwidth is set, it can
// safely use t.GetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) GetBandwidth() Binary {
	if t == nil || t.Bandwidth == nil {
		return nil
	}
	return t.Bandwidth
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Priority == nil {
		return nil, fmt.Errorf("nil value for key Priority")
	}

	return map[string]interface{}{
		"priority": *t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIsReachability_Neighbor_Instance_Subtlv_SetupPriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}
