/*
Package telemetry is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /usr/local/google/home/gdennis/go/pkg/mod/github.com/openconfig/ygot@v0.22.1/genutil/names.go
using the following YANG input files:
	- gnmi-collector-metadata.yang
	- public/release/models/acl/openconfig-acl.yang
	- public/release/models/acl/openconfig-packet-match.yang
	- public/release/models/aft/openconfig-aft.yang
	- public/release/models/aft/openconfig-aft-network-instance.yang
	- public/release/models/ate/openconfig-ate-flow.yang
	- public/release/models/ate/openconfig-ate-intf.yang
	- public/release/models/bfd/openconfig-bfd.yang
	- public/release/models/bgp/openconfig-bgp-policy.yang
	- public/release/models/bgp/openconfig-bgp-types.yang
	- public/release/models/interfaces/openconfig-if-aggregate.yang
	- public/release/models/interfaces/openconfig-if-ethernet.yang
	- public/release/models/interfaces/openconfig-if-ip-ext.yang
	- public/release/models/interfaces/openconfig-if-ip.yang
	- public/release/models/interfaces/openconfig-interfaces.yang
	- public/release/models/isis/openconfig-isis.yang
	- public/release/models/lacp/openconfig-lacp.yang
	- public/release/models/lldp/openconfig-lldp-types.yang
	- public/release/models/lldp/openconfig-lldp.yang
	- public/release/models/local-routing/openconfig-local-routing.yang
	- public/release/models/mpls/openconfig-mpls-types.yang
	- public/release/models/multicast/openconfig-pim.yang
	- public/release/models/network-instance/openconfig-network-instance.yang
	- public/release/models/openconfig-extensions.yang
	- public/release/models/optical-transport/openconfig-transport-types.yang
	- public/release/models/ospf/openconfig-ospfv2.yang
	- public/release/models/p4rt/openconfig-p4rt.yang
	- public/release/models/platform/openconfig-platform-cpu.yang
	- public/release/models/platform/openconfig-platform-fan.yang
	- public/release/models/platform/openconfig-platform-integrated-circuit.yang
	- public/release/models/platform/openconfig-platform-software.yang
	- public/release/models/platform/openconfig-platform-transceiver.yang
	- public/release/models/platform/openconfig-platform.yang
	- public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
	- public/release/models/policy/openconfig-policy-types.yang
	- public/release/models/qos/openconfig-qos-elements.yang
	- public/release/models/qos/openconfig-qos-interfaces.yang
	- public/release/models/qos/openconfig-qos-types.yang
	- public/release/models/qos/openconfig-qos.yang
	- public/release/models/rib/openconfig-rib-bgp.yang
	- public/release/models/segment-routing/openconfig-segment-routing-types.yang
	- public/release/models/system/openconfig-system.yang
	- public/release/models/types/openconfig-inet-types.yang
	- public/release/models/types/openconfig-types.yang
	- public/release/models/types/openconfig-yang-types.yang
	- public/release/models/vlan/openconfig-vlan.yang
	- public/third_party/ietf/iana-if-type.yang
	- public/third_party/ietf/ietf-inet-types.yang
	- public/third_party/ietf/ietf-interfaces.yang
	- public/third_party/ietf/ietf-yang-types.yang
Imported modules were sourced from:
	- public/release/models/...
	- public/third_party/ietf/...
*/
package telemetry

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Interface_Subinterface_Ipv6_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup struct {
	AcceptMode            *bool                                                            `path:"state/accept-mode" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/accept-mode" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	AdvertisementInterval *uint16                                                          `path:"state/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/advertisement-interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	CurrentPriority       *uint8                                                           `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceTracking     *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	Preempt               *bool                                                            `path:"state/preempt" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/preempt" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	PreemptDelay          *uint16                                                          `path:"state/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/preempt-delay" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Priority              *uint8                                                           `path:"state/priority" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/priority" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualAddress        []string                                                         `path:"state/virtual-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/virtual-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualLinkLocal      *string                                                          `path:"state/virtual-link-local" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/virtual-link-local" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	VirtualRouterId       *uint8                                                           `path:"state/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"config/virtual-router-id|virtual-router-id" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualLinkLocal retrieves the value of the leaf VirtualLinkLocal from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualLinkLocal is set, it can
// safely use t.GetVirtualLinkLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualLinkLocal == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualLinkLocal() string {
	if t == nil || t.VirtualLinkLocal == nil {
		return ""
	}
	return *t.VirtualLinkLocal
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking struct {
	PriorityDecrement *uint8   `path:"state/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/priority-decrement" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	TrackInterface    []string `path:"state/track-interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/track-interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Autoconf represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/autoconf YANG schema element.
type Interface_Subinterface_Ipv6_Autoconf struct {
	CreateGlobalAddresses      *bool   `path:"state/create-global-addresses" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"config/create-global-addresses" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	CreateTemporaryAddresses   *bool   `path:"state/create-temporary-addresses" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"config/create-temporary-addresses" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	TemporaryPreferredLifetime *uint32 `path:"state/temporary-preferred-lifetime" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"config/temporary-preferred-lifetime" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	TemporaryValidLifetime     *uint32 `path:"state/temporary-valid-lifetime" module:"openconfig-if-ip-ext/openconfig-if-ip-ext" shadow-path:"config/temporary-valid-lifetime" shadow-module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Autoconf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Autoconf) IsYANGGoStruct() {}

// GetCreateGlobalAddresses retrieves the value of the leaf CreateGlobalAddresses from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CreateGlobalAddresses is set, it can
// safely use t.GetCreateGlobalAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CreateGlobalAddresses == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetCreateGlobalAddresses() bool {
	if t == nil || t.CreateGlobalAddresses == nil {
		return true
	}
	return *t.CreateGlobalAddresses
}

// GetCreateTemporaryAddresses retrieves the value of the leaf CreateTemporaryAddresses from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CreateTemporaryAddresses is set, it can
// safely use t.GetCreateTemporaryAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CreateTemporaryAddresses == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetCreateTemporaryAddresses() bool {
	if t == nil || t.CreateTemporaryAddresses == nil {
		return false
	}
	return *t.CreateTemporaryAddresses
}

// GetTemporaryPreferredLifetime retrieves the value of the leaf TemporaryPreferredLifetime from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TemporaryPreferredLifetime is set, it can
// safely use t.GetTemporaryPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TemporaryPreferredLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetTemporaryPreferredLifetime() uint32 {
	if t == nil || t.TemporaryPreferredLifetime == nil {
		return 86400
	}
	return *t.TemporaryPreferredLifetime
}

// GetTemporaryValidLifetime retrieves the value of the leaf TemporaryValidLifetime from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TemporaryValidLifetime is set, it can
// safely use t.GetTemporaryValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TemporaryValidLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetTemporaryValidLifetime() uint32 {
	if t == nil || t.TemporaryValidLifetime == nil {
		return 604800
	}
	return *t.TemporaryValidLifetime
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Autoconf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Autoconf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CreateGlobalAddresses == nil {
		var v bool = true
		t.CreateGlobalAddresses = &v
	}
	if t.CreateTemporaryAddresses == nil {
		var v bool = false
		t.CreateTemporaryAddresses = &v
	}
	if t.TemporaryPreferredLifetime == nil {
		var v uint32 = 86400
		t.TemporaryPreferredLifetime = &v
	}
	if t.TemporaryValidLifetime == nil {
		var v uint32 = 604800
		t.TemporaryValidLifetime = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Autoconf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Autoconf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Autoconf.
func (*Interface_Subinterface_Ipv6_Autoconf) ΛBelongingModule() string {
	return "openconfig-if-ip-ext"
}

// Interface_Subinterface_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/state/counters YANG schema element.
type Interface_Subinterface_Ipv6_Counters struct {
	InDiscardedPkts    *uint64 `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	InErrorPkts        *uint64 `path:"in-error-pkts" module:"openconfig-if-ip"`
	InForwardedOctets  *uint64 `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	InForwardedPkts    *uint64 `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	InOctets           *uint64 `path:"in-octets" module:"openconfig-if-ip"`
	InPkts             *uint64 `path:"in-pkts" module:"openconfig-if-ip"`
	OutDiscardedPkts   *uint64 `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	OutErrorPkts       *uint64 `path:"out-error-pkts" module:"openconfig-if-ip"`
	OutForwardedOctets *uint64 `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	OutForwardedPkts   *uint64 `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	OutOctets          *uint64 `path:"out-octets" module:"openconfig-if-ip"`
	OutPkts            *uint64 `path:"out-pkts" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Counters.
func (*Interface_Subinterface_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor YANG schema element.
type Interface_Subinterface_Ipv6_Neighbor struct {
	Ip               *string                  `path:"state/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip" shadow-path:"config/ip|ip" shadow-module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	IsRouter         *bool                    `path:"state/is-router" module:"openconfig-if-ip/openconfig-if-ip"`
	LinkLayerAddress *string                  `path:"state/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/link-layer-address" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	NeighborState    E_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-ip/openconfig-if-ip"`
	Origin           E_IfIp_NeighborOrigin    `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetNeighborState() E_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Neighbor.
func (*Interface_Subinterface_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement YANG schema element.
type Interface_Subinterface_Ipv6_RouterAdvertisement struct {
	Interval *uint32 `path:"state/interval" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/interval" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Lifetime *uint32 `path:"state/lifetime" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/lifetime" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Suppress *bool   `path:"state/suppress" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/suppress" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// GetInterval retrieves the value of the leaf Interval from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_RouterAdvertisement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Suppress == nil {
		var v bool = false
		t.Suppress = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_RouterAdvertisement.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered struct {
	Enabled      *bool                                                `path:"state/enabled" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/enabled" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	InterfaceRef *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered.
func (*Interface_Subinterface_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/interface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-if-ip/openconfig-if-ip" shadow-path:"config/subinterface" shadow-module:"openconfig-if-ip/openconfig-if-ip"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Vlan represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan YANG schema element.
type Interface_Subinterface_Vlan struct {
	EgressMapping  *Interface_Subinterface_Vlan_EgressMapping  `path:"egress-mapping" module:"openconfig-vlan"`
	IngressMapping *Interface_Subinterface_Vlan_IngressMapping `path:"ingress-mapping" module:"openconfig-vlan"`
	Match          *Interface_Subinterface_Vlan_Match          `path:"match" module:"openconfig-vlan"`
	VlanId         Interface_Subinterface_Vlan_VlanId_Union    `path:"state/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan) IsYANGGoStruct() {}

// GetOrCreateEgressMapping retrieves the value of the EgressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t.EgressMapping != nil {
		return t.EgressMapping
	}
	t.EgressMapping = &Interface_Subinterface_Vlan_EgressMapping{}
	return t.EgressMapping
}

// GetOrCreateIngressMapping retrieves the value of the IngressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t.IngressMapping != nil {
		return t.IngressMapping
	}
	t.IngressMapping = &Interface_Subinterface_Vlan_IngressMapping{}
	return t.IngressMapping
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateMatch() *Interface_Subinterface_Vlan_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &Interface_Subinterface_Vlan_Match{}
	return t.Match
}

// GetEgressMapping returns the value of the EgressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field EgressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t != nil && t.EgressMapping != nil {
		return t.EgressMapping
	}
	return nil
}

// GetIngressMapping returns the value of the IngressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field IngressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t != nil && t.IngressMapping != nil {
		return t.IngressMapping
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetMatch() *Interface_Subinterface_Vlan_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan) GetVlanId() Interface_Subinterface_Vlan_VlanId_Union {
	if t == nil || t.VlanId == nil {
		return nil
	}
	return t.VlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.EgressMapping.PopulateDefaults()
	t.IngressMapping.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan.
func (*Interface_Subinterface_Vlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_EgressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/egress-mapping YANG schema element.
type Interface_Subinterface_Vlan_EgressMapping struct {
	Tpid            E_VlanTypes_TPID_TYPES      `path:"state/tpid" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/tpid" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanId          *uint16                     `path:"state/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanStackAction E_VlanTypes_VlanStackAction `path:"state/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-stack-action" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_EgressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_EgressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_EgressMapping
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_EgressMapping) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_EgressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_EgressMapping.
func (*Interface_Subinterface_Vlan_EgressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_IngressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/ingress-mapping YANG schema element.
type Interface_Subinterface_Vlan_IngressMapping struct {
	Tpid            E_VlanTypes_TPID_TYPES      `path:"state/tpid" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/tpid" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanId          *uint16                     `path:"state/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	VlanStackAction E_VlanTypes_VlanStackAction `path:"state/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-stack-action" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_IngressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_IngressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_IngressMapping
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_IngressMapping) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_IngressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_IngressMapping.
func (*Interface_Subinterface_Vlan_IngressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match YANG schema element.
type Interface_Subinterface_Vlan_Match struct {
	DoubleTagged                *Interface_Subinterface_Vlan_Match_DoubleTagged                `path:"double-tagged" module:"openconfig-vlan"`
	DoubleTaggedInnerList       *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList       `path:"double-tagged-inner-list" module:"openconfig-vlan"`
	DoubleTaggedInnerOuterRange *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange `path:"double-tagged-inner-outer-range" module:"openconfig-vlan"`
	DoubleTaggedInnerRange      *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange      `path:"double-tagged-inner-range" module:"openconfig-vlan"`
	DoubleTaggedOuterList       *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList       `path:"double-tagged-outer-list" module:"openconfig-vlan"`
	DoubleTaggedOuterRange      *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange      `path:"double-tagged-outer-range" module:"openconfig-vlan"`
	SingleTagged                *Interface_Subinterface_Vlan_Match_SingleTagged                `path:"single-tagged" module:"openconfig-vlan"`
	SingleTaggedList            *Interface_Subinterface_Vlan_Match_SingleTaggedList            `path:"single-tagged-list" module:"openconfig-vlan"`
	SingleTaggedRange           *Interface_Subinterface_Vlan_Match_SingleTaggedRange           `path:"single-tagged-range" module:"openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match) IsYANGGoStruct() {}

// GetOrCreateDoubleTagged retrieves the value of the DoubleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	t.DoubleTagged = &Interface_Subinterface_Vlan_Match_DoubleTagged{}
	return t.DoubleTagged
}

// GetOrCreateDoubleTaggedInnerList retrieves the value of the DoubleTaggedInnerList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	t.DoubleTaggedInnerList = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList{}
	return t.DoubleTaggedInnerList
}

// GetOrCreateDoubleTaggedInnerOuterRange retrieves the value of the DoubleTaggedInnerOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	t.DoubleTaggedInnerOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange{}
	return t.DoubleTaggedInnerOuterRange
}

// GetOrCreateDoubleTaggedInnerRange retrieves the value of the DoubleTaggedInnerRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	t.DoubleTaggedInnerRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange{}
	return t.DoubleTaggedInnerRange
}

// GetOrCreateDoubleTaggedOuterList retrieves the value of the DoubleTaggedOuterList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	t.DoubleTaggedOuterList = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList{}
	return t.DoubleTaggedOuterList
}

// GetOrCreateDoubleTaggedOuterRange retrieves the value of the DoubleTaggedOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	t.DoubleTaggedOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange{}
	return t.DoubleTaggedOuterRange
}

// GetOrCreateSingleTagged retrieves the value of the SingleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t.SingleTagged != nil {
		return t.SingleTagged
	}
	t.SingleTagged = &Interface_Subinterface_Vlan_Match_SingleTagged{}
	return t.SingleTagged
}

// GetOrCreateSingleTaggedList retrieves the value of the SingleTaggedList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	t.SingleTaggedList = &Interface_Subinterface_Vlan_Match_SingleTaggedList{}
	return t.SingleTaggedList
}

// GetOrCreateSingleTaggedRange retrieves the value of the SingleTaggedRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	t.SingleTaggedRange = &Interface_Subinterface_Vlan_Match_SingleTaggedRange{}
	return t.SingleTaggedRange
}

// GetDoubleTagged returns the value of the DoubleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t != nil && t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	return nil
}

// GetDoubleTaggedInnerList returns the value of the DoubleTaggedInnerList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t != nil && t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	return nil
}

// GetDoubleTaggedInnerOuterRange returns the value of the DoubleTaggedInnerOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t != nil && t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	return nil
}

// GetDoubleTaggedInnerRange returns the value of the DoubleTaggedInnerRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t != nil && t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	return nil
}

// GetDoubleTaggedOuterList returns the value of the DoubleTaggedOuterList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t != nil && t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	return nil
}

// GetDoubleTaggedOuterRange returns the value of the DoubleTaggedOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t != nil && t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	return nil
}

// GetSingleTagged returns the value of the SingleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t != nil && t.SingleTagged != nil {
		return t.SingleTagged
	}
	return nil
}

// GetSingleTaggedList returns the value of the SingleTaggedList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t != nil && t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	return nil
}

// GetSingleTaggedRange returns the value of the SingleTaggedRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t != nil && t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DoubleTagged.PopulateDefaults()
	t.DoubleTaggedInnerList.PopulateDefaults()
	t.DoubleTaggedInnerOuterRange.PopulateDefaults()
	t.DoubleTaggedInnerRange.PopulateDefaults()
	t.DoubleTaggedOuterList.PopulateDefaults()
	t.DoubleTaggedOuterRange.PopulateDefaults()
	t.SingleTagged.PopulateDefaults()
	t.SingleTaggedList.PopulateDefaults()
	t.SingleTaggedRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match.
func (*Interface_Subinterface_Vlan_Match) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTagged struct {
	InnerVlanId *uint16 `path:"state/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId *uint16 `path:"state/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTagged.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList struct {
	InnerVlanIds []uint16 `path:"state/inner-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId  *uint16  `path:"state/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) IsYANGGoStruct() {}

// GetInnerVlanIds retrieves the value of the leaf InnerVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanIds is set, it can
// safely use t.GetInnerVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetInnerVlanIds() []uint16 {
	if t == nil || t.InnerVlanIds == nil {
		return nil
	}
	return t.InnerVlanIds
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange struct {
	InnerHighVlanId *uint16 `path:"state/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16 `path:"state/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"state/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"state/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange struct {
	InnerHighVlanId *uint16  `path:"state/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	InnerLowVlanId  *uint16  `path:"state/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanId     []uint16 `path:"state/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetOuterVlanId() []uint16 {
	if t == nil || t.OuterVlanId == nil {
		return nil
	}
	return t.OuterVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList struct {
	InnerVlanId  *uint16  `path:"state/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterVlanIds []uint16 `path:"state/outer-vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanIds retrieves the value of the leaf OuterVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanIds is set, it can
// safely use t.GetOuterVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetOuterVlanIds() []uint16 {
	if t == nil || t.OuterVlanIds == nil {
		return nil
	}
	return t.OuterVlanIds
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange struct {
	InnerVlanId     *uint16 `path:"state/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/inner-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterHighVlanId *uint16 `path:"state/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	OuterLowVlanId  *uint16 `path:"state/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/outer-low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTagged struct {
	VlanId *uint16 `path:"state/vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) IsYANGGoStruct() {}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_Match_SingleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTagged.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedList struct {
	VlanIds []uint16 `path:"state/vlan-ids" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/vlan-ids" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) IsYANGGoStruct() {}

// GetVlanIds retrieves the value of the leaf VlanIds from the Interface_Subinterface_Vlan_Match_SingleTaggedList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanIds is set, it can
// safely use t.GetVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) GetVlanIds() []uint16 {
	if t == nil || t.VlanIds == nil {
		return nil
	}
	return t.VlanIds
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedList.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedRange struct {
	HighVlanId *uint16 `path:"state/high-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/high-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
	LowVlanId  *uint16 `path:"state/low-vlan-id" module:"openconfig-vlan/openconfig-vlan" shadow-path:"config/low-vlan-id" shadow-module:"openconfig-vlan/openconfig-vlan"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) IsYANGGoStruct() {}

// GetHighVlanId retrieves the value of the leaf HighVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighVlanId is set, it can
// safely use t.GetHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetHighVlanId() uint16 {
	if t == nil || t.HighVlanId == nil {
		return 0
	}
	return *t.HighVlanId
}

// GetLowVlanId retrieves the value of the leaf LowVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowVlanId is set, it can
// safely use t.GetLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetLowVlanId() uint16 {
	if t == nil || t.LowVlanId == nil {
		return 0
	}
	return *t.LowVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedRange.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Keychain represents the /openconfig-keychain/keychains/keychain YANG schema element.
type Keychain struct {
	Key       map[uint64]*Keychain_Key `path:"keys/key" module:"openconfig-keychain/openconfig-keychain"`
	Name      *string                  `path:"state/name|name" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain" shadow-path:"config/name|name" shadow-module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	Tolerance Keychain_Tolerance_Union `path:"state/tolerance" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/tolerance" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain) IsYANGGoStruct() {}

// NewKey creates a new entry in the Key list of the
// Keychain struct. The keys of the list are populated from the input
// arguments.
func (t *Keychain) NewKey(KeyId uint64) (*Keychain_Key, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[uint64]*Keychain_Key)
	}

	key := KeyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Key[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Key", key)
	}

	t.Key[key] = &Keychain_Key{
		KeyId: &KeyId,
	}

	return t.Key[key], nil
}

// RenameKey renames an entry in the list Key within
// the Keychain struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Keychain) RenameKey(oldK, newK uint64) error {
	if _, ok := t.Key[newK]; ok {
		return fmt.Errorf("key %v already exists in Key", newK)
	}

	e, ok := t.Key[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Key", oldK)
	}
	e.KeyId = &newK

	t.Key[newK] = e
	delete(t.Key, oldK)
	return nil
}

// GetOrCreateKey retrieves the value with the specified keys from
// the receiver Keychain. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Keychain) GetOrCreateKey(KeyId uint64) *Keychain_Key {

	key := KeyId

	if v, ok := t.Key[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewKey(KeyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateKey got unexpected error: %v", err))
	}
	return v
}

// GetKey retrieves the value with the specified key from
// the Key map field of Keychain. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Keychain) GetKey(KeyId uint64) *Keychain_Key {

	if t == nil {
		return nil
	}

	key := KeyId

	if lm, ok := t.Key[key]; ok {
		return lm
	}
	return nil
}

// DeleteKey deletes the value with the specified keys from
// the receiver Keychain. If there is no such element, the function
// is a no-op.
func (t *Keychain) DeleteKey(KeyId uint64) {
	key := KeyId

	delete(t.Key, key)
}

// AppendKey appends the supplied Keychain_Key struct to the
// list Key of Keychain. If the key value(s) specified in
// the supplied Keychain_Key already exist in the list, an error is
// returned.
func (t *Keychain) AppendKey(v *Keychain_Key) error {
	if v.KeyId == nil {
		return fmt.Errorf("invalid nil key received for KeyId")
	}

	key := *v.KeyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[uint64]*Keychain_Key)
	}

	if _, ok := t.Key[key]; ok {
		return fmt.Errorf("duplicate key for list Key %v", key)
	}

	t.Key[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Keychain) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTolerance retrieves the value of the leaf Tolerance from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tolerance is set, it can
// safely use t.GetTolerance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tolerance == nil' before retrieving the leaf's value.
func (t *Keychain) GetTolerance() Keychain_Tolerance_Union {
	if t == nil || t.Tolerance == nil {
		return nil
	}
	return t.Tolerance
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Key {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Keychain struct, which is a YANG list entry.
func (t *Keychain) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain.
func (*Keychain) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key represents the /openconfig-keychain/keychains/keychain/keys/key YANG schema element.
type Keychain_Key struct {
	CryptoAlgorithm E_KeychainTypes_CRYPTO_TYPE   `path:"state/crypto-algorithm" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/crypto-algorithm" shadow-module:"openconfig-keychain/openconfig-keychain"`
	KeyId           *uint64                       `path:"state/key-id|key-id" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain" shadow-path:"config/key-id|key-id" shadow-module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	ReceiveLifetime *Keychain_Key_ReceiveLifetime `path:"receive-lifetime" module:"openconfig-keychain"`
	SecretKey       *string                       `path:"state/secret-key" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/secret-key" shadow-module:"openconfig-keychain/openconfig-keychain"`
	SendLifetime    *Keychain_Key_SendLifetime    `path:"send-lifetime" module:"openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key) IsYANGGoStruct() {}

// GetOrCreateReceiveLifetime retrieves the value of the ReceiveLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	t.ReceiveLifetime = &Keychain_Key_ReceiveLifetime{}
	return t.ReceiveLifetime
}

// GetOrCreateSendLifetime retrieves the value of the SendLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateSendLifetime() *Keychain_Key_SendLifetime {
	if t.SendLifetime != nil {
		return t.SendLifetime
	}
	t.SendLifetime = &Keychain_Key_SendLifetime{}
	return t.SendLifetime
}

// GetReceiveLifetime returns the value of the ReceiveLifetime struct pointer
// from Keychain_Key. If the receiver or the field ReceiveLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t != nil && t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	return nil
}

// GetSendLifetime returns the value of the SendLifetime struct pointer
// from Keychain_Key. If the receiver or the field SendLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetSendLifetime() *Keychain_Key_SendLifetime {
	if t != nil && t.SendLifetime != nil {
		return t.SendLifetime
	}
	return nil
}

// GetCryptoAlgorithm retrieves the value of the leaf CryptoAlgorithm from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CryptoAlgorithm is set, it can
// safely use t.GetCryptoAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CryptoAlgorithm == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetCryptoAlgorithm() E_KeychainTypes_CRYPTO_TYPE {
	if t == nil || t.CryptoAlgorithm == 0 {
		return 0
	}
	return t.CryptoAlgorithm
}

// GetKeyId retrieves the value of the leaf KeyId from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyId is set, it can
// safely use t.GetKeyId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyId == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetKeyId() uint64 {
	if t == nil || t.KeyId == nil {
		return 0
	}
	return *t.KeyId
}

// GetSecretKey retrieves the value of the leaf SecretKey from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecretKey is set, it can
// safely use t.GetSecretKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecretKey == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetSecretKey() string {
	if t == nil || t.SecretKey == nil {
		return ""
	}
	return *t.SecretKey
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ReceiveLifetime.PopulateDefaults()
	t.SendLifetime.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Keychain_Key struct, which is a YANG list entry.
func (t *Keychain_Key) ΛListKeyMap() (map[string]interface{}, error) {
	if t.KeyId == nil {
		return nil, fmt.Errorf("nil value for key KeyId")
	}

	return map[string]interface{}{
		"key-id": *t.KeyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key.
func (*Keychain_Key) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_ReceiveLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/receive-lifetime YANG schema element.
type Keychain_Key_ReceiveLifetime struct {
	EndTime   *uint64 `path:"state/end-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/end-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
	StartTime *uint64 `path:"state/start-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/start-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key_ReceiveLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_ReceiveLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key_ReceiveLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key_ReceiveLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_ReceiveLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_ReceiveLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_ReceiveLifetime.
func (*Keychain_Key_ReceiveLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_SendLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/send-lifetime YANG schema element.
type Keychain_Key_SendLifetime struct {
	EndTime        *uint64 `path:"state/end-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/end-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
	SendAndReceive *bool   `path:"state/send-and-receive" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/send-and-receive" shadow-module:"openconfig-keychain/openconfig-keychain"`
	StartTime      *uint64 `path:"state/start-time" module:"openconfig-keychain/openconfig-keychain" shadow-path:"config/start-time" shadow-module:"openconfig-keychain/openconfig-keychain"`
}

// IsYANGGoStruct ensures that Keychain_Key_SendLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_SendLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetSendAndReceive retrieves the value of the leaf SendAndReceive from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendAndReceive is set, it can
// safely use t.GetSendAndReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendAndReceive == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetSendAndReceive() bool {
	if t == nil || t.SendAndReceive == nil {
		return true
	}
	return *t.SendAndReceive
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key_SendLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key_SendLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SendAndReceive == nil {
		var v bool = true
		t.SendAndReceive = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_SendLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_SendLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_SendLifetime.
func (*Keychain_Key_SendLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Lacp represents the /openconfig-lacp/lacp YANG schema element.
type Lacp struct {
	Interface      map[string]*Lacp_Interface `path:"interfaces/interface" module:"openconfig-lacp/openconfig-lacp"`
	SystemPriority *uint16                    `path:"state/system-priority" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/system-priority" shadow-module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lacp struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp) NewInterface(Name string) (*Lacp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lacp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lacp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lacp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp) GetOrCreateInterface(Name string) *Lacp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lacp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp) GetInterface(Name string) *Lacp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lacp. If there is no such element, the function
// is a no-op.
func (t *Lacp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lacp_Interface struct to the
// list Interface of Lacp. If the key value(s) specified in
// the supplied Lacp_Interface already exist in the list, an error is
// returned.
func (t *Lacp) AppendInterface(v *Lacp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp.
func (*Lacp) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface represents the /openconfig-lacp/lacp/interfaces/interface YANG schema element.
type Lacp_Interface struct {
	Interval       E_Lacp_LacpPeriodType             `path:"state/interval" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/interval" shadow-module:"openconfig-lacp/openconfig-lacp"`
	LacpMode       E_Lacp_LacpActivityType           `path:"state/lacp-mode" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/lacp-mode" shadow-module:"openconfig-lacp/openconfig-lacp"`
	Member         map[string]*Lacp_Interface_Member `path:"members/member" module:"openconfig-lacp/openconfig-lacp"`
	Name           *string                           `path:"state/name|name" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp" shadow-path:"config/name|name" shadow-module:"openconfig-lacp/openconfig-lacp|openconfig-lacp"`
	SystemIdMac    *string                           `path:"state/system-id-mac" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/system-id-mac" shadow-module:"openconfig-lacp/openconfig-lacp"`
	SystemPriority *uint16                           `path:"state/system-priority" module:"openconfig-lacp/openconfig-lacp" shadow-path:"config/system-priority" shadow-module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface) IsYANGGoStruct() {}

// NewMember creates a new entry in the Member list of the
// Lacp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp_Interface) NewMember(Interface string) (*Lacp_Interface_Member, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Member[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Member", key)
	}

	t.Member[key] = &Lacp_Interface_Member{
		Interface: &Interface,
	}

	return t.Member[key], nil
}

// RenameMember renames an entry in the list Member within
// the Lacp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp_Interface) RenameMember(oldK, newK string) error {
	if _, ok := t.Member[newK]; ok {
		return fmt.Errorf("key %v already exists in Member", newK)
	}

	e, ok := t.Member[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Member", oldK)
	}
	e.Interface = &newK

	t.Member[newK] = e
	delete(t.Member, oldK)
	return nil
}

// GetOrCreateMember retrieves the value with the specified keys from
// the receiver Lacp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp_Interface) GetOrCreateMember(Interface string) *Lacp_Interface_Member {

	key := Interface

	if v, ok := t.Member[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMember(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMember got unexpected error: %v", err))
	}
	return v
}

// GetMember retrieves the value with the specified key from
// the Member map field of Lacp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp_Interface) GetMember(Interface string) *Lacp_Interface_Member {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.Member[key]; ok {
		return lm
	}
	return nil
}

// DeleteMember deletes the value with the specified keys from
// the receiver Lacp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lacp_Interface) DeleteMember(Interface string) {
	key := Interface

	delete(t.Member, key)
}

// AppendMember appends the supplied Lacp_Interface_Member struct to the
// list Member of Lacp_Interface. If the key value(s) specified in
// the supplied Lacp_Interface_Member already exist in the list, an error is
// returned.
func (t *Lacp_Interface) AppendMember(v *Lacp_Interface_Member) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	if _, ok := t.Member[key]; ok {
		return fmt.Errorf("duplicate key for list Member %v", key)
	}

	t.Member[key] = v
	return nil
}

// GetInterval retrieves the value of the leaf Interval from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetInterval() E_Lacp_LacpPeriodType {
	if t == nil || t.Interval == 0 {
		return Lacp_LacpPeriodType_SLOW
	}
	return t.Interval
}

// GetLacpMode retrieves the value of the leaf LacpMode from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpMode is set, it can
// safely use t.GetLacpMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpMode == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetLacpMode() E_Lacp_LacpActivityType {
	if t == nil || t.LacpMode == 0 {
		return Lacp_LacpActivityType_ACTIVE
	}
	return t.LacpMode
}

// GetName retrieves the value of the leaf Name from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSystemIdMac retrieves the value of the leaf SystemIdMac from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemIdMac is set, it can
// safely use t.GetSystemIdMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemIdMac == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemIdMac() string {
	if t == nil || t.SystemIdMac == nil {
		return ""
	}
	return *t.SystemIdMac
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interval == 0 {
		t.Interval = Lacp_LacpPeriodType_SLOW
	}
	if t.LacpMode == 0 {
		t.LacpMode = Lacp_LacpActivityType_ACTIVE
	}
	for _, e := range t.Member {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lacp_Interface struct, which is a YANG list entry.
func (t *Lacp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface.
func (*Lacp_Interface) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface_Member represents the /openconfig-lacp/lacp/interfaces/interface/members/member YANG schema element.
type Lacp_Interface_Member struct {
	Activity        E_Lacp_LacpActivityType         `path:"state/activity" module:"openconfig-lacp/openconfig-lacp"`
	Aggregatable    *bool                           `path:"state/aggregatable" module:"openconfig-lacp/openconfig-lacp"`
	Collecting      *bool                           `path:"state/collecting" module:"openconfig-lacp/openconfig-lacp"`
	Counters        *Lacp_Interface_Member_Counters `path:"state/counters" module:"openconfig-lacp/openconfig-lacp"`
	Distributing    *bool                           `path:"state/distributing" module:"openconfig-lacp/openconfig-lacp"`
	Interface       *string                         `path:"state/interface|interface" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp" shadow-path:"interface" shadow-module:"openconfig-lacp"`
	LastChange      *uint64                         `path:"state/last-change" module:"openconfig-lacp/openconfig-lacp"`
	OperKey         *uint16                         `path:"state/oper-key" module:"openconfig-lacp/openconfig-lacp"`
	PartnerId       *string                         `path:"state/partner-id" module:"openconfig-lacp/openconfig-lacp"`
	PartnerKey      *uint16                         `path:"state/partner-key" module:"openconfig-lacp/openconfig-lacp"`
	PartnerPortNum  *uint16                         `path:"state/partner-port-num" module:"openconfig-lacp/openconfig-lacp"`
	PortNum         *uint16                         `path:"state/port-num" module:"openconfig-lacp/openconfig-lacp"`
	Synchronization E_Lacp_LacpSynchronizationType  `path:"state/synchronization" module:"openconfig-lacp/openconfig-lacp"`
	SystemId        *string                         `path:"state/system-id" module:"openconfig-lacp/openconfig-lacp"`
	Timeout         E_Lacp_LacpTimeoutType          `path:"state/timeout" module:"openconfig-lacp/openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lacp_Interface_Member) GetOrCreateCounters() *Lacp_Interface_Member_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lacp_Interface_Member_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lacp_Interface_Member. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lacp_Interface_Member) GetCounters() *Lacp_Interface_Member_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetActivity retrieves the value of the leaf Activity from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Activity is set, it can
// safely use t.GetActivity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Activity == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetActivity() E_Lacp_LacpActivityType {
	if t == nil || t.Activity == 0 {
		return 0
	}
	return t.Activity
}

// GetAggregatable retrieves the value of the leaf Aggregatable from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Aggregatable is set, it can
// safely use t.GetAggregatable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Aggregatable == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetAggregatable() bool {
	if t == nil || t.Aggregatable == nil {
		return false
	}
	return *t.Aggregatable
}

// GetCollecting retrieves the value of the leaf Collecting from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Collecting is set, it can
// safely use t.GetCollecting() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Collecting == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetCollecting() bool {
	if t == nil || t.Collecting == nil {
		return false
	}
	return *t.Collecting
}

// GetDistributing retrieves the value of the leaf Distributing from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Distributing is set, it can
// safely use t.GetDistributing() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Distributing == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetDistributing() bool {
	if t == nil || t.Distributing == nil {
		return false
	}
	return *t.Distributing
}

// GetInterface retrieves the value of the leaf Interface from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLastChange retrieves the value of the leaf LastChange from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetOperKey retrieves the value of the leaf OperKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperKey is set, it can
// safely use t.GetOperKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetOperKey() uint16 {
	if t == nil || t.OperKey == nil {
		return 0
	}
	return *t.OperKey
}

// GetPartnerId retrieves the value of the leaf PartnerId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerId is set, it can
// safely use t.GetPartnerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerId() string {
	if t == nil || t.PartnerId == nil {
		return ""
	}
	return *t.PartnerId
}

// GetPartnerKey retrieves the value of the leaf PartnerKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerKey is set, it can
// safely use t.GetPartnerKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerKey() uint16 {
	if t == nil || t.PartnerKey == nil {
		return 0
	}
	return *t.PartnerKey
}

// GetPartnerPortNum retrieves the value of the leaf PartnerPortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerPortNum is set, it can
// safely use t.GetPartnerPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerPortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerPortNum() uint16 {
	if t == nil || t.PartnerPortNum == nil {
		return 0
	}
	return *t.PartnerPortNum
}

// GetPortNum retrieves the value of the leaf PortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortNum is set, it can
// safely use t.GetPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPortNum() uint16 {
	if t == nil || t.PortNum == nil {
		return 0
	}
	return *t.PortNum
}

// GetSynchronization retrieves the value of the leaf Synchronization from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Synchronization is set, it can
// safely use t.GetSynchronization() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Synchronization == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSynchronization() E_Lacp_LacpSynchronizationType {
	if t == nil || t.Synchronization == 0 {
		return 0
	}
	return t.Synchronization
}

// GetSystemId retrieves the value of the leaf SystemId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetTimeout retrieves the value of the leaf Timeout from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetTimeout() E_Lacp_LacpTimeoutType {
	if t == nil || t.Timeout == 0 {
		return 0
	}
	return t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface_Member
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface_Member) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Lacp_Interface_Member struct, which is a YANG list entry.
func (t *Lacp_Interface_Member) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member.
func (*Lacp_Interface_Member) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface_Member_Counters represents the /openconfig-lacp/lacp/interfaces/interface/members/member/state/counters YANG schema element.
type Lacp_Interface_Member_Counters struct {
	LacpErrors             *uint64 `path:"lacp-errors" module:"openconfig-lacp"`
	LacpInPkts             *uint64 `path:"lacp-in-pkts" module:"openconfig-lacp"`
	LacpOutPkts            *uint64 `path:"lacp-out-pkts" module:"openconfig-lacp"`
	LacpRxErrors           *uint64 `path:"lacp-rx-errors" module:"openconfig-lacp"`
	LacpTimeoutTransitions *uint64 `path:"lacp-timeout-transitions" module:"openconfig-lacp"`
	LacpTxErrors           *uint64 `path:"lacp-tx-errors" module:"openconfig-lacp"`
	LacpUnknownErrors      *uint64 `path:"lacp-unknown-errors" module:"openconfig-lacp"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member_Counters) IsYANGGoStruct() {}

// GetLacpErrors retrieves the value of the leaf LacpErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpErrors is set, it can
// safely use t.GetLacpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpErrors() uint64 {
	if t == nil || t.LacpErrors == nil {
		return 0
	}
	return *t.LacpErrors
}

// GetLacpInPkts retrieves the value of the leaf LacpInPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpInPkts is set, it can
// safely use t.GetLacpInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpInPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpInPkts() uint64 {
	if t == nil || t.LacpInPkts == nil {
		return 0
	}
	return *t.LacpInPkts
}

// GetLacpOutPkts retrieves the value of the leaf LacpOutPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpOutPkts is set, it can
// safely use t.GetLacpOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpOutPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpOutPkts() uint64 {
	if t == nil || t.LacpOutPkts == nil {
		return 0
	}
	return *t.LacpOutPkts
}

// GetLacpRxErrors retrieves the value of the leaf LacpRxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpRxErrors is set, it can
// safely use t.GetLacpRxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpRxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpRxErrors() uint64 {
	if t == nil || t.LacpRxErrors == nil {
		return 0
	}
	return *t.LacpRxErrors
}

// GetLacpTimeoutTransitions retrieves the value of the leaf LacpTimeoutTransitions from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTimeoutTransitions is set, it can
// safely use t.GetLacpTimeoutTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTimeoutTransitions == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTimeoutTransitions() uint64 {
	if t == nil || t.LacpTimeoutTransitions == nil {
		return 0
	}
	return *t.LacpTimeoutTransitions
}

// GetLacpTxErrors retrieves the value of the leaf LacpTxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTxErrors is set, it can
// safely use t.GetLacpTxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTxErrors() uint64 {
	if t == nil || t.LacpTxErrors == nil {
		return 0
	}
	return *t.LacpTxErrors
}

// GetLacpUnknownErrors retrieves the value of the leaf LacpUnknownErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpUnknownErrors is set, it can
// safely use t.GetLacpUnknownErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpUnknownErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpUnknownErrors() uint64 {
	if t == nil || t.LacpUnknownErrors == nil {
		return 0
	}
	return *t.LacpUnknownErrors
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface_Member_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface_Member_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member_Counters.
func (*Lacp_Interface_Member_Counters) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lldp represents the /openconfig-lldp/lldp YANG schema element.
type Lldp struct {
	ChassisId                *string                    `path:"state/chassis-id" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/chassis-id" shadow-module:"openconfig-lldp/openconfig-lldp"`
	ChassisIdType            E_LldpTypes_ChassisIdType  `path:"state/chassis-id-type" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/chassis-id-type" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Counters                 *Lldp_Counters             `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	Enabled                  *bool                      `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/enabled" shadow-module:"openconfig-lldp/openconfig-lldp"`
	HelloTimer               *uint64                    `path:"state/hello-timer" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/hello-timer" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Interface                map[string]*Lldp_Interface `path:"interfaces/interface" module:"openconfig-lldp/openconfig-lldp"`
	SuppressTlvAdvertisement []E_LldpTypes_LLDP_TLV     `path:"state/suppress-tlv-advertisement" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/suppress-tlv-advertisement" shadow-module:"openconfig-lldp/openconfig-lldp"`
	SystemDescription        *string                    `path:"state/system-description" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/system-description" shadow-module:"openconfig-lldp/openconfig-lldp"`
	SystemName               *string                    `path:"state/system-name" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/system-name" shadow-module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp) NewInterface(Name string) (*Lldp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp) GetOrCreateInterface(Name string) *Lldp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp) GetInterface(Name string) *Lldp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lldp. If there is no such element, the function
// is a no-op.
func (t *Lldp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lldp_Interface struct to the
// list Interface of Lldp. If the key value(s) specified in
// the supplied Lldp_Interface already exist in the list, an error is
// returned.
func (t *Lldp) AppendInterface(v *Lldp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp) GetOrCreateCounters() *Lldp_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp) GetCounters() *Lldp_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetHelloTimer retrieves the value of the leaf HelloTimer from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloTimer is set, it can
// safely use t.GetHelloTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloTimer == nil' before retrieving the leaf's value.
func (t *Lldp) GetHelloTimer() uint64 {
	if t == nil || t.HelloTimer == nil {
		return 0
	}
	return *t.HelloTimer
}

// GetSuppressTlvAdvertisement retrieves the value of the leaf SuppressTlvAdvertisement from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressTlvAdvertisement is set, it can
// safely use t.GetSuppressTlvAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressTlvAdvertisement == nil' before retrieving the leaf's value.
func (t *Lldp) GetSuppressTlvAdvertisement() []E_LldpTypes_LLDP_TLV {
	if t == nil || t.SuppressTlvAdvertisement == nil {
		return nil
	}
	return t.SuppressTlvAdvertisement
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp.
func (*Lldp) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Counters represents the /openconfig-lldp/lldp/state/counters YANG schema element.
type Lldp_Counters struct {
	EntriesAgedOut *uint64 `path:"entries-aged-out" module:"openconfig-lldp"`
	FrameDiscard   *uint64 `path:"frame-discard" module:"openconfig-lldp"`
	FrameErrorIn   *uint64 `path:"frame-error-in" module:"openconfig-lldp"`
	FrameIn        *uint64 `path:"frame-in" module:"openconfig-lldp"`
	FrameOut       *uint64 `path:"frame-out" module:"openconfig-lldp"`
	LastClear      *string `path:"last-clear" module:"openconfig-lldp"`
	TlvAccepted    *uint64 `path:"tlv-accepted" module:"openconfig-lldp"`
	TlvDiscard     *uint64 `path:"tlv-discard" module:"openconfig-lldp"`
	TlvUnknown     *uint64 `path:"tlv-unknown" module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Counters) IsYANGGoStruct() {}

// GetEntriesAgedOut retrieves the value of the leaf EntriesAgedOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntriesAgedOut is set, it can
// safely use t.GetEntriesAgedOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntriesAgedOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetEntriesAgedOut() uint64 {
	if t == nil || t.EntriesAgedOut == nil {
		return 0
	}
	return *t.EntriesAgedOut
}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvAccepted retrieves the value of the leaf TlvAccepted from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvAccepted is set, it can
// safely use t.GetTlvAccepted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvAccepted == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvAccepted() uint64 {
	if t == nil || t.TlvAccepted == nil {
		return 0
	}
	return *t.TlvAccepted
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Counters.
func (*Lldp_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface represents the /openconfig-lldp/lldp/interfaces/interface YANG schema element.
type Lldp_Interface struct {
	Counters *Lldp_Interface_Counters            `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	Enabled  *bool                               `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp" shadow-path:"config/enabled" shadow-module:"openconfig-lldp/openconfig-lldp"`
	Name     *string                             `path:"state/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"config/name|name" shadow-module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	Neighbor map[string]*Lldp_Interface_Neighbor `path:"neighbors/neighbor" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// Lldp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface) NewNeighbor(Id string) (*Lldp_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Lldp_Interface_Neighbor{
		Id: &Id,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Lldp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Id = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Lldp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface) GetOrCreateNeighbor(Id string) *Lldp_Interface_Neighbor {

	key := Id

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Lldp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface) GetNeighbor(Id string) *Lldp_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Lldp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface) DeleteNeighbor(Id string) {
	key := Id

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Lldp_Interface_Neighbor struct to the
// list Neighbor of Lldp_Interface. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *Lldp_Interface) AppendNeighbor(v *Lldp_Interface_Neighbor) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp_Interface) GetOrCreateCounters() *Lldp_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp_Interface) GetCounters() *Lldp_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lldp_Interface struct, which is a YANG list entry.
func (t *Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface.
func (*Lldp_Interface) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Counters represents the /openconfig-lldp/lldp/interfaces/interface/state/counters YANG schema element.
type Lldp_Interface_Counters struct {
	FrameDiscard  *uint64 `path:"frame-discard" module:"openconfig-lldp"`
	FrameErrorIn  *uint64 `path:"frame-error-in" module:"openconfig-lldp"`
	FrameErrorOut *uint64 `path:"frame-error-out" module:"openconfig-lldp"`
	FrameIn       *uint64 `path:"frame-in" module:"openconfig-lldp"`
	FrameOut      *uint64 `path:"frame-out" module:"openconfig-lldp"`
	LastClear     *string `path:"last-clear" module:"openconfig-lldp"`
	TlvDiscard    *uint64 `path:"tlv-discard" module:"openconfig-lldp"`
	TlvUnknown    *uint64 `path:"tlv-unknown" module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Counters) IsYANGGoStruct() {}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameErrorOut retrieves the value of the leaf FrameErrorOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorOut is set, it can
// safely use t.GetFrameErrorOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorOut() uint64 {
	if t == nil || t.FrameErrorOut == nil {
		return 0
	}
	return *t.FrameErrorOut
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Counters.
func (*Lldp_Interface_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor YANG schema element.
type Lldp_Interface_Neighbor struct {
	Age                   *uint64                                                                    `path:"state/age" module:"openconfig-lldp/openconfig-lldp"`
	Capability            map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability `path:"capabilities/capability" module:"openconfig-lldp/openconfig-lldp"`
	ChassisId             *string                                                                    `path:"state/chassis-id" module:"openconfig-lldp/openconfig-lldp"`
	ChassisIdType         E_LldpTypes_ChassisIdType                                                  `path:"state/chassis-id-type" module:"openconfig-lldp/openconfig-lldp"`
	Id                    *string                                                                    `path:"state/id|id" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"id" shadow-module:"openconfig-lldp"`
	LastUpdate            *int64                                                                     `path:"state/last-update" module:"openconfig-lldp/openconfig-lldp"`
	ManagementAddress     *string                                                                    `path:"state/management-address" module:"openconfig-lldp/openconfig-lldp"`
	ManagementAddressType *string                                                                    `path:"state/management-address-type" module:"openconfig-lldp/openconfig-lldp"`
	PortDescription       *string                                                                    `path:"state/port-description" module:"openconfig-lldp/openconfig-lldp"`
	PortId                *string                                                                    `path:"state/port-id" module:"openconfig-lldp/openconfig-lldp"`
	PortIdType            E_LldpTypes_PortIdType                                                     `path:"state/port-id-type" module:"openconfig-lldp/openconfig-lldp"`
	SystemDescription     *string                                                                    `path:"state/system-description" module:"openconfig-lldp/openconfig-lldp"`
	SystemName            *string                                                                    `path:"state/system-name" module:"openconfig-lldp/openconfig-lldp"`
	Tlv                   map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv           `path:"custom-tlvs/tlv" module:"openconfig-lldp/openconfig-lldp"`
	Ttl                   *uint16                                                                    `path:"state/ttl" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor) IsYANGGoStruct() {}

// Lldp_Interface_Neighbor_Tlv_Key represents the key for list Tlv of element /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor.
type Lldp_Interface_Neighbor_Tlv_Key struct {
	Type       int32  `path:"type"`
	Oui        string `path:"oui"`
	OuiSubtype string `path:"oui-subtype"`
}

// NewCapability creates a new entry in the Capability list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) (*Lldp_Interface_Neighbor_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &Lldp_Interface_Neighbor_Capability{
		Name: Name,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameCapability(oldK, newK E_LldpTypes_LLDP_SYSTEM_CAPABILITY) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.Name = newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	key := Name

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// DeleteCapability deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) {
	key := Name

	delete(t.Capability, key)
}

// AppendCapability appends the supplied Lldp_Interface_Neighbor_Capability struct to the
// list Capability of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Capability already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendCapability(v *Lldp_Interface_Neighbor_Capability) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewTlv creates a new entry in the Tlv list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewTlv(Type int32, Oui string, OuiSubtype string) (*Lldp_Interface_Neighbor_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &Lldp_Interface_Neighbor_Tlv{
		Type:       &Type,
		Oui:        &Oui,
		OuiSubtype: &OuiSubtype,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameTlv(oldK, newK Lldp_Interface_Neighbor_Tlv_Key) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = &newK.Type
	e.Oui = &newK.Oui
	e.OuiSubtype = &newK.OuiSubtype

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type, Oui, OuiSubtype)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	if t == nil {
		return nil
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteTlv deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteTlv(Type int32, Oui string, OuiSubtype string) {
	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	delete(t.Tlv, key)
}

// AppendTlv appends the supplied Lldp_Interface_Neighbor_Tlv struct to the
// list Tlv of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Tlv already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendTlv(v *Lldp_Interface_Neighbor_Tlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key for Type")
	}

	if v.Oui == nil {
		return fmt.Errorf("invalid nil key for Oui")
	}

	if v.OuiSubtype == nil {
		return fmt.Errorf("invalid nil key for OuiSubtype")
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       *v.Type,
		Oui:        *v.Oui,
		OuiSubtype: *v.OuiSubtype,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// GetAge retrieves the value of the leaf Age from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetId retrieves the value of the leaf Id from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetLastUpdate retrieves the value of the leaf LastUpdate from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastUpdate is set, it can
// safely use t.GetLastUpdate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastUpdate == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetLastUpdate() int64 {
	if t == nil || t.LastUpdate == nil {
		return 0
	}
	return *t.LastUpdate
}

// GetManagementAddress retrieves the value of the leaf ManagementAddress from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddress is set, it can
// safely use t.GetManagementAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddress == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddress() string {
	if t == nil || t.ManagementAddress == nil {
		return ""
	}
	return *t.ManagementAddress
}

// GetManagementAddressType retrieves the value of the leaf ManagementAddressType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddressType is set, it can
// safely use t.GetManagementAddressType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddressType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddressType() string {
	if t == nil || t.ManagementAddressType == nil {
		return ""
	}
	return *t.ManagementAddressType
}

// GetPortDescription retrieves the value of the leaf PortDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortDescription is set, it can
// safely use t.GetPortDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortDescription() string {
	if t == nil || t.PortDescription == nil {
		return ""
	}
	return *t.PortDescription
}

// GetPortId retrieves the value of the leaf PortId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortId is set, it can
// safely use t.GetPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortId() string {
	if t == nil || t.PortId == nil {
		return ""
	}
	return *t.PortId
}

// GetPortIdType retrieves the value of the leaf PortIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortIdType is set, it can
// safely use t.GetPortIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortIdType() E_LldpTypes_PortIdType {
	if t == nil || t.PortIdType == 0 {
		return 0
	}
	return t.PortIdType
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// GetTtl retrieves the value of the leaf Ttl from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetTtl() uint16 {
	if t == nil || t.Ttl == nil {
		return 0
	}
	return *t.Ttl
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Capability {
		e.PopulateDefaults()
	}
	for _, e := range t.Tlv {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor.
func (*Lldp_Interface_Neighbor) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Capability represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/capabilities/capability YANG schema element.
type Lldp_Interface_Neighbor_Capability struct {
	Enabled *bool                              `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp"`
	Name    E_LldpTypes_LLDP_SYSTEM_CAPABILITY `path:"state/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"name" shadow-module:"openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Capability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Capability) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetName() E_LldpTypes_LLDP_SYSTEM_CAPABILITY {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor_Capability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor_Capability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Capability struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Capability) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Capability.
func (*Lldp_Interface_Neighbor_Capability) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Tlv represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/custom-tlvs/tlv YANG schema element.
type Lldp_Interface_Neighbor_Tlv struct {
	Oui        *string `path:"state/oui|oui" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"oui" shadow-module:"openconfig-lldp"`
	OuiSubtype *string `path:"state/oui-subtype|oui-subtype" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"oui-subtype" shadow-module:"openconfig-lldp"`
	Type       *int32  `path:"state/type|type" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp" shadow-path:"type" shadow-module:"openconfig-lldp"`
	Value      Binary  `path:"state/value" module:"openconfig-lldp/openconfig-lldp"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Tlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Tlv) IsYANGGoStruct() {}

// GetOui retrieves the value of the leaf Oui from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Oui is set, it can
// safely use t.GetOui() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Oui == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOui() string {
	if t == nil || t.Oui == nil {
		return ""
	}
	return *t.Oui
}

// GetOuiSubtype retrieves the value of the leaf OuiSubtype from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuiSubtype is set, it can
// safely use t.GetOuiSubtype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuiSubtype == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOuiSubtype() string {
	if t == nil || t.OuiSubtype == nil {
		return ""
	}
	return *t.OuiSubtype
}

// GetType retrieves the value of the leaf Type from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetType() int32 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// GetValue retrieves the value of the leaf Value from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetValue() Binary {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor_Tlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor_Tlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Tlv struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Tlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Oui == nil {
		return nil, fmt.Errorf("nil value for key Oui")
	}

	if t.OuiSubtype == nil {
		return nil, fmt.Errorf("nil value for key OuiSubtype")
	}

	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"oui":         *t.Oui,
		"oui-subtype": *t.OuiSubtype,
		"type":        *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Tlv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Tlv.
func (*Lldp_Interface_Neighbor_Tlv) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Meta represents the /gnmi-collector-metadata/meta YANG schema element.
type Meta struct {
	ConnectError           *string                 `path:"connectError" module:"gnmi-collector-metadata"`
	Connected              *bool                   `path:"connected" module:"gnmi-collector-metadata"`
	ConnectedAddress       *string                 `path:"connectedAddress" module:"gnmi-collector-metadata"`
	LatencyAvg             *int64                  `path:"latencyAvg" module:"gnmi-collector-metadata"`
	LatencyMax             *int64                  `path:"latencyMax" module:"gnmi-collector-metadata"`
	LatencyMin             *int64                  `path:"latencyMin" module:"gnmi-collector-metadata"`
	LatestTimestamp        *int64                  `path:"latestTimestamp" module:"gnmi-collector-metadata"`
	Sync                   *bool                   `path:"sync" module:"gnmi-collector-metadata"`
	TargetLeaves           *int64                  `path:"targetLeaves" module:"gnmi-collector-metadata"`
	TargetLeavesAdded      *int64                  `path:"targetLeavesAdded" module:"gnmi-collector-metadata"`
	TargetLeavesDeleted    *int64                  `path:"targetLeavesDeleted" module:"gnmi-collector-metadata"`
	TargetLeavesEmpty      *int64                  `path:"targetLeavesEmpty" module:"gnmi-collector-metadata"`
	TargetLeavesStale      *int64                  `path:"targetLeavesStale" module:"gnmi-collector-metadata"`
	TargetLeavesSuppressed *int64                  `path:"targetLeavesSuppressed" module:"gnmi-collector-metadata"`
	TargetLeavesUpdated    *int64                  `path:"targetLeavesUpdated" module:"gnmi-collector-metadata"`
	TargetSize             *int64                  `path:"targetSize" module:"gnmi-collector-metadata"`
	Window                 map[string]*Meta_Window `path:"latency/window" module:"gnmi-collector-metadata/gnmi-collector-metadata"`
}

// IsYANGGoStruct ensures that Meta implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Meta) IsYANGGoStruct() {}

// NewWindow creates a new entry in the Window list of the
// Meta struct. The keys of the list are populated from the input
// arguments.
func (t *Meta) NewWindow(Size string) (*Meta_Window, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Window == nil {
		t.Window = make(map[string]*Meta_Window)
	}

	key := Size

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Window[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Window", key)
	}

	t.Window[key] = &Meta_Window{
		Size: &Size,
	}

	return t.Window[key], nil
}

// RenameWindow renames an entry in the list Window within
// the Meta struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Meta) RenameWindow(oldK, newK string) error {
	if _, ok := t.Window[newK]; ok {
		return fmt.Errorf("key %v already exists in Window", newK)
	}

	e, ok := t.Window[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Window", oldK)
	}
	e.Size = &newK

	t.Window[newK] = e
	delete(t.Window, oldK)
	return nil
}

// GetOrCreateWindow retrieves the value with the specified keys from
// the receiver Meta. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Meta) GetOrCreateWindow(Size string) *Meta_Window {

	key := Size

	if v, ok := t.Window[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewWindow(Size)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateWindow got unexpected error: %v", err))
	}
	return v
}

// GetWindow retrieves the value with the specified key from
// the Window map field of Meta. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Meta) GetWindow(Size string) *Meta_Window {

	if t == nil {
		return nil
	}

	key := Size

	if lm, ok := t.Window[key]; ok {
		return lm
	}
	return nil
}

// DeleteWindow deletes the value with the specified keys from
// the receiver Meta. If there is no such element, the function
// is a no-op.
func (t *Meta) DeleteWindow(Size string) {
	key := Size

	delete(t.Window, key)
}

// AppendWindow appends the supplied Meta_Window struct to the
// list Window of Meta. If the key value(s) specified in
// the supplied Meta_Window already exist in the list, an error is
// returned.
func (t *Meta) AppendWindow(v *Meta_Window) error {
	if v.Size == nil {
		return fmt.Errorf("invalid nil key received for Size")
	}

	key := *v.Size

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Window == nil {
		t.Window = make(map[string]*Meta_Window)
	}

	if _, ok := t.Window[key]; ok {
		return fmt.Errorf("duplicate key for list Window %v", key)
	}

	t.Window[key] = v
	return nil
}

// GetConnectError retrieves the value of the leaf ConnectError from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConnectError is set, it can
// safely use t.GetConnectError() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConnectError == nil' before retrieving the leaf's value.
func (t *Meta) GetConnectError() string {
	if t == nil || t.ConnectError == nil {
		return ""
	}
	return *t.ConnectError
}

// GetConnected retrieves the value of the leaf Connected from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Connected is set, it can
// safely use t.GetConnected() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Connected == nil' before retrieving the leaf's value.
func (t *Meta) GetConnected() bool {
	if t == nil || t.Connected == nil {
		return false
	}
	return *t.Connected
}

// GetConnectedAddress retrieves the value of the leaf ConnectedAddress from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConnectedAddress is set, it can
// safely use t.GetConnectedAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConnectedAddress == nil' before retrieving the leaf's value.
func (t *Meta) GetConnectedAddress() string {
	if t == nil || t.ConnectedAddress == nil {
		return ""
	}
	return *t.ConnectedAddress
}

// GetLatencyAvg retrieves the value of the leaf LatencyAvg from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LatencyAvg is set, it can
// safely use t.GetLatencyAvg() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LatencyAvg == nil' before retrieving the leaf's value.
func (t *Meta) GetLatencyAvg() int64 {
	if t == nil || t.LatencyAvg == nil {
		return 0
	}
	return *t.LatencyAvg
}

// GetLatencyMax retrieves the value of the leaf LatencyMax from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LatencyMax is set, it can
// safely use t.GetLatencyMax() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LatencyMax == nil' before retrieving the leaf's value.
func (t *Meta) GetLatencyMax() int64 {
	if t == nil || t.LatencyMax == nil {
		return 0
	}
	return *t.LatencyMax
}

// GetLatencyMin retrieves the value of the leaf LatencyMin from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LatencyMin is set, it can
// safely use t.GetLatencyMin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LatencyMin == nil' before retrieving the leaf's value.
func (t *Meta) GetLatencyMin() int64 {
	if t == nil || t.LatencyMin == nil {
		return 0
	}
	return *t.LatencyMin
}

// GetLatestTimestamp retrieves the value of the leaf LatestTimestamp from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LatestTimestamp is set, it can
// safely use t.GetLatestTimestamp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LatestTimestamp == nil' before retrieving the leaf's value.
func (t *Meta) GetLatestTimestamp() int64 {
	if t == nil || t.LatestTimestamp == nil {
		return 0
	}
	return *t.LatestTimestamp
}

// GetSync retrieves the value of the leaf Sync from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sync is set, it can
// safely use t.GetSync() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sync == nil' before retrieving the leaf's value.
func (t *Meta) GetSync() bool {
	if t == nil || t.Sync == nil {
		return false
	}
	return *t.Sync
}

// GetTargetLeaves retrieves the value of the leaf TargetLeaves from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetLeaves is set, it can
// safely use t.GetTargetLeaves() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetLeaves == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetLeaves() int64 {
	if t == nil || t.TargetLeaves == nil {
		return 0
	}
	return *t.TargetLeaves
}

// GetTargetLeavesAdded retrieves the value of the leaf TargetLeavesAdded from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetLeavesAdded is set, it can
// safely use t.GetTargetLeavesAdded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetLeavesAdded == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetLeavesAdded() int64 {
	if t == nil || t.TargetLeavesAdded == nil {
		return 0
	}
	return *t.TargetLeavesAdded
}

// GetTargetLeavesDeleted retrieves the value of the leaf TargetLeavesDeleted from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetLeavesDeleted is set, it can
// safely use t.GetTargetLeavesDeleted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetLeavesDeleted == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetLeavesDeleted() int64 {
	if t == nil || t.TargetLeavesDeleted == nil {
		return 0
	}
	return *t.TargetLeavesDeleted
}

// GetTargetLeavesEmpty retrieves the value of the leaf TargetLeavesEmpty from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetLeavesEmpty is set, it can
// safely use t.GetTargetLeavesEmpty() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetLeavesEmpty == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetLeavesEmpty() int64 {
	if t == nil || t.TargetLeavesEmpty == nil {
		return 0
	}
	return *t.TargetLeavesEmpty
}

// GetTargetLeavesStale retrieves the value of the leaf TargetLeavesStale from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetLeavesStale is set, it can
// safely use t.GetTargetLeavesStale() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetLeavesStale == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetLeavesStale() int64 {
	if t == nil || t.TargetLeavesStale == nil {
		return 0
	}
	return *t.TargetLeavesStale
}

// GetTargetLeavesSuppressed retrieves the value of the leaf TargetLeavesSuppressed from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetLeavesSuppressed is set, it can
// safely use t.GetTargetLeavesSuppressed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetLeavesSuppressed == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetLeavesSuppressed() int64 {
	if t == nil || t.TargetLeavesSuppressed == nil {
		return 0
	}
	return *t.TargetLeavesSuppressed
}

// GetTargetLeavesUpdated retrieves the value of the leaf TargetLeavesUpdated from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetLeavesUpdated is set, it can
// safely use t.GetTargetLeavesUpdated() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetLeavesUpdated == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetLeavesUpdated() int64 {
	if t == nil || t.TargetLeavesUpdated == nil {
		return 0
	}
	return *t.TargetLeavesUpdated
}

// GetTargetSize retrieves the value of the leaf TargetSize from the Meta
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetSize is set, it can
// safely use t.GetTargetSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetSize == nil' before retrieving the leaf's value.
func (t *Meta) GetTargetSize() int64 {
	if t == nil || t.TargetSize == nil {
		return 0
	}
	return *t.TargetSize
}

// PopulateDefaults recursively populates unset leaf fields in the Meta
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Meta) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Window {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Meta) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Meta"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Meta) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Meta) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Meta.
func (*Meta) ΛBelongingModule() string {
	return "gnmi-collector-metadata"
}

// Meta_Window represents the /gnmi-collector-metadata/meta/latency/window YANG schema element.
type Meta_Window struct {
	Avg  *int64  `path:"avg" module:"gnmi-collector-metadata"`
	Max  *int64  `path:"max" module:"gnmi-collector-metadata"`
	Min  *int64  `path:"min" module:"gnmi-collector-metadata"`
	Size *string `path:"state/size|size" module:"gnmi-collector-metadata/gnmi-collector-metadata|gnmi-collector-metadata" shadow-path:"size" shadow-module:"gnmi-collector-metadata"`
}

// IsYANGGoStruct ensures that Meta_Window implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Meta_Window) IsYANGGoStruct() {}

// GetAvg retrieves the value of the leaf Avg from the Meta_Window
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Avg is set, it can
// safely use t.GetAvg() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Avg == nil' before retrieving the leaf's value.
func (t *Meta_Window) GetAvg() int64 {
	if t == nil || t.Avg == nil {
		return 0
	}
	return *t.Avg
}

// GetMax retrieves the value of the leaf Max from the Meta_Window
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Max is set, it can
// safely use t.GetMax() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Max == nil' before retrieving the leaf's value.
func (t *Meta_Window) GetMax() int64 {
	if t == nil || t.Max == nil {
		return 0
	}
	return *t.Max
}

// GetMin retrieves the value of the leaf Min from the Meta_Window
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Min is set, it can
// safely use t.GetMin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Min == nil' before retrieving the leaf's value.
func (t *Meta_Window) GetMin() int64 {
	if t == nil || t.Min == nil {
		return 0
	}
	return *t.Min
}

// GetSize retrieves the value of the leaf Size from the Meta_Window
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Size is set, it can
// safely use t.GetSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Size == nil' before retrieving the leaf's value.
func (t *Meta_Window) GetSize() string {
	if t == nil || t.Size == nil {
		return ""
	}
	return *t.Size
}

// PopulateDefaults recursively populates unset leaf fields in the Meta_Window
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Meta_Window) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Meta_Window struct, which is a YANG list entry.
func (t *Meta_Window) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Size == nil {
		return nil, fmt.Errorf("nil value for key Size")
	}

	return map[string]interface{}{
		"size": *t.Size,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Meta_Window) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Meta_Window"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Meta_Window) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Meta_Window) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Meta_Window.
func (*Meta_Window) ΛBelongingModule() string {
	return "gnmi-collector-metadata"
}

// NetworkInstance represents the /openconfig-network-instance/network-instances/network-instance YANG schema element.
type NetworkInstance struct {
	Afts                   *NetworkInstance_Afts                                                    `path:"afts" module:"openconfig-network-instance"`
	ConnectionPoint        map[string]*NetworkInstance_ConnectionPoint                              `path:"connection-points/connection-point" module:"openconfig-network-instance/openconfig-network-instance"`
	Description            *string                                                                  `path:"state/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled                *bool                                                                    `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EnabledAddressFamilies []E_Types_ADDRESS_FAMILY                                                 `path:"state/enabled-address-families" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled-address-families" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Encapsulation          *NetworkInstance_Encapsulation                                           `path:"encapsulation" module:"openconfig-network-instance"`
	Evpn                   *NetworkInstance_Evpn                                                    `path:"evpn" module:"openconfig-network-instance"`
	Fdb                    *NetworkInstance_Fdb                                                     `path:"fdb" module:"openconfig-network-instance"`
	InterInstancePolicies  *NetworkInstance_InterInstancePolicies                                   `path:"inter-instance-policies" module:"openconfig-network-instance"`
	Interface              map[string]*NetworkInstance_Interface                                    `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Mpls                   *NetworkInstance_Mpls                                                    `path:"mpls" module:"openconfig-network-instance"`
	Mtu                    *uint16                                                                  `path:"state/mtu" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mtu" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                   *string                                                                  `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	PolicyForwarding       *NetworkInstance_PolicyForwarding                                        `path:"policy-forwarding" module:"openconfig-network-instance"`
	Protocol               map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol               `path:"protocols/protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	RouteDistinguisher     *string                                                                  `path:"state/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/route-distinguisher" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RouteLimit             map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit                   `path:"route-limits/route-limit" module:"openconfig-network-instance/openconfig-network-instance"`
	RouterId               *string                                                                  `path:"state/router-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/router-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SegmentRouting         *NetworkInstance_SegmentRouting                                          `path:"segment-routing" module:"openconfig-network-instance"`
	Table                  map[NetworkInstance_Table_Key]*NetworkInstance_Table                     `path:"tables/table" module:"openconfig-network-instance/openconfig-network-instance"`
	TableConnection        map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection `path:"table-connections/table-connection" module:"openconfig-network-instance/openconfig-network-instance"`
	Type                   E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE                             `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan                   map[uint16]*NetworkInstance_Vlan                                         `path:"vlans/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Key represents the key for list Protocol of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Protocol_Key struct {
	Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"identifier"`
	Name       string                              `path:"name"`
}

// NetworkInstance_Table_Key represents the key for list Table of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Table_Key struct {
	Protocol      E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// NetworkInstance_TableConnection_Key represents the key for list TableConnection of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_TableConnection_Key struct {
	SrcProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"src-protocol"`
	DstProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"dst-protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// NewConnectionPoint creates a new entry in the ConnectionPoint list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewConnectionPoint(ConnectionPointId string) (*NetworkInstance_ConnectionPoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	key := ConnectionPointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConnectionPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConnectionPoint", key)
	}

	t.ConnectionPoint[key] = &NetworkInstance_ConnectionPoint{
		ConnectionPointId: &ConnectionPointId,
	}

	return t.ConnectionPoint[key], nil
}

// RenameConnectionPoint renames an entry in the list ConnectionPoint within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameConnectionPoint(oldK, newK string) error {
	if _, ok := t.ConnectionPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in ConnectionPoint", newK)
	}

	e, ok := t.ConnectionPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConnectionPoint", oldK)
	}
	e.ConnectionPointId = &newK

	t.ConnectionPoint[newK] = e
	delete(t.ConnectionPoint, oldK)
	return nil
}

// GetOrCreateConnectionPoint retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	key := ConnectionPointId

	if v, ok := t.ConnectionPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConnectionPoint(ConnectionPointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConnectionPoint got unexpected error: %v", err))
	}
	return v
}

// GetConnectionPoint retrieves the value with the specified key from
// the ConnectionPoint map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	if t == nil {
		return nil
	}

	key := ConnectionPointId

	if lm, ok := t.ConnectionPoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConnectionPoint deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteConnectionPoint(ConnectionPointId string) {
	key := ConnectionPointId

	delete(t.ConnectionPoint, key)
}

// AppendConnectionPoint appends the supplied NetworkInstance_ConnectionPoint struct to the
// list ConnectionPoint of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendConnectionPoint(v *NetworkInstance_ConnectionPoint) error {
	if v.ConnectionPointId == nil {
		return fmt.Errorf("invalid nil key received for ConnectionPointId")
	}

	key := *v.ConnectionPointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	if _, ok := t.ConnectionPoint[key]; ok {
		return fmt.Errorf("duplicate key for list ConnectionPoint %v", key)
	}

	t.ConnectionPoint[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewInterface(Id string) (*NetworkInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateInterface(Id string) *NetworkInstance_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetInterface(Id string) *NetworkInstance_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Interface struct to the
// list Interface of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendInterface(v *NetworkInstance_Interface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) (*NetworkInstance_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Protocol{
		Identifier: Identifier,
		Name:       &Name,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameProtocol(oldK, newK NetworkInstance_Protocol_Key) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.Identifier = newK.Identifier
	e.Name = &newK.Name

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(Identifier, Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) {
	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NetworkInstance_Protocol struct to the
// list Protocol of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendProtocol(v *NetworkInstance_Protocol) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key for Name")
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: v.Identifier,
		Name:       *v.Name,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// NewRouteLimit creates a new entry in the RouteLimit list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewRouteLimit(Afi E_Types_ADDRESS_FAMILY) (*NetworkInstance_RouteLimit, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	key := Afi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RouteLimit[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RouteLimit", key)
	}

	t.RouteLimit[key] = &NetworkInstance_RouteLimit{
		Afi: Afi,
	}

	return t.RouteLimit[key], nil
}

// RenameRouteLimit renames an entry in the list RouteLimit within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameRouteLimit(oldK, newK E_Types_ADDRESS_FAMILY) error {
	if _, ok := t.RouteLimit[newK]; ok {
		return fmt.Errorf("key %v already exists in RouteLimit", newK)
	}

	e, ok := t.RouteLimit[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RouteLimit", oldK)
	}
	e.Afi = newK

	t.RouteLimit[newK] = e
	delete(t.RouteLimit, oldK)
	return nil
}

// GetOrCreateRouteLimit retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	key := Afi

	if v, ok := t.RouteLimit[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRouteLimit(Afi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRouteLimit got unexpected error: %v", err))
	}
	return v
}

// GetRouteLimit retrieves the value with the specified key from
// the RouteLimit map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	if t == nil {
		return nil
	}

	key := Afi

	if lm, ok := t.RouteLimit[key]; ok {
		return lm
	}
	return nil
}

// DeleteRouteLimit deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteRouteLimit(Afi E_Types_ADDRESS_FAMILY) {
	key := Afi

	delete(t.RouteLimit, key)
}

// AppendRouteLimit appends the supplied NetworkInstance_RouteLimit struct to the
// list RouteLimit of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_RouteLimit already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendRouteLimit(v *NetworkInstance_RouteLimit) error {
	key := v.Afi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	if _, ok := t.RouteLimit[key]; ok {
		return fmt.Errorf("duplicate key for list RouteLimit %v", key)
	}

	t.RouteLimit[key] = v
	return nil
}

// NewTable creates a new entry in the Table list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_Table, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Table[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Table", key)
	}

	t.Table[key] = &NetworkInstance_Table{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	return t.Table[key], nil
}

// RenameTable renames an entry in the list Table within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTable(oldK, newK NetworkInstance_Table_Key) error {
	if _, ok := t.Table[newK]; ok {
		return fmt.Errorf("key %v already exists in Table", newK)
	}

	e, ok := t.Table[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Table", oldK)
	}
	e.Protocol = newK.Protocol
	e.AddressFamily = newK.AddressFamily

	t.Table[newK] = e
	delete(t.Table, oldK)
	return nil
}

// GetOrCreateTable retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.Table[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTable(Protocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTable got unexpected error: %v", err))
	}
	return v
}

// GetTable retrieves the value with the specified key from
// the Table map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.Table[key]; ok {
		return lm
	}
	return nil
}

// DeleteTable deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	delete(t.Table, key)
}

// AppendTable appends the supplied NetworkInstance_Table struct to the
// list Table of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Table already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTable(v *NetworkInstance_Table) error {
	key := NetworkInstance_Table_Key{
		Protocol:      v.Protocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	if _, ok := t.Table[key]; ok {
		return fmt.Errorf("duplicate key for list Table %v", key)
	}

	t.Table[key] = v
	return nil
}

// NewTableConnection creates a new entry in the TableConnection list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_TableConnection, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TableConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TableConnection", key)
	}

	t.TableConnection[key] = &NetworkInstance_TableConnection{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	return t.TableConnection[key], nil
}

// RenameTableConnection renames an entry in the list TableConnection within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTableConnection(oldK, newK NetworkInstance_TableConnection_Key) error {
	if _, ok := t.TableConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in TableConnection", newK)
	}

	e, ok := t.TableConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TableConnection", oldK)
	}
	e.SrcProtocol = newK.SrcProtocol
	e.DstProtocol = newK.DstProtocol
	e.AddressFamily = newK.AddressFamily

	t.TableConnection[newK] = e
	delete(t.TableConnection, oldK)
	return nil
}

// GetOrCreateTableConnection retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.TableConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTableConnection(SrcProtocol, DstProtocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTableConnection got unexpected error: %v", err))
	}
	return v
}

// GetTableConnection retrieves the value with the specified key from
// the TableConnection map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	if t == nil {
		return nil
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.TableConnection[key]; ok {
		return lm
	}
	return nil
}

// DeleteTableConnection deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	delete(t.TableConnection, key)
}

// AppendTableConnection appends the supplied NetworkInstance_TableConnection struct to the
// list TableConnection of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_TableConnection already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTableConnection(v *NetworkInstance_TableConnection) error {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   v.SrcProtocol,
		DstProtocol:   v.DstProtocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	if _, ok := t.TableConnection[key]; ok {
		return fmt.Errorf("duplicate key for list TableConnection %v", key)
	}

	t.TableConnection[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewVlan(VlanId uint16) (*NetworkInstance_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &NetworkInstance_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateVlan(VlanId uint16) *NetworkInstance_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetVlan(VlanId uint16) *NetworkInstance_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlan deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteVlan(VlanId uint16) {
	key := VlanId

	delete(t.Vlan, key)
}

// AppendVlan appends the supplied NetworkInstance_Vlan struct to the
// list Vlan of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Vlan already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendVlan(v *NetworkInstance_Vlan) error {
	if v.VlanId == nil {
		return fmt.Errorf("invalid nil key received for VlanId")
	}

	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateAfts retrieves the value of the Afts field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateAfts() *NetworkInstance_Afts {
	if t.Afts != nil {
		return t.Afts
	}
	t.Afts = &NetworkInstance_Afts{}
	return t.Afts
}

// GetOrCreateEncapsulation retrieves the value of the Encapsulation field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEncapsulation() *NetworkInstance_Encapsulation {
	if t.Encapsulation != nil {
		return t.Encapsulation
	}
	t.Encapsulation = &NetworkInstance_Encapsulation{}
	return t.Encapsulation
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEvpn() *NetworkInstance_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &NetworkInstance_Evpn{}
	return t.Evpn
}

// GetOrCreateFdb retrieves the value of the Fdb field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateFdb() *NetworkInstance_Fdb {
	if t.Fdb != nil {
		return t.Fdb
	}
	t.Fdb = &NetworkInstance_Fdb{}
	return t.Fdb
}

// GetOrCreateInterInstancePolicies retrieves the value of the InterInstancePolicies field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	t.InterInstancePolicies = &NetworkInstance_InterInstancePolicies{}
	return t.InterInstancePolicies
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateMpls() *NetworkInstance_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Mpls{}
	return t.Mpls
}

// GetOrCreatePolicyForwarding retrieves the value of the PolicyForwarding field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreatePolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	t.PolicyForwarding = &NetworkInstance_PolicyForwarding{}
	return t.PolicyForwarding
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateSegmentRouting() *NetworkInstance_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_SegmentRouting{}
	return t.SegmentRouting
}

// GetAfts returns the value of the Afts struct pointer
// from NetworkInstance. If the receiver or the field Afts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetAfts() *NetworkInstance_Afts {
	if t != nil && t.Afts != nil {
		return t.Afts
	}
	return nil
}

// GetEncapsulation returns the value of the Encapsulation struct pointer
// from NetworkInstance. If the receiver or the field Encapsulation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEncapsulation() *NetworkInstance_Encapsulation {
	if t != nil && t.Encapsulation != nil {
		return t.Encapsulation
	}
	return nil
}

// GetEvpn returns the value of the Evpn struct pointer
// from NetworkInstance. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEvpn() *NetworkInstance_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetFdb returns the value of the Fdb struct pointer
// from NetworkInstance. If the receiver or the field Fdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetFdb() *NetworkInstance_Fdb {
	if t != nil && t.Fdb != nil {
		return t.Fdb
	}
	return nil
}

// GetInterInstancePolicies returns the value of the InterInstancePolicies struct pointer
// from NetworkInstance. If the receiver or the field InterInstancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t != nil && t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetMpls() *NetworkInstance_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetPolicyForwarding returns the value of the PolicyForwarding struct pointer
// from NetworkInstance. If the receiver or the field PolicyForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetPolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t != nil && t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetSegmentRouting() *NetworkInstance_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetEnabledAddressFamilies retrieves the value of the leaf EnabledAddressFamilies from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnabledAddressFamilies is set, it can
// safely use t.GetEnabledAddressFamilies() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnabledAddressFamilies == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetEnabledAddressFamilies() []E_Types_ADDRESS_FAMILY {
	if t == nil || t.EnabledAddressFamilies == nil {
		return nil
	}
	return t.EnabledAddressFamilies
}

// GetMtu retrieves the value of the leaf Mtu from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// GetName retrieves the value of the leaf Name from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouteDistinguisher() string {
	if t == nil || t.RouteDistinguisher == nil {
		return ""
	}
	return *t.RouteDistinguisher
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetType() E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Afts.PopulateDefaults()
	t.Encapsulation.PopulateDefaults()
	t.Evpn.PopulateDefaults()
	t.Fdb.PopulateDefaults()
	t.InterInstancePolicies.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.PolicyForwarding.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
	for _, e := range t.ConnectionPoint {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.Protocol {
		e.PopulateDefaults()
	}
	for _, e := range t.RouteLimit {
		e.PopulateDefaults()
	}
	for _, e := range t.Table {
		e.PopulateDefaults()
	}
	for _, e := range t.TableConnection {
		e.PopulateDefaults()
	}
	for _, e := range t.Vlan {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance struct, which is a YANG list entry.
func (t *NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance.
func (*NetworkInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts represents the /openconfig-network-instance/network-instances/network-instance/afts YANG schema element.
type NetworkInstance_Afts struct {
	Ipv4Entry             map[string]*NetworkInstance_Afts_Ipv4Entry                                       `path:"ipv4-unicast/ipv4-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	Ipv6Entry             map[string]*NetworkInstance_Afts_Ipv6Entry                                       `path:"ipv6-unicast/ipv6-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	LabelEntry            map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry `path:"mpls/label-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	MacEntry              map[string]*NetworkInstance_Afts_MacEntry                                        `path:"ethernet/mac-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop               map[uint64]*NetworkInstance_Afts_NextHop                                         `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup          map[uint64]*NetworkInstance_Afts_NextHopGroup                                    `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	PolicyForwardingEntry map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry                           `path:"policy-forwarding/policy-forwarding-entry" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts) IsYANGGoStruct() {}

// NewIpv4Entry creates a new entry in the Ipv4Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv4Entry(Prefix string) (*NetworkInstance_Afts_Ipv4Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Entry", key)
	}

	t.Ipv4Entry[key] = &NetworkInstance_Afts_Ipv4Entry{
		Prefix: &Prefix,
	}

	return t.Ipv4Entry[key], nil
}

// RenameIpv4Entry renames an entry in the list Ipv4Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv4Entry(oldK, newK string) error {
	if _, ok := t.Ipv4Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Entry", newK)
	}

	e, ok := t.Ipv4Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv4Entry[newK] = e
	delete(t.Ipv4Entry, oldK)
	return nil
}

// GetOrCreateIpv4Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	key := Prefix

	if v, ok := t.Ipv4Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Entry retrieves the value with the specified key from
// the Ipv4Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv4Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv4Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv4Entry, key)
}

// AppendIpv4Entry appends the supplied NetworkInstance_Afts_Ipv4Entry struct to the
// list Ipv4Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv4Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv4Entry(v *NetworkInstance_Afts_Ipv4Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	if _, ok := t.Ipv4Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Entry %v", key)
	}

	t.Ipv4Entry[key] = v
	return nil
}

// NewIpv6Entry creates a new entry in the Ipv6Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv6Entry(Prefix string) (*NetworkInstance_Afts_Ipv6Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Entry", key)
	}

	t.Ipv6Entry[key] = &NetworkInstance_Afts_Ipv6Entry{
		Prefix: &Prefix,
	}

	return t.Ipv6Entry[key], nil
}

// RenameIpv6Entry renames an entry in the list Ipv6Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv6Entry(oldK, newK string) error {
	if _, ok := t.Ipv6Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Entry", newK)
	}

	e, ok := t.Ipv6Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv6Entry[newK] = e
	delete(t.Ipv6Entry, oldK)
	return nil
}

// GetOrCreateIpv6Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	key := Prefix

	if v, ok := t.Ipv6Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Entry retrieves the value with the specified key from
// the Ipv6Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv6Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv6Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv6Entry, key)
}

// AppendIpv6Entry appends the supplied NetworkInstance_Afts_Ipv6Entry struct to the
// list Ipv6Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv6Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv6Entry(v *NetworkInstance_Afts_Ipv6Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	if _, ok := t.Ipv6Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Entry %v", key)
	}

	t.Ipv6Entry[key] = v
	return nil
}

// NewLabelEntry creates a new entry in the LabelEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) (*NetworkInstance_Afts_LabelEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	key := Label

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LabelEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LabelEntry", key)
	}

	t.LabelEntry[key] = &NetworkInstance_Afts_LabelEntry{
		Label: Label,
	}

	return t.LabelEntry[key], nil
}

// RenameLabelEntry renames an entry in the list LabelEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameLabelEntry(oldK, newK NetworkInstance_Afts_LabelEntry_Label_Union) error {
	if _, ok := t.LabelEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in LabelEntry", newK)
	}

	e, ok := t.LabelEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LabelEntry", oldK)
	}
	e.Label = newK

	t.LabelEntry[newK] = e
	delete(t.LabelEntry, oldK)
	return nil
}

// GetOrCreateLabelEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	key := Label

	if v, ok := t.LabelEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLabelEntry(Label)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLabelEntry got unexpected error: %v", err))
	}
	return v
}

// GetLabelEntry retrieves the value with the specified key from
// the LabelEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	if t == nil {
		return nil
	}

	key := Label

	if lm, ok := t.LabelEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteLabelEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) {
	key := Label

	delete(t.LabelEntry, key)
}

// AppendLabelEntry appends the supplied NetworkInstance_Afts_LabelEntry struct to the
// list LabelEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_LabelEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendLabelEntry(v *NetworkInstance_Afts_LabelEntry) error {
	key := v.Label

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	if _, ok := t.LabelEntry[key]; ok {
		return fmt.Errorf("duplicate key for list LabelEntry %v", key)
	}

	t.LabelEntry[key] = v
	return nil
}

// NewMacEntry creates a new entry in the MacEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewMacEntry(MacAddress string) (*NetworkInstance_Afts_MacEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacEntry", key)
	}

	t.MacEntry[key] = &NetworkInstance_Afts_MacEntry{
		MacAddress: &MacAddress,
	}

	return t.MacEntry[key], nil
}

// RenameMacEntry renames an entry in the list MacEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameMacEntry(oldK, newK string) error {
	if _, ok := t.MacEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in MacEntry", newK)
	}

	e, ok := t.MacEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacEntry", oldK)
	}
	e.MacAddress = &newK

	t.MacEntry[newK] = e
	delete(t.MacEntry, oldK)
	return nil
}

// GetOrCreateMacEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	key := MacAddress

	if v, ok := t.MacEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacEntry got unexpected error: %v", err))
	}
	return v
}

// GetMacEntry retrieves the value with the specified key from
// the MacEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.MacEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteMacEntry(MacAddress string) {
	key := MacAddress

	delete(t.MacEntry, key)
}

// AppendMacEntry appends the supplied NetworkInstance_Afts_MacEntry struct to the
// list MacEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_MacEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendMacEntry(v *NetworkInstance_Afts_MacEntry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	if _, ok := t.MacEntry[key]; ok {
		return fmt.Errorf("duplicate key for list MacEntry %v", key)
	}

	t.MacEntry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHop struct to the
// list NextHop of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHop(v *NetworkInstance_Afts_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHopGroup(Id uint64) (*NetworkInstance_Afts_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Afts_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Afts_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHopGroup(v *NetworkInstance_Afts_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// NewPolicyForwardingEntry creates a new entry in the PolicyForwardingEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewPolicyForwardingEntry(Index uint64) (*NetworkInstance_Afts_PolicyForwardingEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyForwardingEntry", key)
	}

	t.PolicyForwardingEntry[key] = &NetworkInstance_Afts_PolicyForwardingEntry{
		Index: &Index,
	}

	return t.PolicyForwardingEntry[key], nil
}

// RenamePolicyForwardingEntry renames an entry in the list PolicyForwardingEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenamePolicyForwardingEntry(oldK, newK uint64) error {
	if _, ok := t.PolicyForwardingEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyForwardingEntry", newK)
	}

	e, ok := t.PolicyForwardingEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyForwardingEntry", oldK)
	}
	e.Index = &newK

	t.PolicyForwardingEntry[newK] = e
	delete(t.PolicyForwardingEntry, oldK)
	return nil
}

// GetOrCreatePolicyForwardingEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreatePolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	key := Index

	if v, ok := t.PolicyForwardingEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyForwardingEntry(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyForwardingEntry got unexpected error: %v", err))
	}
	return v
}

// GetPolicyForwardingEntry retrieves the value with the specified key from
// the PolicyForwardingEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetPolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.PolicyForwardingEntry[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicyForwardingEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeletePolicyForwardingEntry(Index uint64) {
	key := Index

	delete(t.PolicyForwardingEntry, key)
}

// AppendPolicyForwardingEntry appends the supplied NetworkInstance_Afts_PolicyForwardingEntry struct to the
// list PolicyForwardingEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_PolicyForwardingEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendPolicyForwardingEntry(v *NetworkInstance_Afts_PolicyForwardingEntry) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyForwardingEntry %v", key)
	}

	t.PolicyForwardingEntry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Ipv4Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.LabelEntry {
		e.PopulateDefaults()
	}
	for _, e := range t.MacEntry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHopGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.PolicyForwardingEntry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts.
func (*NetworkInstance_Afts) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv4Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry YANG schema element.
type NetworkInstance_Afts_Ipv4Entry struct {
	Counters                    *NetworkInstance_Afts_Ipv4Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader           E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup                *uint64                                  `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                  `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginNetworkInstance       *string                                  `path:"state/origin-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginProtocol              E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix                      *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"prefix" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv4Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv4Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv4Entry) GetCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetOriginNetworkInstance retrieves the value of the leaf OriginNetworkInstance from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginNetworkInstance is set, it can
// safely use t.GetOriginNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOriginNetworkInstance() string {
	if t == nil || t.OriginNetworkInstance == nil {
		return ""
	}
	return *t.OriginNetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv4Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv4Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv4Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry.
func (*NetworkInstance_Afts_Ipv4Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv4Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv4Entry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv4Entry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry_Counters.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry YANG schema element.
type NetworkInstance_Afts_Ipv6Entry struct {
	Counters                    *NetworkInstance_Afts_Ipv6Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader           E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup                *uint64                                  `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                  `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginNetworkInstance       *string                                  `path:"state/origin-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginProtocol              E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix                      *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"prefix" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv6Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv6Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv6Entry) GetCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetOriginNetworkInstance retrieves the value of the leaf OriginNetworkInstance from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginNetworkInstance is set, it can
// safely use t.GetOriginNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOriginNetworkInstance() string {
	if t == nil || t.OriginNetworkInstance == nil {
		return ""
	}
	return *t.OriginNetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv6Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv6Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv6Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry.
func (*NetworkInstance_Afts_Ipv6Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv6Entry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv6Entry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry_Counters.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry YANG schema element.
type NetworkInstance_Afts_LabelEntry struct {
	Counters                    *NetworkInstance_Afts_LabelEntry_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                                       `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	Label                       NetworkInstance_Afts_LabelEntry_Label_Union                  `path:"state/label|label" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"label" shadow-module:"openconfig-network-instance"`
	NextHopGroup                *uint64                                                      `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                                      `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	PoppedMplsLabelStack        []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union `path:"state/popped-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_LabelEntry) GetOrCreateCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_LabelEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_LabelEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_LabelEntry) GetCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetLabel() NetworkInstance_Afts_LabelEntry_Label_Union {
	if t == nil || t.Label == nil {
		return nil
	}
	return t.Label
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetPoppedMplsLabelStack retrieves the value of the leaf PoppedMplsLabelStack from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PoppedMplsLabelStack is set, it can
// safely use t.GetPoppedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PoppedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetPoppedMplsLabelStack() []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union {
	if t == nil || t.PoppedMplsLabelStack == nil {
		return nil
	}
	return t.PoppedMplsLabelStack
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_LabelEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_LabelEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_LabelEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_LabelEntry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"label": t.Label,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry.
func (*NetworkInstance_Afts_LabelEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/counters YANG schema element.
type NetworkInstance_Afts_LabelEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_LabelEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_LabelEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry_Counters.
func (*NetworkInstance_Afts_LabelEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry YANG schema element.
type NetworkInstance_Afts_MacEntry struct {
	Counters                    *NetworkInstance_Afts_MacEntry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                  `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress                  *string                                 `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	NextHopGroup                *uint64                                 `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                 `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_MacEntry) GetOrCreateCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_MacEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_MacEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_MacEntry) GetCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_MacEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_MacEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_MacEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_MacEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry.
func (*NetworkInstance_Afts_MacEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/counters YANG schema element.
type NetworkInstance_Afts_MacEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_MacEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_MacEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry_Counters.
func (*NetworkInstance_Afts_MacEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHop struct {
	Counters             *NetworkInstance_Afts_NextHop_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateHeader    E_AftTypes_EncapsulationHeaderType                        `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulateHeader    E_AftTypes_EncapsulationHeaderType                        `path:"state/encapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	Index                *uint64                                                   `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	InterfaceRef         *NetworkInstance_Afts_NextHop_InterfaceRef                `path:"interface-ref" module:"openconfig-network-instance"`
	IpAddress            *string                                                   `path:"state/ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	IpInIp               *NetworkInstance_Afts_NextHop_IpInIp                      `path:"ip-in-ip" module:"openconfig-network-instance"`
	LspName              *string                                                   `path:"state/lsp-name" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress           *string                                                   `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	NetworkInstance      *string                                                   `path:"state/network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	OriginProtocol       E_PolicyTypes_INSTALL_PROTOCOL_TYPE                       `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	PopTopLabel          *bool                                                     `path:"state/pop-top-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ProgrammedIndex      *uint64                                                   `path:"state/programmed-index" module:"openconfig-network-instance/openconfig-network-instance"`
	PushedMplsLabelStack []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union `path:"state/pushed-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
	TunnelSrcIpAddress   *string                                                   `path:"state/tunnel-src-ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	VniLabel             *uint32                                                   `path:"state/vni-label" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_NextHop_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Afts_NextHop_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateIpInIp retrieves the value of the IpInIp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t.IpInIp != nil {
		return t.IpInIp
	}
	t.IpInIp = &NetworkInstance_Afts_NextHop_IpInIp{}
	return t.IpInIp
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetIpInIp returns the value of the IpInIp struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field IpInIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t != nil && t.IpInIp != nil {
		return t.IpInIp
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEncapsulateHeader retrieves the value of the leaf EncapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulateHeader is set, it can
// safely use t.GetEncapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetEncapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.EncapsulateHeader == 0 {
		return 0
	}
	return t.EncapsulateHeader
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpAddress retrieves the value of the leaf IpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetLspName retrieves the value of the leaf LspName from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspName is set, it can
// safely use t.GetLspName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetLspName() string {
	if t == nil || t.LspName == nil {
		return ""
	}
	return *t.LspName
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPopTopLabel retrieves the value of the leaf PopTopLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PopTopLabel is set, it can
// safely use t.GetPopTopLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PopTopLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPopTopLabel() bool {
	if t == nil || t.PopTopLabel == nil {
		return false
	}
	return *t.PopTopLabel
}

// GetProgrammedIndex retrieves the value of the leaf ProgrammedIndex from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedIndex is set, it can
// safely use t.GetProgrammedIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedIndex == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetProgrammedIndex() uint64 {
	if t == nil || t.ProgrammedIndex == nil {
		return 0
	}
	return *t.ProgrammedIndex
}

// GetPushedMplsLabelStack retrieves the value of the leaf PushedMplsLabelStack from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushedMplsLabelStack is set, it can
// safely use t.GetPushedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPushedMplsLabelStack() []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union {
	if t == nil || t.PushedMplsLabelStack == nil {
		return nil
	}
	return t.PushedMplsLabelStack
}

// GetTunnelSrcIpAddress retrieves the value of the leaf TunnelSrcIpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelSrcIpAddress is set, it can
// safely use t.GetTunnelSrcIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelSrcIpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetTunnelSrcIpAddress() string {
	if t == nil || t.TunnelSrcIpAddress == nil {
		return ""
	}
	return *t.TunnelSrcIpAddress
}

// GetVniLabel retrieves the value of the leaf VniLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniLabel is set, it can
// safely use t.GetVniLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetVniLabel() uint32 {
	if t == nil || t.VniLabel == nil {
		return 0
	}
	return *t.VniLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PopTopLabel == nil {
		var v bool = false
		t.PopTopLabel = &v
	}
	t.Counters.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
	t.IpInIp.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop.
func (*NetworkInstance_Afts_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Afts_NextHopGroup struct {
	BackupNextHopGroup *uint64                                                 `path:"state/backup-next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Color              *uint64                                                 `path:"state/color" module:"openconfig-network-instance/openconfig-network-instance"`
	Condition          map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition `path:"conditional/condition" module:"openconfig-network-instance/openconfig-network-instance"`
	Id                 *uint64                                                 `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	NextHop            map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop   `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ProgrammedId       *uint64                                                 `path:"state/programmed-id" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup) IsYANGGoStruct() {}

// NewCondition creates a new entry in the Condition list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewCondition(Id uint64) (*NetworkInstance_Afts_NextHopGroup_Condition, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Condition[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Condition", key)
	}

	t.Condition[key] = &NetworkInstance_Afts_NextHopGroup_Condition{
		Id: &Id,
	}

	return t.Condition[key], nil
}

// RenameCondition renames an entry in the list Condition within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameCondition(oldK, newK uint64) error {
	if _, ok := t.Condition[newK]; ok {
		return fmt.Errorf("key %v already exists in Condition", newK)
	}

	e, ok := t.Condition[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Condition", oldK)
	}
	e.Id = &newK

	t.Condition[newK] = e
	delete(t.Condition, oldK)
	return nil
}

// GetOrCreateCondition retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	key := Id

	if v, ok := t.Condition[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCondition(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCondition got unexpected error: %v", err))
	}
	return v
}

// GetCondition retrieves the value with the specified key from
// the Condition map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Condition[key]; ok {
		return lm
	}
	return nil
}

// DeleteCondition deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteCondition(Id uint64) {
	key := Id

	delete(t.Condition, key)
}

// AppendCondition appends the supplied NetworkInstance_Afts_NextHopGroup_Condition struct to the
// list Condition of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendCondition(v *NetworkInstance_Afts_NextHopGroup_Condition) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	if _, ok := t.Condition[key]; ok {
		return fmt.Errorf("duplicate key for list Condition %v", key)
	}

	t.Condition[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendNextHop(v *NetworkInstance_Afts_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetBackupNextHopGroup retrieves the value of the leaf BackupNextHopGroup from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackupNextHopGroup is set, it can
// safely use t.GetBackupNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackupNextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetBackupNextHopGroup() uint64 {
	if t == nil || t.BackupNextHopGroup == nil {
		return 0
	}
	return *t.BackupNextHopGroup
}

// GetColor retrieves the value of the leaf Color from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Color is set, it can
// safely use t.GetColor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Color == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetColor() uint64 {
	if t == nil || t.Color == nil {
		return 0
	}
	return *t.Color
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetProgrammedId retrieves the value of the leaf ProgrammedId from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedId is set, it can
// safely use t.GetProgrammedId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetProgrammedId() uint64 {
	if t == nil || t.ProgrammedId == nil {
		return 0
	}
	return *t.ProgrammedId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Condition {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup.
func (*NetworkInstance_Afts_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition struct {
	Dscp           []uint8                                                                `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	Id             *uint64                                                                `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	InputInterface map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface `path:"input-interfaces/input-interface" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup   *uint64                                                                `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition) IsYANGGoStruct() {}

// NewInputInterface creates a new entry in the InputInterface list of the
// NetworkInstance_Afts_NextHopGroup_Condition struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) NewInputInterface(Id string) (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InputInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InputInterface", key)
	}

	t.InputInterface[key] = &NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
		Id: &Id,
	}

	return t.InputInterface[key], nil
}

// RenameInputInterface renames an entry in the list InputInterface within
// the NetworkInstance_Afts_NextHopGroup_Condition struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) RenameInputInterface(oldK, newK string) error {
	if _, ok := t.InputInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in InputInterface", newK)
	}

	e, ok := t.InputInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InputInterface", oldK)
	}
	e.Id = &newK

	t.InputInterface[newK] = e
	delete(t.InputInterface, oldK)
	return nil
}

// GetOrCreateInputInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetOrCreateInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	key := Id

	if v, ok := t.InputInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInputInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInputInterface got unexpected error: %v", err))
	}
	return v
}

// GetInputInterface retrieves the value with the specified key from
// the InputInterface map field of NetworkInstance_Afts_NextHopGroup_Condition. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.InputInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInputInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) DeleteInputInterface(Id string) {
	key := Id

	delete(t.InputInterface, key)
}

// AppendInputInterface appends the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct to the
// list InputInterface of NetworkInstance_Afts_NextHopGroup_Condition. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) AppendInputInterface(v *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	if _, ok := t.InputInterface[key]; ok {
		return fmt.Errorf("duplicate key for list InputInterface %v", key)
	}

	t.InputInterface[key] = v
	return nil
}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetDscp() []uint8 {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_Condition
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.InputInterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition.
func (*NetworkInstance_Afts_NextHopGroup_Condition) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition_InputInterface represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct {
	Id           *string `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"id" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition_InputInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition_InputInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition_InputInterface.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHopGroup_NextHop struct {
	Index  *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Weight *uint64 `path:"state/weight" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetWeight retrieves the value of the leaf Weight from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetWeight() uint64 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_NextHop.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/counters YANG schema element.
type NetworkInstance_Afts_NextHop_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_Counters.
func (*NetworkInstance_Afts_NextHop_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref YANG schema element.
type NetworkInstance_Afts_NextHop_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_InterfaceRef.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_IpInIp represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip YANG schema element.
type NetworkInstance_Afts_NextHop_IpInIp struct {
	DstIp *string `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	SrcIp *string `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_IpInIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_IpInIp) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_IpInIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_IpInIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_IpInIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_IpInIp.
func (*NetworkInstance_Afts_NextHop_IpInIp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry struct {
	Counters                    *NetworkInstance_Afts_PolicyForwardingEntry_Counters        `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryMetadata               Binary                                                      `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	Index                       *uint64                                                     `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	IpDscp                      *uint8                                                      `path:"state/ip-dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	IpPrefix                    *string                                                     `path:"state/ip-prefix" module:"openconfig-network-instance/openconfig-network-instance"`
	IpProtocol                  NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union `path:"state/ip-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	L4DstPort                   *uint16                                                     `path:"state/l4-dst-port" module:"openconfig-network-instance/openconfig-network-instance"`
	L4SrcPort                   *uint16                                                     `path:"state/l4-src-port" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress                  *string                                                     `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsLabel                   NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union  `path:"state/mpls-label" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsTc                      *uint8                                                      `path:"state/mpls-tc" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHopGroup                *uint64                                                     `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	NextHopGroupNetworkInstance *string                                                     `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetOrCreateCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_PolicyForwardingEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_PolicyForwardingEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpDscp retrieves the value of the leaf IpDscp from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpDscp is set, it can
// safely use t.GetIpDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpDscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpDscp() uint8 {
	if t == nil || t.IpDscp == nil {
		return 0
	}
	return *t.IpDscp
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetIpProtocol retrieves the value of the leaf IpProtocol from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpProtocol is set, it can
// safely use t.GetIpProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpProtocol() NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	if t == nil || t.IpProtocol == nil {
		return nil
	}
	return t.IpProtocol
}

// GetL4DstPort retrieves the value of the leaf L4DstPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4DstPort is set, it can
// safely use t.GetL4DstPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4DstPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4DstPort() uint16 {
	if t == nil || t.L4DstPort == nil {
		return 0
	}
	return *t.L4DstPort
}

// GetL4SrcPort retrieves the value of the leaf L4SrcPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4SrcPort is set, it can
// safely use t.GetL4SrcPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4SrcPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4SrcPort() uint16 {
	if t == nil || t.L4SrcPort == nil {
		return 0
	}
	return *t.L4SrcPort
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetMplsLabel retrieves the value of the leaf MplsLabel from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabel is set, it can
// safely use t.GetMplsLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsLabel() NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	if t == nil || t.MplsLabel == nil {
		return nil
	}
	return t.MplsLabel
}

// GetMplsTc retrieves the value of the leaf MplsTc from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsTc is set, it can
// safely use t.GetMplsTc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsTc == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsTc() uint8 {
	if t == nil || t.MplsTc == nil {
		return 0
	}
	return *t.MplsTc
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_PolicyForwardingEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_PolicyForwardingEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry.
func (*NetworkInstance_Afts_PolicyForwardingEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/counters YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry_Counters struct {
	OctetsForwarded  *uint64 `path:"octets-forwarded" module:"openconfig-network-instance"`
	PacketsForwarded *uint64 `path:"packets-forwarded" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry_Counters.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point YANG schema element.
type NetworkInstance_ConnectionPoint struct {
	ConnectionPointId *string                                              `path:"state/connection-point-id|connection-point-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/connection-point-id|connection-point-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Endpoint          map[string]*NetworkInstance_ConnectionPoint_Endpoint `path:"endpoints/endpoint" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint) IsYANGGoStruct() {}

// NewEndpoint creates a new entry in the Endpoint list of the
// NetworkInstance_ConnectionPoint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint) NewEndpoint(EndpointId string) (*NetworkInstance_ConnectionPoint_Endpoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	key := EndpointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Endpoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Endpoint", key)
	}

	t.Endpoint[key] = &NetworkInstance_ConnectionPoint_Endpoint{
		EndpointId: &EndpointId,
	}

	return t.Endpoint[key], nil
}

// RenameEndpoint renames an entry in the list Endpoint within
// the NetworkInstance_ConnectionPoint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint) RenameEndpoint(oldK, newK string) error {
	if _, ok := t.Endpoint[newK]; ok {
		return fmt.Errorf("key %v already exists in Endpoint", newK)
	}

	e, ok := t.Endpoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Endpoint", oldK)
	}
	e.EndpointId = &newK

	t.Endpoint[newK] = e
	delete(t.Endpoint, oldK)
	return nil
}

// GetOrCreateEndpoint retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint) GetOrCreateEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	key := EndpointId

	if v, ok := t.Endpoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpoint(EndpointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpoint got unexpected error: %v", err))
	}
	return v
}

// GetEndpoint retrieves the value with the specified key from
// the Endpoint map field of NetworkInstance_ConnectionPoint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint) GetEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	if t == nil {
		return nil
	}

	key := EndpointId

	if lm, ok := t.Endpoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpoint deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint) DeleteEndpoint(EndpointId string) {
	key := EndpointId

	delete(t.Endpoint, key)
}

// AppendEndpoint appends the supplied NetworkInstance_ConnectionPoint_Endpoint struct to the
// list Endpoint of NetworkInstance_ConnectionPoint. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint) AppendEndpoint(v *NetworkInstance_ConnectionPoint_Endpoint) error {
	if v.EndpointId == nil {
		return fmt.Errorf("invalid nil key received for EndpointId")
	}

	key := *v.EndpointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	if _, ok := t.Endpoint[key]; ok {
		return fmt.Errorf("duplicate key for list Endpoint %v", key)
	}

	t.Endpoint[key] = v
	return nil
}

// GetConnectionPointId retrieves the value of the leaf ConnectionPointId from the NetworkInstance_ConnectionPoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConnectionPointId is set, it can
// safely use t.GetConnectionPointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConnectionPointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint) GetConnectionPointId() string {
	if t == nil || t.ConnectionPointId == nil {
		return ""
	}
	return *t.ConnectionPointId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Endpoint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConnectionPointId == nil {
		return nil, fmt.Errorf("nil value for key ConnectionPointId")
	}

	return map[string]interface{}{
		"connection-point-id": *t.ConnectionPointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint.
func (*NetworkInstance_ConnectionPoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint struct {
	Active     *bool                                            `path:"state/active" module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointId *string                                          `path:"state/endpoint-id|endpoint-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/endpoint-id|endpoint-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Local      *NetworkInstance_ConnectionPoint_Endpoint_Local  `path:"local" module:"openconfig-network-instance"`
	Precedence *uint16                                          `path:"state/precedence" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/precedence" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Remote     *NetworkInstance_ConnectionPoint_Endpoint_Remote `path:"remote" module:"openconfig-network-instance"`
	Type       E_NetworkInstanceTypes_ENDPOINT_TYPE             `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vxlan      *NetworkInstance_ConnectionPoint_Endpoint_Vxlan  `path:"vxlan" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint) IsYANGGoStruct() {}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t.Local != nil {
		return t.Local
	}
	t.Local = &NetworkInstance_ConnectionPoint_Endpoint_Local{}
	return t.Local
}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t.Remote != nil {
		return t.Remote
	}
	t.Remote = &NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	return t.Remote
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	return t.Vxlan
}

// GetLocal returns the value of the Local struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t != nil && t.Local != nil {
		return t.Local
	}
	return nil
}

// GetRemote returns the value of the Remote struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t != nil && t.Remote != nil {
		return t.Remote
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetActive retrieves the value of the leaf Active from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Active is set, it can
// safely use t.GetActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Active == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetActive() bool {
	if t == nil || t.Active == nil {
		return false
	}
	return *t.Active
}

// GetEndpointId retrieves the value of the leaf EndpointId from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndpointId is set, it can
// safely use t.GetEndpointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndpointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetEndpointId() string {
	if t == nil || t.EndpointId == nil {
		return ""
	}
	return *t.EndpointId
}

// GetPrecedence retrieves the value of the leaf Precedence from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetPrecedence() uint16 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetType() E_NetworkInstanceTypes_ENDPOINT_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Local.PopulateDefaults()
	t.Remote.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EndpointId == nil {
		return nil, fmt.Errorf("nil value for key EndpointId")
	}

	return map[string]interface{}{
		"endpoint-id": *t.EndpointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint.
func (*NetworkInstance_ConnectionPoint_Endpoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Local represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Local struct {
	Interface            *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteId               *uint16 `path:"state/site-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteLabelBlockOffset *uint16 `path:"state/site-label-block-offset" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-label-block-offset" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteLabelBlockSize   *uint16 `path:"state/site-label-block-size" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-label-block-size" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface         *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Local implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetSiteLabelBlockOffset retrieves the value of the leaf SiteLabelBlockOffset from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockOffset is set, it can
// safely use t.GetSiteLabelBlockOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockOffset == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockOffset() uint16 {
	if t == nil || t.SiteLabelBlockOffset == nil {
		return 0
	}
	return *t.SiteLabelBlockOffset
}

// GetSiteLabelBlockSize retrieves the value of the leaf SiteLabelBlockSize from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockSize is set, it can
// safely use t.GetSiteLabelBlockSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockSize == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockSize() uint16 {
	if t == nil || t.SiteLabelBlockSize == nil {
		return 0
	}
	return *t.SiteLabelBlockSize
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Local
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Local"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Local.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Remote represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Remote struct {
	RemoteSystem             *string `path:"state/remote-system" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/remote-system" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SiteId                   *uint16 `path:"state/site-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/site-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	VirtualCircuitIdentifier *uint32 `path:"state/virtual-circuit-identifier" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/virtual-circuit-identifier" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Remote implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) IsYANGGoStruct() {}

// GetRemoteSystem retrieves the value of the leaf RemoteSystem from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteSystem is set, it can
// safely use t.GetRemoteSystem() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteSystem == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetRemoteSystem() string {
	if t == nil || t.RemoteSystem == nil {
		return ""
	}
	return *t.RemoteSystem
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetVirtualCircuitIdentifier retrieves the value of the leaf VirtualCircuitIdentifier from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualCircuitIdentifier is set, it can
// safely use t.GetVirtualCircuitIdentifier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualCircuitIdentifier == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetVirtualCircuitIdentifier() uint32 {
	if t == nil || t.VirtualCircuitIdentifier == nil {
		return 0
	}
	return *t.VirtualCircuitIdentifier
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Remote
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Remote.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct {
	Description     *string                                                                 `path:"state/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled         *bool                                                                   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointPeer    map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer `path:"endpoint-peers/endpoint-peer" module:"openconfig-network-instance/openconfig-network-instance"`
	EndpointVni     map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni  `path:"endpoint-vnis/endpoint-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	SourceInterface *string                                                                 `path:"state/source-interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) IsYANGGoStruct() {}

// NewEndpointPeer creates a new entry in the EndpointPeer list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointPeer(PeerAddress string) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	key := PeerAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointPeer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointPeer", key)
	}

	t.EndpointPeer[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer{
		PeerAddress: &PeerAddress,
	}

	return t.EndpointPeer[key], nil
}

// RenameEndpointPeer renames an entry in the list EndpointPeer within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointPeer(oldK, newK string) error {
	if _, ok := t.EndpointPeer[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointPeer", newK)
	}

	e, ok := t.EndpointPeer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointPeer", oldK)
	}
	e.PeerAddress = &newK

	t.EndpointPeer[newK] = e
	delete(t.EndpointPeer, oldK)
	return nil
}

// GetOrCreateEndpointPeer retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	key := PeerAddress

	if v, ok := t.EndpointPeer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointPeer(PeerAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointPeer got unexpected error: %v", err))
	}
	return v
}

// GetEndpointPeer retrieves the value with the specified key from
// the EndpointPeer map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	if t == nil {
		return nil
	}

	key := PeerAddress

	if lm, ok := t.EndpointPeer[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointPeer deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointPeer(PeerAddress string) {
	key := PeerAddress

	delete(t.EndpointPeer, key)
}

// AppendEndpointPeer appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct to the
// list EndpointPeer of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointPeer(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) error {
	if v.PeerAddress == nil {
		return fmt.Errorf("invalid nil key received for PeerAddress")
	}

	key := *v.PeerAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	if _, ok := t.EndpointPeer[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointPeer %v", key)
	}

	t.EndpointPeer[key] = v
	return nil
}

// NewEndpointVni creates a new entry in the EndpointVni list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointVni(Vni uint32) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	key := Vni

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointVni[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointVni", key)
	}

	t.EndpointVni[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni{
		Vni: &Vni,
	}

	return t.EndpointVni[key], nil
}

// RenameEndpointVni renames an entry in the list EndpointVni within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointVni(oldK, newK uint32) error {
	if _, ok := t.EndpointVni[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointVni", newK)
	}

	e, ok := t.EndpointVni[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointVni", oldK)
	}
	e.Vni = &newK

	t.EndpointVni[newK] = e
	delete(t.EndpointVni, oldK)
	return nil
}

// GetOrCreateEndpointVni retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	key := Vni

	if v, ok := t.EndpointVni[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointVni(Vni)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointVni got unexpected error: %v", err))
	}
	return v
}

// GetEndpointVni retrieves the value with the specified key from
// the EndpointVni map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	if t == nil {
		return nil
	}

	key := Vni

	if lm, ok := t.EndpointVni[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointVni deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointVni(Vni uint32) {
	key := Vni

	delete(t.EndpointVni, key)
}

// AppendEndpointVni appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct to the
// list EndpointVni of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointVni(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) error {
	if v.Vni == nil {
		return fmt.Errorf("invalid nil key received for Vni")
	}

	key := *v.Vni

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	if _, ok := t.EndpointVni[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointVni %v", key)
	}

	t.EndpointVni[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetSourceInterface retrieves the value of the leaf SourceInterface from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceInterface is set, it can
// safely use t.GetSourceInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceInterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetSourceInterface() string {
	if t == nil || t.SourceInterface == nil {
		return ""
	}
	return *t.SourceInterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EndpointPeer {
		e.PopulateDefaults()
	}
	for _, e := range t.EndpointVni {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-peers/endpoint-peer YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct {
	ControlPlaneVnis *string                  `path:"state/control-plane-vnis" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerAddress      *string                  `path:"state/peer-address|peer-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"peer-address" shadow-module:"openconfig-network-instance"`
	PeerState        E_EndpointPeer_PeerState `path:"state/peer-state" module:"openconfig-network-instance/openconfig-network-instance"`
	RouterMac        *string                  `path:"state/router-mac" module:"openconfig-network-instance/openconfig-network-instance"`
	Uptime           *uint64                  `path:"state/uptime" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) IsYANGGoStruct() {}

// GetControlPlaneVnis retrieves the value of the leaf ControlPlaneVnis from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlPlaneVnis is set, it can
// safely use t.GetControlPlaneVnis() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlPlaneVnis == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetControlPlaneVnis() string {
	if t == nil || t.ControlPlaneVnis == nil {
		return ""
	}
	return *t.ControlPlaneVnis
}

// GetPeerAddress retrieves the value of the leaf PeerAddress from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerAddress is set, it can
// safely use t.GetPeerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerAddress() string {
	if t == nil || t.PeerAddress == nil {
		return ""
	}
	return *t.PeerAddress
}

// GetPeerState retrieves the value of the leaf PeerState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerState is set, it can
// safely use t.GetPeerState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerState() E_EndpointPeer_PeerState {
	if t == nil || t.PeerState == 0 {
		return 0
	}
	return t.PeerState
}

// GetRouterMac retrieves the value of the leaf RouterMac from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterMac is set, it can
// safely use t.GetRouterMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetRouterMac() string {
	if t == nil || t.RouterMac == nil {
		return ""
	}
	return *t.RouterMac
}

// GetUptime retrieves the value of the leaf Uptime from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uptime is set, it can
// safely use t.GetUptime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uptime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetUptime() uint64 {
	if t == nil || t.Uptime == nil {
		return 0
	}
	return *t.Uptime
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerAddress == nil {
		return nil, fmt.Errorf("nil value for key PeerAddress")
	}

	return map[string]interface{}{
		"peer-address": *t.PeerAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct {
	BridgeDomain            *uint32                                                                                  `path:"state/bridge-domain" module:"openconfig-network-instance/openconfig-network-instance"`
	L3VrfName               *string                                                                                  `path:"state/l3-vrf-name" module:"openconfig-network-instance/openconfig-network-instance"`
	LearningMode            E_EvpnTypes_LearningMode                                                                 `path:"state/learning-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	MultidestinationTraffic NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union `path:"state/multidestination-traffic" module:"openconfig-network-instance/openconfig-network-instance"`
	SviState                E_EndpointVni_SviState                                                                   `path:"state/svi-state" module:"openconfig-network-instance/openconfig-network-instance"`
	Vni                     *uint32                                                                                  `path:"state/vni|vni" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"vni" shadow-module:"openconfig-network-instance"`
	VniState                E_EndpointVni_VniState                                                                   `path:"state/vni-state" module:"openconfig-network-instance/openconfig-network-instance"`
	VniType                 E_EndpointVni_VniType                                                                    `path:"state/vni-type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) IsYANGGoStruct() {}

// GetBridgeDomain retrieves the value of the leaf BridgeDomain from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BridgeDomain is set, it can
// safely use t.GetBridgeDomain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BridgeDomain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetBridgeDomain() uint32 {
	if t == nil || t.BridgeDomain == nil {
		return 0
	}
	return *t.BridgeDomain
}

// GetL3VrfName retrieves the value of the leaf L3VrfName from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3VrfName is set, it can
// safely use t.GetL3VrfName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3VrfName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetL3VrfName() string {
	if t == nil || t.L3VrfName == nil {
		return ""
	}
	return *t.L3VrfName
}

// GetLearningMode retrieves the value of the leaf LearningMode from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearningMode is set, it can
// safely use t.GetLearningMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearningMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetLearningMode() E_EvpnTypes_LearningMode {
	if t == nil || t.LearningMode == 0 {
		return 0
	}
	return t.LearningMode
}

// GetMultidestinationTraffic retrieves the value of the leaf MultidestinationTraffic from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MultidestinationTraffic is set, it can
// safely use t.GetMultidestinationTraffic() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MultidestinationTraffic == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetMultidestinationTraffic() NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union {
	if t == nil || t.MultidestinationTraffic == nil {
		return nil
	}
	return t.MultidestinationTraffic
}

// GetSviState retrieves the value of the leaf SviState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SviState is set, it can
// safely use t.GetSviState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SviState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetSviState() E_EndpointVni_SviState {
	if t == nil || t.SviState == 0 {
		return 0
	}
	return t.SviState
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// GetVniState retrieves the value of the leaf VniState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniState is set, it can
// safely use t.GetVniState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniState() E_EndpointVni_VniState {
	if t == nil || t.VniState == 0 {
		return 0
	}
	return t.VniState
}

// GetVniType retrieves the value of the leaf VniType from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniType is set, it can
// safely use t.GetVniType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniType() E_EndpointVni_VniType {
	if t == nil || t.VniType == 0 {
		return 0
	}
	return t.VniType
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Vni == nil {
		return nil, fmt.Errorf("nil value for key Vni")
	}

	return map[string]interface{}{
		"vni": *t.Vni,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Encapsulation represents the /openconfig-network-instance/network-instances/network-instance/encapsulation YANG schema element.
type NetworkInstance_Encapsulation struct {
	ControlWord         *bool                                        `path:"state/control-word" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/control-word" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulationType   E_NetworkInstanceTypes_ENCAPSULATION         `path:"state/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/encapsulation-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LabelAllocationMode E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE `path:"state/label-allocation-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/label-allocation-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Encapsulation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Encapsulation) IsYANGGoStruct() {}

// GetControlWord retrieves the value of the leaf ControlWord from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlWord is set, it can
// safely use t.GetControlWord() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlWord == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetControlWord() bool {
	if t == nil || t.ControlWord == nil {
		return false
	}
	return *t.ControlWord
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetLabelAllocationMode retrieves the value of the leaf LabelAllocationMode from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelAllocationMode is set, it can
// safely use t.GetLabelAllocationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelAllocationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetLabelAllocationMode() E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	if t == nil || t.LabelAllocationMode == 0 {
		return 0
	}
	return t.LabelAllocationMode
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Encapsulation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Encapsulation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Encapsulation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Encapsulation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Encapsulation.
func (*NetworkInstance_Encapsulation) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn represents the /openconfig-network-instance/network-instances/network-instance/evpn YANG schema element.
type NetworkInstance_Evpn struct {
	EthernetSegment map[string]*NetworkInstance_Evpn_EthernetSegment `path:"ethernet-segments/ethernet-segment" module:"openconfig-network-instance/openconfig-network-instance"`
	EvpnInstance    map[string]*NetworkInstance_Evpn_EvpnInstance    `path:"evpn-instances/evpn-instance" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn) IsYANGGoStruct() {}

// NewEthernetSegment creates a new entry in the EthernetSegment list of the
// NetworkInstance_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn) NewEthernetSegment(Name string) (*NetworkInstance_Evpn_EthernetSegment, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthernetSegment == nil {
		t.EthernetSegment = make(map[string]*NetworkInstance_Evpn_EthernetSegment)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EthernetSegment[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EthernetSegment", key)
	}

	t.EthernetSegment[key] = &NetworkInstance_Evpn_EthernetSegment{
		Name: &Name,
	}

	return t.EthernetSegment[key], nil
}

// RenameEthernetSegment renames an entry in the list EthernetSegment within
// the NetworkInstance_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn) RenameEthernetSegment(oldK, newK string) error {
	if _, ok := t.EthernetSegment[newK]; ok {
		return fmt.Errorf("key %v already exists in EthernetSegment", newK)
	}

	e, ok := t.EthernetSegment[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EthernetSegment", oldK)
	}
	e.Name = &newK

	t.EthernetSegment[newK] = e
	delete(t.EthernetSegment, oldK)
	return nil
}

// GetOrCreateEthernetSegment retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn) GetOrCreateEthernetSegment(Name string) *NetworkInstance_Evpn_EthernetSegment {

	key := Name

	if v, ok := t.EthernetSegment[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEthernetSegment(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEthernetSegment got unexpected error: %v", err))
	}
	return v
}

// GetEthernetSegment retrieves the value with the specified key from
// the EthernetSegment map field of NetworkInstance_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn) GetEthernetSegment(Name string) *NetworkInstance_Evpn_EthernetSegment {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.EthernetSegment[key]; ok {
		return lm
	}
	return nil
}

// DeleteEthernetSegment deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn) DeleteEthernetSegment(Name string) {
	key := Name

	delete(t.EthernetSegment, key)
}

// AppendEthernetSegment appends the supplied NetworkInstance_Evpn_EthernetSegment struct to the
// list EthernetSegment of NetworkInstance_Evpn. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EthernetSegment already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn) AppendEthernetSegment(v *NetworkInstance_Evpn_EthernetSegment) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthernetSegment == nil {
		t.EthernetSegment = make(map[string]*NetworkInstance_Evpn_EthernetSegment)
	}

	if _, ok := t.EthernetSegment[key]; ok {
		return fmt.Errorf("duplicate key for list EthernetSegment %v", key)
	}

	t.EthernetSegment[key] = v
	return nil
}

// NewEvpnInstance creates a new entry in the EvpnInstance list of the
// NetworkInstance_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn) NewEvpnInstance(Evi string) (*NetworkInstance_Evpn_EvpnInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	key := Evi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EvpnInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EvpnInstance", key)
	}

	t.EvpnInstance[key] = &NetworkInstance_Evpn_EvpnInstance{
		Evi: &Evi,
	}

	return t.EvpnInstance[key], nil
}

// RenameEvpnInstance renames an entry in the list EvpnInstance within
// the NetworkInstance_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn) RenameEvpnInstance(oldK, newK string) error {
	if _, ok := t.EvpnInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in EvpnInstance", newK)
	}

	e, ok := t.EvpnInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EvpnInstance", oldK)
	}
	e.Evi = &newK

	t.EvpnInstance[newK] = e
	delete(t.EvpnInstance, oldK)
	return nil
}

// GetOrCreateEvpnInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn) GetOrCreateEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	key := Evi

	if v, ok := t.EvpnInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvpnInstance(Evi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvpnInstance got unexpected error: %v", err))
	}
	return v
}

// GetEvpnInstance retrieves the value with the specified key from
// the EvpnInstance map field of NetworkInstance_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn) GetEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	if t == nil {
		return nil
	}

	key := Evi

	if lm, ok := t.EvpnInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvpnInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn) DeleteEvpnInstance(Evi string) {
	key := Evi

	delete(t.EvpnInstance, key)
}

// AppendEvpnInstance appends the supplied NetworkInstance_Evpn_EvpnInstance struct to the
// list EvpnInstance of NetworkInstance_Evpn. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn) AppendEvpnInstance(v *NetworkInstance_Evpn_EvpnInstance) error {
	if v.Evi == nil {
		return fmt.Errorf("invalid nil key received for Evi")
	}

	key := *v.Evi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	if _, ok := t.EvpnInstance[key]; ok {
		return fmt.Errorf("duplicate key for list EvpnInstance %v", key)
	}

	t.EvpnInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EthernetSegment {
		e.PopulateDefaults()
	}
	for _, e := range t.EvpnInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn.
func (*NetworkInstance_Evpn) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EthernetSegment represents the /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment YANG schema element.
type NetworkInstance_Evpn_EthernetSegment struct {
	DfElection     *NetworkInstance_Evpn_EthernetSegment_DfElection `path:"df-election" module:"openconfig-network-instance"`
	Esi            NetworkInstance_Evpn_EthernetSegment_Esi_Union   `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/esi" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EsiType        E_EvpnTypes_EsiType                              `path:"state/esi-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/esi-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Interface      *string                                          `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name           *string                                          `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	RedundancyMode E_EvpnTypes_EVPN_REDUNDANCY_MODE                 `path:"state/redundancy-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/redundancy-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface   *uint32                                          `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EthernetSegment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EthernetSegment) IsYANGGoStruct() {}

// GetOrCreateDfElection retrieves the value of the DfElection field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EthernetSegment) GetOrCreateDfElection() *NetworkInstance_Evpn_EthernetSegment_DfElection {
	if t.DfElection != nil {
		return t.DfElection
	}
	t.DfElection = &NetworkInstance_Evpn_EthernetSegment_DfElection{}
	return t.DfElection
}

// GetDfElection returns the value of the DfElection struct pointer
// from NetworkInstance_Evpn_EthernetSegment. If the receiver or the field DfElection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EthernetSegment) GetDfElection() *NetworkInstance_Evpn_EthernetSegment_DfElection {
	if t != nil && t.DfElection != nil {
		return t.DfElection
	}
	return nil
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetEsi() NetworkInstance_Evpn_EthernetSegment_Esi_Union {
	if t == nil || t.Esi == nil {
		return nil
	}
	return t.Esi
}

// GetEsiType retrieves the value of the leaf EsiType from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsiType is set, it can
// safely use t.GetEsiType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsiType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetEsiType() E_EvpnTypes_EsiType {
	if t == nil || t.EsiType == 0 {
		return EvpnTypes_EsiType_TYPE_0_OPERATOR_CONFIGURED
	}
	return t.EsiType
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRedundancyMode retrieves the value of the leaf RedundancyMode from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedundancyMode is set, it can
// safely use t.GetRedundancyMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedundancyMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetRedundancyMode() E_EvpnTypes_EVPN_REDUNDANCY_MODE {
	if t == nil || t.RedundancyMode == 0 {
		return 0
	}
	return t.RedundancyMode
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Evpn_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EthernetSegment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EthernetSegment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EsiType == 0 {
		t.EsiType = EvpnTypes_EsiType_TYPE_0_OPERATOR_CONFIGURED
	}
	t.DfElection.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EthernetSegment struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EthernetSegment) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EthernetSegment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EthernetSegment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EthernetSegment.
func (*NetworkInstance_Evpn_EthernetSegment) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EthernetSegment_DfElection represents the /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/df-election YANG schema element.
type NetworkInstance_Evpn_EthernetSegment_DfElection struct {
	DfElectionMethod E_DfElection_DfElectionMethod `path:"state/df-election-method" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/df-election-method" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ElectionWaitTime *uint32                       `path:"state/election-wait-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/election-wait-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Preference       *uint16                       `path:"state/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Revertive        *bool                         `path:"state/revertive" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/revertive" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EthernetSegment_DfElection implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EthernetSegment_DfElection) IsYANGGoStruct() {}

// GetDfElectionMethod retrieves the value of the leaf DfElectionMethod from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DfElectionMethod is set, it can
// safely use t.GetDfElectionMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DfElectionMethod == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetDfElectionMethod() E_DfElection_DfElectionMethod {
	if t == nil || t.DfElectionMethod == 0 {
		return 0
	}
	return t.DfElectionMethod
}

// GetElectionWaitTime retrieves the value of the leaf ElectionWaitTime from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ElectionWaitTime is set, it can
// safely use t.GetElectionWaitTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ElectionWaitTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetElectionWaitTime() uint32 {
	if t == nil || t.ElectionWaitTime == nil {
		return 0
	}
	return *t.ElectionWaitTime
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetPreference() uint16 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetRevertive retrieves the value of the leaf Revertive from the NetworkInstance_Evpn_EthernetSegment_DfElection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Revertive is set, it can
// safely use t.GetRevertive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Revertive == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) GetRevertive() bool {
	if t == nil || t.Revertive == nil {
		return true
	}
	return *t.Revertive
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EthernetSegment_DfElection
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Revertive == nil {
		var v bool = true
		t.Revertive = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EthernetSegment_DfElection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EthernetSegment_DfElection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EthernetSegment_DfElection.
func (*NetworkInstance_Evpn_EthernetSegment_DfElection) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance YANG schema element.
type NetworkInstance_Evpn_EvpnInstance struct {
	BComponent         map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent   `path:"pbb/b-component" module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulationType  E_NetworkInstanceTypes_ENCAPSULATION                       `path:"state/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/encapsulation-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Evi                *string                                                    `path:"state/evi|evi" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/evi|evi" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ImportExportPolicy *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy      `path:"import-export-policy" module:"openconfig-network-instance"`
	MulticastGroup     *string                                                    `path:"state/multicast-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastMask      *string                                                    `path:"state/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReplicationMode    E_EvpnInstance_ReplicationMode                             `path:"state/replication-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/replication-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RouteDistinguisher NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union `path:"state/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/route-distinguisher" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ServiceType        E_EvpnTypes_EVPN_TYPE                                      `path:"state/service-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/service-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vxlan              *NetworkInstance_Evpn_EvpnInstance_Vxlan                   `path:"vxlan" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance) IsYANGGoStruct() {}

// NewBComponent creates a new entry in the BComponent list of the
// NetworkInstance_Evpn_EvpnInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance) NewBComponent(BComponentName string) (*NetworkInstance_Evpn_EvpnInstance_BComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	key := BComponentName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BComponent", key)
	}

	t.BComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent{
		BComponentName: &BComponentName,
	}

	return t.BComponent[key], nil
}

// RenameBComponent renames an entry in the list BComponent within
// the NetworkInstance_Evpn_EvpnInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance) RenameBComponent(oldK, newK string) error {
	if _, ok := t.BComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in BComponent", newK)
	}

	e, ok := t.BComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BComponent", oldK)
	}
	e.BComponentName = &newK

	t.BComponent[newK] = e
	delete(t.BComponent, oldK)
	return nil
}

// GetOrCreateBComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	key := BComponentName

	if v, ok := t.BComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBComponent(BComponentName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBComponent got unexpected error: %v", err))
	}
	return v
}

// GetBComponent retrieves the value with the specified key from
// the BComponent map field of NetworkInstance_Evpn_EvpnInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	if t == nil {
		return nil
	}

	key := BComponentName

	if lm, ok := t.BComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteBComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance) DeleteBComponent(BComponentName string) {
	key := BComponentName

	delete(t.BComponent, key)
}

// AppendBComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent struct to the
// list BComponent of NetworkInstance_Evpn_EvpnInstance. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance) AppendBComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent) error {
	if v.BComponentName == nil {
		return fmt.Errorf("invalid nil key received for BComponentName")
	}

	key := *v.BComponentName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	if _, ok := t.BComponent[key]; ok {
		return fmt.Errorf("duplicate key for list BComponent %v", key)
	}

	t.BComponent[key] = v
	return nil
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	return t.Vxlan
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEvi() string {
	if t == nil || t.Evi == nil {
		return ""
	}
	return *t.Evi
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetReplicationMode retrieves the value of the leaf ReplicationMode from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplicationMode is set, it can
// safely use t.GetReplicationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplicationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetReplicationMode() E_EvpnInstance_ReplicationMode {
	if t == nil || t.ReplicationMode == 0 {
		return 0
	}
	return t.ReplicationMode
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetRouteDistinguisher() NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	if t == nil || t.RouteDistinguisher == nil {
		return nil
	}
	return t.RouteDistinguisher
}

// GetServiceType retrieves the value of the leaf ServiceType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServiceType is set, it can
// safely use t.GetServiceType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServiceType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetServiceType() E_EvpnTypes_EVPN_TYPE {
	if t == nil || t.ServiceType == 0 {
		return 0
	}
	return t.ServiceType
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ImportExportPolicy.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
	for _, e := range t.BComponent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Evi == nil {
		return nil, fmt.Errorf("nil value for key Evi")
	}

	return map[string]interface{}{
		"evi": *t.Evi,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance.
func (*NetworkInstance_Evpn_EvpnInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent struct {
	BComponentName *string                                                             `path:"state/b-component-name|b-component-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/b-component-name|b-component-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	BackboneSrcMac *string                                                             `path:"state/backbone-src-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/backbone-src-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IComponent     map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent `path:"i-components/i-component" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) IsYANGGoStruct() {}

// NewIComponent creates a new entry in the IComponent list of the
// NetworkInstance_Evpn_EvpnInstance_BComponent struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) NewIComponent(ISid uint32) (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	key := ISid

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IComponent", key)
	}

	t.IComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
		ISid: &ISid,
	}

	return t.IComponent[key], nil
}

// RenameIComponent renames an entry in the list IComponent within
// the NetworkInstance_Evpn_EvpnInstance_BComponent struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) RenameIComponent(oldK, newK uint32) error {
	if _, ok := t.IComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in IComponent", newK)
	}

	e, ok := t.IComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IComponent", oldK)
	}
	e.ISid = &newK

	t.IComponent[newK] = e
	delete(t.IComponent, oldK)
	return nil
}

// GetOrCreateIComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetOrCreateIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	key := ISid

	if v, ok := t.IComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIComponent(ISid)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIComponent got unexpected error: %v", err))
	}
	return v
}

// GetIComponent retrieves the value with the specified key from
// the IComponent map field of NetworkInstance_Evpn_EvpnInstance_BComponent. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	if t == nil {
		return nil
	}

	key := ISid

	if lm, ok := t.IComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteIComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) DeleteIComponent(ISid uint32) {
	key := ISid

	delete(t.IComponent, key)
}

// AppendIComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct to the
// list IComponent of NetworkInstance_Evpn_EvpnInstance_BComponent. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) AppendIComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) error {
	if v.ISid == nil {
		return fmt.Errorf("invalid nil key received for ISid")
	}

	key := *v.ISid

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	if _, ok := t.IComponent[key]; ok {
		return fmt.Errorf("duplicate key for list IComponent %v", key)
	}

	t.IComponent[key] = v
	return nil
}

// GetBComponentName retrieves the value of the leaf BComponentName from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BComponentName is set, it can
// safely use t.GetBComponentName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BComponentName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBComponentName() string {
	if t == nil || t.BComponentName == nil {
		return ""
	}
	return *t.BComponentName
}

// GetBackboneSrcMac retrieves the value of the leaf BackboneSrcMac from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackboneSrcMac is set, it can
// safely use t.GetBackboneSrcMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackboneSrcMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBackboneSrcMac() string {
	if t == nil || t.BackboneSrcMac == nil {
		return ""
	}
	return *t.BackboneSrcMac
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_BComponent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.IComponent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BComponentName == nil {
		return nil, fmt.Errorf("nil value for key BComponentName")
	}

	return map[string]interface{}{
		"b-component-name": *t.BComponentName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct {
	ISid *uint32 `path:"state/i-sid|i-sid" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/i-sid|i-sid" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) IsYANGGoStruct() {}

// GetISid retrieves the value of the leaf ISid from the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ISid is set, it can
// safely use t.GetISid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ISid == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) GetISid() uint32 {
	if t == nil || t.ISid == nil {
		return 0
	}
	return *t.ISid
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ISid == nil {
		return nil, fmt.Errorf("nil value for key ISid")
	}

	return map[string]interface{}{
		"i-sid": *t.ISid,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy struct {
	ExportRouteTarget []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union `path:"state/export-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/export-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportRouteTarget []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union `path:"state/import-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan struct {
	AnycastSourceInterface         *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface `path:"anycast-source-interface" module:"openconfig-network-instance"`
	HostReachabilityBgp            *bool                                                           `path:"state/host-reachability-bgp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/host-reachability-bgp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastGroup                 *string                                                         `path:"state/multicast-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MulticastMask                  *string                                                         `path:"state/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/multicast-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverlayEndpoint                *string                                                         `path:"state/overlay-endpoint" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/overlay-endpoint" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	OverlayEndpointNetworkInstance *string                                                         `path:"state/overlay-endpoint-network-instance" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/overlay-endpoint-network-instance" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Vni                            *uint32                                                         `path:"state/vni" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/vni" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) IsYANGGoStruct() {}

// GetOrCreateAnycastSourceInterface retrieves the value of the AnycastSourceInterface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOrCreateAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	t.AnycastSourceInterface = &NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	return t.AnycastSourceInterface
}

// GetAnycastSourceInterface returns the value of the AnycastSourceInterface struct pointer
// from NetworkInstance_Evpn_EvpnInstance_Vxlan. If the receiver or the field AnycastSourceInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t != nil && t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	return nil
}

// GetHostReachabilityBgp retrieves the value of the leaf HostReachabilityBgp from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostReachabilityBgp is set, it can
// safely use t.GetHostReachabilityBgp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostReachabilityBgp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetHostReachabilityBgp() bool {
	if t == nil || t.HostReachabilityBgp == nil {
		return false
	}
	return *t.HostReachabilityBgp
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetOverlayEndpoint retrieves the value of the leaf OverlayEndpoint from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpoint is set, it can
// safely use t.GetOverlayEndpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpoint == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpoint() string {
	if t == nil || t.OverlayEndpoint == nil {
		return ""
	}
	return *t.OverlayEndpoint
}

// GetOverlayEndpointNetworkInstance retrieves the value of the leaf OverlayEndpointNetworkInstance from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpointNetworkInstance is set, it can
// safely use t.GetOverlayEndpointNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpointNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpointNetworkInstance() string {
	if t == nil || t.OverlayEndpointNetworkInstance == nil {
		return ""
	}
	return *t.OverlayEndpointNetworkInstance
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AnycastSourceInterface.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb represents the /openconfig-network-instance/network-instances/network-instance/fdb YANG schema element.
type NetworkInstance_Fdb struct {
	AnycastGatewayMac             *string                          `path:"state/anycast-gateway-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/anycast-gateway-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ArpProxy                      *NetworkInstance_Fdb_ArpProxy    `path:"arp-proxy" module:"openconfig-network-instance"`
	FloodUnknownUnicastSupression *bool                            `path:"state/flood-unknown-unicast-supression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/flood-unknown-unicast-supression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	L2Rib                         *NetworkInstance_Fdb_L2Rib       `path:"l2rib" module:"openconfig-network-instance"`
	MacAgingTime                  *uint16                          `path:"state/mac-aging-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-aging-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacLearning                   *bool                            `path:"state/mac-learning" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-learning" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobility                   *NetworkInstance_Fdb_MacMobility `path:"mac-mobility" module:"openconfig-network-instance"`
	MacTable                      *NetworkInstance_Fdb_MacTable    `path:"mac-table" module:"openconfig-network-instance"`
	MaximumEntries                *uint16                          `path:"state/maximum-entries" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/maximum-entries" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NdProxy                       *NetworkInstance_Fdb_NdProxy     `path:"nd-proxy" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb) IsYANGGoStruct() {}

// GetOrCreateArpProxy retrieves the value of the ArpProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t.ArpProxy != nil {
		return t.ArpProxy
	}
	t.ArpProxy = &NetworkInstance_Fdb_ArpProxy{}
	return t.ArpProxy
}

// GetOrCreateL2Rib retrieves the value of the L2Rib field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t.L2Rib != nil {
		return t.L2Rib
	}
	t.L2Rib = &NetworkInstance_Fdb_L2Rib{}
	return t.L2Rib
}

// GetOrCreateMacMobility retrieves the value of the MacMobility field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t.MacMobility != nil {
		return t.MacMobility
	}
	t.MacMobility = &NetworkInstance_Fdb_MacMobility{}
	return t.MacMobility
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacTable() *NetworkInstance_Fdb_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_MacTable{}
	return t.MacTable
}

// GetOrCreateNdProxy retrieves the value of the NdProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t.NdProxy != nil {
		return t.NdProxy
	}
	t.NdProxy = &NetworkInstance_Fdb_NdProxy{}
	return t.NdProxy
}

// GetArpProxy returns the value of the ArpProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field ArpProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t != nil && t.ArpProxy != nil {
		return t.ArpProxy
	}
	return nil
}

// GetL2Rib returns the value of the L2Rib struct pointer
// from NetworkInstance_Fdb. If the receiver or the field L2Rib is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t != nil && t.L2Rib != nil {
		return t.L2Rib
	}
	return nil
}

// GetMacMobility returns the value of the MacMobility struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacMobility is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t != nil && t.MacMobility != nil {
		return t.MacMobility
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacTable() *NetworkInstance_Fdb_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// GetNdProxy returns the value of the NdProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field NdProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t != nil && t.NdProxy != nil {
		return t.NdProxy
	}
	return nil
}

// GetAnycastGatewayMac retrieves the value of the leaf AnycastGatewayMac from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGatewayMac is set, it can
// safely use t.GetAnycastGatewayMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGatewayMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetAnycastGatewayMac() string {
	if t == nil || t.AnycastGatewayMac == nil {
		return ""
	}
	return *t.AnycastGatewayMac
}

// GetFloodUnknownUnicastSupression retrieves the value of the leaf FloodUnknownUnicastSupression from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FloodUnknownUnicastSupression is set, it can
// safely use t.GetFloodUnknownUnicastSupression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FloodUnknownUnicastSupression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetFloodUnknownUnicastSupression() bool {
	if t == nil || t.FloodUnknownUnicastSupression == nil {
		return false
	}
	return *t.FloodUnknownUnicastSupression
}

// GetMacAgingTime retrieves the value of the leaf MacAgingTime from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAgingTime is set, it can
// safely use t.GetMacAgingTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAgingTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacAgingTime() uint16 {
	if t == nil || t.MacAgingTime == nil {
		return 0
	}
	return *t.MacAgingTime
}

// GetMacLearning retrieves the value of the leaf MacLearning from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacLearning is set, it can
// safely use t.GetMacLearning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacLearning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacLearning() bool {
	if t == nil || t.MacLearning == nil {
		return false
	}
	return *t.MacLearning
}

// GetMaximumEntries retrieves the value of the leaf MaximumEntries from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumEntries is set, it can
// safely use t.GetMaximumEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumEntries == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMaximumEntries() uint16 {
	if t == nil || t.MaximumEntries == nil {
		return 0
	}
	return *t.MaximumEntries
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FloodUnknownUnicastSupression == nil {
		var v bool = false
		t.FloodUnknownUnicastSupression = &v
	}
	t.ArpProxy.PopulateDefaults()
	t.L2Rib.PopulateDefaults()
	t.MacMobility.PopulateDefaults()
	t.MacTable.PopulateDefaults()
	t.NdProxy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb.
func (*NetworkInstance_Fdb) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_ArpProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy YANG schema element.
type NetworkInstance_Fdb_ArpProxy struct {
	ArpSuppression               *bool   `path:"state/arp-suppression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/arp-suppression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DuplicateIpDetectionInterval *uint16 `path:"state/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable                       *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"state/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_ArpProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_ArpProxy) IsYANGGoStruct() {}

// GetArpSuppression retrieves the value of the leaf ArpSuppression from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ArpSuppression is set, it can
// safely use t.GetArpSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ArpSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetArpSuppression() bool {
	if t == nil || t.ArpSuppression == nil {
		return false
	}
	return *t.ArpSuppression
}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_ArpProxy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_ArpProxy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ArpSuppression == nil {
		var v bool = false
		t.ArpSuppression = &v
	}
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_ArpProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_ArpProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_ArpProxy.
func (*NetworkInstance_Fdb_ArpProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib YANG schema element.
type NetworkInstance_Fdb_L2Rib struct {
	MacIpTable *NetworkInstance_Fdb_L2Rib_MacIpTable `path:"mac-ip-table" module:"openconfig-network-instance"`
	MacTable   *NetworkInstance_Fdb_L2Rib_MacTable   `path:"mac-table" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib) IsYANGGoStruct() {}

// GetOrCreateMacIpTable retrieves the value of the MacIpTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t.MacIpTable != nil {
		return t.MacIpTable
	}
	t.MacIpTable = &NetworkInstance_Fdb_L2Rib_MacIpTable{}
	return t.MacIpTable
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_L2Rib_MacTable{}
	return t.MacTable
}

// GetMacIpTable returns the value of the MacIpTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacIpTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t != nil && t.MacIpTable != nil {
		return t.MacIpTable
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MacIpTable.PopulateDefaults()
	t.MacTable.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib.
func (*NetworkInstance_Fdb_L2Rib) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable struct {
	Entry   map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop                                       `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	HostIp     string `path:"host-ip"`
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewEntry(MacAddress string, HostIp string) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry{
		MacAddress: &MacAddress,
		HostIp:     &HostIp,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameEntry(oldK, newK NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.HostIp = &newK.HostIp

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, HostIp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteEntry(MacAddress string, HostIp string) {
	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.HostIp == nil {
		return fmt.Errorf("invalid nil key for HostIp")
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: *v.MacAddress,
		HostIp:     *v.HostIp,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct {
	Evi        *uint32                                                                      `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	HostIp     *string                                                                      `path:"state/host-ip|host-ip" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"host-ip" shadow-module:"openconfig-network-instance"`
	L2Vni      *uint32                                                                      `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	L3Vni      *uint32                                                                      `path:"state/l3-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress *string                                                                      `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	Producer   map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan       *uint16                                                                      `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) NewProducer(Producer E_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) RenameProducer(oldK, newK E_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetOrCreateProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) DeleteProducer(Producer E_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetHostIp retrieves the value of the leaf HostIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostIp is set, it can
// safely use t.GetHostIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetHostIp() string {
	if t == nil || t.HostIp == nil {
		return ""
	}
	return *t.HostIp
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetL3Vni retrieves the value of the leaf L3Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3Vni is set, it can
// safely use t.GetL3Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL3Vni() uint32 {
	if t == nil || t.L3Vni == nil {
		return 0
	}
	return *t.L3Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Producer {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.HostIp == nil {
		return nil, fmt.Errorf("nil value for key HostIp")
	}

	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"host-ip":     *t.HostIp,
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct {
	Esi           *string                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	MobilityState E_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *uint64                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Producer      E_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"producer" shadow-module:"openconfig-network-instance"`
	SeqNumber     *uint32                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	Sticky        *bool                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetMobilityState() E_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetProducer() E_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct {
	Index        *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Label        *uint32 `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerIp       *string `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable struct {
	Entry   map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry   `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewEntry(MacAddress string) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry{
		MacAddress: &MacAddress,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameEntry(oldK, newK string) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	key := MacAddress

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteEntry(MacAddress string) {
	key := MacAddress

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable.
func (*NetworkInstance_Fdb_L2Rib_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry struct {
	Evi        *uint32                                                                    `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	L2Vni      *uint32                                                                    `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	MacAddress *string                                                                    `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mac-address" shadow-module:"openconfig-network-instance"`
	Producer   map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	Vlan       *uint16                                                                    `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) NewProducer(Producer E_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) RenameProducer(oldK, newK E_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetOrCreateProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) DeleteProducer(Producer E_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Producer {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct {
	DerivedFromMacIp *bool                    `path:"state/derived-from-mac-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	DirectlyReceived *bool                    `path:"state/directly-received" module:"openconfig-network-instance/openconfig-network-instance"`
	Esi              *string                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	MobilityState    E_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop          *uint64                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	Producer         E_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"producer" shadow-module:"openconfig-network-instance"`
	SeqNumber        *uint32                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	Sticky           *bool                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) IsYANGGoStruct() {}

// GetDerivedFromMacIp retrieves the value of the leaf DerivedFromMacIp from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DerivedFromMacIp is set, it can
// safely use t.GetDerivedFromMacIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DerivedFromMacIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDerivedFromMacIp() bool {
	if t == nil || t.DerivedFromMacIp == nil {
		return false
	}
	return *t.DerivedFromMacIp
}

// GetDirectlyReceived retrieves the value of the leaf DirectlyReceived from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DirectlyReceived is set, it can
// safely use t.GetDirectlyReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DirectlyReceived == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDirectlyReceived() bool {
	if t == nil || t.DirectlyReceived == nil {
		return false
	}
	return *t.DirectlyReceived
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetMobilityState() E_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetProducer() E_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct {
	Index        *uint64 `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Label        *uint32 `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerIp       *string `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacMobility represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility YANG schema element.
type NetworkInstance_Fdb_MacMobility struct {
	DuplicateIpDetectionInterval *uint16 `path:"state/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"state/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobility                  *bool   `path:"state/mac-mobility" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-mobility" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobilityThreshold         *uint8  `path:"state/mac-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacMobilityWindow            *uint16 `path:"state/mac-mobility-window" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-mobility-window" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacMobility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacMobility) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetMacMobility retrieves the value of the leaf MacMobility from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobility is set, it can
// safely use t.GetMacMobility() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobility == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobility() bool {
	if t == nil || t.MacMobility == nil {
		return false
	}
	return *t.MacMobility
}

// GetMacMobilityThreshold retrieves the value of the leaf MacMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityThreshold is set, it can
// safely use t.GetMacMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityThreshold() uint8 {
	if t == nil || t.MacMobilityThreshold == nil {
		return 5
	}
	return *t.MacMobilityThreshold
}

// GetMacMobilityWindow retrieves the value of the leaf MacMobilityWindow from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityWindow is set, it can
// safely use t.GetMacMobilityWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityWindow == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityWindow() uint16 {
	if t == nil || t.MacMobilityWindow == nil {
		return 180
	}
	return *t.MacMobilityWindow
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacMobility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacMobility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MacMobilityThreshold == nil {
		var v uint8 = 5
		t.MacMobilityThreshold = &v
	}
	if t.MacMobilityWindow == nil {
		var v uint16 = 180
		t.MacMobilityWindow = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacMobility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacMobility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacMobility.
func (*NetworkInstance_Fdb_MacMobility) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table YANG schema element.
type NetworkInstance_Fdb_MacTable struct {
	Entry map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_MacTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/mac-table.
type NetworkInstance_Fdb_MacTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	Vlan       uint16 `path:"vlan"`
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_MacTable) NewEntry(MacAddress string, Vlan uint16) (*NetworkInstance_Fdb_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_MacTable_Entry{
		MacAddress: &MacAddress,
		Vlan:       &Vlan,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_MacTable) RenameEntry(oldK, newK NetworkInstance_Fdb_MacTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.Vlan = &newK.Vlan

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_MacTable) GetOrCreateEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, Vlan)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_MacTable) GetEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_MacTable) DeleteEntry(MacAddress string, Vlan uint16) {
	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_MacTable) AppendEntry(v *NetworkInstance_Fdb_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.Vlan == nil {
		return fmt.Errorf("invalid nil key for Vlan")
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: *v.MacAddress,
		Vlan:       *v.Vlan,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable.
func (*NetworkInstance_Fdb_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry struct {
	Age        *uint64                                       `path:"state/age" module:"openconfig-network-instance/openconfig-network-instance"`
	EntryType  E_Entry_EntryType                             `path:"state/entry-type" module:"openconfig-network-instance/openconfig-network-instance"`
	Evi        *uint32                                       `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	Interface  *NetworkInstance_Fdb_MacTable_Entry_Interface `path:"interface" module:"openconfig-network-instance"`
	MacAddress *string                                       `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/mac-address|mac-address" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Vlan       *uint16                                       `path:"state/vlan|vlan" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/vlan|vlan" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry) IsYANGGoStruct() {}

// GetOrCreateInterface retrieves the value of the Interface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetOrCreateInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t.Interface != nil {
		return t.Interface
	}
	t.Interface = &NetworkInstance_Fdb_MacTable_Entry_Interface{}
	return t.Interface
}

// GetInterface returns the value of the Interface struct pointer
// from NetworkInstance_Fdb_MacTable_Entry. If the receiver or the field Interface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t != nil && t.Interface != nil {
		return t.Interface
	}
	return nil
}

// GetAge retrieves the value of the leaf Age from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetEntryType retrieves the value of the leaf EntryType from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryType is set, it can
// safely use t.GetEntryType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEntryType() E_Entry_EntryType {
	if t == nil || t.EntryType == 0 {
		return 0
	}
	return t.EntryType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Interface.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	if t.Vlan == nil {
		return nil, fmt.Errorf("nil value for key Vlan")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
		"vlan":        *t.Vlan,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry.
func (*NetworkInstance_Fdb_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface struct {
	InterfaceRef *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Fdb_MacTable_Entry_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_NdProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy YANG schema element.
type NetworkInstance_Fdb_NdProxy struct {
	DuplicateIpDetectionInterval *uint16 `path:"state/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/duplicate-ip-detection-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable                       *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IpMobilityThreshold          *uint16 `path:"state/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-mobility-threshold" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NdSuppression                *bool   `path:"state/nd-suppression" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/nd-suppression" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_NdProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_NdProxy) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetNdSuppression retrieves the value of the leaf NdSuppression from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NdSuppression is set, it can
// safely use t.GetNdSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NdSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetNdSuppression() bool {
	if t == nil || t.NdSuppression == nil {
		return false
	}
	return *t.NdSuppression
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_NdProxy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_NdProxy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
	if t.NdSuppression == nil {
		var v bool = false
		t.NdSuppression = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_NdProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_NdProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_NdProxy.
func (*NetworkInstance_Fdb_NdProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies YANG schema element.
type NetworkInstance_InterInstancePolicies struct {
	ApplyPolicy        *NetworkInstance_InterInstancePolicies_ApplyPolicy        `path:"apply-policy" module:"openconfig-network-instance"`
	ImportExportPolicy *NetworkInstance_InterInstancePolicies_ImportExportPolicy `path:"import-export-policy" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies) IsYANGGoStruct() {}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ApplyPolicy.PopulateDefaults()
	t.ImportExportPolicy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies.
func (*NetworkInstance_InterInstancePolicies) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ApplyPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ApplyPolicy struct {
	DefaultExportPolicy E_RoutingPolicy_DefaultPolicyType `path:"state/default-export-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/default-export-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DefaultImportPolicy E_RoutingPolicy_DefaultPolicyType `path:"state/default-import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/default-import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ExportPolicy        []string                          `path:"state/export-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/export-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportPolicy        []string                          `path:"state/import-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ApplyPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) IsYANGGoStruct() {}

// GetDefaultExportPolicy retrieves the value of the leaf DefaultExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultExportPolicy is set, it can
// safely use t.GetDefaultExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultExportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultExportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultExportPolicy
}

// GetDefaultImportPolicy retrieves the value of the leaf DefaultImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultImportPolicy is set, it can
// safely use t.GetDefaultImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultImportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultImportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultImportPolicy
}

// GetExportPolicy retrieves the value of the leaf ExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportPolicy is set, it can
// safely use t.GetExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetExportPolicy() []string {
	if t == nil || t.ExportPolicy == nil {
		return nil
	}
	return t.ExportPolicy
}

// GetImportPolicy retrieves the value of the leaf ImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportPolicy is set, it can
// safely use t.GetImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetImportPolicy() []string {
	if t == nil || t.ImportPolicy == nil {
		return nil
	}
	return t.ImportPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies_ApplyPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultExportPolicy == 0 {
		t.DefaultExportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	if t.DefaultImportPolicy == 0 {
		t.DefaultImportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ApplyPolicy.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ImportExportPolicy struct {
	ExportRouteTarget []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union `path:"state/export-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/export-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ImportRouteTarget []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union `path:"state/import-route-target" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/import-route-target" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ImportExportPolicy.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Interface represents the /openconfig-network-instance/network-instances/network-instance/interfaces/interface YANG schema element.
type NetworkInstance_Interface struct {
	AssociatedAddressFamilies []E_Types_ADDRESS_FAMILY      `path:"state/associated-address-families" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/associated-address-families" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Id                        *string                       `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/id|id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Interface                 *string                       `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IrbAnycastGateway         E_Interface_IrbAnycastGateway `path:"state/irb-anycast-gateway" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/irb-anycast-gateway" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MacPinning                *bool                         `path:"state/mac-pinning" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mac-pinning" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface              *uint32                       `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Interface) IsYANGGoStruct() {}

// GetAssociatedAddressFamilies retrieves the value of the leaf AssociatedAddressFamilies from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedAddressFamilies is set, it can
// safely use t.GetAssociatedAddressFamilies() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedAddressFamilies == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetAssociatedAddressFamilies() []E_Types_ADDRESS_FAMILY {
	if t == nil || t.AssociatedAddressFamilies == nil {
		return nil
	}
	return t.AssociatedAddressFamilies
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIrbAnycastGateway retrieves the value of the leaf IrbAnycastGateway from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IrbAnycastGateway is set, it can
// safely use t.GetIrbAnycastGateway() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IrbAnycastGateway == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetIrbAnycastGateway() E_Interface_IrbAnycastGateway {
	if t == nil || t.IrbAnycastGateway == 0 {
		return 0
	}
	return t.IrbAnycastGateway
}

// GetMacPinning retrieves the value of the leaf MacPinning from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacPinning is set, it can
// safely use t.GetMacPinning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacPinning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetMacPinning() bool {
	if t == nil || t.MacPinning == nil {
		return false
	}
	return *t.MacPinning
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Interface.
func (*NetworkInstance_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls represents the /openconfig-network-instance/network-instances/network-instance/mpls YANG schema element.
type NetworkInstance_Mpls struct {
	Global             *NetworkInstance_Mpls_Global               `path:"global" module:"openconfig-network-instance"`
	Interface          map[string]*NetworkInstance_Mpls_Interface `path:"te-interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Lsps               *NetworkInstance_Mpls_Lsps                 `path:"lsps" module:"openconfig-network-instance"`
	SignalingProtocols *NetworkInstance_Mpls_SignalingProtocols   `path:"signaling-protocols" module:"openconfig-network-instance"`
	TeGlobalAttributes *NetworkInstance_Mpls_TeGlobalAttributes   `path:"te-global-attributes" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Interface struct to the
// list Interface of NetworkInstance_Mpls. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls) AppendInterface(v *NetworkInstance_Mpls_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateGlobal() *NetworkInstance_Mpls_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_Global{}
	return t.Global
}

// GetOrCreateLsps retrieves the value of the Lsps field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateLsps() *NetworkInstance_Mpls_Lsps {
	if t.Lsps != nil {
		return t.Lsps
	}
	t.Lsps = &NetworkInstance_Mpls_Lsps{}
	return t.Lsps
}

// GetOrCreateSignalingProtocols retrieves the value of the SignalingProtocols field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	t.SignalingProtocols = &NetworkInstance_Mpls_SignalingProtocols{}
	return t.SignalingProtocols
}

// GetOrCreateTeGlobalAttributes retrieves the value of the TeGlobalAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	t.TeGlobalAttributes = &NetworkInstance_Mpls_TeGlobalAttributes{}
	return t.TeGlobalAttributes
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetGlobal() *NetworkInstance_Mpls_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetLsps returns the value of the Lsps struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Lsps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetLsps() *NetworkInstance_Mpls_Lsps {
	if t != nil && t.Lsps != nil {
		return t.Lsps
	}
	return nil
}

// GetSignalingProtocols returns the value of the SignalingProtocols struct pointer
// from NetworkInstance_Mpls. If the receiver or the field SignalingProtocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t != nil && t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	return nil
}

// GetTeGlobalAttributes returns the value of the TeGlobalAttributes struct pointer
// from NetworkInstance_Mpls. If the receiver or the field TeGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t != nil && t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	t.Lsps.PopulateDefaults()
	t.SignalingProtocols.PopulateDefaults()
	t.TeGlobalAttributes.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls.
func (*NetworkInstance_Mpls) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/global YANG schema element.
type NetworkInstance_Mpls_Global struct {
	Interface          map[string]*NetworkInstance_Mpls_Global_Interface          `path:"interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	NullLabel          E_MplsTypes_NULL_LABEL_TYPE                                `path:"state/null-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/null-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PwEncapsulation    E_MplsTypes_PSEUDOWIRE_ENCAPSULATION                       `path:"state/pw-encapsulation" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/pw-encapsulation" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReservedLabelBlock map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock `path:"reserved-label-blocks/reserved-label-block" module:"openconfig-network-instance/openconfig-network-instance"`
	TtlPropagation     *bool                                                      `path:"state/ttl-propagation" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ttl-propagation" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Global_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Global_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Global_Interface struct to the
// list Interface of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendInterface(v *NetworkInstance_Mpls_Global_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewReservedLabelBlock creates a new entry in the ReservedLabelBlock list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewReservedLabelBlock(LocalId string) (*NetworkInstance_Mpls_Global_ReservedLabelBlock, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ReservedLabelBlock[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ReservedLabelBlock", key)
	}

	t.ReservedLabelBlock[key] = &NetworkInstance_Mpls_Global_ReservedLabelBlock{
		LocalId: &LocalId,
	}

	return t.ReservedLabelBlock[key], nil
}

// RenameReservedLabelBlock renames an entry in the list ReservedLabelBlock within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameReservedLabelBlock(oldK, newK string) error {
	if _, ok := t.ReservedLabelBlock[newK]; ok {
		return fmt.Errorf("key %v already exists in ReservedLabelBlock", newK)
	}

	e, ok := t.ReservedLabelBlock[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ReservedLabelBlock", oldK)
	}
	e.LocalId = &newK

	t.ReservedLabelBlock[newK] = e
	delete(t.ReservedLabelBlock, oldK)
	return nil
}

// GetOrCreateReservedLabelBlock retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	key := LocalId

	if v, ok := t.ReservedLabelBlock[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewReservedLabelBlock(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateReservedLabelBlock got unexpected error: %v", err))
	}
	return v
}

// GetReservedLabelBlock retrieves the value with the specified key from
// the ReservedLabelBlock map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.ReservedLabelBlock[key]; ok {
		return lm
	}
	return nil
}

// DeleteReservedLabelBlock deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteReservedLabelBlock(LocalId string) {
	key := LocalId

	delete(t.ReservedLabelBlock, key)
}

// AppendReservedLabelBlock appends the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock struct to the
// list ReservedLabelBlock of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendReservedLabelBlock(v *NetworkInstance_Mpls_Global_ReservedLabelBlock) error {
	if v.LocalId == nil {
		return fmt.Errorf("invalid nil key received for LocalId")
	}

	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	if _, ok := t.ReservedLabelBlock[key]; ok {
		return fmt.Errorf("duplicate key for list ReservedLabelBlock %v", key)
	}

	t.ReservedLabelBlock[key] = v
	return nil
}

// GetNullLabel retrieves the value of the leaf NullLabel from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NullLabel is set, it can
// safely use t.GetNullLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NullLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetNullLabel() E_MplsTypes_NULL_LABEL_TYPE {
	if t == nil || t.NullLabel == 0 {
		return MplsTypes_NULL_LABEL_TYPE_IMPLICIT
	}
	return t.NullLabel
}

// GetPwEncapsulation retrieves the value of the leaf PwEncapsulation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PwEncapsulation is set, it can
// safely use t.GetPwEncapsulation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PwEncapsulation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetPwEncapsulation() E_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	if t == nil || t.PwEncapsulation == 0 {
		return 0
	}
	return t.PwEncapsulation
}

// GetTtlPropagation retrieves the value of the leaf TtlPropagation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TtlPropagation is set, it can
// safely use t.GetTtlPropagation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TtlPropagation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetTtlPropagation() bool {
	if t == nil || t.TtlPropagation == nil {
		return true
	}
	return *t.TtlPropagation
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.NullLabel == 0 {
		t.NullLabel = MplsTypes_NULL_LABEL_TYPE_IMPLICIT
	}
	if t.TtlPropagation == nil {
		var v bool = true
		t.TtlPropagation = &v
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.ReservedLabelBlock {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global.
func (*NetworkInstance_Mpls_Global) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Global_Interface struct {
	InterfaceId  *string                                             `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef *NetworkInstance_Mpls_Global_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
	MplsEnabled  *bool                                               `path:"state/mpls-enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mpls-enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Global_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Global_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetMplsEnabled retrieves the value of the leaf MplsEnabled from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsEnabled is set, it can
// safely use t.GetMplsEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetMplsEnabled() bool {
	if t == nil || t.MplsEnabled == nil {
		return false
	}
	return *t.MplsEnabled
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MplsEnabled == nil {
		var v bool = false
		t.MplsEnabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface.
func (*NetworkInstance_Mpls_Global_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Global_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_ReservedLabelBlock represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block YANG schema element.
type NetworkInstance_Mpls_Global_ReservedLabelBlock struct {
	LocalId    *string                                                         `path:"state/local-id|local-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/local-id|local-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	LowerBound NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union `path:"state/lower-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lower-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpperBound NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union `path:"state/upper-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/upper-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_ReservedLabelBlock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) IsYANGGoStruct() {}

// GetLocalId retrieves the value of the leaf LocalId from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalId is set, it can
// safely use t.GetLocalId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLocalId() string {
	if t == nil || t.LocalId == nil {
		return ""
	}
	return *t.LocalId
}

// GetLowerBound retrieves the value of the leaf LowerBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowerBound is set, it can
// safely use t.GetLowerBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowerBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLowerBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	if t == nil || t.LowerBound == nil {
		return nil
	}
	return t.LowerBound
}

// GetUpperBound retrieves the value of the leaf UpperBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpperBound is set, it can
// safely use t.GetUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetUpperBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	if t == nil || t.UpperBound == nil {
		return nil
	}
	return t.UpperBound
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_ReservedLabelBlock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_ReservedLabelBlock struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_ReservedLabelBlock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_ReservedLabelBlock.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Interface struct {
	AdminGroup           []string                                             `path:"state/admin-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/admin-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IgpFloodingBandwidth *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth `path:"igp-flooding-bandwidth" module:"openconfig-network-instance"`
	InterfaceId          *string                                              `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef         *NetworkInstance_Mpls_Interface_InterfaceRef         `path:"interface-ref" module:"openconfig-network-instance"`
	SrlgMembership       []string                                             `path:"state/srlg-membership" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/srlg-membership" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TeMetric             *uint32                                              `path:"state/te-metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/te-metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface) IsYANGGoStruct() {}

// GetOrCreateIgpFloodingBandwidth retrieves the value of the IgpFloodingBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	t.IgpFloodingBandwidth = &NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	return t.IgpFloodingBandwidth
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetIgpFloodingBandwidth returns the value of the IgpFloodingBandwidth struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field IgpFloodingBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t != nil && t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetAdminGroup retrieves the value of the leaf AdminGroup from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroup is set, it can
// safely use t.GetAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetAdminGroup() []string {
	if t == nil || t.AdminGroup == nil {
		return nil
	}
	return t.AdminGroup
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetSrlgMembership retrieves the value of the leaf SrlgMembership from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrlgMembership is set, it can
// safely use t.GetSrlgMembership() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrlgMembership == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetSrlgMembership() []string {
	if t == nil || t.SrlgMembership == nil {
		return nil
	}
	return t.SrlgMembership
}

// GetTeMetric retrieves the value of the leaf TeMetric from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TeMetric is set, it can
// safely use t.GetTeMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TeMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetTeMetric() uint32 {
	if t == nil || t.TeMetric == nil {
		return 0
	}
	return *t.TeMetric
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IgpFloodingBandwidth.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface.
func (*NetworkInstance_Mpls_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_IgpFloodingBandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth YANG schema element.
type NetworkInstance_Mpls_Interface_IgpFloodingBandwidth struct {
	DeltaPercentage        *uint8                                        `path:"state/delta-percentage" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/delta-percentage" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DownThresholds         []uint8                                       `path:"state/down-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/down-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ThresholdSpecification E_IgpFloodingBandwidth_ThresholdSpecification `path:"state/threshold-specification" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/threshold-specification" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ThresholdType          E_IgpFloodingBandwidth_ThresholdType          `path:"state/threshold-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/threshold-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpDownThresholds       []uint8                                       `path:"state/up-down-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/up-down-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	UpThresholds           []uint8                                       `path:"state/up-thresholds" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/up-thresholds" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_IgpFloodingBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) IsYANGGoStruct() {}

// GetDeltaPercentage retrieves the value of the leaf DeltaPercentage from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeltaPercentage is set, it can
// safely use t.GetDeltaPercentage() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeltaPercentage == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDeltaPercentage() uint8 {
	if t == nil || t.DeltaPercentage == nil {
		return 0
	}
	return *t.DeltaPercentage
}

// GetDownThresholds retrieves the value of the leaf DownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DownThresholds is set, it can
// safely use t.GetDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDownThresholds() []uint8 {
	if t == nil || t.DownThresholds == nil {
		return nil
	}
	return t.DownThresholds
}

// GetThresholdSpecification retrieves the value of the leaf ThresholdSpecification from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdSpecification is set, it can
// safely use t.GetThresholdSpecification() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdSpecification == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdSpecification() E_IgpFloodingBandwidth_ThresholdSpecification {
	if t == nil || t.ThresholdSpecification == 0 {
		return 0
	}
	return t.ThresholdSpecification
}

// GetThresholdType retrieves the value of the leaf ThresholdType from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdType is set, it can
// safely use t.GetThresholdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdType() E_IgpFloodingBandwidth_ThresholdType {
	if t == nil || t.ThresholdType == 0 {
		return 0
	}
	return t.ThresholdType
}

// GetUpDownThresholds retrieves the value of the leaf UpDownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpDownThresholds is set, it can
// safely use t.GetUpDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpDownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpDownThresholds() []uint8 {
	if t == nil || t.UpDownThresholds == nil {
		return nil
	}
	return t.UpDownThresholds
}

// GetUpThresholds retrieves the value of the leaf UpThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpThresholds is set, it can
// safely use t.GetUpThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpThresholds() []uint8 {
	if t == nil || t.UpThresholds == nil {
		return nil
	}
	return t.UpThresholds
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_IgpFloodingBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_IgpFloodingBandwidth.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps YANG schema element.
type NetworkInstance_Mpls_Lsps struct {
	ConstrainedPath   *NetworkInstance_Mpls_Lsps_ConstrainedPath      `path:"constrained-path" module:"openconfig-network-instance"`
	StaticLsp         map[string]*NetworkInstance_Mpls_Lsps_StaticLsp `path:"static-lsps/static-lsp" module:"openconfig-network-instance/openconfig-network-instance"`
	UnconstrainedPath *NetworkInstance_Mpls_Lsps_UnconstrainedPath    `path:"unconstrained-path" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps) IsYANGGoStruct() {}

// NewStaticLsp creates a new entry in the StaticLsp list of the
// NetworkInstance_Mpls_Lsps struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps) NewStaticLsp(Name string) (*NetworkInstance_Mpls_Lsps_StaticLsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticLsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticLsp", key)
	}

	t.StaticLsp[key] = &NetworkInstance_Mpls_Lsps_StaticLsp{
		Name: &Name,
	}

	return t.StaticLsp[key], nil
}

// RenameStaticLsp renames an entry in the list StaticLsp within
// the NetworkInstance_Mpls_Lsps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps) RenameStaticLsp(oldK, newK string) error {
	if _, ok := t.StaticLsp[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticLsp", newK)
	}

	e, ok := t.StaticLsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticLsp", oldK)
	}
	e.Name = &newK

	t.StaticLsp[newK] = e
	delete(t.StaticLsp, oldK)
	return nil
}

// GetOrCreateStaticLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	key := Name

	if v, ok := t.StaticLsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticLsp(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticLsp got unexpected error: %v", err))
	}
	return v
}

// GetStaticLsp retrieves the value with the specified key from
// the StaticLsp map field of NetworkInstance_Mpls_Lsps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticLsp[key]; ok {
		return lm
	}
	return nil
}

// DeleteStaticLsp deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps) DeleteStaticLsp(Name string) {
	key := Name

	delete(t.StaticLsp, key)
}

// AppendStaticLsp appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp struct to the
// list StaticLsp of NetworkInstance_Mpls_Lsps. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps) AppendStaticLsp(v *NetworkInstance_Mpls_Lsps_StaticLsp) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	if _, ok := t.StaticLsp[key]; ok {
		return fmt.Errorf("duplicate key for list StaticLsp %v", key)
	}

	t.StaticLsp[key] = v
	return nil
}

// GetOrCreateConstrainedPath retrieves the value of the ConstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	t.ConstrainedPath = &NetworkInstance_Mpls_Lsps_ConstrainedPath{}
	return t.ConstrainedPath
}

// GetOrCreateUnconstrainedPath retrieves the value of the UnconstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	t.UnconstrainedPath = &NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	return t.UnconstrainedPath
}

// GetConstrainedPath returns the value of the ConstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field ConstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t != nil && t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	return nil
}

// GetUnconstrainedPath returns the value of the UnconstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field UnconstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t != nil && t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ConstrainedPath.PopulateDefaults()
	t.UnconstrainedPath.PopulateDefaults()
	for _, e := range t.StaticLsp {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps.
func (*NetworkInstance_Mpls_Lsps) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath struct {
	NamedExplicitPath map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath `path:"named-explicit-paths/named-explicit-path" module:"openconfig-network-instance/openconfig-network-instance"`
	Tunnel            map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel            `path:"tunnels/tunnel" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) IsYANGGoStruct() {}

// NewNamedExplicitPath creates a new entry in the NamedExplicitPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewNamedExplicitPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NamedExplicitPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NamedExplicitPath", key)
	}

	t.NamedExplicitPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
		Name: &Name,
	}

	return t.NamedExplicitPath[key], nil
}

// RenameNamedExplicitPath renames an entry in the list NamedExplicitPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameNamedExplicitPath(oldK, newK string) error {
	if _, ok := t.NamedExplicitPath[newK]; ok {
		return fmt.Errorf("key %v already exists in NamedExplicitPath", newK)
	}

	e, ok := t.NamedExplicitPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NamedExplicitPath", oldK)
	}
	e.Name = &newK

	t.NamedExplicitPath[newK] = e
	delete(t.NamedExplicitPath, oldK)
	return nil
}

// GetOrCreateNamedExplicitPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	key := Name

	if v, ok := t.NamedExplicitPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNamedExplicitPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNamedExplicitPath got unexpected error: %v", err))
	}
	return v
}

// GetNamedExplicitPath retrieves the value with the specified key from
// the NamedExplicitPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NamedExplicitPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteNamedExplicitPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteNamedExplicitPath(Name string) {
	key := Name

	delete(t.NamedExplicitPath, key)
}

// AppendNamedExplicitPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct to the
// list NamedExplicitPath of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendNamedExplicitPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	if _, ok := t.NamedExplicitPath[key]; ok {
		return fmt.Errorf("duplicate key for list NamedExplicitPath %v", key)
	}

	t.NamedExplicitPath[key] = v
	return nil
}

// NewTunnel creates a new entry in the Tunnel list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewTunnel(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tunnel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tunnel", key)
	}

	t.Tunnel[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
		Name: &Name,
	}

	return t.Tunnel[key], nil
}

// RenameTunnel renames an entry in the list Tunnel within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameTunnel(oldK, newK string) error {
	if _, ok := t.Tunnel[newK]; ok {
		return fmt.Errorf("key %v already exists in Tunnel", newK)
	}

	e, ok := t.Tunnel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tunnel", oldK)
	}
	e.Name = &newK

	t.Tunnel[newK] = e
	delete(t.Tunnel, oldK)
	return nil
}

// GetOrCreateTunnel retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	key := Name

	if v, ok := t.Tunnel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnel(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnel got unexpected error: %v", err))
	}
	return v
}

// GetTunnel retrieves the value with the specified key from
// the Tunnel map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Tunnel[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnel deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteTunnel(Name string) {
	key := Name

	delete(t.Tunnel, key)
}

// AppendTunnel appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct to the
// list Tunnel of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendTunnel(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	if _, ok := t.Tunnel[key]; ok {
		return fmt.Errorf("duplicate key for list Tunnel %v", key)
	}

	t.Tunnel[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NamedExplicitPath {
		e.PopulateDefaults()
	}
	for _, e := range t.Tunnel {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct {
	ExplicitRouteObject   map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject `path:"explicit-route-objects/explicit-route-object" module:"openconfig-network-instance/openconfig-network-instance"`
	Name                  *string                                                                                    `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	SidProtectionRequired *bool                                                                                      `path:"state/sid-protection-required" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/sid-protection-required" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SidSelectionMode      E_NamedExplicitPath_SidSelectionMode                                                       `path:"state/sid-selection-mode" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/sid-selection-mode" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) IsYANGGoStruct() {}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) NewExplicitRouteObject(Index uint8) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) RenameExplicitRouteObject(oldK, newK uint8) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteExplicitRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) DeleteExplicitRouteObject(Index uint8) {
	key := Index

	delete(t.ExplicitRouteObject, key)
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) AppendExplicitRouteObject(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSidProtectionRequired retrieves the value of the leaf SidProtectionRequired from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidProtectionRequired is set, it can
// safely use t.GetSidProtectionRequired() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidProtectionRequired == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidProtectionRequired() bool {
	if t == nil || t.SidProtectionRequired == nil {
		return false
	}
	return *t.SidProtectionRequired
}

// GetSidSelectionMode retrieves the value of the leaf SidSelectionMode from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidSelectionMode is set, it can
// safely use t.GetSidSelectionMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidSelectionMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidSelectionMode() E_NamedExplicitPath_SidSelectionMode {
	if t == nil || t.SidSelectionMode == 0 {
		return NamedExplicitPath_SidSelectionMode_MIXED_MODE
	}
	return t.SidSelectionMode
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SidProtectionRequired == nil {
		var v bool = false
		t.SidProtectionRequired = &v
	}
	if t.SidSelectionMode == 0 {
		t.SidSelectionMode = NamedExplicitPath_SidSelectionMode_MIXED_MODE
	}
	for _, e := range t.ExplicitRouteObject {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct {
	Address *string            `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HopType E_Mpls_MplsHopType `path:"state/hop-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hop-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Index   *uint8             `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/index|index" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetHopType retrieves the value of the leaf HopType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopType is set, it can
// safely use t.GetHopType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetHopType() E_Mpls_MplsHopType {
	if t == nil || t.HopType == 0 {
		return 0
	}
	return t.HopType
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct {
	AdminStatus              E_MplsTypes_TUNNEL_ADMIN_STATUS                                       `path:"state/admin-status" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/admin-status" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	AutoGenerated            *bool                                                                 `path:"state/auto-generated" module:"openconfig-network-instance/openconfig-network-instance"`
	Bandwidth                *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth           `path:"bandwidth" module:"openconfig-network-instance"`
	Counters                 *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters            `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	Description              *string                                                               `path:"state/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HoldPriority             *uint8                                                                `path:"state/hold-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hold-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Metric                   *int32                                                                `path:"state/metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MetricType               E_MplsTypes_LSP_METRIC_TYPE                                           `path:"state/metric-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                     *string                                                               `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	OperStatus               E_MplsTypes_LSP_OPER_STATUS                                           `path:"state/oper-status" module:"openconfig-network-instance/openconfig-network-instance"`
	P2PTunnelAttributes      *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes `path:"p2p-tunnel-attributes" module:"openconfig-network-instance"`
	Preference               *uint8                                                                `path:"state/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ProtectionStyleRequested E_MplsTypes_PROTECTION_TYPE                                           `path:"state/protection-style-requested" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/protection-style-requested" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReoptimizeTimer          *uint16                                                               `path:"state/reoptimize-timer" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/reoptimize-timer" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Role                     E_MplsTypes_LSP_ROLE                                                  `path:"state/role" module:"openconfig-network-instance/openconfig-network-instance"`
	SetupPriority            *uint8                                                                `path:"state/setup-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/setup-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ShortcutEligible         *bool                                                                 `path:"state/shortcut-eligible" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/shortcut-eligible" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SignalingProtocol        E_MplsTypes_PATH_SETUP_PROTOCOL                                       `path:"state/signaling-protocol" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/signaling-protocol" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SoftPreemption           *bool                                                                 `path:"state/soft-preemption" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/soft-preemption" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Source                   *string                                                               `path:"state/source" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Type                     E_MplsTypes_TUNNEL_TYPE                                               `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) IsYANGGoStruct() {}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t.Bandwidth != nil {
		return t.Bandwidth
	}
	t.Bandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	return t.Bandwidth
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	return t.Counters
}

// GetOrCreateP2PTunnelAttributes retrieves the value of the P2PTunnelAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	t.P2PTunnelAttributes = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	return t.P2PTunnelAttributes
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t != nil && t.Bandwidth != nil {
		return t.Bandwidth
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetP2PTunnelAttributes returns the value of the P2PTunnelAttributes struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field P2PTunnelAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t != nil && t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAdminStatus() E_MplsTypes_TUNNEL_ADMIN_STATUS {
	if t == nil || t.AdminStatus == 0 {
		return MplsTypes_TUNNEL_ADMIN_STATUS_ADMIN_UP
	}
	return t.AdminStatus
}

// GetAutoGenerated retrieves the value of the leaf AutoGenerated from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoGenerated is set, it can
// safely use t.GetAutoGenerated() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoGenerated == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAutoGenerated() bool {
	if t == nil || t.AutoGenerated == nil {
		return false
	}
	return *t.AutoGenerated
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetric() int32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetMetricType retrieves the value of the leaf MetricType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricType is set, it can
// safely use t.GetMetricType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetricType() E_MplsTypes_LSP_METRIC_TYPE {
	if t == nil || t.MetricType == 0 {
		return MplsTypes_LSP_METRIC_TYPE_LSP_METRIC_INHERITED
	}
	return t.MetricType
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOperStatus() E_MplsTypes_LSP_OPER_STATUS {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetProtectionStyleRequested retrieves the value of the leaf ProtectionStyleRequested from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionStyleRequested is set, it can
// safely use t.GetProtectionStyleRequested() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionStyleRequested == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetProtectionStyleRequested() E_MplsTypes_PROTECTION_TYPE {
	if t == nil || t.ProtectionStyleRequested == 0 {
		return MplsTypes_PROTECTION_TYPE_UNPROTECTED
	}
	return t.ProtectionStyleRequested
}

// GetReoptimizeTimer retrieves the value of the leaf ReoptimizeTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReoptimizeTimer is set, it can
// safely use t.GetReoptimizeTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReoptimizeTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetReoptimizeTimer() uint16 {
	if t == nil || t.ReoptimizeTimer == nil {
		return 0
	}
	return *t.ReoptimizeTimer
}

// GetRole retrieves the value of the leaf Role from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Role is set, it can
// safely use t.GetRole() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Role == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetRole() E_MplsTypes_LSP_ROLE {
	if t == nil || t.Role == 0 {
		return 0
	}
	return t.Role
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetShortcutEligible retrieves the value of the leaf ShortcutEligible from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ShortcutEligible is set, it can
// safely use t.GetShortcutEligible() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ShortcutEligible == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetShortcutEligible() bool {
	if t == nil || t.ShortcutEligible == nil {
		return true
	}
	return *t.ShortcutEligible
}

// GetSignalingProtocol retrieves the value of the leaf SignalingProtocol from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignalingProtocol is set, it can
// safely use t.GetSignalingProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignalingProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSignalingProtocol() E_MplsTypes_PATH_SETUP_PROTOCOL {
	if t == nil || t.SignalingProtocol == 0 {
		return 0
	}
	return t.SignalingProtocol
}

// GetSoftPreemption retrieves the value of the leaf SoftPreemption from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SoftPreemption is set, it can
// safely use t.GetSoftPreemption() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SoftPreemption == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSoftPreemption() bool {
	if t == nil || t.SoftPreemption == nil {
		return false
	}
	return *t.SoftPreemption
}

// GetSource retrieves the value of the leaf Source from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Source is set, it can
// safely use t.GetSource() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Source == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSource() string {
	if t == nil || t.Source == nil {
		return ""
	}
	return *t.Source
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetType() E_MplsTypes_TUNNEL_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminStatus == 0 {
		t.AdminStatus = MplsTypes_TUNNEL_ADMIN_STATUS_ADMIN_UP
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.MetricType == 0 {
		t.MetricType = MplsTypes_LSP_METRIC_TYPE_LSP_METRIC_INHERITED
	}
	if t.ProtectionStyleRequested == 0 {
		t.ProtectionStyleRequested = MplsTypes_PROTECTION_TYPE_UNPROTECTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	if t.ShortcutEligible == nil {
		var v bool = true
		t.ShortcutEligible = &v
	}
	if t.SoftPreemption == nil {
		var v bool = false
		t.SoftPreemption = &v
	}
	t.Bandwidth.PopulateDefaults()
	t.Counters.PopulateDefaults()
	t.P2PTunnelAttributes.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛBelongingModule() string {
	return "openconfig-network-instance"
}
