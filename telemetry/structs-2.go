/*
Package telemetry is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /usr/local/google/home/hines/go/pkg/mod/github.com/openconfig/ygot@v0.16.2/genutil/names.go
using the following YANG input files:
	- gnmi-collector-metadata.yang
	- public/release/models/acl/openconfig-acl.yang
	- public/release/models/acl/openconfig-packet-match.yang
	- public/release/models/aft/openconfig-aft.yang
	- public/release/models/ate/openconfig-ate-flow.yang
	- public/release/models/ate/openconfig-ate-intf.yang
	- public/release/models/bfd/openconfig-bfd.yang
	- public/release/models/bgp/openconfig-bgp-policy.yang
	- public/release/models/bgp/openconfig-bgp-types.yang
	- public/release/models/interfaces/openconfig-if-aggregate.yang
	- public/release/models/interfaces/openconfig-if-ethernet.yang
	- public/release/models/interfaces/openconfig-if-ip-ext.yang
	- public/release/models/interfaces/openconfig-if-ip.yang
	- public/release/models/interfaces/openconfig-interfaces.yang
	- public/release/models/isis/openconfig-isis.yang
	- public/release/models/lacp/openconfig-lacp.yang
	- public/release/models/lldp/openconfig-lldp-types.yang
	- public/release/models/lldp/openconfig-lldp.yang
	- public/release/models/local-routing/openconfig-local-routing.yang
	- public/release/models/mpls/openconfig-mpls-types.yang
	- public/release/models/multicast/openconfig-pim.yang
	- public/release/models/network-instance/openconfig-network-instance.yang
	- public/release/models/openconfig-extensions.yang
	- public/release/models/optical-transport/openconfig-transport-types.yang
	- public/release/models/ospf/openconfig-ospfv2.yang
	- public/release/models/platform/openconfig-platform-cpu.yang
	- public/release/models/platform/openconfig-platform-integrated-circuit.yang
	- public/release/models/platform/openconfig-platform-software.yang
	- public/release/models/platform/openconfig-platform-transceiver.yang
	- public/release/models/platform/openconfig-platform.yang
	- public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
	- public/release/models/policy/openconfig-policy-types.yang
	- public/release/models/qos/openconfig-qos-elements.yang
	- public/release/models/qos/openconfig-qos-interfaces.yang
	- public/release/models/qos/openconfig-qos-types.yang
	- public/release/models/qos/openconfig-qos.yang
	- public/release/models/rib/openconfig-rib-bgp.yang
	- public/release/models/segment-routing/openconfig-segment-routing-types.yang
	- public/release/models/system/openconfig-system.yang
	- public/release/models/types/openconfig-inet-types.yang
	- public/release/models/types/openconfig-types.yang
	- public/release/models/types/openconfig-yang-types.yang
	- public/release/models/vlan/openconfig-vlan.yang
	- public/third_party/ietf/iana-if-type.yang
	- public/third_party/ietf/ietf-inet-types.yang
	- public/third_party/ietf/ietf-interfaces.yang
	- public/third_party/ietf/ietf-yang-types.yang
Imported modules were sourced from:
	- public/release/models/...
	- public/third_party/ietf/...
*/
package telemetry

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups struct {
	ExcludeGroup    []string `path:"state/exclude-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/exclude-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAllGroup []string `path:"state/include-all-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-all-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAnyGroup []string `path:"state/include-any-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-any-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) IsYANGGoStruct() {
}

// GetExcludeGroup retrieves the value of the leaf ExcludeGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeGroup is set, it can
// safely use t.GetExcludeGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetExcludeGroup() []string {
	if t == nil || t.ExcludeGroup == nil {
		return nil
	}
	return t.ExcludeGroup
}

// GetIncludeAllGroup retrieves the value of the leaf IncludeAllGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAllGroup is set, it can
// safely use t.GetIncludeAllGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAllGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetIncludeAllGroup() []string {
	if t == nil || t.IncludeAllGroup == nil {
		return nil
	}
	return t.IncludeAllGroup
}

// GetIncludeAnyGroup retrieves the value of the leaf IncludeAnyGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAnyGroup is set, it can
// safely use t.GetIncludeAnyGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAnyGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetIncludeAnyGroup() []string {
	if t == nil || t.IncludeAnyGroup == nil {
		return nil
	}
	return t.IncludeAnyGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct {
	Active        *bool   `path:"state/active" module:"openconfig-network-instance/openconfig-network-instance"`
	Priority      *uint16 `path:"state/priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SecondaryPath *string `path:"state/secondary-path|secondary-path" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/secondary-path|secondary-path" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) IsYANGGoStruct() {
}

// GetActive retrieves the value of the leaf Active from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Active is set, it can
// safely use t.GetActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Active == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetActive() bool {
	if t == nil || t.Active == nil {
		return false
	}
	return *t.Active
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetPriority() uint16 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// GetSecondaryPath retrieves the value of the leaf SecondaryPath from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecondaryPath is set, it can
// safely use t.GetSecondaryPath() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecondaryPath == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetSecondaryPath() string {
	if t == nil || t.SecondaryPath == nil {
		return ""
	}
	return *t.SecondaryPath
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SecondaryPath == nil {
		return nil, fmt.Errorf("nil value for key SecondaryPath")
	}

	return map[string]interface{}{
		"secondary-path": *t.SecondaryPath,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct {
	MetricUpperBound *uint64                      `path:"state/metric-upper-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric-upper-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Type             E_MplsTypes_PATH_METRIC_TYPE `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/type|type" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) IsYANGGoStruct() {
}

// GetMetricUpperBound retrieves the value of the leaf MetricUpperBound from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricUpperBound is set, it can
// safely use t.GetMetricUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricUpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) GetMetricUpperBound() uint64 {
	if t == nil || t.MetricUpperBound == nil {
		return 0
	}
	return *t.MetricUpperBound
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) GetType() E_MplsTypes_PATH_METRIC_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MetricUpperBound == nil {
		var v uint64 = 0
		t.MetricUpperBound = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct {
	AdminGroups               *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups                                                `path:"admin-groups" module:"openconfig-network-instance"`
	AssociatedRsvpSessions    []uint64                                                                                                                                          `path:"state/associated-rsvp-sessions" module:"openconfig-network-instance/openconfig-network-instance"`
	CspfMetric                *uint64                                                                                                                                           `path:"state/cspf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	CspfTiebreaker            E_Mpls_CspfTieBreaking                                                                                                                            `path:"state/cspf-tiebreaker" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/cspf-tiebreaker" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ExplicitPathName          *string                                                                                                                                           `path:"state/explicit-path-name" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/explicit-path-name" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HoldPriority              *uint8                                                                                                                                            `path:"state/hold-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hold-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Name                      *string                                                                                                                                           `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	PathComputationMethod     E_MplsTypes_PATH_COMPUTATION_METHOD                                                                                                               `path:"state/path-computation-method" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-computation-method" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathComputationServer     *string                                                                                                                                           `path:"state/path-computation-server" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-computation-server" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathMetricBoundConstraint map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint `path:"path-metric-bound-constraints/path-metric-bound-constraint" module:"openconfig-network-instance/openconfig-network-instance"`
	Preference                *uint8                                                                                                                                            `path:"state/preference" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/preference" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RetryTimer                *uint16                                                                                                                                           `path:"state/retry-timer" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/retry-timer" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SetupPriority             *uint8                                                                                                                                            `path:"state/setup-priority" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/setup-priority" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SpfMetric                 *uint64                                                                                                                                           `path:"state/spf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	UseCspf                   *bool                                                                                                                                             `path:"state/use-cspf" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/use-cspf" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) IsYANGGoStruct() {
}

// NewPathMetricBoundConstraint creates a new entry in the PathMetricBoundConstraint list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) NewPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathMetricBoundConstraint", key)
	}

	t.PathMetricBoundConstraint[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
		Type: Type,
	}

	return t.PathMetricBoundConstraint[key], nil
}

// RenamePathMetricBoundConstraint renames an entry in the list PathMetricBoundConstraint within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) RenamePathMetricBoundConstraint(oldK, newK E_MplsTypes_PATH_METRIC_TYPE) error {
	if _, ok := t.PathMetricBoundConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in PathMetricBoundConstraint", newK)
	}

	e, ok := t.PathMetricBoundConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathMetricBoundConstraint", oldK)
	}
	e.Type = newK

	t.PathMetricBoundConstraint[newK] = e
	delete(t.PathMetricBoundConstraint, oldK)
	return nil
}

// GetOrCreatePathMetricBoundConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreatePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {

	key := Type

	if v, ok := t.PathMetricBoundConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathMetricBoundConstraint(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathMetricBoundConstraint got unexpected error: %v", err))
	}
	return v
}

// GetPathMetricBoundConstraint retrieves the value with the specified key from
// the PathMetricBoundConstraint map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.PathMetricBoundConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeletePathMetricBoundConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) DeletePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) {
	key := Type

	delete(t.PathMetricBoundConstraint, key)
}

// AppendPathMetricBoundConstraint appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct to the
// list PathMetricBoundConstraint of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) AppendPathMetricBoundConstraint(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
	}

	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list PathMetricBoundConstraint %v", key)
	}

	t.PathMetricBoundConstraint[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	return t.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// GetAssociatedRsvpSessions retrieves the value of the leaf AssociatedRsvpSessions from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedRsvpSessions is set, it can
// safely use t.GetAssociatedRsvpSessions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedRsvpSessions == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAssociatedRsvpSessions() []uint64 {
	if t == nil || t.AssociatedRsvpSessions == nil {
		return nil
	}
	return t.AssociatedRsvpSessions
}

// GetCspfMetric retrieves the value of the leaf CspfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfMetric is set, it can
// safely use t.GetCspfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetCspfMetric() uint64 {
	if t == nil || t.CspfMetric == nil {
		return 0
	}
	return *t.CspfMetric
}

// GetCspfTiebreaker retrieves the value of the leaf CspfTiebreaker from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfTiebreaker is set, it can
// safely use t.GetCspfTiebreaker() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfTiebreaker == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetCspfTiebreaker() E_Mpls_CspfTieBreaking {
	if t == nil || t.CspfTiebreaker == 0 {
		return Mpls_CspfTieBreaking_RANDOM
	}
	return t.CspfTiebreaker
}

// GetExplicitPathName retrieves the value of the leaf ExplicitPathName from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExplicitPathName is set, it can
// safely use t.GetExplicitPathName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExplicitPathName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetExplicitPathName() string {
	if t == nil || t.ExplicitPathName == nil {
		return ""
	}
	return *t.ExplicitPathName
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPathComputationMethod retrieves the value of the leaf PathComputationMethod from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationMethod is set, it can
// safely use t.GetPathComputationMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationMethod == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathComputationMethod() E_MplsTypes_PATH_COMPUTATION_METHOD {
	if t == nil || t.PathComputationMethod == 0 {
		return MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	return t.PathComputationMethod
}

// GetPathComputationServer retrieves the value of the leaf PathComputationServer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationServer is set, it can
// safely use t.GetPathComputationServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationServer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathComputationServer() string {
	if t == nil || t.PathComputationServer == nil {
		return ""
	}
	return *t.PathComputationServer
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetRetryTimer retrieves the value of the leaf RetryTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RetryTimer is set, it can
// safely use t.GetRetryTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RetryTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetRetryTimer() uint16 {
	if t == nil || t.RetryTimer == nil {
		return 0
	}
	return *t.RetryTimer
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetSpfMetric retrieves the value of the leaf SpfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfMetric is set, it can
// safely use t.GetSpfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetSpfMetric() uint64 {
	if t == nil || t.SpfMetric == nil {
		return 0
	}
	return *t.SpfMetric
}

// GetUseCspf retrieves the value of the leaf UseCspf from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseCspf is set, it can
// safely use t.GetUseCspf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseCspf == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetUseCspf() bool {
	if t == nil || t.UseCspf == nil {
		return false
	}
	return *t.UseCspf
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CspfTiebreaker == 0 {
		t.CspfTiebreaker = Mpls_CspfTieBreaking_RANDOM
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.PathComputationMethod == 0 {
		t.PathComputationMethod = MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	t.AdminGroups.PopulateDefaults()
	for _, e := range t.PathMetricBoundConstraint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups struct {
	ExcludeGroup    []string `path:"state/exclude-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/exclude-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAllGroup []string `path:"state/include-all-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-all-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	IncludeAnyGroup []string `path:"state/include-any-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/include-any-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) IsYANGGoStruct() {
}

// GetExcludeGroup retrieves the value of the leaf ExcludeGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeGroup is set, it can
// safely use t.GetExcludeGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetExcludeGroup() []string {
	if t == nil || t.ExcludeGroup == nil {
		return nil
	}
	return t.ExcludeGroup
}

// GetIncludeAllGroup retrieves the value of the leaf IncludeAllGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAllGroup is set, it can
// safely use t.GetIncludeAllGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAllGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetIncludeAllGroup() []string {
	if t == nil || t.IncludeAllGroup == nil {
		return nil
	}
	return t.IncludeAllGroup
}

// GetIncludeAnyGroup retrieves the value of the leaf IncludeAnyGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAnyGroup is set, it can
// safely use t.GetIncludeAnyGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAnyGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetIncludeAnyGroup() []string {
	if t == nil || t.IncludeAnyGroup == nil {
		return nil
	}
	return t.IncludeAnyGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct {
	MetricUpperBound *uint64                      `path:"state/metric-upper-bound" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/metric-upper-bound" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Type             E_MplsTypes_PATH_METRIC_TYPE `path:"state/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/type|type" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) IsYANGGoStruct() {
}

// GetMetricUpperBound retrieves the value of the leaf MetricUpperBound from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricUpperBound is set, it can
// safely use t.GetMetricUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricUpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) GetMetricUpperBound() uint64 {
	if t == nil || t.MetricUpperBound == nil {
		return 0
	}
	return *t.MetricUpperBound
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) GetType() E_MplsTypes_PATH_METRIC_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MetricUpperBound == nil {
		var v uint64 = 0
		t.MetricUpperBound = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_StaticLsp represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp struct {
	Egress  *NetworkInstance_Mpls_Lsps_StaticLsp_Egress  `path:"egress" module:"openconfig-network-instance"`
	Ingress *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress `path:"ingress" module:"openconfig-network-instance"`
	Name    *string                                      `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Transit *NetworkInstance_Mpls_Lsps_StaticLsp_Transit `path:"transit" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp) IsYANGGoStruct() {}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t.Egress != nil {
		return t.Egress
	}
	t.Egress = &NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	return t.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t.Ingress != nil {
		return t.Ingress
	}
	t.Ingress = &NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	return t.Ingress
}

// GetOrCreateTransit retrieves the value of the Transit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t.Transit != nil {
		return t.Transit
	}
	t.Transit = &NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	return t.Transit
}

// GetEgress returns the value of the Egress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t != nil && t.Egress != nil {
		return t.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t != nil && t.Ingress != nil {
		return t.Ingress
	}
	return nil
}

// GetTransit returns the value of the Transit struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Transit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t != nil && t.Transit != nil {
		return t.Transit
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_StaticLsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Egress.PopulateDefaults()
	t.Ingress.PopulateDefaults()
	t.Transit.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Egress represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Egress struct {
	IncomingLabel NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union `path:"state/incoming-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/incoming-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *string                                                        `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/next-hop" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel     NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union     `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Egress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress) IsYANGGoStruct() {}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Egress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Ingress represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Ingress struct {
	IncomingLabel NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union `path:"state/incoming-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/incoming-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *string                                                         `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/next-hop" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel     NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union     `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Ingress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) IsYANGGoStruct() {}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Ingress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Transit represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Transit struct {
	IncomingLabel NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union `path:"state/incoming-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/incoming-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop       *string                                                         `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/next-hop" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PushLabel     NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union     `path:"state/push-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/push-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Transit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit) IsYANGGoStruct() {}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Transit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath struct {
	PathSetupProtocol *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol `path:"path-setup-protocol" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath) IsYANGGoStruct() {}

// GetOrCreatePathSetupProtocol retrieves the value of the PathSetupProtocol field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetOrCreatePathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	t.PathSetupProtocol = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	return t.PathSetupProtocol
}

// GetPathSetupProtocol returns the value of the PathSetupProtocol struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath. If the receiver or the field PathSetupProtocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetPathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t != nil && t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PathSetupProtocol.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol struct {
	Ldp *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp `path:"ldp" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) IsYANGGoStruct() {}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetOrCreateLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	return t.Ldp
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ldp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp struct {
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols struct {
	Ldp            *NetworkInstance_Mpls_SignalingProtocols_Ldp            `path:"ldp" module:"openconfig-network-instance"`
	RsvpTe         *NetworkInstance_Mpls_SignalingProtocols_RsvpTe         `path:"rsvp-te" module:"openconfig-network-instance"`
	SegmentRouting *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting `path:"segment-routing" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols) IsYANGGoStruct() {}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	return t.Ldp
}

// GetOrCreateRsvpTe retrieves the value of the RsvpTe field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t.RsvpTe != nil {
		return t.RsvpTe
	}
	t.RsvpTe = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	return t.RsvpTe
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	return t.SegmentRouting
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// GetRsvpTe returns the value of the RsvpTe struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field RsvpTe is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t != nil && t.RsvpTe != nil {
		return t.RsvpTe
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ldp.PopulateDefaults()
	t.RsvpTe.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp struct {
	Global              *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global                                                                `path:"global" module:"openconfig-network-instance"`
	InterfaceAttributes *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes                                                   `path:"interface-attributes" module:"openconfig-network-instance"`
	Neighbor            map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor `path:"neighbors/neighbor" module:"openconfig-network-instance/openconfig-network-instance"`
	Targeted            *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted                                                              `path:"targeted" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp) IsYANGGoStruct() {}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key represents the key for list Neighbor of element /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key struct {
	LsrId        string `path:"lsr-id"`
	LabelSpaceId uint16 `path:"label-space-id"`
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) NewNeighbor(LsrId string, LabelSpaceId uint16) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
		LsrId:        &LsrId,
		LabelSpaceId: &LabelSpaceId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) RenameNeighbor(oldK, newK NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.LsrId = &newK.LsrId
	e.LabelSpaceId = &newK.LabelSpaceId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(LsrId, LabelSpaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) DeleteNeighbor(LsrId string, LabelSpaceId uint16) {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct to the
// list Neighbor of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) AppendNeighbor(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) error {
	if v.LsrId == nil {
		return fmt.Errorf("invalid nil key for LsrId")
	}

	if v.LabelSpaceId == nil {
		return fmt.Errorf("invalid nil key for LabelSpaceId")
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        *v.LsrId,
		LabelSpaceId: *v.LabelSpaceId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	return t.Global
}

// GetOrCreateInterfaceAttributes retrieves the value of the InterfaceAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	t.InterfaceAttributes = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	return t.InterfaceAttributes
}

// GetOrCreateTargeted retrieves the value of the Targeted field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t.Targeted != nil {
		return t.Targeted
	}
	t.Targeted = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	return t.Targeted
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetInterfaceAttributes returns the value of the InterfaceAttributes struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field InterfaceAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t != nil && t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	return nil
}

// GetTargeted returns the value of the Targeted struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Targeted is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t != nil && t.Targeted != nil {
		return t.Targeted
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	t.InterfaceAttributes.PopulateDefaults()
	t.Targeted.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Global struct {
	Authentication  *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication  `path:"authentication" module:"openconfig-network-instance"`
	GracefulRestart *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart `path:"graceful-restart" module:"openconfig-network-instance"`
	LsrId           *string                                                             `path:"state/lsr-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/lsr-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	return t.Authentication
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetLsrId retrieves the value of the leaf LsrId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LsrId is set, it can
// safely use t.GetLsrId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LsrId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetLsrId() string {
	if t == nil || t.LsrId == nil {
		return ""
	}
	return *t.LsrId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Authentication.PopulateDefaults()
	t.GracefulRestart.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication struct {
	AuthenticationKey *string `path:"state/authentication-key" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/authentication-key" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable            *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) IsYANGGoStruct() {}

// GetAuthenticationKey retrieves the value of the leaf AuthenticationKey from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationKey is set, it can
// safely use t.GetAuthenticationKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationKey == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) GetAuthenticationKey() string {
	if t == nil || t.AuthenticationKey == nil {
		return ""
	}
	return *t.AuthenticationKey
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart struct {
	Enabled            *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ForwardingHoldtime *uint16 `path:"state/forwarding-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/forwarding-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelperEnable       *bool   `path:"state/helper-enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/helper-enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReconnectTime      *uint16 `path:"state/reconnect-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/reconnect-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RecoveryTime       *uint16 `path:"state/recovery-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/recovery-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetForwardingHoldtime retrieves the value of the leaf ForwardingHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingHoldtime is set, it can
// safely use t.GetForwardingHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetForwardingHoldtime() uint16 {
	if t == nil || t.ForwardingHoldtime == nil {
		return 0
	}
	return *t.ForwardingHoldtime
}

// GetHelperEnable retrieves the value of the leaf HelperEnable from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelperEnable is set, it can
// safely use t.GetHelperEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelperEnable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetHelperEnable() bool {
	if t == nil || t.HelperEnable == nil {
		return false
	}
	return *t.HelperEnable
}

// GetReconnectTime retrieves the value of the leaf ReconnectTime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReconnectTime is set, it can
// safely use t.GetReconnectTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReconnectTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetReconnectTime() uint16 {
	if t == nil || t.ReconnectTime == nil {
		return 0
	}
	return *t.ReconnectTime
}

// GetRecoveryTime retrieves the value of the leaf RecoveryTime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RecoveryTime is set, it can
// safely use t.GetRecoveryTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RecoveryTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) GetRecoveryTime() uint16 {
	if t == nil || t.RecoveryTime == nil {
		return 0
	}
	return *t.RecoveryTime
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct {
	HelloHoldtime *uint16                                                                               `path:"state/hello-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloInterval *uint16                                                                               `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Interface     map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetHelloHoldtime retrieves the value of the leaf HelloHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloHoldtime is set, it can
// safely use t.GetHelloHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetHelloHoldtime() uint16 {
	if t == nil || t.HelloHoldtime == nil {
		return 0
	}
	return *t.HelloHoldtime
}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 0
	}
	return *t.HelloInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct {
	AddressFamily map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily `path:"address-families/address-family" module:"openconfig-network-instance/openconfig-network-instance"`
	Counters      *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters                               `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	HelloHoldtime *uint16                                                                                                           `path:"state/hello-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloInterval *uint16                                                                                                           `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	InterfaceId   *string                                                                                                           `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef  *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef                           `path:"interface-ref" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) IsYANGGoStruct() {}

// NewAddressFamily creates a new entry in the AddressFamily list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) NewAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AddressFamily[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AddressFamily", key)
	}

	t.AddressFamily[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
		AfiName: AfiName,
	}

	return t.AddressFamily[key], nil
}

// RenameAddressFamily renames an entry in the list AddressFamily within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) RenameAddressFamily(oldK, newK E_MplsLdp_MplsLdpAfi) error {
	if _, ok := t.AddressFamily[newK]; ok {
		return fmt.Errorf("key %v already exists in AddressFamily", newK)
	}

	e, ok := t.AddressFamily[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AddressFamily", oldK)
	}
	e.AfiName = newK

	t.AddressFamily[newK] = e
	delete(t.AddressFamily, oldK)
	return nil
}

// GetOrCreateAddressFamily retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {

	key := AfiName

	if v, ok := t.AddressFamily[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddressFamily(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddressFamily got unexpected error: %v", err))
	}
	return v
}

// GetAddressFamily retrieves the value with the specified key from
// the AddressFamily map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.AddressFamily[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddressFamily deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) DeleteAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) {
	key := AfiName

	delete(t.AddressFamily, key)
}

// AppendAddressFamily appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct to the
// list AddressFamily of NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) AppendAddressFamily(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
	}

	if _, ok := t.AddressFamily[key]; ok {
		return fmt.Errorf("duplicate key for list AddressFamily %v", key)
	}

	t.AddressFamily[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetHelloHoldtime retrieves the value of the leaf HelloHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloHoldtime is set, it can
// safely use t.GetHelloHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetHelloHoldtime() uint16 {
	if t == nil || t.HelloHoldtime == nil {
		return 0
	}
	return *t.HelloHoldtime
}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 0
	}
	return *t.HelloInterval
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
	for _, e := range t.AddressFamily {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct {
	AfiName E_MplsLdp_MplsLdpAfi `path:"state/afi-name|afi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-name|afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Enabled *bool                `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) IsYANGGoStruct() {
}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) GetAfiName() E_MplsLdp_MplsLdpAfi {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters struct {
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct {
	Authentication *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication                                                                             `path:"authentication" module:"openconfig-network-instance"`
	HelloAdjacency map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency `path:"hello-adjacencies/hello-adjacency" module:"openconfig-network-instance/openconfig-network-instance"`
	LabelSpaceId   *uint16                                                                                                                                          `path:"state/label-space-id|label-space-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/label-space-id|label-space-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	LsrId          *string                                                                                                                                          `path:"state/lsr-id|lsr-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/lsr-id|lsr-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	SessionState   E_MplsLdp_Neighbor_SessionState                                                                                                                  `path:"state/session-state" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) IsYANGGoStruct() {}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key represents the key for list HelloAdjacency of element /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key struct {
	RemoteAddress string `path:"remote-address"`
	LocalAddress  string `path:"local-address"`
}

// NewHelloAdjacency creates a new entry in the HelloAdjacency list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) NewHelloAdjacency(RemoteAddress string, LocalAddress string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HelloAdjacency == nil {
		t.HelloAdjacency = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HelloAdjacency[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HelloAdjacency", key)
	}

	t.HelloAdjacency[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
		RemoteAddress: &RemoteAddress,
		LocalAddress:  &LocalAddress,
	}

	return t.HelloAdjacency[key], nil
}

// RenameHelloAdjacency renames an entry in the list HelloAdjacency within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) RenameHelloAdjacency(oldK, newK NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key) error {
	if _, ok := t.HelloAdjacency[newK]; ok {
		return fmt.Errorf("key %v already exists in HelloAdjacency", newK)
	}

	e, ok := t.HelloAdjacency[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HelloAdjacency", oldK)
	}
	e.RemoteAddress = &newK.RemoteAddress
	e.LocalAddress = &newK.LocalAddress

	t.HelloAdjacency[newK] = e
	delete(t.HelloAdjacency, oldK)
	return nil
}

// GetOrCreateHelloAdjacency retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetOrCreateHelloAdjacency(RemoteAddress string, LocalAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	if v, ok := t.HelloAdjacency[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHelloAdjacency(RemoteAddress, LocalAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHelloAdjacency got unexpected error: %v", err))
	}
	return v
}

// GetHelloAdjacency retrieves the value with the specified key from
// the HelloAdjacency map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetHelloAdjacency(RemoteAddress string, LocalAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	if lm, ok := t.HelloAdjacency[key]; ok {
		return lm
	}
	return nil
}

// DeleteHelloAdjacency deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) DeleteHelloAdjacency(RemoteAddress string, LocalAddress string) {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: RemoteAddress,
		LocalAddress:  LocalAddress,
	}

	delete(t.HelloAdjacency, key)
}

// AppendHelloAdjacency appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency struct to the
// list HelloAdjacency of NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) AppendHelloAdjacency(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) error {
	if v.RemoteAddress == nil {
		return fmt.Errorf("invalid nil key for RemoteAddress")
	}

	if v.LocalAddress == nil {
		return fmt.Errorf("invalid nil key for LocalAddress")
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key{
		RemoteAddress: *v.RemoteAddress,
		LocalAddress:  *v.LocalAddress,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HelloAdjacency == nil {
		t.HelloAdjacency = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
	}

	if _, ok := t.HelloAdjacency[key]; ok {
		return fmt.Errorf("duplicate key for list HelloAdjacency %v", key)
	}

	t.HelloAdjacency[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	return t.Authentication
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetLabelSpaceId retrieves the value of the leaf LabelSpaceId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelSpaceId is set, it can
// safely use t.GetLabelSpaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelSpaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetLabelSpaceId() uint16 {
	if t == nil || t.LabelSpaceId == nil {
		return 0
	}
	return *t.LabelSpaceId
}

// GetLsrId retrieves the value of the leaf LsrId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LsrId is set, it can
// safely use t.GetLsrId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LsrId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetLsrId() string {
	if t == nil || t.LsrId == nil {
		return ""
	}
	return *t.LsrId
}

// GetSessionState retrieves the value of the leaf SessionState from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionState is set, it can
// safely use t.GetSessionState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) GetSessionState() E_MplsLdp_Neighbor_SessionState {
	if t == nil || t.SessionState == 0 {
		return 0
	}
	return t.SessionState
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Authentication.PopulateDefaults()
	for _, e := range t.HelloAdjacency {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LabelSpaceId == nil {
		return nil, fmt.Errorf("nil value for key LabelSpaceId")
	}

	if t.LsrId == nil {
		return nil, fmt.Errorf("nil value for key LsrId")
	}

	return map[string]interface{}{
		"label-space-id": *t.LabelSpaceId,
		"lsr-id":         *t.LsrId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication struct {
	AuthenticationKey *string `path:"state/authentication-key" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/authentication-key" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable            *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) IsYANGGoStruct() {}

// GetAuthenticationKey retrieves the value of the leaf AuthenticationKey from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationKey is set, it can
// safely use t.GetAuthenticationKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationKey == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) GetAuthenticationKey() string {
	if t == nil || t.AuthenticationKey == nil {
		return ""
	}
	return *t.AuthenticationKey
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency struct {
	AdjacencyType E_MplsLdp_MplsLdpAdjacencyType                                                     `path:"state/adjacency-type" module:"openconfig-network-instance/openconfig-network-instance"`
	HelloDropped  *uint64                                                                            `path:"state/hello-dropped" module:"openconfig-network-instance/openconfig-network-instance"`
	HelloHoldtime *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime `path:"hello-holdtime" module:"openconfig-network-instance"`
	HelloReceived *uint64                                                                            `path:"state/hello-received" module:"openconfig-network-instance/openconfig-network-instance"`
	InterfaceRef  *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef  `path:"interface-ref" module:"openconfig-network-instance"`
	LastClear     *uint64                                                                            `path:"state/last-clear" module:"openconfig-network-instance/openconfig-network-instance"`
	LocalAddress  *string                                                                            `path:"state/local-address|local-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"local-address" shadow-module:"openconfig-network-instance"`
	RemoteAddress *string                                                                            `path:"state/remote-address|remote-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"remote-address" shadow-module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) IsYANGGoStruct() {}

// GetOrCreateHelloHoldtime retrieves the value of the HelloHoldtime field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetOrCreateHelloHoldtime() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	if t.HelloHoldtime != nil {
		return t.HelloHoldtime
	}
	t.HelloHoldtime = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	return t.HelloHoldtime
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	return t.InterfaceRef
}

// GetHelloHoldtime returns the value of the HelloHoldtime struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency. If the receiver or the field HelloHoldtime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetHelloHoldtime() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	if t != nil && t.HelloHoldtime != nil {
		return t.HelloHoldtime
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetAdjacencyType retrieves the value of the leaf AdjacencyType from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjacencyType is set, it can
// safely use t.GetAdjacencyType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjacencyType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetAdjacencyType() E_MplsLdp_MplsLdpAdjacencyType {
	if t == nil || t.AdjacencyType == 0 {
		return 0
	}
	return t.AdjacencyType
}

// GetHelloDropped retrieves the value of the leaf HelloDropped from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloDropped is set, it can
// safely use t.GetHelloDropped() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloDropped == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetHelloDropped() uint64 {
	if t == nil || t.HelloDropped == nil {
		return 0
	}
	return *t.HelloDropped
}

// GetHelloReceived retrieves the value of the leaf HelloReceived from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloReceived is set, it can
// safely use t.GetHelloReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloReceived == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetHelloReceived() uint64 {
	if t == nil || t.HelloReceived == nil {
		return 0
	}
	return *t.HelloReceived
}

// GetLastClear retrieves the value of the leaf LastClear from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetLastClear() uint64 {
	if t == nil || t.LastClear == nil {
		return 0
	}
	return *t.LastClear
}

// GetLocalAddress retrieves the value of the leaf LocalAddress from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalAddress is set, it can
// safely use t.GetLocalAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetLocalAddress() string {
	if t == nil || t.LocalAddress == nil {
		return ""
	}
	return *t.LocalAddress
}

// GetRemoteAddress retrieves the value of the leaf RemoteAddress from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteAddress is set, it can
// safely use t.GetRemoteAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) GetRemoteAddress() string {
	if t == nil || t.RemoteAddress == nil {
		return ""
	}
	return *t.RemoteAddress
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.HelloHoldtime.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalAddress == nil {
		return nil, fmt.Errorf("nil value for key LocalAddress")
	}

	if t.RemoteAddress == nil {
		return nil, fmt.Errorf("nil value for key RemoteAddress")
	}

	return map[string]interface{}{
		"local-address":  *t.LocalAddress,
		"remote-address": *t.RemoteAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime struct {
	Adjacent        *uint16 `path:"state/adjacent" module:"openconfig-network-instance/openconfig-network-instance"`
	HelloExpiration *uint64 `path:"state/hello-expiration" module:"openconfig-network-instance/openconfig-network-instance"`
	Negotiated      *uint16 `path:"state/negotiated" module:"openconfig-network-instance/openconfig-network-instance"`
	NextHello       *uint64 `path:"state/next-hello" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) IsYANGGoStruct() {
}

// GetAdjacent retrieves the value of the leaf Adjacent from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Adjacent is set, it can
// safely use t.GetAdjacent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Adjacent == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) GetAdjacent() uint16 {
	if t == nil || t.Adjacent == nil {
		return 0
	}
	return *t.Adjacent
}

// GetHelloExpiration retrieves the value of the leaf HelloExpiration from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloExpiration is set, it can
// safely use t.GetHelloExpiration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloExpiration == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) GetHelloExpiration() uint64 {
	if t == nil || t.HelloExpiration == nil {
		return 0
	}
	return *t.HelloExpiration
}

// GetNegotiated retrieves the value of the leaf Negotiated from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Negotiated is set, it can
// safely use t.GetNegotiated() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Negotiated == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) GetNegotiated() uint16 {
	if t == nil || t.Negotiated == nil {
		return 0
	}
	return *t.Negotiated
}

// GetNextHello retrieves the value of the leaf NextHello from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHello is set, it can
// safely use t.GetNextHello() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHello == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) GetNextHello() uint64 {
	if t == nil || t.NextHello == nil {
		return 0
	}
	return *t.NextHello
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted struct {
	AddressFamily map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily `path:"address-families/address-family" module:"openconfig-network-instance/openconfig-network-instance"`
	HelloAccept   *bool                                                                                        `path:"state/hello-accept" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-accept" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloHoldtime *uint16                                                                                      `path:"state/hello-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloInterval *uint16                                                                                      `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) IsYANGGoStruct() {}

// NewAddressFamily creates a new entry in the AddressFamily list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) NewAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)
	}

	key := AfiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AddressFamily[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AddressFamily", key)
	}

	t.AddressFamily[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
		AfiName: AfiName,
	}

	return t.AddressFamily[key], nil
}

// RenameAddressFamily renames an entry in the list AddressFamily within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) RenameAddressFamily(oldK, newK E_MplsLdp_MplsLdpAfi) error {
	if _, ok := t.AddressFamily[newK]; ok {
		return fmt.Errorf("key %v already exists in AddressFamily", newK)
	}

	e, ok := t.AddressFamily[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AddressFamily", oldK)
	}
	e.AfiName = newK

	t.AddressFamily[newK] = e
	delete(t.AddressFamily, oldK)
	return nil
}

// GetOrCreateAddressFamily retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) GetOrCreateAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {

	key := AfiName

	if v, ok := t.AddressFamily[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddressFamily(AfiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddressFamily got unexpected error: %v", err))
	}
	return v
}

// GetAddressFamily retrieves the value with the specified key from
// the AddressFamily map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) GetAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {

	if t == nil {
		return nil
	}

	key := AfiName

	if lm, ok := t.AddressFamily[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddressFamily deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) DeleteAddressFamily(AfiName E_MplsLdp_MplsLdpAfi) {
	key := AfiName

	delete(t.AddressFamily, key)
}

// AppendAddressFamily appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct to the
// list AddressFamily of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) AppendAddressFamily(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) error {
	key := v.AfiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AddressFamily == nil {
		t.AddressFamily = make(map[E_MplsLdp_MplsLdpAfi]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)
	}

	if _, ok := t.AddressFamily[key]; ok {
		return fmt.Errorf("duplicate key for list AddressFamily %v", key)
	}

	t.AddressFamily[key] = v
	return nil
}

// GetHelloAccept retrieves the value of the leaf HelloAccept from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloAccept is set, it can
// safely use t.GetHelloAccept() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloAccept == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) GetHelloAccept() bool {
	if t == nil || t.HelloAccept == nil {
		return false
	}
	return *t.HelloAccept
}

// GetHelloHoldtime retrieves the value of the leaf HelloHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloHoldtime is set, it can
// safely use t.GetHelloHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) GetHelloHoldtime() uint16 {
	if t == nil || t.HelloHoldtime == nil {
		return 0
	}
	return *t.HelloHoldtime
}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 0
	}
	return *t.HelloInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AddressFamily {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct {
	AfiName E_MplsLdp_MplsLdpAfi                                                                  `path:"state/afi-name|afi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-name|afi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Target  map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target `path:"targets/target" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) IsYANGGoStruct() {}

// NewTarget creates a new entry in the Target list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) NewTarget(RemoteAddress string) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)
	}

	key := RemoteAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Target[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Target", key)
	}

	t.Target[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
		RemoteAddress: &RemoteAddress,
	}

	return t.Target[key], nil
}

// RenameTarget renames an entry in the list Target within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) RenameTarget(oldK, newK string) error {
	if _, ok := t.Target[newK]; ok {
		return fmt.Errorf("key %v already exists in Target", newK)
	}

	e, ok := t.Target[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Target", oldK)
	}
	e.RemoteAddress = &newK

	t.Target[newK] = e
	delete(t.Target, oldK)
	return nil
}

// GetOrCreateTarget retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) GetOrCreateTarget(RemoteAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {

	key := RemoteAddress

	if v, ok := t.Target[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTarget(RemoteAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTarget got unexpected error: %v", err))
	}
	return v
}

// GetTarget retrieves the value with the specified key from
// the Target map field of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) GetTarget(RemoteAddress string) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {

	if t == nil {
		return nil
	}

	key := RemoteAddress

	if lm, ok := t.Target[key]; ok {
		return lm
	}
	return nil
}

// DeleteTarget deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) DeleteTarget(RemoteAddress string) {
	key := RemoteAddress

	delete(t.Target, key)
}

// AppendTarget appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target struct to the
// list Target of NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) AppendTarget(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) error {
	if v.RemoteAddress == nil {
		return fmt.Errorf("invalid nil key received for RemoteAddress")
	}

	key := *v.RemoteAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)
	}

	if _, ok := t.Target[key]; ok {
		return fmt.Errorf("duplicate key for list Target %v", key)
	}

	t.Target[key] = v
	return nil
}

// GetAfiName retrieves the value of the leaf AfiName from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiName is set, it can
// safely use t.GetAfiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) GetAfiName() E_MplsLdp_MplsLdpAfi {
	if t == nil || t.AfiName == 0 {
		return 0
	}
	return t.AfiName
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Target {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-name": t.AfiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target struct {
	Enabled       *bool   `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloHoldtime *uint16 `path:"state/hello-holdtime" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-holdtime" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HelloInterval *uint16 `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LocalAddress  *string `path:"state/local-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/local-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RemoteAddress *string `path:"state/remote-address|remote-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/remote-address|remote-address" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetHelloHoldtime retrieves the value of the leaf HelloHoldtime from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloHoldtime is set, it can
// safely use t.GetHelloHoldtime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloHoldtime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) GetHelloHoldtime() uint16 {
	if t == nil || t.HelloHoldtime == nil {
		return 0
	}
	return *t.HelloHoldtime
}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 0
	}
	return *t.HelloInterval
}

// GetLocalAddress retrieves the value of the leaf LocalAddress from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalAddress is set, it can
// safely use t.GetLocalAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) GetLocalAddress() string {
	if t == nil || t.LocalAddress == nil {
		return ""
	}
	return *t.LocalAddress
}

// GetRemoteAddress retrieves the value of the leaf RemoteAddress from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteAddress is set, it can
// safely use t.GetRemoteAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) GetRemoteAddress() string {
	if t == nil || t.RemoteAddress == nil {
		return ""
	}
	return *t.RemoteAddress
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RemoteAddress == nil {
		return nil, fmt.Errorf("nil value for key RemoteAddress")
	}

	return map[string]interface{}{
		"remote-address": *t.RemoteAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct {
	Global    *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global               `path:"global" module:"openconfig-network-instance"`
	Interface map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface `path:"interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	Neighbor  map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor  `path:"neighbors/neighbor" module:"openconfig-network-instance/openconfig-network-instance"`
	Session   map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session   `path:"sessions/session" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewNeighbor(Address string) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
		Address: &Address,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Address = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateNeighbor(Address string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {

	key := Address

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetNeighbor(Address string) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) DeleteNeighbor(Address string) {
	key := Address

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor struct to the
// list Neighbor of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendNeighbor(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key received for Address")
	}

	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewSession creates a new entry in the Session list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) NewSession(LocalIndex uint64) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
	}

	key := LocalIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
		LocalIndex: &LocalIndex,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) RenameSession(oldK, newK uint64) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.LocalIndex = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateSession(LocalIndex uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {

	key := LocalIndex

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(LocalIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetSession(LocalIndex uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {

	if t == nil {
		return nil
	}

	key := LocalIndex

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// DeleteSession deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) DeleteSession(LocalIndex uint64) {
	key := LocalIndex

	delete(t.Session, key)
}

// AppendSession appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct to the
// list Session of NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) AppendSession(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) error {
	if v.LocalIndex == nil {
		return fmt.Errorf("invalid nil key received for LocalIndex")
	}

	key := *v.LocalIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetOrCreateGlobal() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	return t.Global
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) GetGlobal() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
	for _, e := range t.Session {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global struct {
	Counters        *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters        `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	GracefulRestart *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart `path:"graceful-restart" module:"openconfig-network-instance"`
	Hellos          *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos          `path:"hellos" module:"openconfig-network-instance"`
	SoftPreemption  *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption  `path:"soft-preemption" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	return t.Counters
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if t.Hellos != nil {
		return t.Hellos
	}
	t.Hellos = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	return t.Hellos
}

// GetOrCreateSoftPreemption retrieves the value of the SoftPreemption field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetOrCreateSoftPreemption() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if t.SoftPreemption != nil {
		return t.SoftPreemption
	}
	t.SoftPreemption = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	return t.SoftPreemption
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	if t != nil && t.Hellos != nil {
		return t.Hellos
	}
	return nil
}

// GetSoftPreemption returns the value of the SoftPreemption struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global. If the receiver or the field SoftPreemption is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) GetSoftPreemption() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	if t != nil && t.SoftPreemption != nil {
		return t.SoftPreemption
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	t.GracefulRestart.PopulateDefaults()
	t.Hellos.PopulateDefaults()
	t.SoftPreemption.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters struct {
	Errors                      *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors `path:"errors" module:"openconfig-network-instance"`
	InAckMessages               *uint64                                                                `path:"in-ack-messages" module:"openconfig-network-instance"`
	InHelloMessages             *uint64                                                                `path:"in-hello-messages" module:"openconfig-network-instance"`
	InPathErrorMessages         *uint64                                                                `path:"in-path-error-messages" module:"openconfig-network-instance"`
	InPathMessages              *uint64                                                                `path:"in-path-messages" module:"openconfig-network-instance"`
	InPathTearMessages          *uint64                                                                `path:"in-path-tear-messages" module:"openconfig-network-instance"`
	InReservationErrorMessages  *uint64                                                                `path:"in-reservation-error-messages" module:"openconfig-network-instance"`
	InReservationMessages       *uint64                                                                `path:"in-reservation-messages" module:"openconfig-network-instance"`
	InReservationTearMessages   *uint64                                                                `path:"in-reservation-tear-messages" module:"openconfig-network-instance"`
	InSrefreshMessages          *uint64                                                                `path:"in-srefresh-messages" module:"openconfig-network-instance"`
	OutAckMessages              *uint64                                                                `path:"out-ack-messages" module:"openconfig-network-instance"`
	OutHelloMessages            *uint64                                                                `path:"out-hello-messages" module:"openconfig-network-instance"`
	OutPathErrorMessages        *uint64                                                                `path:"out-path-error-messages" module:"openconfig-network-instance"`
	OutPathMessages             *uint64                                                                `path:"out-path-messages" module:"openconfig-network-instance"`
	OutPathTearMessages         *uint64                                                                `path:"out-path-tear-messages" module:"openconfig-network-instance"`
	OutReservationErrorMessages *uint64                                                                `path:"out-reservation-error-messages" module:"openconfig-network-instance"`
	OutReservationMessages      *uint64                                                                `path:"out-reservation-messages" module:"openconfig-network-instance"`
	OutReservationTearMessages  *uint64                                                                `path:"out-reservation-tear-messages" module:"openconfig-network-instance"`
	OutSrefreshMessages         *uint64                                                                `path:"out-srefresh-messages" module:"openconfig-network-instance"`
	PathTimeouts                *uint64                                                                `path:"path-timeouts" module:"openconfig-network-instance"`
	RateLimitedMessages         *uint64                                                                `path:"rate-limited-messages" module:"openconfig-network-instance"`
	ReservationTimeouts         *uint64                                                                `path:"reservation-timeouts" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) IsYANGGoStruct() {}

// GetOrCreateErrors retrieves the value of the Errors field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOrCreateErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	if t.Errors != nil {
		return t.Errors
	}
	t.Errors = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	return t.Errors
}

// GetErrors returns the value of the Errors struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters. If the receiver or the field Errors is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	if t != nil && t.Errors != nil {
		return t.Errors
	}
	return nil
}

// GetInAckMessages retrieves the value of the leaf InAckMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InAckMessages is set, it can
// safely use t.GetInAckMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InAckMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInAckMessages() uint64 {
	if t == nil || t.InAckMessages == nil {
		return 0
	}
	return *t.InAckMessages
}

// GetInHelloMessages retrieves the value of the leaf InHelloMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InHelloMessages is set, it can
// safely use t.GetInHelloMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InHelloMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInHelloMessages() uint64 {
	if t == nil || t.InHelloMessages == nil {
		return 0
	}
	return *t.InHelloMessages
}

// GetInPathErrorMessages retrieves the value of the leaf InPathErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPathErrorMessages is set, it can
// safely use t.GetInPathErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPathErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInPathErrorMessages() uint64 {
	if t == nil || t.InPathErrorMessages == nil {
		return 0
	}
	return *t.InPathErrorMessages
}

// GetInPathMessages retrieves the value of the leaf InPathMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPathMessages is set, it can
// safely use t.GetInPathMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPathMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInPathMessages() uint64 {
	if t == nil || t.InPathMessages == nil {
		return 0
	}
	return *t.InPathMessages
}

// GetInPathTearMessages retrieves the value of the leaf InPathTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPathTearMessages is set, it can
// safely use t.GetInPathTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPathTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInPathTearMessages() uint64 {
	if t == nil || t.InPathTearMessages == nil {
		return 0
	}
	return *t.InPathTearMessages
}

// GetInReservationErrorMessages retrieves the value of the leaf InReservationErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InReservationErrorMessages is set, it can
// safely use t.GetInReservationErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InReservationErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInReservationErrorMessages() uint64 {
	if t == nil || t.InReservationErrorMessages == nil {
		return 0
	}
	return *t.InReservationErrorMessages
}

// GetInReservationMessages retrieves the value of the leaf InReservationMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InReservationMessages is set, it can
// safely use t.GetInReservationMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InReservationMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInReservationMessages() uint64 {
	if t == nil || t.InReservationMessages == nil {
		return 0
	}
	return *t.InReservationMessages
}

// GetInReservationTearMessages retrieves the value of the leaf InReservationTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InReservationTearMessages is set, it can
// safely use t.GetInReservationTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InReservationTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInReservationTearMessages() uint64 {
	if t == nil || t.InReservationTearMessages == nil {
		return 0
	}
	return *t.InReservationTearMessages
}

// GetInSrefreshMessages retrieves the value of the leaf InSrefreshMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSrefreshMessages is set, it can
// safely use t.GetInSrefreshMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSrefreshMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetInSrefreshMessages() uint64 {
	if t == nil || t.InSrefreshMessages == nil {
		return 0
	}
	return *t.InSrefreshMessages
}

// GetOutAckMessages retrieves the value of the leaf OutAckMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutAckMessages is set, it can
// safely use t.GetOutAckMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutAckMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutAckMessages() uint64 {
	if t == nil || t.OutAckMessages == nil {
		return 0
	}
	return *t.OutAckMessages
}

// GetOutHelloMessages retrieves the value of the leaf OutHelloMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutHelloMessages is set, it can
// safely use t.GetOutHelloMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutHelloMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutHelloMessages() uint64 {
	if t == nil || t.OutHelloMessages == nil {
		return 0
	}
	return *t.OutHelloMessages
}

// GetOutPathErrorMessages retrieves the value of the leaf OutPathErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPathErrorMessages is set, it can
// safely use t.GetOutPathErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPathErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutPathErrorMessages() uint64 {
	if t == nil || t.OutPathErrorMessages == nil {
		return 0
	}
	return *t.OutPathErrorMessages
}

// GetOutPathMessages retrieves the value of the leaf OutPathMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPathMessages is set, it can
// safely use t.GetOutPathMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPathMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutPathMessages() uint64 {
	if t == nil || t.OutPathMessages == nil {
		return 0
	}
	return *t.OutPathMessages
}

// GetOutPathTearMessages retrieves the value of the leaf OutPathTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPathTearMessages is set, it can
// safely use t.GetOutPathTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPathTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutPathTearMessages() uint64 {
	if t == nil || t.OutPathTearMessages == nil {
		return 0
	}
	return *t.OutPathTearMessages
}

// GetOutReservationErrorMessages retrieves the value of the leaf OutReservationErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutReservationErrorMessages is set, it can
// safely use t.GetOutReservationErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutReservationErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutReservationErrorMessages() uint64 {
	if t == nil || t.OutReservationErrorMessages == nil {
		return 0
	}
	return *t.OutReservationErrorMessages
}

// GetOutReservationMessages retrieves the value of the leaf OutReservationMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutReservationMessages is set, it can
// safely use t.GetOutReservationMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutReservationMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutReservationMessages() uint64 {
	if t == nil || t.OutReservationMessages == nil {
		return 0
	}
	return *t.OutReservationMessages
}

// GetOutReservationTearMessages retrieves the value of the leaf OutReservationTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutReservationTearMessages is set, it can
// safely use t.GetOutReservationTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutReservationTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutReservationTearMessages() uint64 {
	if t == nil || t.OutReservationTearMessages == nil {
		return 0
	}
	return *t.OutReservationTearMessages
}

// GetOutSrefreshMessages retrieves the value of the leaf OutSrefreshMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutSrefreshMessages is set, it can
// safely use t.GetOutSrefreshMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutSrefreshMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetOutSrefreshMessages() uint64 {
	if t == nil || t.OutSrefreshMessages == nil {
		return 0
	}
	return *t.OutSrefreshMessages
}

// GetPathTimeouts retrieves the value of the leaf PathTimeouts from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathTimeouts is set, it can
// safely use t.GetPathTimeouts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathTimeouts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetPathTimeouts() uint64 {
	if t == nil || t.PathTimeouts == nil {
		return 0
	}
	return *t.PathTimeouts
}

// GetRateLimitedMessages retrieves the value of the leaf RateLimitedMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimitedMessages is set, it can
// safely use t.GetRateLimitedMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimitedMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetRateLimitedMessages() uint64 {
	if t == nil || t.RateLimitedMessages == nil {
		return 0
	}
	return *t.RateLimitedMessages
}

// GetReservationTimeouts retrieves the value of the leaf ReservationTimeouts from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReservationTimeouts is set, it can
// safely use t.GetReservationTimeouts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReservationTimeouts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) GetReservationTimeouts() uint64 {
	if t == nil || t.ReservationTimeouts == nil {
		return 0
	}
	return *t.ReservationTimeouts
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Errors.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors struct {
	AuthenticationFail *uint64 `path:"authentication-fail" module:"openconfig-network-instance"`
	BadChecksum        *uint64 `path:"bad-checksum" module:"openconfig-network-instance"`
	BadPacketFormat    *uint64 `path:"bad-packet-format" module:"openconfig-network-instance"`
	BadPacketLength    *uint64 `path:"bad-packet-length" module:"openconfig-network-instance"`
	OutOfOrder         *uint64 `path:"out-of-order" module:"openconfig-network-instance"`
	ReceivedNack       *uint64 `path:"received-nack" module:"openconfig-network-instance"`
	TransmitFailure    *uint64 `path:"transmit-failure" module:"openconfig-network-instance"`
	TransmitQueueFull  *uint64 `path:"transmit-queue-full" module:"openconfig-network-instance"`
	UnknownAck         *uint64 `path:"unknown-ack" module:"openconfig-network-instance"`
	UnknownNack        *uint64 `path:"unknown-nack" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) IsYANGGoStruct() {}

// GetAuthenticationFail retrieves the value of the leaf AuthenticationFail from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationFail is set, it can
// safely use t.GetAuthenticationFail() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationFail == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetAuthenticationFail() uint64 {
	if t == nil || t.AuthenticationFail == nil {
		return 0
	}
	return *t.AuthenticationFail
}

// GetBadChecksum retrieves the value of the leaf BadChecksum from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadChecksum is set, it can
// safely use t.GetBadChecksum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadChecksum == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetBadChecksum() uint64 {
	if t == nil || t.BadChecksum == nil {
		return 0
	}
	return *t.BadChecksum
}

// GetBadPacketFormat retrieves the value of the leaf BadPacketFormat from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadPacketFormat is set, it can
// safely use t.GetBadPacketFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadPacketFormat == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetBadPacketFormat() uint64 {
	if t == nil || t.BadPacketFormat == nil {
		return 0
	}
	return *t.BadPacketFormat
}

// GetBadPacketLength retrieves the value of the leaf BadPacketLength from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadPacketLength is set, it can
// safely use t.GetBadPacketLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadPacketLength == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetBadPacketLength() uint64 {
	if t == nil || t.BadPacketLength == nil {
		return 0
	}
	return *t.BadPacketLength
}

// GetOutOfOrder retrieves the value of the leaf OutOfOrder from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOfOrder is set, it can
// safely use t.GetOutOfOrder() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOfOrder == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetOutOfOrder() uint64 {
	if t == nil || t.OutOfOrder == nil {
		return 0
	}
	return *t.OutOfOrder
}

// GetReceivedNack retrieves the value of the leaf ReceivedNack from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReceivedNack is set, it can
// safely use t.GetReceivedNack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReceivedNack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetReceivedNack() uint64 {
	if t == nil || t.ReceivedNack == nil {
		return 0
	}
	return *t.ReceivedNack
}

// GetTransmitFailure retrieves the value of the leaf TransmitFailure from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitFailure is set, it can
// safely use t.GetTransmitFailure() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitFailure == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetTransmitFailure() uint64 {
	if t == nil || t.TransmitFailure == nil {
		return 0
	}
	return *t.TransmitFailure
}

// GetTransmitQueueFull retrieves the value of the leaf TransmitQueueFull from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitQueueFull is set, it can
// safely use t.GetTransmitQueueFull() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitQueueFull == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetTransmitQueueFull() uint64 {
	if t == nil || t.TransmitQueueFull == nil {
		return 0
	}
	return *t.TransmitQueueFull
}

// GetUnknownAck retrieves the value of the leaf UnknownAck from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnknownAck is set, it can
// safely use t.GetUnknownAck() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnknownAck == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetUnknownAck() uint64 {
	if t == nil || t.UnknownAck == nil {
		return 0
	}
	return *t.UnknownAck
}

// GetUnknownNack retrieves the value of the leaf UnknownNack from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnknownNack is set, it can
// safely use t.GetUnknownNack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnknownNack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) GetUnknownNack() uint64 {
	if t == nil || t.UnknownNack == nil {
		return 0
	}
	return *t.UnknownNack
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart struct {
	Enable       *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RecoveryTime *uint32 `path:"state/recovery-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/recovery-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RestartTime  *uint32 `path:"state/restart-time" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/restart-time" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) IsYANGGoStruct() {}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetRecoveryTime retrieves the value of the leaf RecoveryTime from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RecoveryTime is set, it can
// safely use t.GetRecoveryTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RecoveryTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) GetRecoveryTime() uint32 {
	if t == nil || t.RecoveryTime == nil {
		return 0
	}
	return *t.RecoveryTime
}

// GetRestartTime retrieves the value of the leaf RestartTime from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RestartTime is set, it can
// safely use t.GetRestartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RestartTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) GetRestartTime() uint32 {
	if t == nil || t.RestartTime == nil {
		return 0
	}
	return *t.RestartTime
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos struct {
	HelloInterval    *uint16 `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RefreshReduction *bool   `path:"state/refresh-reduction" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/refresh-reduction" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) IsYANGGoStruct() {}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 9000
	}
	return *t.HelloInterval
}

// GetRefreshReduction retrieves the value of the leaf RefreshReduction from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RefreshReduction is set, it can
// safely use t.GetRefreshReduction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RefreshReduction == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) GetRefreshReduction() bool {
	if t == nil || t.RefreshReduction == nil {
		return true
	}
	return *t.RefreshReduction
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.HelloInterval == nil {
		var v uint16 = 9000
		t.HelloInterval = &v
	}
	if t.RefreshReduction == nil {
		var v bool = true
		t.RefreshReduction = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption struct {
	Enable                *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SoftPreemptionTimeout *uint16 `path:"state/soft-preemption-timeout" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/soft-preemption-timeout" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) IsYANGGoStruct() {}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetSoftPreemptionTimeout retrieves the value of the leaf SoftPreemptionTimeout from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SoftPreemptionTimeout is set, it can
// safely use t.GetSoftPreemptionTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SoftPreemptionTimeout == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) GetSoftPreemptionTimeout() uint16 {
	if t == nil || t.SoftPreemptionTimeout == nil {
		return 30
	}
	return *t.SoftPreemptionTimeout
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
	if t.SoftPreemptionTimeout == nil {
		var v uint16 = 30
		t.SoftPreemptionTimeout = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct {
	Authentication       *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication                                                                                                        `path:"authentication" module:"openconfig-network-instance"`
	BandwidthReservation map[NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation `path:"bandwidth-reservations/bandwidth-reservation" module:"openconfig-network-instance/openconfig-network-instance"`
	Counters             *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters                                                                                                              `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	Hellos               *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos                                                                                                                `path:"hellos" module:"openconfig-network-instance"`
	InterfaceId          *string                                                                                                                                                                         `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef         *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef                                                                                                          `path:"interface-ref" module:"openconfig-network-instance"`
	MaxLinkBandwidth     *uint64                                                                                                                                                                         `path:"state/max-link-bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	Protection           *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection                                                                                                            `path:"protection" module:"openconfig-network-instance"`
	Subscription         *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription                                                                                                          `path:"subscription" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) IsYANGGoStruct() {}

// NewBandwidthReservation creates a new entry in the BandwidthReservation list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) NewBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	key := Priority

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BandwidthReservation[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BandwidthReservation", key)
	}

	t.BandwidthReservation[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
		Priority: Priority,
	}

	return t.BandwidthReservation[key], nil
}

// RenameBandwidthReservation renames an entry in the list BandwidthReservation within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) RenameBandwidthReservation(oldK, newK NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) error {
	if _, ok := t.BandwidthReservation[newK]; ok {
		return fmt.Errorf("key %v already exists in BandwidthReservation", newK)
	}

	e, ok := t.BandwidthReservation[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BandwidthReservation", oldK)
	}
	e.Priority = newK

	t.BandwidthReservation[newK] = e
	delete(t.BandwidthReservation, oldK)
	return nil
}

// GetOrCreateBandwidthReservation retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	key := Priority

	if v, ok := t.BandwidthReservation[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBandwidthReservation(Priority)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBandwidthReservation got unexpected error: %v", err))
	}
	return v
}

// GetBandwidthReservation retrieves the value with the specified key from
// the BandwidthReservation map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {

	if t == nil {
		return nil
	}

	key := Priority

	if lm, ok := t.BandwidthReservation[key]; ok {
		return lm
	}
	return nil
}

// DeleteBandwidthReservation deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) DeleteBandwidthReservation(Priority NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) {
	key := Priority

	delete(t.BandwidthReservation, key)
}

// AppendBandwidthReservation appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct to the
// list BandwidthReservation of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) AppendBandwidthReservation(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) error {
	key := v.Priority

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BandwidthReservation == nil {
		t.BandwidthReservation = make(map[NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
	}

	if _, ok := t.BandwidthReservation[key]; ok {
		return fmt.Errorf("duplicate key for list BandwidthReservation %v", key)
	}

	t.BandwidthReservation[key] = v
	return nil
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	return t.Authentication
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	return t.Counters
}

// GetOrCreateHellos retrieves the value of the Hellos field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if t.Hellos != nil {
		return t.Hellos
	}
	t.Hellos = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	return t.Hellos
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateProtection retrieves the value of the Protection field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateProtection() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if t.Protection != nil {
		return t.Protection
	}
	t.Protection = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	return t.Protection
}

// GetOrCreateSubscription retrieves the value of the Subscription field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetOrCreateSubscription() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if t.Subscription != nil {
		return t.Subscription
	}
	t.Subscription = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	return t.Subscription
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetCounters() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetHellos returns the value of the Hellos struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Hellos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetHellos() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	if t != nil && t.Hellos != nil {
		return t.Hellos
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetProtection returns the value of the Protection struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Protection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetProtection() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	if t != nil && t.Protection != nil {
		return t.Protection
	}
	return nil
}

// GetSubscription returns the value of the Subscription struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface. If the receiver or the field Subscription is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetSubscription() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	if t != nil && t.Subscription != nil {
		return t.Subscription
	}
	return nil
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetMaxLinkBandwidth retrieves the value of the leaf MaxLinkBandwidth from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxLinkBandwidth is set, it can
// safely use t.GetMaxLinkBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxLinkBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) GetMaxLinkBandwidth() uint64 {
	if t == nil || t.MaxLinkBandwidth == nil {
		return 0
	}
	return *t.MaxLinkBandwidth
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Authentication.PopulateDefaults()
	t.Counters.PopulateDefaults()
	t.Hellos.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
	t.Protection.PopulateDefaults()
	t.Subscription.PopulateDefaults()
	for _, e := range t.BandwidthReservation {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication struct {
	AuthenticationKey *string `path:"state/authentication-key" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/authentication-key" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enable            *bool   `path:"state/enable" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enable" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) IsYANGGoStruct() {}

// GetAuthenticationKey retrieves the value of the leaf AuthenticationKey from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationKey is set, it can
// safely use t.GetAuthenticationKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationKey == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) GetAuthenticationKey() string {
	if t == nil || t.AuthenticationKey == nil {
		return ""
	}
	return *t.AuthenticationKey
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct {
	ActiveReservationsCount *uint64                                                                                      `path:"state/active-reservations-count" module:"openconfig-network-instance/openconfig-network-instance"`
	AvailableBandwidth      *uint64                                                                                      `path:"state/available-bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	HighwaterMark           *uint64                                                                                      `path:"state/highwater-mark" module:"openconfig-network-instance/openconfig-network-instance"`
	Priority                NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union `path:"state/priority|priority" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"priority" shadow-module:"openconfig-network-instance"`
	ReservedBandwidth       *uint64                                                                                      `path:"state/reserved-bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) IsYANGGoStruct() {
}

// GetActiveReservationsCount retrieves the value of the leaf ActiveReservationsCount from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActiveReservationsCount is set, it can
// safely use t.GetActiveReservationsCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActiveReservationsCount == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) GetActiveReservationsCount() uint64 {
	if t == nil || t.ActiveReservationsCount == nil {
		return 0
	}
	return *t.ActiveReservationsCount
}

// GetAvailableBandwidth retrieves the value of the leaf AvailableBandwidth from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AvailableBandwidth is set, it can
// safely use t.GetAvailableBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AvailableBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) GetAvailableBandwidth() uint64 {
	if t == nil || t.AvailableBandwidth == nil {
		return 0
	}
	return *t.AvailableBandwidth
}

// GetHighwaterMark retrieves the value of the leaf HighwaterMark from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighwaterMark is set, it can
// safely use t.GetHighwaterMark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighwaterMark == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) GetHighwaterMark() uint64 {
	if t == nil || t.HighwaterMark == nil {
		return 0
	}
	return *t.HighwaterMark
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) GetPriority() NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	if t == nil || t.Priority == nil {
		return nil
	}
	return t.Priority
}

// GetReservedBandwidth retrieves the value of the leaf ReservedBandwidth from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReservedBandwidth is set, it can
// safely use t.GetReservedBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReservedBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) GetReservedBandwidth() uint64 {
	if t == nil || t.ReservedBandwidth == nil {
		return 0
	}
	return *t.ReservedBandwidth
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"priority": t.Priority,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters struct {
	Errors                      *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors `path:"errors" module:"openconfig-network-instance"`
	InAckMessages               *uint64                                                                   `path:"in-ack-messages" module:"openconfig-network-instance"`
	InHelloMessages             *uint64                                                                   `path:"in-hello-messages" module:"openconfig-network-instance"`
	InPathErrorMessages         *uint64                                                                   `path:"in-path-error-messages" module:"openconfig-network-instance"`
	InPathMessages              *uint64                                                                   `path:"in-path-messages" module:"openconfig-network-instance"`
	InPathTearMessages          *uint64                                                                   `path:"in-path-tear-messages" module:"openconfig-network-instance"`
	InReservationErrorMessages  *uint64                                                                   `path:"in-reservation-error-messages" module:"openconfig-network-instance"`
	InReservationMessages       *uint64                                                                   `path:"in-reservation-messages" module:"openconfig-network-instance"`
	InReservationTearMessages   *uint64                                                                   `path:"in-reservation-tear-messages" module:"openconfig-network-instance"`
	InSrefreshMessages          *uint64                                                                   `path:"in-srefresh-messages" module:"openconfig-network-instance"`
	OutAckMessages              *uint64                                                                   `path:"out-ack-messages" module:"openconfig-network-instance"`
	OutHelloMessages            *uint64                                                                   `path:"out-hello-messages" module:"openconfig-network-instance"`
	OutPathErrorMessages        *uint64                                                                   `path:"out-path-error-messages" module:"openconfig-network-instance"`
	OutPathMessages             *uint64                                                                   `path:"out-path-messages" module:"openconfig-network-instance"`
	OutPathTearMessages         *uint64                                                                   `path:"out-path-tear-messages" module:"openconfig-network-instance"`
	OutReservationErrorMessages *uint64                                                                   `path:"out-reservation-error-messages" module:"openconfig-network-instance"`
	OutReservationMessages      *uint64                                                                   `path:"out-reservation-messages" module:"openconfig-network-instance"`
	OutReservationTearMessages  *uint64                                                                   `path:"out-reservation-tear-messages" module:"openconfig-network-instance"`
	OutSrefreshMessages         *uint64                                                                   `path:"out-srefresh-messages" module:"openconfig-network-instance"`
	RateLimitedMessages         *uint64                                                                   `path:"rate-limited-messages" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) IsYANGGoStruct() {}

// GetOrCreateErrors retrieves the value of the Errors field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOrCreateErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	if t.Errors != nil {
		return t.Errors
	}
	t.Errors = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	return t.Errors
}

// GetErrors returns the value of the Errors struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters. If the receiver or the field Errors is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetErrors() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	if t != nil && t.Errors != nil {
		return t.Errors
	}
	return nil
}

// GetInAckMessages retrieves the value of the leaf InAckMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InAckMessages is set, it can
// safely use t.GetInAckMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InAckMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInAckMessages() uint64 {
	if t == nil || t.InAckMessages == nil {
		return 0
	}
	return *t.InAckMessages
}

// GetInHelloMessages retrieves the value of the leaf InHelloMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InHelloMessages is set, it can
// safely use t.GetInHelloMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InHelloMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInHelloMessages() uint64 {
	if t == nil || t.InHelloMessages == nil {
		return 0
	}
	return *t.InHelloMessages
}

// GetInPathErrorMessages retrieves the value of the leaf InPathErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPathErrorMessages is set, it can
// safely use t.GetInPathErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPathErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInPathErrorMessages() uint64 {
	if t == nil || t.InPathErrorMessages == nil {
		return 0
	}
	return *t.InPathErrorMessages
}

// GetInPathMessages retrieves the value of the leaf InPathMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPathMessages is set, it can
// safely use t.GetInPathMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPathMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInPathMessages() uint64 {
	if t == nil || t.InPathMessages == nil {
		return 0
	}
	return *t.InPathMessages
}

// GetInPathTearMessages retrieves the value of the leaf InPathTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPathTearMessages is set, it can
// safely use t.GetInPathTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPathTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInPathTearMessages() uint64 {
	if t == nil || t.InPathTearMessages == nil {
		return 0
	}
	return *t.InPathTearMessages
}

// GetInReservationErrorMessages retrieves the value of the leaf InReservationErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InReservationErrorMessages is set, it can
// safely use t.GetInReservationErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InReservationErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInReservationErrorMessages() uint64 {
	if t == nil || t.InReservationErrorMessages == nil {
		return 0
	}
	return *t.InReservationErrorMessages
}

// GetInReservationMessages retrieves the value of the leaf InReservationMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InReservationMessages is set, it can
// safely use t.GetInReservationMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InReservationMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInReservationMessages() uint64 {
	if t == nil || t.InReservationMessages == nil {
		return 0
	}
	return *t.InReservationMessages
}

// GetInReservationTearMessages retrieves the value of the leaf InReservationTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InReservationTearMessages is set, it can
// safely use t.GetInReservationTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InReservationTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInReservationTearMessages() uint64 {
	if t == nil || t.InReservationTearMessages == nil {
		return 0
	}
	return *t.InReservationTearMessages
}

// GetInSrefreshMessages retrieves the value of the leaf InSrefreshMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSrefreshMessages is set, it can
// safely use t.GetInSrefreshMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSrefreshMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetInSrefreshMessages() uint64 {
	if t == nil || t.InSrefreshMessages == nil {
		return 0
	}
	return *t.InSrefreshMessages
}

// GetOutAckMessages retrieves the value of the leaf OutAckMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutAckMessages is set, it can
// safely use t.GetOutAckMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutAckMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutAckMessages() uint64 {
	if t == nil || t.OutAckMessages == nil {
		return 0
	}
	return *t.OutAckMessages
}

// GetOutHelloMessages retrieves the value of the leaf OutHelloMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutHelloMessages is set, it can
// safely use t.GetOutHelloMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutHelloMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutHelloMessages() uint64 {
	if t == nil || t.OutHelloMessages == nil {
		return 0
	}
	return *t.OutHelloMessages
}

// GetOutPathErrorMessages retrieves the value of the leaf OutPathErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPathErrorMessages is set, it can
// safely use t.GetOutPathErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPathErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutPathErrorMessages() uint64 {
	if t == nil || t.OutPathErrorMessages == nil {
		return 0
	}
	return *t.OutPathErrorMessages
}

// GetOutPathMessages retrieves the value of the leaf OutPathMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPathMessages is set, it can
// safely use t.GetOutPathMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPathMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutPathMessages() uint64 {
	if t == nil || t.OutPathMessages == nil {
		return 0
	}
	return *t.OutPathMessages
}

// GetOutPathTearMessages retrieves the value of the leaf OutPathTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPathTearMessages is set, it can
// safely use t.GetOutPathTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPathTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutPathTearMessages() uint64 {
	if t == nil || t.OutPathTearMessages == nil {
		return 0
	}
	return *t.OutPathTearMessages
}

// GetOutReservationErrorMessages retrieves the value of the leaf OutReservationErrorMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutReservationErrorMessages is set, it can
// safely use t.GetOutReservationErrorMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutReservationErrorMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutReservationErrorMessages() uint64 {
	if t == nil || t.OutReservationErrorMessages == nil {
		return 0
	}
	return *t.OutReservationErrorMessages
}

// GetOutReservationMessages retrieves the value of the leaf OutReservationMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutReservationMessages is set, it can
// safely use t.GetOutReservationMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutReservationMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutReservationMessages() uint64 {
	if t == nil || t.OutReservationMessages == nil {
		return 0
	}
	return *t.OutReservationMessages
}

// GetOutReservationTearMessages retrieves the value of the leaf OutReservationTearMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutReservationTearMessages is set, it can
// safely use t.GetOutReservationTearMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutReservationTearMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutReservationTearMessages() uint64 {
	if t == nil || t.OutReservationTearMessages == nil {
		return 0
	}
	return *t.OutReservationTearMessages
}

// GetOutSrefreshMessages retrieves the value of the leaf OutSrefreshMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutSrefreshMessages is set, it can
// safely use t.GetOutSrefreshMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutSrefreshMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetOutSrefreshMessages() uint64 {
	if t == nil || t.OutSrefreshMessages == nil {
		return 0
	}
	return *t.OutSrefreshMessages
}

// GetRateLimitedMessages retrieves the value of the leaf RateLimitedMessages from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimitedMessages is set, it can
// safely use t.GetRateLimitedMessages() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimitedMessages == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) GetRateLimitedMessages() uint64 {
	if t == nil || t.RateLimitedMessages == nil {
		return 0
	}
	return *t.RateLimitedMessages
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Errors.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors struct {
	AuthenticationFail *uint64 `path:"authentication-fail" module:"openconfig-network-instance"`
	BadChecksum        *uint64 `path:"bad-checksum" module:"openconfig-network-instance"`
	BadPacketFormat    *uint64 `path:"bad-packet-format" module:"openconfig-network-instance"`
	BadPacketLength    *uint64 `path:"bad-packet-length" module:"openconfig-network-instance"`
	OutOfOrder         *uint64 `path:"out-of-order" module:"openconfig-network-instance"`
	ReceivedNack       *uint64 `path:"received-nack" module:"openconfig-network-instance"`
	TransmitFailure    *uint64 `path:"transmit-failure" module:"openconfig-network-instance"`
	TransmitQueueFull  *uint64 `path:"transmit-queue-full" module:"openconfig-network-instance"`
	UnknownAck         *uint64 `path:"unknown-ack" module:"openconfig-network-instance"`
	UnknownNack        *uint64 `path:"unknown-nack" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) IsYANGGoStruct() {}

// GetAuthenticationFail retrieves the value of the leaf AuthenticationFail from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationFail is set, it can
// safely use t.GetAuthenticationFail() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationFail == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetAuthenticationFail() uint64 {
	if t == nil || t.AuthenticationFail == nil {
		return 0
	}
	return *t.AuthenticationFail
}

// GetBadChecksum retrieves the value of the leaf BadChecksum from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadChecksum is set, it can
// safely use t.GetBadChecksum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadChecksum == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetBadChecksum() uint64 {
	if t == nil || t.BadChecksum == nil {
		return 0
	}
	return *t.BadChecksum
}

// GetBadPacketFormat retrieves the value of the leaf BadPacketFormat from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadPacketFormat is set, it can
// safely use t.GetBadPacketFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadPacketFormat == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetBadPacketFormat() uint64 {
	if t == nil || t.BadPacketFormat == nil {
		return 0
	}
	return *t.BadPacketFormat
}

// GetBadPacketLength retrieves the value of the leaf BadPacketLength from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BadPacketLength is set, it can
// safely use t.GetBadPacketLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BadPacketLength == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetBadPacketLength() uint64 {
	if t == nil || t.BadPacketLength == nil {
		return 0
	}
	return *t.BadPacketLength
}

// GetOutOfOrder retrieves the value of the leaf OutOfOrder from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOfOrder is set, it can
// safely use t.GetOutOfOrder() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOfOrder == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetOutOfOrder() uint64 {
	if t == nil || t.OutOfOrder == nil {
		return 0
	}
	return *t.OutOfOrder
}

// GetReceivedNack retrieves the value of the leaf ReceivedNack from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReceivedNack is set, it can
// safely use t.GetReceivedNack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReceivedNack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetReceivedNack() uint64 {
	if t == nil || t.ReceivedNack == nil {
		return 0
	}
	return *t.ReceivedNack
}

// GetTransmitFailure retrieves the value of the leaf TransmitFailure from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitFailure is set, it can
// safely use t.GetTransmitFailure() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitFailure == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetTransmitFailure() uint64 {
	if t == nil || t.TransmitFailure == nil {
		return 0
	}
	return *t.TransmitFailure
}

// GetTransmitQueueFull retrieves the value of the leaf TransmitQueueFull from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitQueueFull is set, it can
// safely use t.GetTransmitQueueFull() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitQueueFull == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetTransmitQueueFull() uint64 {
	if t == nil || t.TransmitQueueFull == nil {
		return 0
	}
	return *t.TransmitQueueFull
}

// GetUnknownAck retrieves the value of the leaf UnknownAck from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnknownAck is set, it can
// safely use t.GetUnknownAck() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnknownAck == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetUnknownAck() uint64 {
	if t == nil || t.UnknownAck == nil {
		return 0
	}
	return *t.UnknownAck
}

// GetUnknownNack retrieves the value of the leaf UnknownNack from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnknownNack is set, it can
// safely use t.GetUnknownNack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnknownNack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) GetUnknownNack() uint64 {
	if t == nil || t.UnknownNack == nil {
		return 0
	}
	return *t.UnknownNack
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos struct {
	HelloInterval    *uint16 `path:"state/hello-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hello-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	RefreshReduction *bool   `path:"state/refresh-reduction" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/refresh-reduction" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) IsYANGGoStruct() {}

// GetHelloInterval retrieves the value of the leaf HelloInterval from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloInterval is set, it can
// safely use t.GetHelloInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) GetHelloInterval() uint16 {
	if t == nil || t.HelloInterval == nil {
		return 9000
	}
	return *t.HelloInterval
}

// GetRefreshReduction retrieves the value of the leaf RefreshReduction from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RefreshReduction is set, it can
// safely use t.GetRefreshReduction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RefreshReduction == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) GetRefreshReduction() bool {
	if t == nil || t.RefreshReduction == nil {
		return true
	}
	return *t.RefreshReduction
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.HelloInterval == nil {
		var v uint16 = 9000
		t.HelloInterval = &v
	}
	if t.RefreshReduction == nil {
		var v bool = true
		t.RefreshReduction = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection struct {
	BypassOptimizeInterval       *uint16                     `path:"state/bypass-optimize-interval" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/bypass-optimize-interval" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	LinkProtectionStyleRequested E_MplsTypes_PROTECTION_TYPE `path:"state/link-protection-style-requested" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/link-protection-style-requested" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) IsYANGGoStruct() {}

// GetBypassOptimizeInterval retrieves the value of the leaf BypassOptimizeInterval from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BypassOptimizeInterval is set, it can
// safely use t.GetBypassOptimizeInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BypassOptimizeInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) GetBypassOptimizeInterval() uint16 {
	if t == nil || t.BypassOptimizeInterval == nil {
		return 0
	}
	return *t.BypassOptimizeInterval
}

// GetLinkProtectionStyleRequested retrieves the value of the leaf LinkProtectionStyleRequested from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkProtectionStyleRequested is set, it can
// safely use t.GetLinkProtectionStyleRequested() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkProtectionStyleRequested == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) GetLinkProtectionStyleRequested() E_MplsTypes_PROTECTION_TYPE {
	if t == nil || t.LinkProtectionStyleRequested == 0 {
		return MplsTypes_PROTECTION_TYPE_LINK_NODE_PROTECTION_REQUESTED
	}
	return t.LinkProtectionStyleRequested
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.LinkProtectionStyleRequested == 0 {
		t.LinkProtectionStyleRequested = MplsTypes_PROTECTION_TYPE_LINK_NODE_PROTECTION_REQUESTED
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription struct {
	CalculatedAbsoluteSubscriptionBw *uint64 `path:"state/calculated-absolute-subscription-bw" module:"openconfig-network-instance/openconfig-network-instance"`
	Subscription                     *uint8  `path:"state/subscription" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subscription" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) IsYANGGoStruct() {}

// GetCalculatedAbsoluteSubscriptionBw retrieves the value of the leaf CalculatedAbsoluteSubscriptionBw from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CalculatedAbsoluteSubscriptionBw is set, it can
// safely use t.GetCalculatedAbsoluteSubscriptionBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CalculatedAbsoluteSubscriptionBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) GetCalculatedAbsoluteSubscriptionBw() uint64 {
	if t == nil || t.CalculatedAbsoluteSubscriptionBw == nil {
		return 0
	}
	return *t.CalculatedAbsoluteSubscriptionBw
}

// GetSubscription retrieves the value of the leaf Subscription from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subscription is set, it can
// safely use t.GetSubscription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subscription == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) GetSubscription() uint8 {
	if t == nil || t.Subscription == nil {
		return 0
	}
	return *t.Subscription
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor struct {
	Address           *string                   `path:"state/address|address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"address" shadow-module:"openconfig-network-instance"`
	DetectedInterface *string                   `path:"state/detected-interface" module:"openconfig-network-instance/openconfig-network-instance"`
	NeighborStatus    E_Neighbor_NeighborStatus `path:"state/neighbor-status" module:"openconfig-network-instance/openconfig-network-instance"`
	RefreshReduction  *bool                     `path:"state/refresh-reduction" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetDetectedInterface retrieves the value of the leaf DetectedInterface from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DetectedInterface is set, it can
// safely use t.GetDetectedInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DetectedInterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) GetDetectedInterface() string {
	if t == nil || t.DetectedInterface == nil {
		return ""
	}
	return *t.DetectedInterface
}

// GetNeighborStatus retrieves the value of the leaf NeighborStatus from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborStatus is set, it can
// safely use t.GetNeighborStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) GetNeighborStatus() E_Neighbor_NeighborStatus {
	if t == nil || t.NeighborStatus == 0 {
		return 0
	}
	return t.NeighborStatus
}

// GetRefreshReduction retrieves the value of the leaf RefreshReduction from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RefreshReduction is set, it can
// safely use t.GetRefreshReduction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RefreshReduction == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) GetRefreshReduction() bool {
	if t == nil || t.RefreshReduction == nil {
		return false
	}
	return *t.RefreshReduction
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct {
	DestinationAddress  *string                                                                                `path:"state/destination-address" module:"openconfig-network-instance/openconfig-network-instance"`
	ExplicitRouteObject map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject `path:"explicit-route-objects/explicit-route-object" module:"openconfig-network-instance/openconfig-network-instance"`
	LabelIn             NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union                   `path:"state/label-in" module:"openconfig-network-instance/openconfig-network-instance"`
	LabelOut            NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union                  `path:"state/label-out" module:"openconfig-network-instance/openconfig-network-instance"`
	LocalIndex          *uint64                                                                                `path:"state/local-index|local-index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"local-index" shadow-module:"openconfig-network-instance"`
	LspId               *uint16                                                                                `path:"state/lsp-id" module:"openconfig-network-instance/openconfig-network-instance"`
	ProtectionRequested E_MplsTypes_PROTECTION_TYPE                                                            `path:"state/protection-requested" module:"openconfig-network-instance/openconfig-network-instance"`
	RecordRouteObject   map[uint8]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject    `path:"record-route-objects/record-route-object" module:"openconfig-network-instance/openconfig-network-instance"`
	SenderTspec         *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec                    `path:"state/sender-tspec" module:"openconfig-network-instance/openconfig-network-instance"`
	SessionName         *string                                                                                `path:"state/session-name" module:"openconfig-network-instance/openconfig-network-instance"`
	SourceAddress       *string                                                                                `path:"state/source-address" module:"openconfig-network-instance/openconfig-network-instance"`
	Status              E_Session_Status                                                                       `path:"state/status" module:"openconfig-network-instance/openconfig-network-instance"`
	TunnelId            *uint16                                                                                `path:"state/tunnel-id" module:"openconfig-network-instance/openconfig-network-instance"`
	Type                E_MplsTypes_LSP_ROLE                                                                   `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) IsYANGGoStruct() {}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) NewExplicitRouteObject(Index uint64) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) RenameExplicitRouteObject(oldK, newK uint64) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateExplicitRouteObject(Index uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetExplicitRouteObject(Index uint64) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteExplicitRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) DeleteExplicitRouteObject(Index uint64) {
	key := Index

	delete(t.ExplicitRouteObject, key)
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) AppendExplicitRouteObject(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint64]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// NewRecordRouteObject creates a new entry in the RecordRouteObject list of the
// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) NewRecordRouteObject(Index uint8) (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RecordRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RecordRouteObject", key)
	}

	t.RecordRouteObject[key] = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
		Index: &Index,
	}

	return t.RecordRouteObject[key], nil
}

// RenameRecordRouteObject renames an entry in the list RecordRouteObject within
// the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) RenameRecordRouteObject(oldK, newK uint8) error {
	if _, ok := t.RecordRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in RecordRouteObject", newK)
	}

	e, ok := t.RecordRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RecordRouteObject", oldK)
	}
	e.Index = &newK

	t.RecordRouteObject[newK] = e
	delete(t.RecordRouteObject, oldK)
	return nil
}

// GetOrCreateRecordRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateRecordRouteObject(Index uint8) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	key := Index

	if v, ok := t.RecordRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRecordRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRecordRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetRecordRouteObject retrieves the value with the specified key from
// the RecordRouteObject map field of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetRecordRouteObject(Index uint8) *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.RecordRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteRecordRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) DeleteRecordRouteObject(Index uint8) {
	key := Index

	delete(t.RecordRouteObject, key)
}

// AppendRecordRouteObject appends the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct to the
// list RecordRouteObject of NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) AppendRecordRouteObject(v *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RecordRouteObject == nil {
		t.RecordRouteObject = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
	}

	if _, ok := t.RecordRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list RecordRouteObject %v", key)
	}

	t.RecordRouteObject[key] = v
	return nil
}

// GetOrCreateSenderTspec retrieves the value of the SenderTspec field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetOrCreateSenderTspec() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if t.SenderTspec != nil {
		return t.SenderTspec
	}
	t.SenderTspec = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	return t.SenderTspec
}

// GetSenderTspec returns the value of the SenderTspec struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session. If the receiver or the field SenderTspec is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetSenderTspec() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	if t != nil && t.SenderTspec != nil {
		return t.SenderTspec
	}
	return nil
}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetDestinationAddress() string {
	if t == nil || t.DestinationAddress == nil {
		return ""
	}
	return *t.DestinationAddress
}

// GetLabelIn retrieves the value of the leaf LabelIn from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelIn is set, it can
// safely use t.GetLabelIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelIn == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetLabelIn() NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	if t == nil || t.LabelIn == nil {
		return nil
	}
	return t.LabelIn
}

// GetLabelOut retrieves the value of the leaf LabelOut from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelOut is set, it can
// safely use t.GetLabelOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelOut == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetLabelOut() NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	if t == nil || t.LabelOut == nil {
		return nil
	}
	return t.LabelOut
}

// GetLocalIndex retrieves the value of the leaf LocalIndex from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalIndex is set, it can
// safely use t.GetLocalIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalIndex == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetLocalIndex() uint64 {
	if t == nil || t.LocalIndex == nil {
		return 0
	}
	return *t.LocalIndex
}

// GetLspId retrieves the value of the leaf LspId from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspId is set, it can
// safely use t.GetLspId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetLspId() uint16 {
	if t == nil || t.LspId == nil {
		return 0
	}
	return *t.LspId
}

// GetProtectionRequested retrieves the value of the leaf ProtectionRequested from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionRequested is set, it can
// safely use t.GetProtectionRequested() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionRequested == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetProtectionRequested() E_MplsTypes_PROTECTION_TYPE {
	if t == nil || t.ProtectionRequested == 0 {
		return 0
	}
	return t.ProtectionRequested
}

// GetSessionName retrieves the value of the leaf SessionName from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionName is set, it can
// safely use t.GetSessionName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetSessionName() string {
	if t == nil || t.SessionName == nil {
		return ""
	}
	return *t.SessionName
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// GetStatus retrieves the value of the leaf Status from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetStatus() E_Session_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// GetTunnelId retrieves the value of the leaf TunnelId from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelId is set, it can
// safely use t.GetTunnelId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetTunnelId() uint16 {
	if t == nil || t.TunnelId == nil {
		return 0
	}
	return *t.TunnelId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) GetType() E_MplsTypes_LSP_ROLE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SenderTspec.PopulateDefaults()
	for _, e := range t.ExplicitRouteObject {
		e.PopulateDefaults()
	}
	for _, e := range t.RecordRouteObject {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalIndex == nil {
		return nil, fmt.Errorf("nil value for key LocalIndex")
	}

	return map[string]interface{}{
		"local-index": *t.LocalIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject struct {
	Asn         *uint32                                                                                `path:"state/asn" module:"openconfig-network-instance/openconfig-network-instance"`
	Index       *uint64                                                                                `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	InterfaceId *uint32                                                                                `path:"state/interface-id" module:"openconfig-network-instance/openconfig-network-instance"`
	IpPrefix    *string                                                                                `path:"state/ip-prefix" module:"openconfig-network-instance/openconfig-network-instance"`
	Label       NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	Loose       *bool                                                                                  `path:"state/loose" module:"openconfig-network-instance/openconfig-network-instance"`
	Type        E_ExplicitRouteObject_Type                                                             `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) IsYANGGoStruct() {}

// GetAsn retrieves the value of the leaf Asn from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Asn is set, it can
// safely use t.GetAsn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Asn == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) GetAsn() uint32 {
	if t == nil || t.Asn == nil {
		return 0
	}
	return *t.Asn
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) GetInterfaceId() uint32 {
	if t == nil || t.InterfaceId == nil {
		return 0
	}
	return *t.InterfaceId
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) GetLabel() NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	if t == nil || t.Label == nil {
		return nil
	}
	return t.Label
}

// GetLoose retrieves the value of the leaf Loose from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Loose is set, it can
// safely use t.GetLoose() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Loose == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) GetLoose() bool {
	if t == nil || t.Loose == nil {
		return false
	}
	return *t.Loose
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) GetType() E_ExplicitRouteObject_Type {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct {
	Address       *string                                                                                      `path:"state/address" module:"openconfig-network-instance/openconfig-network-instance"`
	Index         *uint8                                                                                       `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"index" shadow-module:"openconfig-network-instance"`
	ReportedFlags *uint8                                                                                       `path:"state/reported-flags" module:"openconfig-network-instance/openconfig-network-instance"`
	ReportedLabel NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union `path:"state/reported-label" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetReportedFlags retrieves the value of the leaf ReportedFlags from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReportedFlags is set, it can
// safely use t.GetReportedFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReportedFlags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) GetReportedFlags() uint8 {
	if t == nil || t.ReportedFlags == nil {
		return 0
	}
	return *t.ReportedFlags
}

// GetReportedLabel retrieves the value of the leaf ReportedLabel from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReportedLabel is set, it can
// safely use t.GetReportedLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReportedLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) GetReportedLabel() NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	if t == nil || t.ReportedLabel == nil {
		return nil
	}
	return t.ReportedLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec struct {
	PeakDataRate Binary `path:"peak-data-rate" module:"openconfig-network-instance"`
	Rate         Binary `path:"rate" module:"openconfig-network-instance"`
	Size         Binary `path:"size" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) IsYANGGoStruct() {}

// GetPeakDataRate retrieves the value of the leaf PeakDataRate from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakDataRate is set, it can
// safely use t.GetPeakDataRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakDataRate == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) GetPeakDataRate() Binary {
	if t == nil || t.PeakDataRate == nil {
		return nil
	}
	return t.PeakDataRate
}

// GetRate retrieves the value of the leaf Rate from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rate is set, it can
// safely use t.GetRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rate == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) GetRate() Binary {
	if t == nil || t.Rate == nil {
		return nil
	}
	return t.Rate
}

// GetSize retrieves the value of the leaf Size from the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Size is set, it can
// safely use t.GetSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Size == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) GetSize() Binary {
	if t == nil || t.Size == nil {
		return nil
	}
	return t.Size
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct {
	AggregateSidCounter map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter `path:"aggregate-sid-counters/aggregate-sid-counter" module:"openconfig-network-instance/openconfig-network-instance"`
	Interface           map[string]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface                                                                                               `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_SegmentRouting implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) IsYANGGoStruct() {}

// NewAggregateSidCounter creates a new entry in the AggregateSidCounter list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) NewAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AggregateSidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AggregateSidCounter", key)
	}

	t.AggregateSidCounter[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
		MplsLabel: MplsLabel,
	}

	return t.AggregateSidCounter[key], nil
}

// RenameAggregateSidCounter renames an entry in the list AggregateSidCounter within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) RenameAggregateSidCounter(oldK, newK NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) error {
	if _, ok := t.AggregateSidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in AggregateSidCounter", newK)
	}

	e, ok := t.AggregateSidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AggregateSidCounter", oldK)
	}
	e.MplsLabel = newK

	t.AggregateSidCounter[newK] = e
	delete(t.AggregateSidCounter, oldK)
	return nil
}

// GetOrCreateAggregateSidCounter retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetOrCreateAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	key := MplsLabel

	if v, ok := t.AggregateSidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregateSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetAggregateSidCounter retrieves the value with the specified key from
// the AggregateSidCounter map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.AggregateSidCounter[key]; ok {
		return lm
	}
	return nil
}

// DeleteAggregateSidCounter deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) DeleteAggregateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) {
	key := MplsLabel

	delete(t.AggregateSidCounter, key)
}

// AppendAggregateSidCounter appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct to the
// list AggregateSidCounter of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) AppendAggregateSidCounter(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AggregateSidCounter == nil {
		t.AggregateSidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
	}

	if _, ok := t.AggregateSidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list AggregateSidCounter %v", key)
	}

	t.AggregateSidCounter[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) GetInterface(InterfaceId string) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct to the
// list Interface of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) AppendInterface(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AggregateSidCounter {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct {
	InOctets  *uint64                                                                                    `path:"state/in-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	InPkts    *uint64                                                                                    `path:"state/in-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union `path:"state/mpls-label|mpls-label" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mpls-label" shadow-module:"openconfig-network-instance"`
	OutOctets *uint64                                                                                    `path:"state/out-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	OutPkts   *uint64                                                                                    `path:"state/out-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) IsYANGGoStruct() {}

// GetInOctets retrieves the value of the leaf InOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetMplsLabel retrieves the value of the leaf MplsLabel from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabel is set, it can
// safely use t.GetMplsLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) GetMplsLabel() NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	if t == nil || t.MplsLabel == nil {
		return nil
	}
	return t.MplsLabel
}

// GetOutOctets retrieves the value of the leaf OutOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct {
	InOctets     *uint64                                                                                                                                                                      `path:"state/in-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	InPkts       *uint64                                                                                                                                                                      `path:"state/in-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
	InterfaceId  *string                                                                                                                                                                      `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef                                                                                               `path:"interface-ref" module:"openconfig-network-instance"`
	OutOctets    *uint64                                                                                                                                                                      `path:"state/out-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	OutPkts      *uint64                                                                                                                                                                      `path:"state/out-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
	SidCounter   map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter `path:"sid-counters/sid-counter" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) IsYANGGoStruct() {}

// NewSidCounter creates a new entry in the SidCounter list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) NewSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	key := MplsLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SidCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SidCounter", key)
	}

	t.SidCounter[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
		MplsLabel: MplsLabel,
	}

	return t.SidCounter[key], nil
}

// RenameSidCounter renames an entry in the list SidCounter within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) RenameSidCounter(oldK, newK NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) error {
	if _, ok := t.SidCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in SidCounter", newK)
	}

	e, ok := t.SidCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SidCounter", oldK)
	}
	e.MplsLabel = newK

	t.SidCounter[newK] = e
	delete(t.SidCounter, oldK)
	return nil
}

// GetOrCreateSidCounter retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	key := MplsLabel

	if v, ok := t.SidCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSidCounter(MplsLabel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSidCounter got unexpected error: %v", err))
	}
	return v
}

// GetSidCounter retrieves the value with the specified key from
// the SidCounter map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {

	if t == nil {
		return nil
	}

	key := MplsLabel

	if lm, ok := t.SidCounter[key]; ok {
		return lm
	}
	return nil
}

// DeleteSidCounter deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) DeleteSidCounter(MplsLabel NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) {
	key := MplsLabel

	delete(t.SidCounter, key)
}

// AppendSidCounter appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct to the
// list SidCounter of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) AppendSidCounter(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) error {
	key := v.MplsLabel

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SidCounter == nil {
		t.SidCounter = make(map[NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
	}

	if _, ok := t.SidCounter[key]; ok {
		return fmt.Errorf("duplicate key for list SidCounter %v", key)
	}

	t.SidCounter[key] = v
	return nil
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetInterfaceRef() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetInOctets retrieves the value of the leaf InOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetOutOctets retrieves the value of the leaf OutOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InterfaceRef.PopulateDefaults()
	for _, e := range t.SidCounter {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct {
	ForwardingClass map[uint8]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass `path:"forwarding-classes/forwarding-class" module:"openconfig-network-instance/openconfig-network-instance"`
	InOctets        *uint64                                                                                                `path:"state/in-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	InPkts          *uint64                                                                                                `path:"state/in-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
	MplsLabel       NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union            `path:"state/mpls-label|mpls-label" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"mpls-label" shadow-module:"openconfig-network-instance"`
	OutOctets       *uint64                                                                                                `path:"state/out-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	OutPkts         *uint64                                                                                                `path:"state/out-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) IsYANGGoStruct() {
}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) NewForwardingClass(Exp uint8) (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	key := Exp

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
		Exp: &Exp,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) RenameForwardingClass(oldK, newK uint8) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Exp = &newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetOrCreateForwardingClass(Exp uint8) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	key := Exp

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Exp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetForwardingClass(Exp uint8) *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {

	if t == nil {
		return nil
	}

	key := Exp

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingClass deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) DeleteForwardingClass(Exp uint8) {
	key := Exp

	delete(t.ForwardingClass, key)
}

// AppendForwardingClass appends the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct to the
// list ForwardingClass of NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) AppendForwardingClass(v *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) error {
	if v.Exp == nil {
		return fmt.Errorf("invalid nil key received for Exp")
	}

	key := *v.Exp

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[uint8]*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// GetInOctets retrieves the value of the leaf InOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetMplsLabel retrieves the value of the leaf MplsLabel from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabel is set, it can
// safely use t.GetMplsLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetMplsLabel() NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	if t == nil || t.MplsLabel == nil {
		return nil
	}
	return t.MplsLabel
}

// GetOutOctets retrieves the value of the leaf OutOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ForwardingClass {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"mpls-label": t.MplsLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct {
	Exp       *uint8  `path:"state/exp|exp" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"exp" shadow-module:"openconfig-network-instance"`
	InOctets  *uint64 `path:"state/in-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	InPkts    *uint64 `path:"state/in-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
	OutOctets *uint64 `path:"state/out-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	OutPkts   *uint64 `path:"state/out-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) IsYANGGoStruct() {
}

// GetExp retrieves the value of the leaf Exp from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Exp is set, it can
// safely use t.GetExp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Exp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) GetExp() uint8 {
	if t == nil || t.Exp == nil {
		return 0
	}
	return *t.Exp
}

// GetInOctets retrieves the value of the leaf InOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Exp == nil {
		return nil, fmt.Errorf("nil value for key Exp")
	}

	return map[string]interface{}{
		"exp": *t.Exp,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_TeGlobalAttributes represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes YANG schema element.
type NetworkInstance_Mpls_TeGlobalAttributes struct {
	AdminGroup  map[string]*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup `path:"mpls-admin-groups/admin-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Srlg        map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg       `path:"srlgs/srlg" module:"openconfig-network-instance/openconfig-network-instance"`
	TeLspTimers *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers           `path:"te-lsp-timers" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_TeGlobalAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_TeGlobalAttributes) IsYANGGoStruct() {}

// NewAdminGroup creates a new entry in the AdminGroup list of the
// NetworkInstance_Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) NewAdminGroup(AdminGroupName string) (*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
	}

	key := AdminGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdminGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdminGroup", key)
	}

	t.AdminGroup[key] = &NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
		AdminGroupName: &AdminGroupName,
	}

	return t.AdminGroup[key], nil
}

// RenameAdminGroup renames an entry in the list AdminGroup within
// the NetworkInstance_Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) RenameAdminGroup(oldK, newK string) error {
	if _, ok := t.AdminGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AdminGroup", newK)
	}

	e, ok := t.AdminGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdminGroup", oldK)
	}
	e.AdminGroupName = &newK

	t.AdminGroup[newK] = e
	delete(t.AdminGroup, oldK)
	return nil
}

// GetOrCreateAdminGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateAdminGroup(AdminGroupName string) *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {

	key := AdminGroupName

	if v, ok := t.AdminGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdminGroup(AdminGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdminGroup got unexpected error: %v", err))
	}
	return v
}

// GetAdminGroup retrieves the value with the specified key from
// the AdminGroup map field of NetworkInstance_Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetAdminGroup(AdminGroupName string) *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {

	if t == nil {
		return nil
	}

	key := AdminGroupName

	if lm, ok := t.AdminGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdminGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) DeleteAdminGroup(AdminGroupName string) {
	key := AdminGroupName

	delete(t.AdminGroup, key)
}

// AppendAdminGroup appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup struct to the
// list AdminGroup of NetworkInstance_Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) AppendAdminGroup(v *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) error {
	if v.AdminGroupName == nil {
		return fmt.Errorf("invalid nil key received for AdminGroupName")
	}

	key := *v.AdminGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
	}

	if _, ok := t.AdminGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AdminGroup %v", key)
	}

	t.AdminGroup[key] = v
	return nil
}

// NewSrlg creates a new entry in the Srlg list of the
// NetworkInstance_Mpls_TeGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) NewSrlg(Name string) (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srlg", key)
	}

	t.Srlg[key] = &NetworkInstance_Mpls_TeGlobalAttributes_Srlg{
		Name: &Name,
	}

	return t.Srlg[key], nil
}

// RenameSrlg renames an entry in the list Srlg within
// the NetworkInstance_Mpls_TeGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) RenameSrlg(oldK, newK string) error {
	if _, ok := t.Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Srlg", newK)
	}

	e, ok := t.Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srlg", oldK)
	}
	e.Name = &newK

	t.Srlg[newK] = e
	delete(t.Srlg, oldK)
	return nil
}

// GetOrCreateSrlg retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateSrlg(Name string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg {

	key := Name

	if v, ok := t.Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrlg(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrlg got unexpected error: %v", err))
	}
	return v
}

// GetSrlg retrieves the value with the specified key from
// the Srlg map field of NetworkInstance_Mpls_TeGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetSrlg(Name string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Srlg[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrlg deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) DeleteSrlg(Name string) {
	key := Name

	delete(t.Srlg, key)
}

// AppendSrlg appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct to the
// list Srlg of NetworkInstance_Mpls_TeGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) AppendSrlg(v *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg)
	}

	if _, ok := t.Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Srlg %v", key)
	}

	t.Srlg[key] = v
	return nil
}

// GetOrCreateTeLspTimers retrieves the value of the TeLspTimers field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetOrCreateTeLspTimers() *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	if t.TeLspTimers != nil {
		return t.TeLspTimers
	}
	t.TeLspTimers = &NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	return t.TeLspTimers
}

// GetTeLspTimers returns the value of the TeLspTimers struct pointer
// from NetworkInstance_Mpls_TeGlobalAttributes. If the receiver or the field TeLspTimers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) GetTeLspTimers() *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	if t != nil && t.TeLspTimers != nil {
		return t.TeLspTimers
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_TeGlobalAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.TeLspTimers.PopulateDefaults()
	for _, e := range t.AdminGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.Srlg {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group YANG schema element.
type NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup struct {
	AdminGroupName *string `path:"state/admin-group-name|admin-group-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/admin-group-name|admin-group-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	BitPosition    *uint32 `path:"state/bit-position" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/bit-position" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) IsYANGGoStruct() {}

// GetAdminGroupName retrieves the value of the leaf AdminGroupName from the NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroupName is set, it can
// safely use t.GetAdminGroupName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroupName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) GetAdminGroupName() string {
	if t == nil || t.AdminGroupName == nil {
		return ""
	}
	return *t.AdminGroupName
}

// GetBitPosition retrieves the value of the leaf BitPosition from the NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BitPosition is set, it can
// safely use t.GetBitPosition() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BitPosition == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) GetBitPosition() uint32 {
	if t == nil || t.BitPosition == nil {
		return 0
	}
	return *t.BitPosition
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AdminGroupName == nil {
		return nil, fmt.Errorf("nil value for key AdminGroupName")
	}

	return map[string]interface{}{
		"admin-group-name": *t.AdminGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_TeGlobalAttributes_Srlg represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg YANG schema element.
type NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct {
	Cost         *uint32                                                              `path:"state/cost" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/cost" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	FloodingType E_Mpls_MplsSrlgFloodingType                                          `path:"state/flooding-type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/flooding-type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	MembersList  map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList `path:"static-srlg-members/members-list" module:"openconfig-network-instance/openconfig-network-instance"`
	Name         *string                                                              `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Value        *uint32                                                              `path:"state/value" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/value" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_TeGlobalAttributes_Srlg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg) IsYANGGoStruct() {}

// NewMembersList creates a new entry in the MembersList list of the
// NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) NewMembersList(FromAddress string) (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	key := FromAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MembersList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MembersList", key)
	}

	t.MembersList[key] = &NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
		FromAddress: &FromAddress,
	}

	return t.MembersList[key], nil
}

// RenameMembersList renames an entry in the list MembersList within
// the NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) RenameMembersList(oldK, newK string) error {
	if _, ok := t.MembersList[newK]; ok {
		return fmt.Errorf("key %v already exists in MembersList", newK)
	}

	e, ok := t.MembersList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MembersList", oldK)
	}
	e.FromAddress = &newK

	t.MembersList[newK] = e
	delete(t.MembersList, oldK)
	return nil
}

// GetOrCreateMembersList retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetOrCreateMembersList(FromAddress string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {

	key := FromAddress

	if v, ok := t.MembersList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMembersList(FromAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMembersList got unexpected error: %v", err))
	}
	return v
}

// GetMembersList retrieves the value with the specified key from
// the MembersList map field of NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetMembersList(FromAddress string) *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {

	if t == nil {
		return nil
	}

	key := FromAddress

	if lm, ok := t.MembersList[key]; ok {
		return lm
	}
	return nil
}

// DeleteMembersList deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) DeleteMembersList(FromAddress string) {
	key := FromAddress

	delete(t.MembersList, key)
}

// AppendMembersList appends the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList struct to the
// list MembersList of NetworkInstance_Mpls_TeGlobalAttributes_Srlg. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) AppendMembersList(v *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) error {
	if v.FromAddress == nil {
		return fmt.Errorf("invalid nil key received for FromAddress")
	}

	key := *v.FromAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MembersList == nil {
		t.MembersList = make(map[string]*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
	}

	if _, ok := t.MembersList[key]; ok {
		return fmt.Errorf("duplicate key for list MembersList %v", key)
	}

	t.MembersList[key] = v
	return nil
}

// GetCost retrieves the value of the leaf Cost from the NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cost is set, it can
// safely use t.GetCost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cost == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetCost() uint32 {
	if t == nil || t.Cost == nil {
		return 0
	}
	return *t.Cost
}

// GetFloodingType retrieves the value of the leaf FloodingType from the NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FloodingType is set, it can
// safely use t.GetFloodingType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FloodingType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetFloodingType() E_Mpls_MplsSrlgFloodingType {
	if t == nil || t.FloodingType == 0 {
		return Mpls_MplsSrlgFloodingType_FLOODED_SRLG
	}
	return t.FloodingType
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetValue retrieves the value of the leaf Value from the NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FloodingType == 0 {
		t.FloodingType = Mpls_MplsSrlgFloodingType_FLOODED_SRLG
	}
	for _, e := range t.MembersList {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_Srlg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list YANG schema element.
type NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList struct {
	FromAddress *string `path:"state/from-address|from-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/from-address|from-address" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ToAddress   *string `path:"state/to-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/to-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) IsYANGGoStruct() {}

// GetFromAddress retrieves the value of the leaf FromAddress from the NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FromAddress is set, it can
// safely use t.GetFromAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FromAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) GetFromAddress() string {
	if t == nil || t.FromAddress == nil {
		return ""
	}
	return *t.FromAddress
}

// GetToAddress retrieves the value of the leaf ToAddress from the NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ToAddress is set, it can
// safely use t.GetToAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ToAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) GetToAddress() string {
	if t == nil || t.ToAddress == nil {
		return ""
	}
	return *t.ToAddress
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FromAddress == nil {
		return nil, fmt.Errorf("nil value for key FromAddress")
	}

	return map[string]interface{}{
		"from-address": *t.FromAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers YANG schema element.
type NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers struct {
	CleanupDelay    *uint16 `path:"state/cleanup-delay" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/cleanup-delay" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	InstallDelay    *uint16 `path:"state/install-delay" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/install-delay" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ReoptimizeTimer *uint16 `path:"state/reoptimize-timer" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/reoptimize-timer" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) IsYANGGoStruct() {}

// GetCleanupDelay retrieves the value of the leaf CleanupDelay from the NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CleanupDelay is set, it can
// safely use t.GetCleanupDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CleanupDelay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) GetCleanupDelay() uint16 {
	if t == nil || t.CleanupDelay == nil {
		return 0
	}
	return *t.CleanupDelay
}

// GetInstallDelay retrieves the value of the leaf InstallDelay from the NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstallDelay is set, it can
// safely use t.GetInstallDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstallDelay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) GetInstallDelay() uint16 {
	if t == nil || t.InstallDelay == nil {
		return 0
	}
	return *t.InstallDelay
}

// GetReoptimizeTimer retrieves the value of the leaf ReoptimizeTimer from the NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReoptimizeTimer is set, it can
// safely use t.GetReoptimizeTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReoptimizeTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) GetReoptimizeTimer() uint16 {
	if t == nil || t.ReoptimizeTimer == nil {
		return 0
	}
	return *t.ReoptimizeTimer
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding YANG schema element.
type NetworkInstance_PolicyForwarding struct {
	Interface          map[string]*NetworkInstance_PolicyForwarding_Interface          `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	PathSelectionGroup map[string]*NetworkInstance_PolicyForwarding_PathSelectionGroup `path:"path-selection-groups/path-selection-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Policy             map[string]*NetworkInstance_PolicyForwarding_Policy             `path:"policies/policy" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewInterface(InterfaceId string) (*NetworkInstance_PolicyForwarding_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_PolicyForwarding_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_PolicyForwarding_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreateInterface(InterfaceId string) *NetworkInstance_PolicyForwarding_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetInterface(InterfaceId string) *NetworkInstance_PolicyForwarding_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_PolicyForwarding_Interface struct to the
// list Interface of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendInterface(v *NetworkInstance_PolicyForwarding_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_PolicyForwarding_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewPathSelectionGroup creates a new entry in the PathSelectionGroup list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewPathSelectionGroup(GroupId string) (*NetworkInstance_PolicyForwarding_PathSelectionGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathSelectionGroup == nil {
		t.PathSelectionGroup = make(map[string]*NetworkInstance_PolicyForwarding_PathSelectionGroup)
	}

	key := GroupId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathSelectionGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathSelectionGroup", key)
	}

	t.PathSelectionGroup[key] = &NetworkInstance_PolicyForwarding_PathSelectionGroup{
		GroupId: &GroupId,
	}

	return t.PathSelectionGroup[key], nil
}

// RenamePathSelectionGroup renames an entry in the list PathSelectionGroup within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenamePathSelectionGroup(oldK, newK string) error {
	if _, ok := t.PathSelectionGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PathSelectionGroup", newK)
	}

	e, ok := t.PathSelectionGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathSelectionGroup", oldK)
	}
	e.GroupId = &newK

	t.PathSelectionGroup[newK] = e
	delete(t.PathSelectionGroup, oldK)
	return nil
}

// GetOrCreatePathSelectionGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreatePathSelectionGroup(GroupId string) *NetworkInstance_PolicyForwarding_PathSelectionGroup {

	key := GroupId

	if v, ok := t.PathSelectionGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathSelectionGroup(GroupId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathSelectionGroup got unexpected error: %v", err))
	}
	return v
}

// GetPathSelectionGroup retrieves the value with the specified key from
// the PathSelectionGroup map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetPathSelectionGroup(GroupId string) *NetworkInstance_PolicyForwarding_PathSelectionGroup {

	if t == nil {
		return nil
	}

	key := GroupId

	if lm, ok := t.PathSelectionGroup[key]; ok {
		return lm
	}
	return nil
}

// DeletePathSelectionGroup deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding) DeletePathSelectionGroup(GroupId string) {
	key := GroupId

	delete(t.PathSelectionGroup, key)
}

// AppendPathSelectionGroup appends the supplied NetworkInstance_PolicyForwarding_PathSelectionGroup struct to the
// list PathSelectionGroup of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_PathSelectionGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendPathSelectionGroup(v *NetworkInstance_PolicyForwarding_PathSelectionGroup) error {
	if v.GroupId == nil {
		return fmt.Errorf("invalid nil key received for GroupId")
	}

	key := *v.GroupId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathSelectionGroup == nil {
		t.PathSelectionGroup = make(map[string]*NetworkInstance_PolicyForwarding_PathSelectionGroup)
	}

	if _, ok := t.PathSelectionGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PathSelectionGroup %v", key)
	}

	t.PathSelectionGroup[key] = v
	return nil
}

// NewPolicy creates a new entry in the Policy list of the
// NetworkInstance_PolicyForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding) NewPolicy(PolicyId string) (*NetworkInstance_PolicyForwarding_Policy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*NetworkInstance_PolicyForwarding_Policy)
	}

	key := PolicyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &NetworkInstance_PolicyForwarding_Policy{
		PolicyId: &PolicyId,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the NetworkInstance_PolicyForwarding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.PolicyId = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding) GetOrCreatePolicy(PolicyId string) *NetworkInstance_PolicyForwarding_Policy {

	key := PolicyId

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(PolicyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of NetworkInstance_PolicyForwarding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding) GetPolicy(PolicyId string) *NetworkInstance_PolicyForwarding_Policy {

	if t == nil {
		return nil
	}

	key := PolicyId

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding) DeletePolicy(PolicyId string) {
	key := PolicyId

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied NetworkInstance_PolicyForwarding_Policy struct to the
// list Policy of NetworkInstance_PolicyForwarding. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding) AppendPolicy(v *NetworkInstance_PolicyForwarding_Policy) error {
	if v.PolicyId == nil {
		return fmt.Errorf("invalid nil key received for PolicyId")
	}

	key := *v.PolicyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*NetworkInstance_PolicyForwarding_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.PathSelectionGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.Policy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Interface represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/interfaces/interface YANG schema element.
type NetworkInstance_PolicyForwarding_Interface struct {
	ApplyForwardingPolicy   *string                                                  `path:"state/apply-forwarding-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/apply-forwarding-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	ApplyVrfSelectionPolicy *string                                                  `path:"state/apply-vrf-selection-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/apply-vrf-selection-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	InterfaceId             *string                                                  `path:"state/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/interface-id|interface-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	InterfaceRef            *NetworkInstance_PolicyForwarding_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Interface) GetOrCreateInterfaceRef() *NetworkInstance_PolicyForwarding_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_PolicyForwarding_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_PolicyForwarding_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Interface) GetInterfaceRef() *NetworkInstance_PolicyForwarding_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetApplyForwardingPolicy retrieves the value of the leaf ApplyForwardingPolicy from the NetworkInstance_PolicyForwarding_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ApplyForwardingPolicy is set, it can
// safely use t.GetApplyForwardingPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ApplyForwardingPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Interface) GetApplyForwardingPolicy() string {
	if t == nil || t.ApplyForwardingPolicy == nil {
		return ""
	}
	return *t.ApplyForwardingPolicy
}

// GetApplyVrfSelectionPolicy retrieves the value of the leaf ApplyVrfSelectionPolicy from the NetworkInstance_PolicyForwarding_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ApplyVrfSelectionPolicy is set, it can
// safely use t.GetApplyVrfSelectionPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ApplyVrfSelectionPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Interface) GetApplyVrfSelectionPolicy() string {
	if t == nil || t.ApplyVrfSelectionPolicy == nil {
		return ""
	}
	return *t.ApplyVrfSelectionPolicy
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_PolicyForwarding_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/interfaces/interface/interface-ref YANG schema element.
type NetworkInstance_PolicyForwarding_Interface_InterfaceRef struct {
	Interface    *string `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/interface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Subinterface *uint32 `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/subinterface" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_PolicyForwarding_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_PolicyForwarding_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_PathSelectionGroup represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/path-selection-groups/path-selection-group YANG schema element.
type NetworkInstance_PolicyForwarding_PathSelectionGroup struct {
	GroupId *string  `path:"state/group-id|group-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/group-id|group-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	MplsLsp []string `path:"state/mpls-lsp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/mpls-lsp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_PathSelectionGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_PathSelectionGroup) IsYANGGoStruct() {}

// GetGroupId retrieves the value of the leaf GroupId from the NetworkInstance_PolicyForwarding_PathSelectionGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GroupId is set, it can
// safely use t.GetGroupId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GroupId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) GetGroupId() string {
	if t == nil || t.GroupId == nil {
		return ""
	}
	return *t.GroupId
}

// GetMplsLsp retrieves the value of the leaf MplsLsp from the NetworkInstance_PolicyForwarding_PathSelectionGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLsp is set, it can
// safely use t.GetMplsLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLsp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) GetMplsLsp() []string {
	if t == nil || t.MplsLsp == nil {
		return nil
	}
	return t.MplsLsp
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_PathSelectionGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_PathSelectionGroup struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GroupId == nil {
		return nil, fmt.Errorf("nil value for key GroupId")
	}

	return map[string]interface{}{
		"group-id": *t.GroupId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_PathSelectionGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_PathSelectionGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy YANG schema element.
type NetworkInstance_PolicyForwarding_Policy struct {
	PolicyId *string                                                  `path:"state/policy-id|policy-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/policy-id|policy-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Rule     map[uint32]*NetworkInstance_PolicyForwarding_Policy_Rule `path:"rules/rule" module:"openconfig-network-instance/openconfig-network-instance"`
	Type     E_Policy_Type                                            `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/type" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy) IsYANGGoStruct() {}

// NewRule creates a new entry in the Rule list of the
// NetworkInstance_PolicyForwarding_Policy struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding_Policy) NewRule(SequenceId uint32) (*NetworkInstance_PolicyForwarding_Policy_Rule, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[uint32]*NetworkInstance_PolicyForwarding_Policy_Rule)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Rule[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Rule", key)
	}

	t.Rule[key] = &NetworkInstance_PolicyForwarding_Policy_Rule{
		SequenceId: &SequenceId,
	}

	return t.Rule[key], nil
}

// RenameRule renames an entry in the list Rule within
// the NetworkInstance_PolicyForwarding_Policy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding_Policy) RenameRule(oldK, newK uint32) error {
	if _, ok := t.Rule[newK]; ok {
		return fmt.Errorf("key %v already exists in Rule", newK)
	}

	e, ok := t.Rule[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Rule", oldK)
	}
	e.SequenceId = &newK

	t.Rule[newK] = e
	delete(t.Rule, oldK)
	return nil
}

// GetOrCreateRule retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding_Policy) GetOrCreateRule(SequenceId uint32) *NetworkInstance_PolicyForwarding_Policy_Rule {

	key := SequenceId

	if v, ok := t.Rule[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRule(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRule got unexpected error: %v", err))
	}
	return v
}

// GetRule retrieves the value with the specified key from
// the Rule map field of NetworkInstance_PolicyForwarding_Policy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy) GetRule(SequenceId uint32) *NetworkInstance_PolicyForwarding_Policy_Rule {

	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Rule[key]; ok {
		return lm
	}
	return nil
}

// DeleteRule deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding_Policy) DeleteRule(SequenceId uint32) {
	key := SequenceId

	delete(t.Rule, key)
}

// AppendRule appends the supplied NetworkInstance_PolicyForwarding_Policy_Rule struct to the
// list Rule of NetworkInstance_PolicyForwarding_Policy. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy_Rule already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding_Policy) AppendRule(v *NetworkInstance_PolicyForwarding_Policy_Rule) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[uint32]*NetworkInstance_PolicyForwarding_Policy_Rule)
	}

	if _, ok := t.Rule[key]; ok {
		return fmt.Errorf("duplicate key for list Rule %v", key)
	}

	t.Rule[key] = v
	return nil
}

// GetPolicyId retrieves the value of the leaf PolicyId from the NetworkInstance_PolicyForwarding_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicyId is set, it can
// safely use t.GetPolicyId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicyId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy) GetPolicyId() string {
	if t == nil || t.PolicyId == nil {
		return ""
	}
	return *t.PolicyId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_PolicyForwarding_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy) GetType() E_Policy_Type {
	if t == nil || t.Type == 0 {
		return Policy_Type_PBR_POLICY
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = Policy_Type_PBR_POLICY
	}
	for _, e := range t.Rule {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PolicyId == nil {
		return nil, fmt.Errorf("nil value for key PolicyId")
	}

	return map[string]interface{}{
		"policy-id": *t.PolicyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule struct {
	Action        *NetworkInstance_PolicyForwarding_Policy_Rule_Action    `path:"action" module:"openconfig-network-instance"`
	Ipv4          *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4      `path:"ipv4" module:"openconfig-network-instance"`
	Ipv6          *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6      `path:"ipv6" module:"openconfig-network-instance"`
	L2            *NetworkInstance_PolicyForwarding_Policy_Rule_L2        `path:"l2" module:"openconfig-network-instance"`
	MatchedOctets *uint64                                                 `path:"state/matched-octets" module:"openconfig-network-instance/openconfig-network-instance"`
	MatchedPkts   *uint64                                                 `path:"state/matched-pkts" module:"openconfig-network-instance/openconfig-network-instance"`
	SequenceId    *uint32                                                 `path:"state/sequence-id|sequence-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/sequence-id|sequence-id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Transport     *NetworkInstance_PolicyForwarding_Policy_Rule_Transport `path:"transport" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateAction() *NetworkInstance_PolicyForwarding_Policy_Rule_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &NetworkInstance_PolicyForwarding_Policy_Rule_Action{}
	return t.Action
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateIpv4() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateIpv6() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6{}
	return t.Ipv6
}

// GetOrCreateL2 retrieves the value of the L2 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateL2() *NetworkInstance_PolicyForwarding_Policy_Rule_L2 {
	if t.L2 != nil {
		return t.L2
	}
	t.L2 = &NetworkInstance_PolicyForwarding_Policy_Rule_L2{}
	return t.L2
}

// GetOrCreateTransport retrieves the value of the Transport field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetOrCreateTransport() *NetworkInstance_PolicyForwarding_Policy_Rule_Transport {
	if t.Transport != nil {
		return t.Transport
	}
	t.Transport = &NetworkInstance_PolicyForwarding_Policy_Rule_Transport{}
	return t.Transport
}

// GetAction returns the value of the Action struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetAction() *NetworkInstance_PolicyForwarding_Policy_Rule_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetIpv4() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetIpv6() *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetL2 returns the value of the L2 struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field L2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetL2() *NetworkInstance_PolicyForwarding_Policy_Rule_L2 {
	if t != nil && t.L2 != nil {
		return t.L2
	}
	return nil
}

// GetTransport returns the value of the Transport struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule. If the receiver or the field Transport is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetTransport() *NetworkInstance_PolicyForwarding_Policy_Rule_Transport {
	if t != nil && t.Transport != nil {
		return t.Transport
	}
	return nil
}

// GetMatchedOctets retrieves the value of the leaf MatchedOctets from the NetworkInstance_PolicyForwarding_Policy_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedOctets is set, it can
// safely use t.GetMatchedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedOctets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetMatchedOctets() uint64 {
	if t == nil || t.MatchedOctets == nil {
		return 0
	}
	return *t.MatchedOctets
}

// GetMatchedPkts retrieves the value of the leaf MatchedPkts from the NetworkInstance_PolicyForwarding_Policy_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchedPkts is set, it can
// safely use t.GetMatchedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchedPkts == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetMatchedPkts() uint64 {
	if t == nil || t.MatchedPkts == nil {
		return 0
	}
	return *t.MatchedPkts
}

// GetSequenceId retrieves the value of the leaf SequenceId from the NetworkInstance_PolicyForwarding_Policy_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
	t.L2.PopulateDefaults()
	t.Transport.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy_Rule struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Action represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/action YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule_Action struct {
	DecapsulateGre       *bool                                                               `path:"state/decapsulate-gre" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/decapsulate-gre" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateGue       *bool                                                               `path:"state/decapsulate-gue" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/decapsulate-gue" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DecapsulateMplsInUdp *bool                                                               `path:"state/decapsulate-mpls-in-udp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/decapsulate-mpls-in-udp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Discard              *bool                                                               `path:"state/discard" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/discard" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	EncapsulateGre       *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre `path:"encapsulate-gre" module:"openconfig-network-instance"`
	NetworkInstance      *string                                                             `path:"state/network-instance" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/network-instance" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	NextHop              *string                                                             `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/next-hop" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PathSelectionGroup   *string                                                             `path:"state/path-selection-group" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/path-selection-group" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule_Action) IsYANGGoStruct() {}

// GetOrCreateEncapsulateGre retrieves the value of the EncapsulateGre field
// or returns the existing field if it already exists.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetOrCreateEncapsulateGre() *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre {
	if t.EncapsulateGre != nil {
		return t.EncapsulateGre
	}
	t.EncapsulateGre = &NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre{}
	return t.EncapsulateGre
}

// GetEncapsulateGre returns the value of the EncapsulateGre struct pointer
// from NetworkInstance_PolicyForwarding_Policy_Rule_Action. If the receiver or the field EncapsulateGre is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetEncapsulateGre() *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre {
	if t != nil && t.EncapsulateGre != nil {
		return t.EncapsulateGre
	}
	return nil
}

// GetDecapsulateGre retrieves the value of the leaf DecapsulateGre from the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateGre is set, it can
// safely use t.GetDecapsulateGre() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateGre == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetDecapsulateGre() bool {
	if t == nil || t.DecapsulateGre == nil {
		return false
	}
	return *t.DecapsulateGre
}

// GetDecapsulateGue retrieves the value of the leaf DecapsulateGue from the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateGue is set, it can
// safely use t.GetDecapsulateGue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateGue == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetDecapsulateGue() bool {
	if t == nil || t.DecapsulateGue == nil {
		return false
	}
	return *t.DecapsulateGue
}

// GetDecapsulateMplsInUdp retrieves the value of the leaf DecapsulateMplsInUdp from the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateMplsInUdp is set, it can
// safely use t.GetDecapsulateMplsInUdp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateMplsInUdp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetDecapsulateMplsInUdp() bool {
	if t == nil || t.DecapsulateMplsInUdp == nil {
		return false
	}
	return *t.DecapsulateMplsInUdp
}

// GetDiscard retrieves the value of the leaf Discard from the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Discard is set, it can
// safely use t.GetDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Discard == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetDiscard() bool {
	if t == nil || t.Discard == nil {
		return false
	}
	return *t.Discard
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPathSelectionGroup retrieves the value of the leaf PathSelectionGroup from the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathSelectionGroup is set, it can
// safely use t.GetPathSelectionGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathSelectionGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) GetPathSelectionGroup() string {
	if t == nil || t.PathSelectionGroup == nil {
		return ""
	}
	return *t.PathSelectionGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DecapsulateGre == nil {
		var v bool = false
		t.DecapsulateGre = &v
	}
	if t.DecapsulateGue == nil {
		var v bool = false
		t.DecapsulateGue = &v
	}
	if t.DecapsulateMplsInUdp == nil {
		var v bool = false
		t.DecapsulateMplsInUdp = &v
	}
	if t.Discard == nil {
		var v bool = false
		t.Discard = &v
	}
	t.EncapsulateGre.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/action/encapsulate-gre YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre struct {
	IdentifyingPrefix *string                                                                               `path:"state/identifying-prefix" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/identifying-prefix" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Target            map[string]*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target `path:"targets/target" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) IsYANGGoStruct() {}

// NewTarget creates a new entry in the Target list of the
// NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) NewTarget(Id string) (*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Target[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Target", key)
	}

	t.Target[key] = &NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target{
		Id: &Id,
	}

	return t.Target[key], nil
}

// RenameTarget renames an entry in the list Target within
// the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) RenameTarget(oldK, newK string) error {
	if _, ok := t.Target[newK]; ok {
		return fmt.Errorf("key %v already exists in Target", newK)
	}

	e, ok := t.Target[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Target", oldK)
	}
	e.Id = &newK

	t.Target[newK] = e
	delete(t.Target, oldK)
	return nil
}

// GetOrCreateTarget retrieves the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) GetOrCreateTarget(Id string) *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target {

	key := Id

	if v, ok := t.Target[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTarget(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTarget got unexpected error: %v", err))
	}
	return v
}

// GetTarget retrieves the value with the specified key from
// the Target map field of NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) GetTarget(Id string) *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Target[key]; ok {
		return lm
	}
	return nil
}

// DeleteTarget deletes the value with the specified keys from
// the receiver NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) DeleteTarget(Id string) {
	key := Id

	delete(t.Target, key)
}

// AppendTarget appends the supplied NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target struct to the
// list Target of NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre. If the key value(s) specified in
// the supplied NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target already exist in the list, an error is
// returned.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) AppendTarget(v *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target)
	}

	if _, ok := t.Target[key]; ok {
		return fmt.Errorf("duplicate key for list Target %v", key)
	}

	t.Target[key] = v
	return nil
}

// GetIdentifyingPrefix retrieves the value of the leaf IdentifyingPrefix from the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IdentifyingPrefix is set, it can
// safely use t.GetIdentifyingPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IdentifyingPrefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) GetIdentifyingPrefix() string {
	if t == nil || t.IdentifyingPrefix == nil {
		return ""
	}
	return *t.IdentifyingPrefix
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Target {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/action/encapsulate-gre/targets/target YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target struct {
	Destination *string `path:"state/destination" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Id          *string `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/id|id" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	IpTtl       *uint8  `path:"state/ip-ttl" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ip-ttl" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Source      *string `path:"state/source" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) IsYANGGoStruct() {}

// GetDestination retrieves the value of the leaf Destination from the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Destination is set, it can
// safely use t.GetDestination() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Destination == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) GetDestination() string {
	if t == nil || t.Destination == nil {
		return ""
	}
	return *t.Destination
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetIpTtl retrieves the value of the leaf IpTtl from the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpTtl is set, it can
// safely use t.GetIpTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpTtl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) GetIpTtl() uint8 {
	if t == nil || t.IpTtl == nil {
		return 0
	}
	return *t.IpTtl
}

// GetSource retrieves the value of the leaf Source from the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Source is set, it can
// safely use t.GetSource() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Source == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) GetSource() string {
	if t == nil || t.Source == nil {
		return ""
	}
	return *t.Source
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target struct, which is a YANG list entry.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Action_EncapsulateGre_Target) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/ipv4 YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 struct {
	DestinationAddress *string                                                          `path:"state/destination-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Dscp               *uint8                                                           `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/dscp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DscpSet            []uint8                                                          `path:"state/dscp-set" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/dscp-set" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HopLimit           *uint8                                                           `path:"state/hop-limit" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hop-limit" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Protocol           NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union `path:"state/protocol" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/protocol" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SourceAddress      *string                                                          `path:"state/source-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) IsYANGGoStruct() {}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) GetDestinationAddress() string {
	if t == nil || t.DestinationAddress == nil {
		return ""
	}
	return *t.DestinationAddress
}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) GetDscp() uint8 {
	if t == nil || t.Dscp == nil {
		return 0
	}
	return *t.Dscp
}

// GetDscpSet retrieves the value of the leaf DscpSet from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) GetDscpSet() []uint8 {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetHopLimit retrieves the value of the leaf HopLimit from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopLimit is set, it can
// safely use t.GetHopLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopLimit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) GetHopLimit() uint8 {
	if t == nil || t.HopLimit == nil {
		return 0
	}
	return *t.HopLimit
}

// GetProtocol retrieves the value of the leaf Protocol from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) GetProtocol() NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/ipv6 YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 struct {
	DestinationAddress   *string                                                          `path:"state/destination-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DestinationFlowLabel *uint32                                                          `path:"state/destination-flow-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination-flow-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Dscp                 *uint8                                                           `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/dscp" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DscpSet              []uint8                                                          `path:"state/dscp-set" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/dscp-set" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	HopLimit             *uint8                                                           `path:"state/hop-limit" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/hop-limit" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Protocol             NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union `path:"state/protocol" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/protocol" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SourceAddress        *string                                                          `path:"state/source-address" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-address" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SourceFlowLabel      *uint32                                                          `path:"state/source-flow-label" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-flow-label" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) IsYANGGoStruct() {}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetDestinationAddress() string {
	if t == nil || t.DestinationAddress == nil {
		return ""
	}
	return *t.DestinationAddress
}

// GetDestinationFlowLabel retrieves the value of the leaf DestinationFlowLabel from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationFlowLabel is set, it can
// safely use t.GetDestinationFlowLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationFlowLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetDestinationFlowLabel() uint32 {
	if t == nil || t.DestinationFlowLabel == nil {
		return 0
	}
	return *t.DestinationFlowLabel
}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetDscp() uint8 {
	if t == nil || t.Dscp == nil {
		return 0
	}
	return *t.Dscp
}

// GetDscpSet retrieves the value of the leaf DscpSet from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetDscpSet() []uint8 {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetHopLimit retrieves the value of the leaf HopLimit from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopLimit is set, it can
// safely use t.GetHopLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopLimit == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetHopLimit() uint8 {
	if t == nil || t.HopLimit == nil {
		return 0
	}
	return *t.HopLimit
}

// GetProtocol retrieves the value of the leaf Protocol from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetProtocol() NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// GetSourceFlowLabel retrieves the value of the leaf SourceFlowLabel from the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceFlowLabel is set, it can
// safely use t.GetSourceFlowLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceFlowLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) GetSourceFlowLabel() uint32 {
	if t == nil || t.SourceFlowLabel == nil {
		return 0
	}
	return *t.SourceFlowLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule_L2 represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/l2 YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule_L2 struct {
	DestinationMac     *string                                                         `path:"state/destination-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	DestinationMacMask *string                                                         `path:"state/destination-mac-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination-mac-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Ethertype          NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union `path:"state/ethertype" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/ethertype" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SourceMac          *string                                                         `path:"state/source-mac" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-mac" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SourceMacMask      *string                                                         `path:"state/source-mac-mask" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-mac-mask" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule_L2 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule_L2) IsYANGGoStruct() {}

// GetDestinationMac retrieves the value of the leaf DestinationMac from the NetworkInstance_PolicyForwarding_Policy_Rule_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationMac is set, it can
// safely use t.GetDestinationMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) GetDestinationMac() string {
	if t == nil || t.DestinationMac == nil {
		return ""
	}
	return *t.DestinationMac
}

// GetDestinationMacMask retrieves the value of the leaf DestinationMacMask from the NetworkInstance_PolicyForwarding_Policy_Rule_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationMacMask is set, it can
// safely use t.GetDestinationMacMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationMacMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) GetDestinationMacMask() string {
	if t == nil || t.DestinationMacMask == nil {
		return ""
	}
	return *t.DestinationMacMask
}

// GetEthertype retrieves the value of the leaf Ethertype from the NetworkInstance_PolicyForwarding_Policy_Rule_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ethertype is set, it can
// safely use t.GetEthertype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ethertype == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) GetEthertype() NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union {
	if t == nil || t.Ethertype == nil {
		return nil
	}
	return t.Ethertype
}

// GetSourceMac retrieves the value of the leaf SourceMac from the NetworkInstance_PolicyForwarding_Policy_Rule_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceMac is set, it can
// safely use t.GetSourceMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) GetSourceMac() string {
	if t == nil || t.SourceMac == nil {
		return ""
	}
	return *t.SourceMac
}

// GetSourceMacMask retrieves the value of the leaf SourceMacMask from the NetworkInstance_PolicyForwarding_Policy_Rule_L2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceMacMask is set, it can
// safely use t.GetSourceMacMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceMacMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) GetSourceMacMask() string {
	if t == nil || t.SourceMacMask == nil {
		return ""
	}
	return *t.SourceMacMask
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule_L2
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_L2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Transport represents the /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/transport YANG schema element.
type NetworkInstance_PolicyForwarding_Policy_Rule_Transport struct {
	DestinationPort NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union `path:"state/destination-port" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/destination-port" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SourcePort      NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union      `path:"state/source-port" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/source-port" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TcpFlags        []E_PacketMatchTypes_TCP_FLAGS                                               `path:"state/tcp-flags" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/tcp-flags" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_PolicyForwarding_Policy_Rule_Transport implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_PolicyForwarding_Policy_Rule_Transport) IsYANGGoStruct() {}

// GetDestinationPort retrieves the value of the leaf DestinationPort from the NetworkInstance_PolicyForwarding_Policy_Rule_Transport
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationPort is set, it can
// safely use t.GetDestinationPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) GetDestinationPort() NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union {
	if t == nil || t.DestinationPort == nil {
		return nil
	}
	return t.DestinationPort
}

// GetSourcePort retrieves the value of the leaf SourcePort from the NetworkInstance_PolicyForwarding_Policy_Rule_Transport
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourcePort is set, it can
// safely use t.GetSourcePort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourcePort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) GetSourcePort() NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union {
	if t == nil || t.SourcePort == nil {
		return nil
	}
	return t.SourcePort
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the NetworkInstance_PolicyForwarding_Policy_Rule_Transport
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) GetTcpFlags() []E_PacketMatchTypes_TCP_FLAGS {
	if t == nil || t.TcpFlags == nil {
		return nil
	}
	return t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_PolicyForwarding_Policy_Rule_Transport
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_PolicyForwarding_Policy_Rule_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol YANG schema element.
type NetworkInstance_Protocol struct {
	Aggregate     map[string]*NetworkInstance_Protocol_Aggregate `path:"local-aggregates/aggregate" module:"openconfig-network-instance/openconfig-network-instance"`
	Bgp           *NetworkInstance_Protocol_Bgp                  `path:"bgp" module:"openconfig-network-instance"`
	DefaultMetric *uint32                                        `path:"state/default-metric" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/default-metric" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Enabled       *bool                                          `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Identifier    E_PolicyTypes_INSTALL_PROTOCOL_TYPE            `path:"state/identifier|identifier" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/identifier|identifier" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Igmp          *NetworkInstance_Protocol_Igmp                 `path:"igmp" module:"openconfig-network-instance"`
	Isis          *NetworkInstance_Protocol_Isis                 `path:"isis" module:"openconfig-network-instance"`
	Name          *string                                        `path:"state/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/name|name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Ospfv2        *NetworkInstance_Protocol_Ospfv2               `path:"ospfv2" module:"openconfig-network-instance"`
	Pim           *NetworkInstance_Protocol_Pim                  `path:"pim" module:"openconfig-network-instance"`
	Static        map[string]*NetworkInstance_Protocol_Static    `path:"static-routes/static" module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol) IsYANGGoStruct() {}

// NewAggregate creates a new entry in the Aggregate list of the
// NetworkInstance_Protocol struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol) NewAggregate(Prefix string) (*NetworkInstance_Protocol_Aggregate, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*NetworkInstance_Protocol_Aggregate)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Aggregate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Aggregate", key)
	}

	t.Aggregate[key] = &NetworkInstance_Protocol_Aggregate{
		Prefix: &Prefix,
	}

	return t.Aggregate[key], nil
}

// RenameAggregate renames an entry in the list Aggregate within
// the NetworkInstance_Protocol struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol) RenameAggregate(oldK, newK string) error {
	if _, ok := t.Aggregate[newK]; ok {
		return fmt.Errorf("key %v already exists in Aggregate", newK)
	}

	e, ok := t.Aggregate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Aggregate", oldK)
	}
	e.Prefix = &newK

	t.Aggregate[newK] = e
	delete(t.Aggregate, oldK)
	return nil
}

// GetOrCreateAggregate retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol) GetOrCreateAggregate(Prefix string) *NetworkInstance_Protocol_Aggregate {

	key := Prefix

	if v, ok := t.Aggregate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAggregate(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAggregate got unexpected error: %v", err))
	}
	return v
}

// GetAggregate retrieves the value with the specified key from
// the Aggregate map field of NetworkInstance_Protocol. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol) GetAggregate(Prefix string) *NetworkInstance_Protocol_Aggregate {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Aggregate[key]; ok {
		return lm
	}
	return nil
}

// DeleteAggregate deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol) DeleteAggregate(Prefix string) {
	key := Prefix

	delete(t.Aggregate, key)
}

// AppendAggregate appends the supplied NetworkInstance_Protocol_Aggregate struct to the
// list Aggregate of NetworkInstance_Protocol. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Aggregate already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol) AppendAggregate(v *NetworkInstance_Protocol_Aggregate) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aggregate == nil {
		t.Aggregate = make(map[string]*NetworkInstance_Protocol_Aggregate)
	}

	if _, ok := t.Aggregate[key]; ok {
		return fmt.Errorf("duplicate key for list Aggregate %v", key)
	}

	t.Aggregate[key] = v
	return nil
}

// NewStatic creates a new entry in the Static list of the
// NetworkInstance_Protocol struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol) NewStatic(Prefix string) (*NetworkInstance_Protocol_Static, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*NetworkInstance_Protocol_Static)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Static[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Static", key)
	}

	t.Static[key] = &NetworkInstance_Protocol_Static{
		Prefix: &Prefix,
	}

	return t.Static[key], nil
}

// RenameStatic renames an entry in the list Static within
// the NetworkInstance_Protocol struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol) RenameStatic(oldK, newK string) error {
	if _, ok := t.Static[newK]; ok {
		return fmt.Errorf("key %v already exists in Static", newK)
	}

	e, ok := t.Static[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Static", oldK)
	}
	e.Prefix = &newK

	t.Static[newK] = e
	delete(t.Static, oldK)
	return nil
}

// GetOrCreateStatic retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol) GetOrCreateStatic(Prefix string) *NetworkInstance_Protocol_Static {

	key := Prefix

	if v, ok := t.Static[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatic(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatic got unexpected error: %v", err))
	}
	return v
}

// GetStatic retrieves the value with the specified key from
// the Static map field of NetworkInstance_Protocol. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol) GetStatic(Prefix string) *NetworkInstance_Protocol_Static {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Static[key]; ok {
		return lm
	}
	return nil
}

// DeleteStatic deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol) DeleteStatic(Prefix string) {
	key := Prefix

	delete(t.Static, key)
}

// AppendStatic appends the supplied NetworkInstance_Protocol_Static struct to the
// list Static of NetworkInstance_Protocol. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Static already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol) AppendStatic(v *NetworkInstance_Protocol_Static) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*NetworkInstance_Protocol_Static)
	}

	if _, ok := t.Static[key]; ok {
		return fmt.Errorf("duplicate key for list Static %v", key)
	}

	t.Static[key] = v
	return nil
}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateBgp() *NetworkInstance_Protocol_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &NetworkInstance_Protocol_Bgp{}
	return t.Bgp
}

// GetOrCreateIgmp retrieves the value of the Igmp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateIgmp() *NetworkInstance_Protocol_Igmp {
	if t.Igmp != nil {
		return t.Igmp
	}
	t.Igmp = &NetworkInstance_Protocol_Igmp{}
	return t.Igmp
}

// GetOrCreateIsis retrieves the value of the Isis field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateIsis() *NetworkInstance_Protocol_Isis {
	if t.Isis != nil {
		return t.Isis
	}
	t.Isis = &NetworkInstance_Protocol_Isis{}
	return t.Isis
}

// GetOrCreateOspfv2 retrieves the value of the Ospfv2 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreateOspfv2() *NetworkInstance_Protocol_Ospfv2 {
	if t.Ospfv2 != nil {
		return t.Ospfv2
	}
	t.Ospfv2 = &NetworkInstance_Protocol_Ospfv2{}
	return t.Ospfv2
}

// GetOrCreatePim retrieves the value of the Pim field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol) GetOrCreatePim() *NetworkInstance_Protocol_Pim {
	if t.Pim != nil {
		return t.Pim
	}
	t.Pim = &NetworkInstance_Protocol_Pim{}
	return t.Pim
}

// GetBgp returns the value of the Bgp struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetBgp() *NetworkInstance_Protocol_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetIgmp returns the value of the Igmp struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Igmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetIgmp() *NetworkInstance_Protocol_Igmp {
	if t != nil && t.Igmp != nil {
		return t.Igmp
	}
	return nil
}

// GetIsis returns the value of the Isis struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Isis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetIsis() *NetworkInstance_Protocol_Isis {
	if t != nil && t.Isis != nil {
		return t.Isis
	}
	return nil
}

// GetOspfv2 returns the value of the Ospfv2 struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Ospfv2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetOspfv2() *NetworkInstance_Protocol_Ospfv2 {
	if t != nil && t.Ospfv2 != nil {
		return t.Ospfv2
	}
	return nil
}

// GetPim returns the value of the Pim struct pointer
// from NetworkInstance_Protocol. If the receiver or the field Pim is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol) GetPim() *NetworkInstance_Protocol_Pim {
	if t != nil && t.Pim != nil {
		return t.Pim
	}
	return nil
}

// GetDefaultMetric retrieves the value of the leaf DefaultMetric from the NetworkInstance_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultMetric is set, it can
// safely use t.GetDefaultMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol) GetDefaultMetric() uint32 {
	if t == nil || t.DefaultMetric == nil {
		return 0
	}
	return *t.DefaultMetric
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetIdentifier retrieves the value of the leaf Identifier from the NetworkInstance_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Identifier is set, it can
// safely use t.GetIdentifier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Identifier == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol) GetIdentifier() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.Identifier == 0 {
		return 0
	}
	return t.Identifier
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
	t.Igmp.PopulateDefaults()
	t.Isis.PopulateDefaults()
	t.Ospfv2.PopulateDefaults()
	t.Pim.PopulateDefaults()
	for _, e := range t.Aggregate {
		e.PopulateDefaults()
	}
	for _, e := range t.Static {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol) ΛListKeyMap() (map[string]interface{}, error) {

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"identifier": t.Identifier,
		"name":       *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NetworkInstance_Protocol_Aggregate represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/local-aggregates/aggregate YANG schema element.
type NetworkInstance_Protocol_Aggregate struct {
	Description *string                                         `path:"state/description" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/description" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Discard     *bool                                           `path:"state/discard" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/discard" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Prefix      *string                                         `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/prefix|prefix" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	SetTag      NetworkInstance_Protocol_Aggregate_SetTag_Union `path:"state/set-tag" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/set-tag" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Aggregate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Aggregate) IsYANGGoStruct() {}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_Protocol_Aggregate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Aggregate) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetDiscard retrieves the value of the leaf Discard from the NetworkInstance_Protocol_Aggregate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Discard is set, it can
// safely use t.GetDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Discard == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Aggregate) GetDiscard() bool {
	if t == nil || t.Discard == nil {
		return false
	}
	return *t.Discard
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Protocol_Aggregate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Aggregate) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetSetTag retrieves the value of the leaf SetTag from the NetworkInstance_Protocol_Aggregate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetTag is set, it can
// safely use t.GetSetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetTag == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Aggregate) GetSetTag() NetworkInstance_Protocol_Aggregate_SetTag_Union {
	if t == nil || t.SetTag == nil {
		return nil
	}
	return t.SetTag
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Aggregate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Aggregate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Discard == nil {
		var v bool = false
		t.Discard = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Aggregate struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Aggregate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Aggregate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Aggregate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Aggregate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp YANG schema element.
type NetworkInstance_Protocol_Bgp struct {
	Global    *NetworkInstance_Protocol_Bgp_Global               `path:"global" module:"openconfig-network-instance"`
	Neighbor  map[string]*NetworkInstance_Protocol_Bgp_Neighbor  `path:"neighbors/neighbor" module:"openconfig-network-instance/openconfig-network-instance"`
	PeerGroup map[string]*NetworkInstance_Protocol_Bgp_PeerGroup `path:"peer-groups/peer-group" module:"openconfig-network-instance/openconfig-network-instance"`
	Rib       *NetworkInstance_Protocol_Bgp_Rib                  `path:"rib" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Protocol_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp) NewNeighbor(NeighborAddress string) (*NetworkInstance_Protocol_Bgp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Bgp_Neighbor)
	}

	key := NeighborAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Protocol_Bgp_Neighbor{
		NeighborAddress: &NeighborAddress,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Protocol_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.NeighborAddress = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreateNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Bgp_Neighbor {

	key := NeighborAddress

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(NeighborAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Protocol_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetNeighbor(NeighborAddress string) *NetworkInstance_Protocol_Bgp_Neighbor {

	if t == nil {
		return nil
	}

	key := NeighborAddress

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp) DeleteNeighbor(NeighborAddress string) {
	key := NeighborAddress

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Protocol_Bgp_Neighbor struct to the
// list Neighbor of NetworkInstance_Protocol_Bgp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp) AppendNeighbor(v *NetworkInstance_Protocol_Bgp_Neighbor) error {
	if v.NeighborAddress == nil {
		return fmt.Errorf("invalid nil key received for NeighborAddress")
	}

	key := *v.NeighborAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*NetworkInstance_Protocol_Bgp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// NewPeerGroup creates a new entry in the PeerGroup list of the
// NetworkInstance_Protocol_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp) NewPeerGroup(PeerGroupName string) (*NetworkInstance_Protocol_Bgp_PeerGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*NetworkInstance_Protocol_Bgp_PeerGroup)
	}

	key := PeerGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PeerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PeerGroup", key)
	}

	t.PeerGroup[key] = &NetworkInstance_Protocol_Bgp_PeerGroup{
		PeerGroupName: &PeerGroupName,
	}

	return t.PeerGroup[key], nil
}

// RenamePeerGroup renames an entry in the list PeerGroup within
// the NetworkInstance_Protocol_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp) RenamePeerGroup(oldK, newK string) error {
	if _, ok := t.PeerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in PeerGroup", newK)
	}

	e, ok := t.PeerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PeerGroup", oldK)
	}
	e.PeerGroupName = &newK

	t.PeerGroup[newK] = e
	delete(t.PeerGroup, oldK)
	return nil
}

// GetOrCreatePeerGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreatePeerGroup(PeerGroupName string) *NetworkInstance_Protocol_Bgp_PeerGroup {

	key := PeerGroupName

	if v, ok := t.PeerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPeerGroup(PeerGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePeerGroup got unexpected error: %v", err))
	}
	return v
}

// GetPeerGroup retrieves the value with the specified key from
// the PeerGroup map field of NetworkInstance_Protocol_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetPeerGroup(PeerGroupName string) *NetworkInstance_Protocol_Bgp_PeerGroup {

	if t == nil {
		return nil
	}

	key := PeerGroupName

	if lm, ok := t.PeerGroup[key]; ok {
		return lm
	}
	return nil
}

// DeletePeerGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp) DeletePeerGroup(PeerGroupName string) {
	key := PeerGroupName

	delete(t.PeerGroup, key)
}

// AppendPeerGroup appends the supplied NetworkInstance_Protocol_Bgp_PeerGroup struct to the
// list PeerGroup of NetworkInstance_Protocol_Bgp. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_PeerGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp) AppendPeerGroup(v *NetworkInstance_Protocol_Bgp_PeerGroup) error {
	if v.PeerGroupName == nil {
		return fmt.Errorf("invalid nil key received for PeerGroupName")
	}

	key := *v.PeerGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PeerGroup == nil {
		t.PeerGroup = make(map[string]*NetworkInstance_Protocol_Bgp_PeerGroup)
	}

	if _, ok := t.PeerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list PeerGroup %v", key)
	}

	t.PeerGroup[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreateGlobal() *NetworkInstance_Protocol_Bgp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Protocol_Bgp_Global{}
	return t.Global
}

// GetOrCreateRib retrieves the value of the Rib field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp) GetOrCreateRib() *NetworkInstance_Protocol_Bgp_Rib {
	if t.Rib != nil {
		return t.Rib
	}
	t.Rib = &NetworkInstance_Protocol_Bgp_Rib{}
	return t.Rib
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Protocol_Bgp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetGlobal() *NetworkInstance_Protocol_Bgp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetRib returns the value of the Rib struct pointer
// from NetworkInstance_Protocol_Bgp. If the receiver or the field Rib is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp) GetRib() *NetworkInstance_Protocol_Bgp_Rib {
	if t != nil && t.Rib != nil {
		return t.Rib
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	t.Rib.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
	for _, e := range t.PeerGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// NetworkInstance_Protocol_Bgp_Global represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global YANG schema element.
type NetworkInstance_Protocol_Bgp_Global struct {
	AfiSafi               map[E_BgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Global_AfiSafi `path:"afi-safis/afi-safi" module:"openconfig-network-instance/openconfig-network-instance"`
	As                    *uint32                                                                   `path:"state/as" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/as" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Confederation         *NetworkInstance_Protocol_Bgp_Global_Confederation                        `path:"confederation" module:"openconfig-network-instance"`
	DefaultRouteDistance  *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance                 `path:"default-route-distance" module:"openconfig-network-instance"`
	DynamicNeighborPrefix map[string]*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix     `path:"dynamic-neighbor-prefixes/dynamic-neighbor-prefix" module:"openconfig-network-instance/openconfig-network-instance"`
	GracefulRestart       *NetworkInstance_Protocol_Bgp_Global_GracefulRestart                      `path:"graceful-restart" module:"openconfig-network-instance"`
	RouteSelectionOptions *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions                `path:"route-selection-options" module:"openconfig-network-instance"`
	RouterId              *string                                                                   `path:"state/router-id" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/router-id" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	TotalPaths            *uint32                                                                   `path:"state/total-paths" module:"openconfig-network-instance/openconfig-network-instance"`
	TotalPrefixes         *uint32                                                                   `path:"state/total-prefixes" module:"openconfig-network-instance/openconfig-network-instance"`
	UseMultiplePaths      *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths                     `path:"use-multiple-paths" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global) IsYANGGoStruct() {}

// NewAfiSafi creates a new entry in the AfiSafi list of the
// NetworkInstance_Protocol_Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Global) NewAfiSafi(AfiSafiName E_BgpTypes_AFI_SAFI_TYPE) (*NetworkInstance_Protocol_Bgp_Global_AfiSafi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_BgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Global_AfiSafi)
	}

	key := AfiSafiName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &NetworkInstance_Protocol_Bgp_Global_AfiSafi{
		AfiSafiName: AfiSafiName,
	}

	return t.AfiSafi[key], nil
}

// RenameAfiSafi renames an entry in the list AfiSafi within
// the NetworkInstance_Protocol_Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Global) RenameAfiSafi(oldK, newK E_BgpTypes_AFI_SAFI_TYPE) error {
	if _, ok := t.AfiSafi[newK]; ok {
		return fmt.Errorf("key %v already exists in AfiSafi", newK)
	}

	e, ok := t.AfiSafi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AfiSafi", oldK)
	}
	e.AfiSafiName = newK

	t.AfiSafi[newK] = e
	delete(t.AfiSafi, oldK)
	return nil
}

// GetOrCreateAfiSafi retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateAfiSafi(AfiSafiName E_BgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Global_AfiSafi {

	key := AfiSafiName

	if v, ok := t.AfiSafi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAfiSafi(AfiSafiName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAfiSafi got unexpected error: %v", err))
	}
	return v
}

// GetAfiSafi retrieves the value with the specified key from
// the AfiSafi map field of NetworkInstance_Protocol_Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetAfiSafi(AfiSafiName E_BgpTypes_AFI_SAFI_TYPE) *NetworkInstance_Protocol_Bgp_Global_AfiSafi {

	if t == nil {
		return nil
	}

	key := AfiSafiName

	if lm, ok := t.AfiSafi[key]; ok {
		return lm
	}
	return nil
}

// DeleteAfiSafi deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp_Global) DeleteAfiSafi(AfiSafiName E_BgpTypes_AFI_SAFI_TYPE) {
	key := AfiSafiName

	delete(t.AfiSafi, key)
}

// AppendAfiSafi appends the supplied NetworkInstance_Protocol_Bgp_Global_AfiSafi struct to the
// list AfiSafi of NetworkInstance_Protocol_Bgp_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Global_AfiSafi already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Global) AppendAfiSafi(v *NetworkInstance_Protocol_Bgp_Global_AfiSafi) error {
	key := v.AfiSafiName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_BgpTypes_AFI_SAFI_TYPE]*NetworkInstance_Protocol_Bgp_Global_AfiSafi)
	}

	if _, ok := t.AfiSafi[key]; ok {
		return fmt.Errorf("duplicate key for list AfiSafi %v", key)
	}

	t.AfiSafi[key] = v
	return nil
}

// NewDynamicNeighborPrefix creates a new entry in the DynamicNeighborPrefix list of the
// NetworkInstance_Protocol_Bgp_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Protocol_Bgp_Global) NewDynamicNeighborPrefix(Prefix string) (*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DynamicNeighborPrefix", key)
	}

	t.DynamicNeighborPrefix[key] = &NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix{
		Prefix: &Prefix,
	}

	return t.DynamicNeighborPrefix[key], nil
}

// RenameDynamicNeighborPrefix renames an entry in the list DynamicNeighborPrefix within
// the NetworkInstance_Protocol_Bgp_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Protocol_Bgp_Global) RenameDynamicNeighborPrefix(oldK, newK string) error {
	if _, ok := t.DynamicNeighborPrefix[newK]; ok {
		return fmt.Errorf("key %v already exists in DynamicNeighborPrefix", newK)
	}

	e, ok := t.DynamicNeighborPrefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DynamicNeighborPrefix", oldK)
	}
	e.Prefix = &newK

	t.DynamicNeighborPrefix[newK] = e
	delete(t.DynamicNeighborPrefix, oldK)
	return nil
}

// GetOrCreateDynamicNeighborPrefix retrieves the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateDynamicNeighborPrefix(Prefix string) *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix {

	key := Prefix

	if v, ok := t.DynamicNeighborPrefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDynamicNeighborPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDynamicNeighborPrefix got unexpected error: %v", err))
	}
	return v
}

// GetDynamicNeighborPrefix retrieves the value with the specified key from
// the DynamicNeighborPrefix map field of NetworkInstance_Protocol_Bgp_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetDynamicNeighborPrefix(Prefix string) *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.DynamicNeighborPrefix[key]; ok {
		return lm
	}
	return nil
}

// DeleteDynamicNeighborPrefix deletes the value with the specified keys from
// the receiver NetworkInstance_Protocol_Bgp_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Protocol_Bgp_Global) DeleteDynamicNeighborPrefix(Prefix string) {
	key := Prefix

	delete(t.DynamicNeighborPrefix, key)
}

// AppendDynamicNeighborPrefix appends the supplied NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix struct to the
// list DynamicNeighborPrefix of NetworkInstance_Protocol_Bgp_Global. If the key value(s) specified in
// the supplied NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix already exist in the list, an error is
// returned.
func (t *NetworkInstance_Protocol_Bgp_Global) AppendDynamicNeighborPrefix(v *NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DynamicNeighborPrefix == nil {
		t.DynamicNeighborPrefix = make(map[string]*NetworkInstance_Protocol_Bgp_Global_DynamicNeighborPrefix)
	}

	if _, ok := t.DynamicNeighborPrefix[key]; ok {
		return fmt.Errorf("duplicate key for list DynamicNeighborPrefix %v", key)
	}

	t.DynamicNeighborPrefix[key] = v
	return nil
}

// GetOrCreateConfederation retrieves the value of the Confederation field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateConfederation() *NetworkInstance_Protocol_Bgp_Global_Confederation {
	if t.Confederation != nil {
		return t.Confederation
	}
	t.Confederation = &NetworkInstance_Protocol_Bgp_Global_Confederation{}
	return t.Confederation
}

// GetOrCreateDefaultRouteDistance retrieves the value of the DefaultRouteDistance field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateDefaultRouteDistance() *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance {
	if t.DefaultRouteDistance != nil {
		return t.DefaultRouteDistance
	}
	t.DefaultRouteDistance = &NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance{}
	return t.DefaultRouteDistance
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions {
	if t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	t.RouteSelectionOptions = &NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions{}
	return t.RouteSelectionOptions
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetConfederation returns the value of the Confederation struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field Confederation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetConfederation() *NetworkInstance_Protocol_Bgp_Global_Confederation {
	if t != nil && t.Confederation != nil {
		return t.Confederation
	}
	return nil
}

// GetDefaultRouteDistance returns the value of the DefaultRouteDistance struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field DefaultRouteDistance is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetDefaultRouteDistance() *NetworkInstance_Protocol_Bgp_Global_DefaultRouteDistance {
	if t != nil && t.DefaultRouteDistance != nil {
		return t.DefaultRouteDistance
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_RouteSelectionOptions {
	if t != nil && t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// GetAs retrieves the value of the leaf As from the NetworkInstance_Protocol_Bgp_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if As is set, it can
// safely use t.GetAs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.As == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global) GetAs() uint32 {
	if t == nil || t.As == nil {
		return 0
	}
	return *t.As
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance_Protocol_Bgp_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetTotalPaths retrieves the value of the leaf TotalPaths from the NetworkInstance_Protocol_Bgp_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalPaths is set, it can
// safely use t.GetTotalPaths() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalPaths == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global) GetTotalPaths() uint32 {
	if t == nil || t.TotalPaths == nil {
		return 0
	}
	return *t.TotalPaths
}

// GetTotalPrefixes retrieves the value of the leaf TotalPrefixes from the NetworkInstance_Protocol_Bgp_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalPrefixes is set, it can
// safely use t.GetTotalPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global) GetTotalPrefixes() uint32 {
	if t == nil || t.TotalPrefixes == nil {
		return 0
	}
	return *t.TotalPrefixes
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Confederation.PopulateDefaults()
	t.DefaultRouteDistance.PopulateDefaults()
	t.GracefulRestart.PopulateDefaults()
	t.RouteSelectionOptions.PopulateDefaults()
	t.UseMultiplePaths.PopulateDefaults()
	for _, e := range t.AfiSafi {
		e.PopulateDefaults()
	}
	for _, e := range t.DynamicNeighborPrefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi struct {
	AddPaths              *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths              `path:"add-paths" module:"openconfig-network-instance"`
	AfiSafiName           E_BgpTypes_AFI_SAFI_TYPE                                           `path:"state/afi-safi-name|afi-safi-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance" shadow-path:"config/afi-safi-name|afi-safi-name" shadow-module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	Enabled               *bool                                                              `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	GracefulRestart       *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart       `path:"graceful-restart" module:"openconfig-network-instance"`
	Ipv4LabeledUnicast    *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast    `path:"ipv4-labeled-unicast" module:"openconfig-network-instance"`
	Ipv4Unicast           *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast           `path:"ipv4-unicast" module:"openconfig-network-instance"`
	Ipv6LabeledUnicast    *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast    `path:"ipv6-labeled-unicast" module:"openconfig-network-instance"`
	Ipv6Unicast           *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast           `path:"ipv6-unicast" module:"openconfig-network-instance"`
	L2VpnEvpn             *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn             `path:"l2vpn-evpn" module:"openconfig-network-instance"`
	L2VpnVpls             *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls             `path:"l2vpn-vpls" module:"openconfig-network-instance"`
	L3VpnIpv4Multicast    *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast    `path:"l3vpn-ipv4-multicast" module:"openconfig-network-instance"`
	L3VpnIpv4Unicast      *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast      `path:"l3vpn-ipv4-unicast" module:"openconfig-network-instance"`
	L3VpnIpv6Multicast    *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast    `path:"l3vpn-ipv6-multicast" module:"openconfig-network-instance"`
	L3VpnIpv6Unicast      *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast      `path:"l3vpn-ipv6-unicast" module:"openconfig-network-instance"`
	RouteSelectionOptions *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions `path:"route-selection-options" module:"openconfig-network-instance"`
	SrtePolicyIpv4        *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4        `path:"srte-policy-ipv4" module:"openconfig-network-instance"`
	SrtePolicyIpv6        *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6        `path:"srte-policy-ipv6" module:"openconfig-network-instance"`
	TotalPaths            *uint32                                                            `path:"state/total-paths" module:"openconfig-network-instance/openconfig-network-instance"`
	TotalPrefixes         *uint32                                                            `path:"state/total-prefixes" module:"openconfig-network-instance/openconfig-network-instance"`
	UseMultiplePaths      *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths      `path:"use-multiple-paths" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi) IsYANGGoStruct() {}

// GetOrCreateAddPaths retrieves the value of the AddPaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateAddPaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths {
	if t.AddPaths != nil {
		return t.AddPaths
	}
	t.AddPaths = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths{}
	return t.AddPaths
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart{}
	return t.GracefulRestart
}

// GetOrCreateIpv4LabeledUnicast retrieves the value of the Ipv4LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	t.Ipv4LabeledUnicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast{}
	return t.Ipv4LabeledUnicast
}

// GetOrCreateIpv4Unicast retrieves the value of the Ipv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast {
	if t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	t.Ipv4Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast{}
	return t.Ipv4Unicast
}

// GetOrCreateIpv6LabeledUnicast retrieves the value of the Ipv6LabeledUnicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	t.Ipv6LabeledUnicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast{}
	return t.Ipv6LabeledUnicast
}

// GetOrCreateIpv6Unicast retrieves the value of the Ipv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast {
	if t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	t.Ipv6Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast{}
	return t.Ipv6Unicast
}

// GetOrCreateL2VpnEvpn retrieves the value of the L2VpnEvpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn {
	if t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	t.L2VpnEvpn = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn{}
	return t.L2VpnEvpn
}

// GetOrCreateL2VpnVpls retrieves the value of the L2VpnVpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL2VpnVpls() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls {
	if t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	t.L2VpnVpls = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls{}
	return t.L2VpnVpls
}

// GetOrCreateL3VpnIpv4Multicast retrieves the value of the L3VpnIpv4Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	t.L3VpnIpv4Multicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast{}
	return t.L3VpnIpv4Multicast
}

// GetOrCreateL3VpnIpv4Unicast retrieves the value of the L3VpnIpv4Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	t.L3VpnIpv4Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast{}
	return t.L3VpnIpv4Unicast
}

// GetOrCreateL3VpnIpv6Multicast retrieves the value of the L3VpnIpv6Multicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	t.L3VpnIpv6Multicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast{}
	return t.L3VpnIpv6Multicast
}

// GetOrCreateL3VpnIpv6Unicast retrieves the value of the L3VpnIpv6Unicast field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	t.L3VpnIpv6Unicast = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast{}
	return t.L3VpnIpv6Unicast
}

// GetOrCreateRouteSelectionOptions retrieves the value of the RouteSelectionOptions field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions {
	if t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	t.RouteSelectionOptions = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions{}
	return t.RouteSelectionOptions
}

// GetOrCreateSrtePolicyIpv4 retrieves the value of the SrtePolicyIpv4 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	t.SrtePolicyIpv4 = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4{}
	return t.SrtePolicyIpv4
}

// GetOrCreateSrtePolicyIpv6 retrieves the value of the SrtePolicyIpv6 field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	t.SrtePolicyIpv6 = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6{}
	return t.SrtePolicyIpv6
}

// GetOrCreateUseMultiplePaths retrieves the value of the UseMultiplePaths field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetOrCreateUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths {
	if t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	t.UseMultiplePaths = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths{}
	return t.UseMultiplePaths
}

// GetAddPaths returns the value of the AddPaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field AddPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetAddPaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths {
	if t != nil && t.AddPaths != nil {
		return t.AddPaths
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetGracefulRestart() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetIpv4LabeledUnicast returns the value of the Ipv4LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv4LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv4LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast {
	if t != nil && t.Ipv4LabeledUnicast != nil {
		return t.Ipv4LabeledUnicast
	}
	return nil
}

// GetIpv4Unicast returns the value of the Ipv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast {
	if t != nil && t.Ipv4Unicast != nil {
		return t.Ipv4Unicast
	}
	return nil
}

// GetIpv6LabeledUnicast returns the value of the Ipv6LabeledUnicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv6LabeledUnicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv6LabeledUnicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast {
	if t != nil && t.Ipv6LabeledUnicast != nil {
		return t.Ipv6LabeledUnicast
	}
	return nil
}

// GetIpv6Unicast returns the value of the Ipv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field Ipv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast {
	if t != nil && t.Ipv6Unicast != nil {
		return t.Ipv6Unicast
	}
	return nil
}

// GetL2VpnEvpn returns the value of the L2VpnEvpn struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L2VpnEvpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL2VpnEvpn() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn {
	if t != nil && t.L2VpnEvpn != nil {
		return t.L2VpnEvpn
	}
	return nil
}

// GetL2VpnVpls returns the value of the L2VpnVpls struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L2VpnVpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL2VpnVpls() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls {
	if t != nil && t.L2VpnVpls != nil {
		return t.L2VpnVpls
	}
	return nil
}

// GetL3VpnIpv4Multicast returns the value of the L3VpnIpv4Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv4Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast {
	if t != nil && t.L3VpnIpv4Multicast != nil {
		return t.L3VpnIpv4Multicast
	}
	return nil
}

// GetL3VpnIpv4Unicast returns the value of the L3VpnIpv4Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv4Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv4Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast {
	if t != nil && t.L3VpnIpv4Unicast != nil {
		return t.L3VpnIpv4Unicast
	}
	return nil
}

// GetL3VpnIpv6Multicast returns the value of the L3VpnIpv6Multicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv6Multicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Multicast {
	if t != nil && t.L3VpnIpv6Multicast != nil {
		return t.L3VpnIpv6Multicast
	}
	return nil
}

// GetL3VpnIpv6Unicast returns the value of the L3VpnIpv6Unicast struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field L3VpnIpv6Unicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetL3VpnIpv6Unicast() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv6Unicast {
	if t != nil && t.L3VpnIpv6Unicast != nil {
		return t.L3VpnIpv6Unicast
	}
	return nil
}

// GetRouteSelectionOptions returns the value of the RouteSelectionOptions struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field RouteSelectionOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetRouteSelectionOptions() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_RouteSelectionOptions {
	if t != nil && t.RouteSelectionOptions != nil {
		return t.RouteSelectionOptions
	}
	return nil
}

// GetSrtePolicyIpv4 returns the value of the SrtePolicyIpv4 struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetSrtePolicyIpv4() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv4 {
	if t != nil && t.SrtePolicyIpv4 != nil {
		return t.SrtePolicyIpv4
	}
	return nil
}

// GetSrtePolicyIpv6 returns the value of the SrtePolicyIpv6 struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field SrtePolicyIpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetSrtePolicyIpv6() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_SrtePolicyIpv6 {
	if t != nil && t.SrtePolicyIpv6 != nil {
		return t.SrtePolicyIpv6
	}
	return nil
}

// GetUseMultiplePaths returns the value of the UseMultiplePaths struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi. If the receiver or the field UseMultiplePaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetUseMultiplePaths() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_UseMultiplePaths {
	if t != nil && t.UseMultiplePaths != nil {
		return t.UseMultiplePaths
	}
	return nil
}

// GetAfiSafiName retrieves the value of the leaf AfiSafiName from the NetworkInstance_Protocol_Bgp_Global_AfiSafi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AfiSafiName is set, it can
// safely use t.GetAfiSafiName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AfiSafiName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetAfiSafiName() E_BgpTypes_AFI_SAFI_TYPE {
	if t == nil || t.AfiSafiName == 0 {
		return 0
	}
	return t.AfiSafiName
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Bgp_Global_AfiSafi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetTotalPaths retrieves the value of the leaf TotalPaths from the NetworkInstance_Protocol_Bgp_Global_AfiSafi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalPaths is set, it can
// safely use t.GetTotalPaths() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalPaths == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetTotalPaths() uint32 {
	if t == nil || t.TotalPaths == nil {
		return 0
	}
	return *t.TotalPaths
}

// GetTotalPrefixes retrieves the value of the leaf TotalPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalPrefixes is set, it can
// safely use t.GetTotalPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) GetTotalPrefixes() uint32 {
	if t == nil || t.TotalPrefixes == nil {
		return 0
	}
	return *t.TotalPrefixes
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.AddPaths.PopulateDefaults()
	t.GracefulRestart.PopulateDefaults()
	t.Ipv4LabeledUnicast.PopulateDefaults()
	t.Ipv4Unicast.PopulateDefaults()
	t.Ipv6LabeledUnicast.PopulateDefaults()
	t.Ipv6Unicast.PopulateDefaults()
	t.L2VpnEvpn.PopulateDefaults()
	t.L2VpnVpls.PopulateDefaults()
	t.L3VpnIpv4Multicast.PopulateDefaults()
	t.L3VpnIpv4Unicast.PopulateDefaults()
	t.L3VpnIpv6Multicast.PopulateDefaults()
	t.L3VpnIpv6Unicast.PopulateDefaults()
	t.RouteSelectionOptions.PopulateDefaults()
	t.SrtePolicyIpv4.PopulateDefaults()
	t.SrtePolicyIpv6.PopulateDefaults()
	t.UseMultiplePaths.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Protocol_Bgp_Global_AfiSafi struct, which is a YANG list entry.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"afi-safi-name": t.AfiSafiName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/add-paths YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths struct {
	EligiblePrefixPolicy *string `path:"state/eligible-prefix-policy" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/eligible-prefix-policy" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Receive              *bool   `path:"state/receive" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/receive" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	Send                 *bool   `path:"state/send" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/send" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	SendMax              *uint8  `path:"state/send-max" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/send-max" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) IsYANGGoStruct() {}

// GetEligiblePrefixPolicy retrieves the value of the leaf EligiblePrefixPolicy from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EligiblePrefixPolicy is set, it can
// safely use t.GetEligiblePrefixPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EligiblePrefixPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) GetEligiblePrefixPolicy() string {
	if t == nil || t.EligiblePrefixPolicy == nil {
		return ""
	}
	return *t.EligiblePrefixPolicy
}

// GetReceive retrieves the value of the leaf Receive from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Receive is set, it can
// safely use t.GetReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Receive == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) GetReceive() bool {
	if t == nil || t.Receive == nil {
		return false
	}
	return *t.Receive
}

// GetSend retrieves the value of the leaf Send from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Send is set, it can
// safely use t.GetSend() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Send == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) GetSend() bool {
	if t == nil || t.Send == nil {
		return false
	}
	return *t.Send
}

// GetSendMax retrieves the value of the leaf SendMax from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendMax is set, it can
// safely use t.GetSendMax() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendMax == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) GetSendMax() uint8 {
	if t == nil || t.SendMax == nil {
		return 0
	}
	return *t.SendMax
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Receive == nil {
		var v bool = false
		t.Receive = &v
	}
	if t.Send == nil {
		var v bool = false
		t.Send = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_AddPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/graceful-restart YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart struct {
	Enabled *bool `path:"state/enabled" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/enabled" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv4-labeled-unicast YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv4-labeled-unicast/prefix-limit YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv4-labeled-unicast/prefix-limit-received YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) IsYANGGoStruct() {
}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4LabeledUnicast_PrefixLimitReceived) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv4-unicast YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
	SendDefaultRoute    *bool                                                                        `path:"state/send-default-route" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/send-default-route" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// GetSendDefaultRoute retrieves the value of the leaf SendDefaultRoute from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendDefaultRoute is set, it can
// safely use t.GetSendDefaultRoute() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendDefaultRoute == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) GetSendDefaultRoute() bool {
	if t == nil || t.SendDefaultRoute == nil {
		return false
	}
	return *t.SendDefaultRoute
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SendDefaultRoute == nil {
		var v bool = false
		t.SendDefaultRoute = &v
	}
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv4-unicast/prefix-limit YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv4-unicast/prefix-limit-received YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) IsYANGGoStruct() {
}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv4Unicast_PrefixLimitReceived) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv6-labeled-unicast YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv6-labeled-unicast/prefix-limit YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv6-labeled-unicast/prefix-limit-received YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) IsYANGGoStruct() {
}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6LabeledUnicast_PrefixLimitReceived) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv6-unicast YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
	SendDefaultRoute    *bool                                                                        `path:"state/send-default-route" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/send-default-route" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// GetSendDefaultRoute retrieves the value of the leaf SendDefaultRoute from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendDefaultRoute is set, it can
// safely use t.GetSendDefaultRoute() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendDefaultRoute == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) GetSendDefaultRoute() bool {
	if t == nil || t.SendDefaultRoute == nil {
		return false
	}
	return *t.SendDefaultRoute
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SendDefaultRoute == nil {
		var v bool = false
		t.SendDefaultRoute = &v
	}
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv6-unicast/prefix-limit YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/ipv6-unicast/prefix-limit-received YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) IsYANGGoStruct() {
}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_Ipv6Unicast_PrefixLimitReceived) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l2vpn-evpn YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l2vpn-evpn/prefix-limit YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l2vpn-evpn/prefix-limit-received YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnEvpn_PrefixLimitReceived) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l2vpn-vpls YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l2vpn-vpls/prefix-limit YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l2vpn-vpls/prefix-limit-received YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L2VpnVpls_PrefixLimitReceived) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-multicast YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-multicast/prefix-limit YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) IsYANGGoStruct() {}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-multicast/prefix-limit-received YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived struct {
	MaxPrefixes         *uint32 `path:"state/max-prefixes" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/max-prefixes" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	PrefixLimitExceeded *bool   `path:"state/prefix-limit-exceeded" module:"openconfig-network-instance/openconfig-network-instance"`
	PreventTeardown     *bool   `path:"state/prevent-teardown" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/prevent-teardown" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
	WarningThresholdPct *uint8  `path:"state/warning-threshold-pct" module:"openconfig-network-instance/openconfig-network-instance" shadow-path:"config/warning-threshold-pct" shadow-module:"openconfig-network-instance/openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) IsYANGGoStruct() {
}

// GetMaxPrefixes retrieves the value of the leaf MaxPrefixes from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPrefixes is set, it can
// safely use t.GetMaxPrefixes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPrefixes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) GetMaxPrefixes() uint32 {
	if t == nil || t.MaxPrefixes == nil {
		return 0
	}
	return *t.MaxPrefixes
}

// GetPrefixLimitExceeded retrieves the value of the leaf PrefixLimitExceeded from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLimitExceeded is set, it can
// safely use t.GetPrefixLimitExceeded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLimitExceeded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) GetPrefixLimitExceeded() bool {
	if t == nil || t.PrefixLimitExceeded == nil {
		return false
	}
	return *t.PrefixLimitExceeded
}

// GetPreventTeardown retrieves the value of the leaf PreventTeardown from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreventTeardown is set, it can
// safely use t.GetPreventTeardown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreventTeardown == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) GetPreventTeardown() bool {
	if t == nil || t.PreventTeardown == nil {
		return false
	}
	return *t.PreventTeardown
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) GetWarningThresholdPct() uint8 {
	if t == nil || t.WarningThresholdPct == nil {
		return 0
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreventTeardown == nil {
		var v bool = false
		t.PreventTeardown = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Multicast_PrefixLimitReceived) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast represents the /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-unicast YANG schema element.
type NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast struct {
	PrefixLimit         *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit         `path:"prefix-limit" module:"openconfig-network-instance"`
	PrefixLimitReceived *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimitReceived `path:"prefix-limit-received" module:"openconfig-network-instance"`
}

// IsYANGGoStruct ensures that NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) IsYANGGoStruct() {}

// GetOrCreatePrefixLimit retrieves the value of the PrefixLimit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	t.PrefixLimit = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit{}
	return t.PrefixLimit
}

// GetOrCreatePrefixLimitReceived retrieves the value of the PrefixLimitReceived field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetOrCreatePrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimitReceived {
	if t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	t.PrefixLimitReceived = &NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimitReceived{}
	return t.PrefixLimitReceived
}

// GetPrefixLimit returns the value of the PrefixLimit struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimit() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimit {
	if t != nil && t.PrefixLimit != nil {
		return t.PrefixLimit
	}
	return nil
}

// GetPrefixLimitReceived returns the value of the PrefixLimitReceived struct pointer
// from NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast. If the receiver or the field PrefixLimitReceived is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) GetPrefixLimitReceived() *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast_PrefixLimitReceived {
	if t != nil && t.PrefixLimitReceived != nil {
		return t.PrefixLimitReceived
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixLimit.PopulateDefaults()
	t.PrefixLimitReceived.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Protocol_Bgp_Global_AfiSafi_L3VpnIpv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}
